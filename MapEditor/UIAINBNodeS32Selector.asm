; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_01ICJEACDI@?$DL@				; `string'
PUBLIC	??_C@_0P@NGILPLHN@?9?$CD?$CDS32Selector@	; `string'
PUBLIC	??_C@_0P@PEHBCPIP@?$CL?$CD?$CDS32Selector@	; `string'
PUBLIC	??_C@_0O@EPJALJIO@Add?5condition@		; `string'
PUBLIC	??_C@_0BF@GDLLHGNJ@signed?532?9bit?5number@	; `string'
PUBLIC	??_C@_0CA@NFBKPPAJ@Condition?3?5signed?532?9bit?5number@ ; `string'
PUBLIC	??_7UIAINBNodeS32Selector@@6B@			; UIAINBNodeS32Selector::`vftable'
PUBLIC	??_R3UIAINBNodeS32Selector@@8			; UIAINBNodeS32Selector::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4UIAINBNodeS32Selector@@6B@			; UIAINBNodeS32Selector::`RTTI Complete Object Locator'
PUBLIC	??_R2UIAINBNodeS32Selector@@8			; UIAINBNodeS32Selector::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@UIAINBNodeS32Selector@@8		; UIAINBNodeS32Selector::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Min_buckets
PUBLIC	??_R0?AVUIAINBNodeS32Selector@@@8		; UIAINBNodeS32Selector `RTTI Type Descriptor'
;	COMDAT ??_R0?AVUIAINBNodeS32Selector@@@8
data$rs	SEGMENT
??_R0?AVUIAINBNodeS32Selector@@@8 DQ FLAT:??_7type_info@@6B@ ; UIAINBNodeS32Selector `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVUIAINBNodeS32Selector@@', 00H
data$rs	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@UIAINBNodeS32Selector@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UIAINBNodeS32Selector@@8 DD imagerel ??_R0?AVUIAINBNodeS32Selector@@@8 ; UIAINBNodeS32Selector::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3UIAINBNodeS32Selector@@8
rdata$r	ENDS
;	COMDAT ??_R2UIAINBNodeS32Selector@@8
rdata$r	SEGMENT
??_R2UIAINBNodeS32Selector@@8 DD imagerel ??_R1A@?0A@EA@UIAINBNodeS32Selector@@8 ; UIAINBNodeS32Selector::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@UIAINBNodeBase@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4UIAINBNodeS32Selector@@6B@
rdata$r	SEGMENT
??_R4UIAINBNodeS32Selector@@6B@ DD 01H			; UIAINBNodeS32Selector::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVUIAINBNodeS32Selector@@@8
	DD	imagerel ??_R3UIAINBNodeS32Selector@@8
	DD	imagerel ??_R4UIAINBNodeS32Selector@@6B@
rdata$r	ENDS
;	COMDAT ??_R3UIAINBNodeS32Selector@@8
rdata$r	SEGMENT
??_R3UIAINBNodeS32Selector@@8 DD 00H			; UIAINBNodeS32Selector::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2UIAINBNodeS32Selector@@8
rdata$r	ENDS
;	COMDAT ??_7UIAINBNodeS32Selector@@6B@
CONST	SEGMENT
??_7UIAINBNodeS32Selector@@6B@ DQ FLAT:??_R4UIAINBNodeS32Selector@@6B@ ; UIAINBNodeS32Selector::`vftable'
	DQ	FLAT:?Render@UIAINBNodeS32Selector@@UEAAXXZ
	DQ	FLAT:?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ
	DQ	FLAT:?UpdateVisuals@UIAINBNodeBase@@UEAAXXZ
	DQ	FLAT:?PostProcessLinkedNodeInfo@UIAINBNodeS32Selector@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z
	DQ	FLAT:?PostProcessNode@UIAINBNodeBase@@UEAAXXZ
	DQ	FLAT:?GetNodeType@UIAINBNodeBase@@UEAA?AW4NodeType@1@XZ
	DQ	FLAT:?RenderLinks@UIAINBNodeS32Selector@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
	DQ	FLAT:?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ
	DQ	FLAT:?GetHeaderColor@UIAINBNodeS32Selector@@UEAA?AUImColor@@XZ
CONST	ENDS
;	COMDAT ??_C@_0CA@NFBKPPAJ@Condition?3?5signed?532?9bit?5number@
CONST	SEGMENT
??_C@_0CA@NFBKPPAJ@Condition?3?5signed?532?9bit?5number@ DB 'Condition: s'
	DB	'igned 32-bit number', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GDLLHGNJ@signed?532?9bit?5number@
CONST	SEGMENT
??_C@_0BF@GDLLHGNJ@signed?532?9bit?5number@ DB 'signed 32-bit number', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EPJALJIO@Add?5condition@
CONST	SEGMENT
??_C@_0O@EPJALJIO@Add?5condition@ DB 'Add condition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PEHBCPIP@?$CL?$CD?$CDS32Selector@
CONST	SEGMENT
??_C@_0P@PEHBCPIP@?$CL?$CD?$CDS32Selector@ DB '+##S32Selector', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NGILPLHN@?9?$CD?$CDS32Selector@
CONST	SEGMENT
??_C@_0P@NGILPLHN@?9?$CD?$CDS32Selector@ DB '-##S32Selector', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL@
CONST	SEGMENT
??_C@_01ICJEACDI@?$DL@ DB ';', 00H			; `string'
PUBLIC	??$move@AEAV?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z ; std::move<std::tuple<int &&> &>
PUBLIC	??$_Tuple_get@$0A@$$QEAH@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAH@0@@Z ; std::_Tuple_get<0,int &&>
PUBLIC	??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHI@std@@QEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<int const ,unsigned int>::pair<int const ,unsigned int><std::tuple<int &&>,std::tuple<>,0>
PUBLIC	??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z	; std::_Tuple_val<int &&>::_Tuple_val<int &&><int>
PUBLIC	??$?0$$QEAH$$Z$$V@?$pair@$$CBHI@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z ; std::pair<int const ,unsigned int>::pair<int const ,unsigned int><int &&>
PUBLIC	??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z		; std::tuple<int &&>::tuple<int &&>
PUBLIC	??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &,0>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >
PUBLIC	??$construct_at@U?$pair@$$CBHI@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBHI@0@QEAU10@$$QEAU10@@Z ; std::construct_at<std::pair<int const ,unsigned int>,std::pair<int const ,unsigned int>,0>
PUBLIC	??$construct_at@U?$pair@$$CBHI@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBHI@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@$$QEAH@0@$$QEAV?$tuple@$$V@0@@Z ; std::construct_at<std::pair<int const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<>,0>
PUBLIC	??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z ; std::tuple<int &&>::tuple<int &&><std::_Exact_args_t,int,0>
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * const &,0>
PUBLIC	??$forward@AEBQEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,unsigned int>,void *> * const &>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &>
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &>
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >
PUBLIC	??$construct@U?$pair@$$CBHI@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@QEAU?$pair@$$CBHI@1@$$QEAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::construct<std::pair<int const ,unsigned int>,std::pair<int const ,unsigned int> >
PUBLIC	??$forward@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,unsigned int>,void *> *>
PUBLIC	??$construct@U?$pair@$$CBHI@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@QEAU?$pair@$$CBHI@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::construct<std::pair<int const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >
PUBLIC	??$forward@V?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z ; std::forward<std::tuple<int &&> >
PUBLIC	??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z	; std::tuple<int &&>::tuple<int &&><int,0>
PUBLIC	??$__std_find_trivial@HI@@YAPEAHPEAH0I@Z	; __std_find_trivial<int,unsigned int>
PUBLIC	??$_Could_compare_equal_to_value_type@PEAHI@std@@YA_NAEBI@Z ; std::_Could_compare_equal_to_value_type<int *,unsigned int>
PUBLIC	??$__std_find_trivial@IH@@YAPEAIPEAI0H@Z	; __std_find_trivial<unsigned int,int>
PUBLIC	??$_Could_compare_equal_to_value_type@PEAIH@std@@YA_NAEBH@Z ; std::_Could_compare_equal_to_value_type<unsigned int *,int>
PUBLIC	??$?0U?$pair@$$CBHI@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > ><std::pair<int const ,unsigned int> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_Allocate
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > const >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * const &>
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::nullptr_t>
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * &,0>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,unsigned int>,void *> * &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<int const ,unsigned int>,void *> *>
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >,1><std::allocator<std::pair<int const ,unsigned int> > const &>
PUBLIC	??$forward@AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBHI@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<int const ,unsigned int> > const &>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,bool,0>
PUBLIC	??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > ><std::pair<int const ,unsigned int> >
PUBLIC	??$forward@U?$pair@$$CBHI@std@@@std@@YA$$QEAU?$pair@$$CBHI@0@AEAU10@@Z ; std::forward<std::pair<int const ,unsigned int> >
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>
PUBLIC	??$?0PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool,0>
PUBLIC	??$?0AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned int>,void *> * &,bool,0>
PUBLIC	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >
PUBLIC	??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z ; std::forward_as_tuple<int>
PUBLIC	??$_Find_last@H@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBH_K@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Find_last<int>
PUBLIC	??$_Find_unchecked@PEAHI@std@@YAPEAHPEAHQEAHAEBI@Z ; std::_Find_unchecked<int *,unsigned int>
PUBLIC	??$_Find_unchecked@PEAIH@std@@YAPEAIPEAIQEAIAEBH@Z ; std::_Find_unchecked<unsigned int *,int>
PUBLIC	??$?0U?$pair@$$CBHI@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> ><std::pair<int const ,unsigned int> >
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Unchecked_begin
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::max_size
PUBLIC	?_Getal@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@XZ ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Getal
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >::_Unchecked_splice
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Unchecked_begin
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Min_load_factor_buckets
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Max_bucket_size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::max_size
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBHI@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator==
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHI@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::operator++
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::__autoclassinit2
PUBLIC	?max_size@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::max_size
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::max_load_factor
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Forced_rehash
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@@Z ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Make_iter
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rehash_for_1
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_Release
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
PUBLIC	?_Extract@?$_In_place_key_extract_map@HU?$pair@$$CBHI@std@@@std@@SAAEBHAEBU?$pair@$$CBHI@2@@Z ; std::_In_place_key_extract_map<int,std::pair<int const ,unsigned int> >::_Extract
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::_Release
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * &>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,1><std::allocator<std::pair<int const ,unsigned int> > const &>
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > ><std::allocator<std::pair<int const ,unsigned int> > const &,0>
PUBLIC	??$_Kfn@$$CBHI@?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBHI@1@@Z ; std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0>::_Kfn<int const ,unsigned int>
PUBLIC	??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::emplace<std::pair<int const ,unsigned int> >
PUBLIC	??$move@AEAU?$pair@$$CBHI@std@@@std@@YA$$QEAU?$pair@$$CBHI@0@AEAU10@@Z ; std::move<std::pair<int const ,unsigned int> &>
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > * const &>
PUBLIC	??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Try_emplace<int>
PUBLIC	??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>
PUBLIC	??$_Move_unchecked@PEAHPEAH@std@@YAPEAHPEAH00@Z	; std::_Move_unchecked<int *,int *>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@I@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBI@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,unsigned int>
PUBLIC	??$?0AEAHI$0A@@?$pair@$$CBHI@std@@QEAA@AEAH$$QEAI@Z ; std::pair<int const ,unsigned int>::pair<int const ,unsigned int><int &,unsigned int,0>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBH@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >,int>
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >::allocate
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Alloc_sentinel_and_proxy
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >::allocate
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::size
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >
PUBLIC	??0?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ; std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0>::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0>
PUBLIC	??0?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Unchecked_end
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >::_Orphan_non_end
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::bucket
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Max_bucket_size
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Assign_grow
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	??0?$allocator@U?$pair@$$CBHI@std@@@std@@QEAA@XZ ; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >
PUBLIC	?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::clear
PUBLIC	??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Unchecked_end
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::bucket_count
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Unchecked_erase
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAAEBHXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator++
PUBLIC	?insert@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHI@2@@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::insert
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::clear
PUBLIC	??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ ; std::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >
PUBLIC	??A?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAAEAI$$QEAH@Z ; std::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >::operator[]
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z ; std::vector<int,std::allocator<int> >::erase
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ ; std::vector<int,std::allocator<int> >::clear
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAAEAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator++
PUBLIC	?GetHeaderColor@UIAINBNodeS32Selector@@UEAA?AUImColor@@XZ ; UIAINBNodeS32Selector::GetHeaderColor
PUBLIC	?RenderLinks@UIAINBNodeS32Selector@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z ; UIAINBNodeS32Selector::RenderLinks
PUBLIC	?PostProcessLinkedNodeInfo@UIAINBNodeS32Selector@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z ; UIAINBNodeS32Selector::PostProcessLinkedNodeInfo
PUBLIC	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAX_K@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::__autoclassinit2
PUBLIC	?Render@UIAINBNodeS32Selector@@UEAAXXZ		; UIAINBNodeS32Selector::Render
PUBLIC	?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ ; UIAINBNodeS32Selector::GenerateNodeShapeInfo
PUBLIC	?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ	; UIAINBNodeS32Selector::RebuildNode
PUBLIC	??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ; UIAINBNodeS32Selector::UIAINBNodeS32Selector
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN33
	DD	imagerel $LN33+37
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z DD imagerel $LN40
	DD	imagerel $LN40+63
	DD	imagerel $unwind$??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN50
	DD	imagerel $LN50+83
	DD	imagerel $unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN10
	DD	imagerel $LN10+99
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN21
	DD	imagerel $LN21+159
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN141
	DD	imagerel $LN141+57
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN141+57
	DD	imagerel $LN141+130
	DD	imagerel $chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN141+130
	DD	imagerel $LN141+372
	DD	imagerel $chain$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN141+372
	DD	imagerel $LN141+389
	DD	imagerel $chain$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN141+389
	DD	imagerel $LN141+427
	DD	imagerel $chain$5$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN6
	DD	imagerel $LN6+39
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN23
	DD	imagerel $LN23+175
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z DD imagerel $LN182
	DD	imagerel $LN182+566
	DD	imagerel $unwind$??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21+62
	DD	imagerel $LN21+98
	DD	imagerel $chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21+98
	DD	imagerel $LN21+132
	DD	imagerel $chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z DD imagerel $LN184
	DD	imagerel $LN184+549
	DD	imagerel $unwind$??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Move_unchecked@PEAHPEAH@std@@YAPEAHPEAH00@Z DD imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$??$_Move_unchecked@PEAHPEAH@std@@YAPEAHPEAH00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@I@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBI@Z DD imagerel $LN20
	DD	imagerel $LN20+41
	DD	imagerel $unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@I@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBH@Z DD imagerel $LN20
	DD	imagerel $LN20+41
	DD	imagerel $unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@AEAAXXZ DD imagerel $LN33
	DD	imagerel $LN33+35
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD imagerel $LN41
	DD	imagerel $LN41+45
	DD	imagerel $unwind$??0?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z DD imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z DD imagerel $LN88+54
	DD	imagerel $LN88+270
	DD	imagerel $chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z DD imagerel $LN88+270
	DD	imagerel $LN88+277
	DD	imagerel $chain$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z DD imagerel $LN88+277
	DD	imagerel $LN88+301
	DD	imagerel $chain$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z DD imagerel $LN88+301
	DD	imagerel $LN88+307
	DD	imagerel $chain$5$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN52
	DD	imagerel $LN52+43
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ DD imagerel $LN64
	DD	imagerel $LN64+31
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ DD imagerel $LN64+31
	DD	imagerel $LN64+74
	DD	imagerel $chain$0$?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ DD imagerel $LN64+74
	DD	imagerel $LN64+101
	DD	imagerel $chain$1$?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD imagerel $LN60
	DD	imagerel $LN60+115
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN206
	DD	imagerel $LN206+43
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN206+43
	DD	imagerel $LN206+260
	DD	imagerel $chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN206+260
	DD	imagerel $LN206+272
	DD	imagerel $chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN206+272
	DD	imagerel $LN206+459
	DD	imagerel $chain$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHI@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?insert@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHI@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN79
	DD	imagerel $LN79+81
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN79+81
	DD	imagerel $LN79+122
	DD	imagerel $chain$0$?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN79+122
	DD	imagerel $LN79+178
	DD	imagerel $chain$1$?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ DD imagerel $LN70
	DD	imagerel $LN70+113
	DD	imagerel $unwind$??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAAEAI$$QEAH@Z DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$??A?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAAEAI$$QEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z DD imagerel $LN23
	DD	imagerel $LN23+70
	DD	imagerel $unwind$?erase@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderLinks@UIAINBNodeS32Selector@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD imagerel $LN197
	DD	imagerel $LN197+1057
	DD	imagerel $unwind$?RenderLinks@UIAINBNodeS32Selector@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PostProcessLinkedNodeInfo@UIAINBNodeS32Selector@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z DD imagerel $LN49
	DD	imagerel $LN49+137
	DD	imagerel $unwind$?PostProcessLinkedNodeInfo@UIAINBNodeS32Selector@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel ?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel ?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+159
	DD	imagerel $unwind$?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Render@UIAINBNodeS32Selector@@UEAAXXZ DD imagerel $LN1874
	DD	imagerel $LN1874+6548
	DD	imagerel $unwind$?Render@UIAINBNodeS32Selector@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD imagerel ?dtor$2@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$2@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD imagerel ?dtor$3@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DD	imagerel ?dtor$3@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA+41
	DD	imagerel $unwind$?dtor$3@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ DD imagerel $LN1353
	DD	imagerel $LN1353+3528
	DD	imagerel $unwind$?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DD	imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DD	imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DD	imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ DD imagerel $LN243
	DD	imagerel $LN243+609
	DD	imagerel $unwind$?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DD imagerel $LN135
	DD	imagerel $LN135+451
	DD	imagerel $unwind$??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 0cH
	DB	'\'
	DB	00H
	DB	'`'
	DB	02H
	DB	'z'
	DB	06H
	DB	'8'
	DB	0aH
	DB	'!', 03H
	DB	00H
	DB	'P'
	DB	0aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 0aH
	DB	0cH
	DD	imagerel ??1UIAINBNodeBase@@QEAA@XZ
	DB	070H
	DB	036H
	DD	imagerel ?dtor$4@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA
	DB	086H
	DD	imagerel ?dtor$1@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 028H
	DD	imagerel $stateUnwindMap$??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
	DD	imagerel $ip2state$??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DD 0a2319H
	DD	0143414H
	DD	0f0109214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ DB 04H
	DB	')', 07H
	DB	02H
	DB	0c0H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ DB 02H
	DB	0aH
	DD	imagerel ??1InputEntry@AINBFile@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ
	DD	imagerel $ip2state$?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ DD 0d3219H
	DD	02d7424H
	DD	02c6424H
	DD	02b3424H
	DD	0240124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ
	DD	0112H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ DB 01cH
	DB	0feH
	DB	00H
	DB	0a9H, 07H
	DB	02H
	DB	'=', 03H
	DB	00H
	DB	0bcH
	DB	04H
	DB	'0'
	DB	06H
	DB	0b6H
	DB	08H
	DB	081H, 0cH
	DB	00H
	DB	'%', 08H
	DB	0cH
	DB	'.'
	DB	0eH
	DB	0b4H
	DB	010H
	DB	'm', 0fH
	DB	0cH
	DB	0cH
	DB	00H
	DB	0cH
	DB	04H
	DB	0cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ DB 010H
	DB	0eH
	DD	imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	02H
	DB	0ceH
	DD	imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ
	DD	imagerel $ip2state$?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ DD 01d5511H
	DD	017d855H
	DD	018c84dH
	DD	019b845H
	DD	01aa83dH
	DD	01b9838H
	DD	01c8833H
	DD	01d782eH
	DD	01e682aH
	DD	0477426H
	DD	0466426H
	DD	0453426H
	DD	03e0126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Render@UIAINBNodeS32Selector@@UEAAXXZ DB 'J'
	DB	'a', 02H
	DB	00H
	DB	0e9H, 05H
	DB	02H
	DB	':'
	DB	00H
	DB	'Y', 07H
	DB	04H
	DB	','
	DB	00H
	DB	0bcH
	DB	06H
	DB	'6'
	DB	08H
	DB	'<'
	DB	0aH
	DB	'y', 02H
	DB	08H
	DB	0f2H
	DB	00H
	DB	'a', 07H
	DB	0cH
	DB	'i', 0eH
	DB	0eH
	DB	0acH
	DB	012H
	DB	0d5H, 06H
	DB	014H
	DB	0caH
	DB	016H
	DB	0aeH
	DB	018H
	DB	'v'
	DB	01aH
	DB	'*'
	DB	01cH
	DB	'<'
	DB	01aH
	DB	0dH, 05H
	DB	012H
	DB	01dH, 09H
	DB	0cH
	DB	']', 03H
	DB	01eH
	DB	080H
	DB	' '
	DB	':'
	DB	01eH
	DB	082H
	DB	0cH
	DB	'p'
	DB	'"'
	DB	'p'
	DB	'$'
	DB	'v'
	DB	'*'
	DB	0e2H
	DB	'('
	DB	')', 04H
	DB	0cH
	DB	099H, 03H
	DB	02H
	DB	095H, 04H
	DB	0cH
	DB	0f5H, 02H
	DB	00H
	DB	'}', 02H
	DB	0cH
	DB	0cH
	DB	00H
	DB	018H
	DB	06H
	DB	0cH
	DB	012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Render@UIAINBNodeS32Selector@@UEAAXXZ DB 02aH
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	06H
	DB	046H
	DD	imagerel ?dtor$2@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	06H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	03H
	DB	05H
	DB	02H
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	01H
	DB	07H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	06H
	DB	0b2H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	06H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	06H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	02H
	DB	0f5H
	DB	03H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	03H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	02H
	DB	0e9H
	DB	04H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	04H
	DB	044H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	0d9H
	DB	05H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	05H
	DB	044H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	03H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Render@UIAINBNodeS32Selector@@UEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?Render@UIAINBNodeS32Selector@@UEAAXXZ
	DD	imagerel $ip2state$?Render@UIAINBNodeS32Selector@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Render@UIAINBNodeS32Selector@@UEAAXXZ DD 01d6619H
	DD	024d855H
	DD	025c84dH
	DD	026b845H
	DD	027a83dH
	DD	0289838H
	DD	0298833H
	DD	02a782eH
	DD	02b682aH
	DD	0617426H
	DD	0606426H
	DD	05f3426H
	DD	0580126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?Render@UIAINBNodeS32Selector@@UEAAXXZ
	DD	023aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'R'
	DB	02H
	DB	0a8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 061b19H
	DD	0e340cH
	DD	07008720cH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	032H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PostProcessLinkedNodeInfo@UIAINBNodeS32Selector@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderLinks@UIAINBNodeS32Selector@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD 0c3b01H
	DD	0a683bH
	DD	0170122H
	DD	0e015f017H
	DD	0c011d013H
	DD	0600e700fH
	DD	0500c300dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAAEAI$$QEAH@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ DB 04H
	DB	'B'
	DB	00H
	DB	'x'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0???0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+81
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 020521H
	DD	093405H
	DD	imagerel $LN79
	DD	imagerel $LN79+81
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHI@2@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z DD 0a0021H
	DD	08f400H
	DD	09d400H
	DD	011c400H
	DD	0107400H
	DD	0f3400H
	DD	imagerel $LN206
	DD	imagerel $LN206+43
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z DD 021H
	DD	imagerel $LN206
	DD	imagerel $LN206+43
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z DD 0a2421H
	DD	08f424H
	DD	09d41cH
	DD	011c40fH
	DD	010740bH
	DD	0f3404H
	DD	imagerel $LN206
	DD	imagerel $LN206+43
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z DD 040b01H
	DD	0e007920bH
	DD	050046005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z DB 04H
	DB	'F'
	DB	00H
	DB	'x'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+31
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ DD 020521H
	DD	073405H
	DD	imagerel $LN64
	DD	imagerel $LN64+31
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z DD 040021H
	DD	047400H
	DD	0b6400H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z DD 040021H
	DD	047400H
	DD	0b6400H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z DD 040a21H
	DD	04740aH
	DD	0b6405H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z DD 030c01H
	DD	0e008420cH
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@I@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Move_unchecked@PEAHPEAH@std@@YAPEAHPEAH00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z DB 06H
	DB	085H, 03H
	DB	00H
	DB	'4'
	DB	02H
	DB	0faH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z
	DD	imagerel $ip2state$??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z DD 0a1411H
	DD	0113414H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z DB 06H
	DB	085H, 03H
	DB	00H
	DB	'4'
	DB	02H
	DB	0f0H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z
	DD	imagerel $ip2state$??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z DD 0a1411H
	DD	0113414H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 060021H
	DD	04e400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN141
	DD	imagerel $LN141+57
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN141+57
	DD	imagerel $LN141+130
	DD	imagerel $chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 020521H
	DD	0b5405H
	DD	imagerel $LN141+57
	DD	imagerel $LN141+130
	DD	imagerel $chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 041821H
	DD	04e418H
	DD	0a3405H
	DD	imagerel $LN141
	DD	imagerel $LN141+57
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 030701H
	DD	070034207H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	'Z'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z DB 02H
	DB	'B'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z
	DD	imagerel $ip2state$??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
;	COMDAT ??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
_TEXT	SEGMENT
$T1 = 48
this$GSCopy$ = 56
_Eptr$2 = 64
this$ = 64
__$ArrayPad$ = 72
this$ = 144
Node$ = 152
EditorId$ = 160
HeaderBackground$ = 168
EnableFlow$dead$ = 176
??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z PROC ; UIAINBNodeS32Selector::UIAINBNodeS32Selector, COMDAT

; 7    : {

$LN135:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	r12, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx

; 6    :     : UIAINBNodeBase(&Node, EditorId, HeaderBackground, EnableFlow)

	call	??0UIAINBNodeBase@@QEAA@PEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ; UIAINBNodeBase::UIAINBNodeBase
	npad	1

; 7    : {

	lea	rax, OFFSET FLAT:??_7UIAINBNodeS32Selector@@6B@
	mov	QWORD PTR [r12], rax
	lea	rbx, QWORD PTR [r12+272]
	mov	QWORD PTR this$[rsp], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	xor	r13d, r13d
	mov	DWORD PTR [rbx], r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rbx+8], r13
	mov	QWORD PTR [rbx+16], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [r13+24]
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	lea	rcx, QWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], r13
	mov	QWORD PTR [rcx+8], r13
	mov	QWORD PTR [rcx+16], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR [rbx+48], 7
	mov	QWORD PTR [rbx+56], 8

; 377  :         // construct empty hash table
; 378  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [rbx], 1065353216		; 3f800000H

; 379  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, QWORD PTR [rbx+8]
	lea	edx, QWORD PTR [r13+16]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Assign_grow
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 7    : {

	lea	rsi, QWORD PTR [r12+336]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsi], r13
	mov	QWORD PTR [rsi+8], r13
	mov	QWORD PTR [rsi+16], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 8    :     GenerateNodeShapeInfo();

	mov	rcx, r12
	call	?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ ; UIAINBNodeS32Selector::GenerateNodeShapeInfo

; 10   :     for (AINBFile::LinkedNodeInfo& Info : Node.LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink]) {

	mov	rbp, QWORD PTR [rdi+440]
	mov	r15, QWORD PTR [rdi+448]
	cmp	rbp, r15
	je	$LN3@UIAINBNode

; 7    : {

	lea	rbx, QWORD PTR [rbp+40]
	npad	9
$LL4@UIAINBNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN131@UIAINBNode

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN131@UIAINBNode:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	QWORD PTR [rbx+16], 7
	jne	SHORT $LN129@UIAINBNode

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8d, 7
	lea	rdx, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN2@UIAINBNode
$LN129@UIAINBNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 90   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	call	QWORD PTR __imp__errno
	mov	r14, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdi, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN130@UIAINBNode

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rbx]
$LN130@UIAINBNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 93   :     _Errno_ref      = 0;

	mov	DWORD PTR [rax], r13d

; 94   :     const long _Ans = _CSTD strtol(_Ptr, &_Eptr, _Base);

	mov	r8d, 10
	lea	rdx, QWORD PTR _Eptr$2[rsp]
	mov	rcx, rdi
	call	QWORD PTR __imp_strtol

; 95   : 
; 96   :     if (_Ptr == _Eptr) {

	cmp	rdi, QWORD PTR _Eptr$2[rsp]
	je	SHORT $LN120@UIAINBNode

; 98   :     }
; 99   : 
; 100  :     if (_Errno_ref == ERANGE) {

	cmp	DWORD PTR [r14], 34			; 00000022H
	je	SHORT $LN121@UIAINBNode
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 14   :         mConditions.push_back(std::stoi(Info.Condition));

	mov	DWORD PTR $T1[rsp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rsi+8]
	cmp	rdx, QWORD PTR [rsi+16]
	je	SHORT $LN115@UIAINBNode

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], eax

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [rsi+8], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@UIAINBNode
$LN115@UIAINBNode:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T1[rsp]
	mov	rcx, rsi
	call	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAH$$QEAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
$LN2@UIAINBNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 10   :     for (AINBFile::LinkedNodeInfo& Info : Node.LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink]) {

	add	rbp, 312				; 00000138H
	add	rbx, 312				; 00000138H
	cmp	rbp, r15
	jne	$LL4@UIAINBNode
$LN3@UIAINBNode:

; 16   : }

	mov	rax, r12
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+160]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN121@UIAINBNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 101  :         _Xout_of_range("stoi argument out of range");

	lea	rcx, OFFSET FLAT:??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN120@UIAINBNode:

; 97   :         _Xinvalid_argument("invalid stoi argument");

	lea	rcx, OFFSET FLAT:??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
	call	QWORD PTR __imp_?_Xinvalid_argument@std@@YAXPEBD@Z
	int	3
$LN132@UIAINBNode:
??0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ENDP ; UIAINBNodeS32Selector::UIAINBNodeS32Selector
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$GSCopy$ = 56
_Eptr$2 = 64
this$ = 64
__$ArrayPad$ = 72
this$ = 144
Node$ = 152
EditorId$ = 160
HeaderBackground$ = 168
EnableFlow$dead$ = 176
?dtor$0@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA PROC ; `UIAINBNodeS32Selector::UIAINBNodeS32Selector'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1UIAINBNodeBase@@QEAA@XZ
?dtor$0@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA ENDP ; `UIAINBNodeS32Selector::UIAINBNodeS32Selector'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$GSCopy$ = 56
_Eptr$2 = 64
this$ = 64
__$ArrayPad$ = 72
this$ = 144
Node$ = 152
EditorId$ = 160
HeaderBackground$ = 168
EnableFlow$dead$ = 176
?dtor$4@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA PROC ; `UIAINBNodeS32Selector::UIAINBNodeS32Selector'::`1'::dtor$4
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::~list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >
?dtor$4@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA ENDP ; `UIAINBNodeS32Selector::UIAINBNodeS32Selector'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$GSCopy$ = 56
_Eptr$2 = 64
this$ = 64
__$ArrayPad$ = 72
this$ = 144
Node$ = 152
EditorId$ = 160
HeaderBackground$ = 168
EnableFlow$dead$ = 176
?dtor$5@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA PROC ; `UIAINBNodeS32Selector::UIAINBNodeS32Selector'::`1'::dtor$5
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >
?dtor$5@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA ENDP ; `UIAINBNodeS32Selector::UIAINBNodeS32Selector'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$GSCopy$ = 56
_Eptr$2 = 64
this$ = 64
__$ArrayPad$ = 72
this$ = 144
Node$ = 152
EditorId$ = 160
HeaderBackground$ = 168
EnableFlow$dead$ = 176
?dtor$1@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA PROC ; `UIAINBNodeS32Selector::UIAINBNodeS32Selector'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 272				; 00000110H
	jmp	??1?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ
?dtor$1@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA ENDP ; `UIAINBNodeS32Selector::UIAINBNodeS32Selector'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$GSCopy$ = 56
_Eptr$2 = 64
this$ = 64
__$ArrayPad$ = 72
this$ = 144
Node$ = 152
EditorId$ = 160
HeaderBackground$ = 168
EnableFlow$dead$ = 176
?dtor$2@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA PROC ; `UIAINBNodeS32Selector::UIAINBNodeS32Selector'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 336				; 00000150H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
?dtor$2@?0???0UIAINBNodeS32Selector@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA ENDP ; `UIAINBNodeS32Selector::UIAINBNodeS32Selector'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
;	COMDAT ?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ
_TEXT	SEGMENT
Param$ = 32
__$ArrayPad$ = 272
this$ = 336
?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ PROC	; UIAINBNodeS32Selector::RebuildNode, COMDAT

; 19   : {

$LN243:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-32]
	sub	rsp, 288				; 00000120H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r15, rcx

; 20   :     mNode->Flags.clear();

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rcx, QWORD PTR [rax+8]
	cmp	rcx, QWORD PTR [rax+16]
	je	SHORT $LN10@RebuildNod

; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rax+16], rcx
$LN10@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 22   :     for (int i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r13d, r13d
	mov	r14d, r13d
	lea	r12d, QWORD PTR [r13+6]
$LL4@RebuildNod:

; 23   :         mNode->InputParameters[i].clear();

	mov	rax, QWORD PTR [r15+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rsi, QWORD PTR [rax+176]
	add	rsi, r14

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rsi]
	mov	rdi, QWORD PTR [rsi+8]
	cmp	rbx, rdi
	je	SHORT $LN15@RebuildNod
	npad	5
$LL21@RebuildNod:
	mov	rcx, rbx
	call	??1InputEntry@AINBFile@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 240				; 000000f0H
	cmp	rbx, rdi
	jne	SHORT $LL21@RebuildNod
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rsi+8], rax
$LN15@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 24   :         mNode->OutputParameters[i].clear();

	mov	rax, QWORD PTR [r15+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rsi, QWORD PTR [rax+200]
	add	rsi, r14

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rsi]
	mov	rdi, QWORD PTR [rsi+8]
	cmp	rbx, rdi
	je	SHORT $LN2@RebuildNod
$LL38@RebuildNod:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+40]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 72					; 00000048H
	cmp	rbx, rdi
	jne	SHORT $LL38@RebuildNod
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rsi+8], rax
$LN2@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 22   :     for (int i = 0; i < AINBFile::ValueTypeCount; i++) {

	add	r14, 24
	sub	r12, 1
	jne	SHORT $LL4@RebuildNod

; 27   :     for (int i = 0; i < 10; i++) {

	mov	r14, r13
	npad	13
$LL7@RebuildNod:

; 28   :         mNode->LinkedNodes[i].clear();

	mov	rsi, QWORD PTR [r15+8]
	add	rsi, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rsi+392]
	mov	rdi, QWORD PTR [rsi+400]
	cmp	rbx, rdi
	je	SHORT $LN5@RebuildNod
	npad	6
$LL62@RebuildNod:
	mov	rcx, rbx
	call	??1LinkedNodeInfo@AINBFile@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 312				; 00000138H
	cmp	rbx, rdi
	jne	SHORT $LL62@RebuildNod
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rsi+392]
	mov	QWORD PTR [rsi+400], rax
$LN5@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 27   :     for (int i = 0; i < 10; i++) {

	add	r14, 24
	cmp	r14, 240				; 000000f0H
	jl	SHORT $LL7@RebuildNod
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Param$[rsp], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Param$[rsp+16], r13

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Param$[rsp+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Param$[rsp], r13b

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Param$[rsp+32], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Param$[rsp+48], r13

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Param$[rsp+56], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Param$[rsp+32], r13b
	mov	DWORD PTR Param$[rsp+64], 65535		; 0000ffffH
	mov	DWORD PTR Param$[rsp+68], -1		; ffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR Param$[rsp+72], r13
	movdqa	XMMWORD PTR Param$[rsp+80], xmm0
	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR Param$[rbp-160], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR Param$[rbp-120], r13b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR Param$[rbp-104], r13
	movdqa	XMMWORD PTR Param$[rbp-96], xmm0
	mov	WORD PTR Param$[rbp-80], ax
	mov	QWORD PTR Param$[rbp-72], r13
	mov	QWORD PTR Param$[rbp-64], r13
	mov	QWORD PTR Param$[rbp-56], r13
	mov	DWORD PTR Param$[rbp-48], r13d
	mov	QWORD PTR Param$[rbp-40], r13
	movdqa	XMMWORD PTR Param$[rbp-32], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	mov	DWORD PTR Param$[rbp-152], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 33   :     Param.ValueType = (int)AINBFile::ValueType::Int;

	mov	DWORD PTR Param$[rbp-112], r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05DCDOHKAB@Input@
	lea	rcx, QWORD PTR Param$[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 35   :     Param.NodeIndex = -1;

	mov	DWORD PTR Param$[rsp+64], -1		; ffffffffH

; 36   :     Param.ParameterIndex = -1;
; 37   :     mNode->InputParameters[(int)AINBFile::ValueType::Int].push_back(Param);

	mov	rax, QWORD PTR [r15+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rbx, QWORD PTR [rax+176]

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	rax, QWORD PTR [rbx+16]
	je	SHORT $LN210@RebuildNod
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR Param$[rsp]
	mov	rcx, rax
	call	??0InputEntry@AINBFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rbx+8], 240			; 000000f0H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN209@RebuildNod
$LN210@RebuildNod:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Param$[rsp]
	mov	rdx, rax
	mov	rcx, rbx
	call	??$_Emplace_reallocate@AEBUInputEntry@AINBFile@@@?$vector@UInputEntry@AINBFile@@V?$allocator@UInputEntry@AINBFile@@@std@@@std@@AEAAPEAUInputEntry@AINBFile@@QEAU23@AEBU23@@Z ; std::vector<AINBFile::InputEntry,std::allocator<AINBFile::InputEntry> >::_Emplace_reallocate<AINBFile::InputEntry const &>
$LN209@RebuildNod:

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [r15+336]
	cmp	rax, QWORD PTR [r15+344]
	je	SHORT $LN218@RebuildNod

; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [r15+344], rax
$LN218@RebuildNod:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 40   : }

	lea	rcx, QWORD PTR Param$[rsp]
	call	??1InputEntry@AINBFile@@QEAA@XZ
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ ENDP	; UIAINBNodeS32Selector::RebuildNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Param$ = 32
__$ArrayPad$ = 272
this$ = 336
?dtor$0@?0??RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::RebuildNode'::`1'::dtor$0
	lea	rcx, QWORD PTR Param$[rdx]
	jmp	??1InputEntry@AINBFile@@QEAA@XZ
?dtor$0@?0??RebuildNode@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::RebuildNode'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
;	COMDAT ?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ
_TEXT	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ PROC ; UIAINBNodeS32Selector::GenerateNodeShapeInfo, COMDAT

; 43   : {

$LN1353:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-280]
	sub	rsp, 496				; 000001f0H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$1$[rbp-256], rcx
	xor	r14d, r14d
	mov	DWORD PTR $T4[rsp], r14d

; 44   :     mNodeShapeInfo.FrameWidth = 8 * 2 + ImGui::CalcTextSize(mNode->GetName().c_str()).x + 24 + ImGui::GetStyle().ItemSpacing.x;

	mov	rdx, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	movzx	eax, WORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 43   : {

	mov	ebx, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	bts	ebx, 12
	lea	rcx, QWORD PTR $T17[rbp-256]
	test	ax, ax
	jne	SHORT $LN1059@GenerateNo

; 2909 : 		return this->Name;

	add	rdx, 32					; 00000020H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN1344@GenerateNo
$LN1059@GenerateNo:

; 2910 : 
; 2911 : 	return AINBFile::NodeTypeToString((AINBFile::NodeTypes)this->Type);

	movzx	edx, ax
	call	?NodeTypeToString@AINBFile@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4NodeTypes@1@@Z ; AINBFile::NodeTypeToString
$LN1344@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	mov	DWORD PTR $T4[rsp], ebx
	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

	lea	rax, QWORD PTR $T17[rbp-256]
	mov	rdx, QWORD PTR $T17[rbp-256]
	mov	r8, QWORD PTR $T17[rbp-232]
	cmp	r8, 16
	cmovae	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5418 :     if (text == text_display_end)

	movss	xmm9, DWORD PTR __real@bf800000
	movss	xmm10, DWORD PTR __real@7f7fffff
	movss	xmm11, DWORD PTR __real@3f7fff58
	xorps	xmm7, xmm7
	test	rax, rax
	jne	SHORT $LN1041@GenerateNo
	xorps	xmm0, xmm0

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN1038@GenerateNo
$LN1041@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rdi+15696]
	lea	rdx, QWORD PTR text_size$9[rbp-256]
	mov	rcx, QWORD PTR [rdi+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$9[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mov	r8, QWORD PTR $T17[rbp-232]
	mov	rdx, QWORD PTR $T17[rbp-256]
$LN1038@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 44   :     mNodeShapeInfo.FrameWidth = 8 * 2 + ImGui::CalcTextSize(mNode->GetName().c_str()).x + 24 + ImGui::GetStyle().ItemSpacing.x;

	movss	xmm8, DWORD PTR __real@41800000
	addss	xmm0, xmm8
	movss	xmm12, DWORD PTR __real@41c00000
	addss	xmm0, xmm12
	addss	xmm0, DWORD PTR [rdi+14628]
	movss	DWORD PTR [rsi+20], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	r8, 16
	jb	SHORT $LN1067@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1067@GenerateNo:

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T17[rbp-240], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T17[rbp-256], r14b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 46   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r13b, r13b
	movss	xmm13, DWORD PTR __real@42000000
$LN1350@GenerateNo:

; 47   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	lea	r9, OFFSET FLAT:__ImageBase
	mov	r11, -1
	lea	r10d, QWORD PTR [r11+23]
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	mov	rcx, QWORD PTR [rsi+8]
	movzx	eax, r13b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdx, QWORD PTR [rax+rax*2]
	mov	QWORD PTR tv6748[rbp-256], rdx
	mov	rax, QWORD PTR [rcx+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 47   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	mov	r15, QWORD PTR [rax+rdx*8]
	mov	r12, QWORD PTR [rax+rdx*8+8]
	cmp	r15, r12
	je	$LN1327@GenerateNo
	npad	3
$LL7@GenerateNo:

; 49   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	cmp	r13b, 5
	jne	$LN16@GenerateNo
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T8[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T8[rsp+16], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T8[rbp-232], r14

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r15+48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR [r15+32]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+56], 16
	jb	SHORT $LN1005@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r14]
$LN1005@GenerateNo:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, r8
	ja	$LN1108@GenerateNo

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN1011@GenerateNo

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rsp+16], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-232], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T8[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN1027@GenerateNo
$LN1011@GenerateNo:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15
	cmp	rdi, r8

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN1022@GenerateNo

; 4716 :             return _Max;

	mov	rdi, r8
	jmp	SHORT $LN1021@GenerateNo
$LN1022@GenerateNo:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	cmovb	rdi, r10
$LN1021@GenerateNo:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	cmovb	rdx, r11
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T8[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T8[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN1027@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 49   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	lea	rdi, QWORD PTR $T8[rsp]
	or	ebx, 1
	mov	rsi, QWORD PTR this$GSCopy$1$[rbp-256]
	xor	r14d, r14d
	jmp	$LN1345@GenerateNo
$LN16@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 210  :     switch (ValueType) {

	movzx	eax, r13b
	cmp	eax, 5
	ja	$LN880@GenerateNo
	mov	ecx, DWORD PTR $LN1335@GenerateNo[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN874@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T6[rsp+16], 3

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T6[rsp+24], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_03DBLNGNIM@Int@
	mov	WORD PTR $T6[rsp], ax
	movzx	eax, BYTE PTR ??_C@_03DBLNGNIM@Int@+2
	mov	BYTE PTR $T6[rsp+2], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T6[rsp+3], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 212  :         return "Int";

	jmp	SHORT $LN1346@GenerateNo
$LN875@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04PCGIEMCI@Bool@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 214  :         return "Bool";

	jmp	SHORT $LN1347@GenerateNo
$LN876@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05KKPNNHNB@Float@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 216  :         return "Float";

	jmp	SHORT $LN1347@GenerateNo
$LN877@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:??_C@_06ENNEIMBA@String@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 218  :         return "String";

	jmp	SHORT $LN1347@GenerateNo
$LN878@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05PJCBICIO@Vec3f@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 220  :         return "Vec3f";

	jmp	SHORT $LN1347@GenerateNo
$LN879@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@EALHFGP@UserDefined@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 222  :         return "UserDefined";

	jmp	SHORT $LN1347@GenerateNo
$LN880@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 7
	lea	rdx, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
$LN1347@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 49   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T6[rsp], xmm0
	mov	QWORD PTR $T6[rsp+16], r14
	mov	QWORD PTR $T6[rsp+24], r14
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN1346@GenerateNo:
	bts	ebx, 11
	lea	rdi, QWORD PTR $T6[rsp]
	or	ebx, 2
$LN1345@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T4[rsp], ebx
	mov	rcx, QWORD PTR [r15+16]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, r8
	sub	rax, rcx
	cmp	rax, 2
	jb	$LN1110@GenerateNo

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN698@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN698@GenerateNo:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rax, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T19[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	ebx, 9
	mov	DWORD PTR $T4[rsp], ebx

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rdi
	lea	r8, QWORD PTR $T19[rbp-256]
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	ebx, 10
	mov	DWORD PTR $T4[rsp], ebx

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T12[rbp-240]
	mov	rdx, QWORD PTR $T12[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN636@GenerateNo

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T12[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T12[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T12[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 41			; 00000029H

; 3277 :             return *this;

	lea	rax, QWORD PTR $T12[rbp-256]
	jmp	SHORT $LN635@GenerateNo
$LN636@GenerateNo:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	mov	edx, 1
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN635@GenerateNo:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T11[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T11[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T11[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T11[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	bts	ebx, 8
	mov	DWORD PTR $T4[rsp], ebx

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR $T11[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, QWORD PTR $T11[rbp-256]
	mov	rdx, QWORD PTR $T11[rbp-232]
	cmp	rdx, 16
	cmovae	r8, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	r8, r8
	jne	SHORT $LN716@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm6, xmm7
	jmp	SHORT $LN713@GenerateNo
$LN716@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], r8
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rax+15696]
	lea	rdx, QWORD PTR text_size$15[rbp-256]
	mov	rcx, QWORD PTR [rax+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$15[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	movss	DWORD PTR text_size$15[rbp-256], xmm6

; 5428 : 
; 5429 :     return text_size;

	mov	rdx, QWORD PTR $T11[rbp-232]
	mov	rcx, QWORD PTR $T11[rbp-256]
$LN713@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 49   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	addss	xmm6, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN738@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN750@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN747@GenerateNo
$LN750@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN738@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T11[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T11[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T11[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T12[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN767@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T12[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN779@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN776@GenerateNo
$LN779@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN767@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T12[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T12[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T12[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T19[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN796@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T19[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN808@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN805@GenerateNo
$LN808@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN796@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 49   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 2
	je	SHORT $LN854@GenerateNo
	and	ebx, -3
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T6[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN854@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T6[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN866@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN863@GenerateNo
$LN866@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN854@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 49   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 1
	je	SHORT $LN825@GenerateNo
	and	ebx, -2
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T8[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN825@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T8[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN837@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN834@GenerateNo
$LN837@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN825@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 50   :             Width += ImGui::GetStyle().ItemSpacing.x + 24;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+14628]

; 51   :             Width += GetParamValueWidth(i);

	movzx	edx, r13b
	mov	rcx, rsi
	call	?GetParamValueWidth@UIAINBNodeBase@@QEAAME@Z ; UIAINBNodeBase::GetParamValueWidth

; 50   :             Width += ImGui::GetStyle().ItemSpacing.x + 24;

	movaps	xmm2, xmm1
	addss	xmm2, xmm12
	addss	xmm2, xmm6

; 51   :             Width += GetParamValueWidth(i);

	addss	xmm0, xmm2

; 52   :             if (i == (int)AINBFile::ValueType::Vec3f) {

	cmp	r13b, 4
	jne	SHORT $LN14@GenerateNo

; 53   :                 Width += ImGui::GetStyle().ItemSpacing.x;

	addss	xmm0, xmm1
$LN14@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR [rsi+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 55   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 47   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	add	r15, 240				; 000000f0H
	cmp	r15, r12
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	lea	r9, OFFSET FLAT:__ImageBase
	mov	r10d, 22
	lea	r11, QWORD PTR [r10-23]
	jne	$LL7@GenerateNo
	mov	rdx, QWORD PTR tv6748[rbp-256]
$LN1327@GenerateNo:

; 58   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) {

	mov	rax, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+200]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 58   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) {

	mov	r15, QWORD PTR [rcx+rdx*8]
	mov	r12, QWORD PTR [rcx+rdx*8+8]
	cmp	r15, r12
	je	$LN1341@GenerateNo
$LL10@GenerateNo:

; 60   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	cmp	r13b, 5
	jne	$LN18@GenerateNo
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T7[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T7[rsp+16], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T7[rbp-232], r14

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r15+56]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR [r15+40]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+64], 16
	jb	SHORT $LN594@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r14]
$LN594@GenerateNo:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, r8
	ja	$LN1112@GenerateNo

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN600@GenerateNo

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rsp+16], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-232], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T7[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN616@GenerateNo
$LN600@GenerateNo:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15
	cmp	rdi, r8

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN611@GenerateNo

; 4716 :             return _Max;

	mov	rdi, r8
	jmp	SHORT $LN610@GenerateNo
$LN611@GenerateNo:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	cmovb	rdi, r10
$LN610@GenerateNo:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	cmovb	rdx, r11
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T7[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T7[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN616@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 60   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	lea	rdi, QWORD PTR $T7[rsp]
	or	ebx, 4
	mov	rsi, QWORD PTR this$GSCopy$1$[rbp-256]
	xor	r14d, r14d
	jmp	$LN1348@GenerateNo
$LN18@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 210  :     switch (ValueType) {

	movzx	eax, r13b
	cmp	eax, 5
	ja	$LN261@GenerateNo
	mov	ecx, DWORD PTR $LN1334@GenerateNo[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN255@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 3

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_03DBLNGNIM@Int@
	mov	WORD PTR $T5[rsp], ax
	movzx	eax, BYTE PTR ??_C@_03DBLNGNIM@Int@+2
	mov	BYTE PTR $T5[rsp+2], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+3], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 212  :         return "Int";

	jmp	$LN1349@GenerateNo
$LN256@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 4

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	DWORD PTR $T5[rsp], 1819242306		; 6c6f6f42H

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+4], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 214  :         return "Bool";

	jmp	$LN1349@GenerateNo
$LN257@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 5

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_05KKPNNHNB@Float@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, BYTE PTR ??_C@_05KKPNNHNB@Float@+4
	mov	BYTE PTR $T5[rsp+4], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+5], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 216  :         return "Float";

	jmp	$LN1349@GenerateNo
$LN258@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 6

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_06ENNEIMBA@String@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, WORD PTR ??_C@_06ENNEIMBA@String@+4
	mov	WORD PTR $T5[rsp+4], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+6], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 218  :         return "String";

	jmp	$LN1349@GenerateNo
$LN259@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 5

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_05PJCBICIO@Vec3f@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, BYTE PTR ??_C@_05PJCBICIO@Vec3f@+4
	mov	BYTE PTR $T5[rsp+4], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+5], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 220  :         return "Vec3f";

	jmp	SHORT $LN1349@GenerateNo
$LN260@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 11

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movsd	xmm0, QWORD PTR ??_C@_0M@EALHFGP@UserDefined@
	movsd	QWORD PTR $T5[rsp], xmm0
	movzx	eax, WORD PTR ??_C@_0M@EALHFGP@UserDefined@+8
	mov	WORD PTR $T5[rsp+8], ax
	movzx	eax, BYTE PTR ??_C@_0M@EALHFGP@UserDefined@+10
	mov	BYTE PTR $T5[rsp+10], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+11], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 222  :         return "UserDefined";

	jmp	SHORT $LN1349@GenerateNo
$LN261@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 7

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rax, QWORD PTR ??_C@_07NBCGADJA@Unknown@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, WORD PTR ??_C@_07NBCGADJA@Unknown@+4
	mov	WORD PTR $T5[rsp+4], ax
	movzx	eax, BYTE PTR ??_C@_07NBCGADJA@Unknown@+6
	mov	BYTE PTR $T5[rsp+6], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+7], 0
$LN1349@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 60   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	mov	QWORD PTR $T5[rsp+24], 15
	bts	ebx, 7
	lea	rdi, QWORD PTR $T5[rsp]
	or	ebx, 8
$LN1348@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T4[rsp], ebx
	mov	rcx, QWORD PTR [r15+16]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, r8
	sub	rax, rcx
	cmp	rax, 2
	jb	$LN1120@GenerateNo

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN244@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN244@GenerateNo:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rax, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T18[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	ebx, 64					; 00000040H
	mov	DWORD PTR $T4[rsp], ebx

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rdi
	lea	r8, QWORD PTR $T18[rbp-256]
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	ebx, 32					; 00000020H
	mov	DWORD PTR $T4[rsp], ebx

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T14[rbp-240]
	mov	rdx, QWORD PTR $T14[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN178@GenerateNo

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T14[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T14[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T14[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 41			; 00000029H

; 3277 :             return *this;

	lea	rax, QWORD PTR $T14[rbp-256]
	jmp	SHORT $LN177@GenerateNo
$LN178@GenerateNo:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	mov	edx, 1
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN177@GenerateNo:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T13[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T13[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T13[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T13[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T13[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	or	ebx, 16
	mov	DWORD PTR $T4[rsp], ebx

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR $T13[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, QWORD PTR $T13[rbp-256]
	mov	rdx, QWORD PTR $T13[rbp-232]
	cmp	rdx, 16
	cmovae	r8, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	r8, r8
	jne	SHORT $LN152@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm6, xmm7
	jmp	SHORT $LN149@GenerateNo
$LN152@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], r8
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rax+15696]
	lea	rdx, QWORD PTR text_size$16[rbp-256]
	mov	rcx, QWORD PTR [rax+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$16[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	movss	DWORD PTR text_size$16[rbp-256], xmm6

; 5428 : 
; 5429 :     return text_size;

	mov	rdx, QWORD PTR $T13[rbp-232]
	mov	rcx, QWORD PTR $T13[rbp-256]
$LN149@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 60   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	addss	xmm6, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN103@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN115@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN112@GenerateNo
$LN115@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN103@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T13[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T13[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T13[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T14[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN73@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T14[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN85@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN82@GenerateNo
$LN85@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN73@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T14[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T14[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T14[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T18[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN132@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T18[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN144@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN141@GenerateNo
$LN144@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN132@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 60   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 8
	je	SHORT $LN566@GenerateNo
	and	ebx, -9
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T5[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN566@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T5[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN578@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN575@GenerateNo
$LN578@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN566@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 60   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 4
	je	SHORT $LN537@GenerateNo
	and	ebx, -5
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T7[rbp-232]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN537@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T7[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN549@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN546@GenerateNo
$LN549@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN537@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 61   :             Width += 2 * ImGui::GetStyle().ItemSpacing.x + 32;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+14628]
	addss	xmm1, xmm1
	addss	xmm1, xmm13
	addss	xmm1, xmm6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movss	xmm0, DWORD PTR [rsi+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 62   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 58   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) {

	add	r15, 72					; 00000048H
	cmp	r15, r12
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	lea	r9, OFFSET FLAT:__ImageBase
	mov	r10d, 22
	lea	r11, QWORD PTR [r10-23]
	jne	$LL10@GenerateNo
	mov	rdx, QWORD PTR tv6748[rbp-256]
$LN1341@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rax+152]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 65   :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	r14, QWORD PTR [rcx+rdx*8+8]
	mov	rdi, QWORD PTR [rcx+rdx*8]
	cmp	rdi, r14
	je	$LN2@GenerateNo
	xor	r15d, r15d
	npad	2
$LL13@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN44@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN44@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	rax, rax
	jne	SHORT $LN51@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm1, xmm7
	jmp	SHORT $LN48@GenerateNo
$LN51@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r15
	mov	QWORD PTR [rsp+48], r15
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rsi+15696]
	lea	rdx, QWORD PTR text_size$10[rbp-256]
	mov	rcx, QWORD PTR [rsi+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$10[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR text_size$10[rbp-256], xmm1
$LN48@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 69   :             Width += GetParamValueWidth(i);

	movzx	edx, r13b
	mov	rcx, QWORD PTR this$GSCopy$1$[rbp-256]
	call	?GetParamValueWidth@UIAINBNodeBase@@QEAAME@Z ; UIAINBNodeBase::GetParamValueWidth

; 66   :             float Width = 8 * 2;
; 67   :             Width += ImGui::CalcTextSize(Immediate.Name.c_str()).x;

	addss	xmm1, xmm8

; 68   :             Width += ImGui::GetStyle().ItemSpacing.x;

	addss	xmm1, DWORD PTR [rsi+14628]

; 69   :             Width += GetParamValueWidth(i);

	addss	xmm0, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movaps	xmm1, xmm0
	mov	rsi, rcx
	movss	xmm0, DWORD PTR [rcx+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 70   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 65   :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	add	rdi, 200				; 000000c8H
	cmp	rdi, r14
	jne	$LL13@GenerateNo
$LN2@GenerateNo:

; 46   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r13b
	cmp	r13b, 6
	jae	SHORT $LN1331@GenerateNo
	xor	r14d, r14d
	jmp	$LN1350@GenerateNo
$LN747@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN776@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN805@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN863@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN834@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN112@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN82@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN141@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN575@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN546@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1331@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 73   : }

	lea	r11, QWORD PTR [rsp+496]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN1120@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1108@GenerateNo:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1110@GenerateNo:

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1112@GenerateNo:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1343@GenerateNo:
	npad	2
$LN1335@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 73   : }

	DD	$LN874@GenerateNo
	DD	$LN875@GenerateNo
	DD	$LN876@GenerateNo
	DD	$LN877@GenerateNo
	DD	$LN878@GenerateNo
	DD	$LN879@GenerateNo
$LN1334@GenerateNo:
	DD	$LN255@GenerateNo
	DD	$LN256@GenerateNo
	DD	$LN257@GenerateNo
	DD	$LN258@GenerateNo
	DD	$LN259@GenerateNo
	DD	$LN260@GenerateNo
?GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ ENDP ; UIAINBNodeS32Selector::GenerateNodeShapeInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN22@dtor$1
	and	DWORD PTR $T4[rbp], -2
	lea	rcx, QWORD PTR $T8[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN22@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN24@dtor$2
	and	DWORD PTR $T4[rbp], -3
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN24@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$3@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$3
	lea	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$4@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$4
	lea	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN31@dtor$6
	and	DWORD PTR $T4[rbp], -5
	lea	rcx, QWORD PTR $T7[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN31@dtor$6:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN33@dtor$7
	and	DWORD PTR $T4[rbp], -9
	lea	rcx, QWORD PTR $T5[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN33@dtor$7:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$8@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$8
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 544
?dtor$9@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$9
	lea	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0??GenerateNodeShapeInfo@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::GenerateNodeShapeInfo'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupAINBElementSelector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupAINBElementSelector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupAINBElementSelector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
;	COMDAT ?Render@UIAINBNodeS32Selector@@UEAAXXZ
_TEXT	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?Render@UIAINBNodeS32Selector@@UEAAXXZ PROC		; UIAINBNodeS32Selector::Render, COMDAT

; 76   : {

$LN1874:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-488]
	sub	rsp, 704				; 000002c0H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r12, rcx
	mov	QWORD PTR this$GSCopy$1$[rbp-256], rcx
	xor	r14d, r14d
	mov	esi, r14d
	mov	DWORD PTR $T16[rsp], r14d

; 77   :     mPinIds.clear();

	add	rcx, 272				; 00000110H
	call	?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::clear

; 78   : 
; 79   :     uint32_t CurrentId = mEditorId;

	mov	edi, DWORD PTR [r12+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm0, XMMWORD PTR __xmm@41000000410000004100000041000000
	movups	XMMWORD PTR $T51[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 82   :     ed::PushStyleVar(ed::StyleVar_NodePadding, ImVec4(8, 8, 8, 8));

	lea	rdx, QWORD PTR $T51[rbp-256]
	call	?PushStyleVar@NodeEditor@ax@@YAXW4StyleVar@12@AEBUImVec4@@@Z ; ax::NodeEditor::PushStyleVar

; 83   :     ed::BeginNode(CurrentId++);

	mov	edx, edi
	inc	edi
	mov	DWORD PTR CurrentId$1$[rsp], edi
	mov	ebx, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp

; 148  :     s_Editor->GetNodeBuilder().Begin(id);

	mov	rcx, QWORD PTR ?s_Editor@@3PEAUEditorContext@Detail@NodeEditor@ax@@EA
	add	rcx, 1032				; 00000408H
	call	?Begin@NodeBuilder@Detail@NodeEditor@ax@@QEAAXUNodeId@34@@Z ; ax::NodeEditor::Detail::NodeBuilder::Begin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 87   :     if (mEnableFlow) {

	mov	rax, QWORD PTR [r12+256]
	movss	xmm12, DWORD PTR __real@41000000
	lea	r15, QWORD PTR [r14-1]
	movss	xmm7, DWORD PTR __real@437f0000
	cmp	BYTE PTR [rax], r14b
	je	$LN28@Render

; 88   :         float Alpha = ImGui::GetStyle().Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm6, DWORD PTR [rax+14552]

; 89   :         ImGui::PushStyleVar(ImGuiStyleVar_Alpha, Alpha);

	movaps	xmm1, xmm6
	xor	ecx, ecx
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 90   :         ImRect HeaderRect = DrawPin(CurrentId++, mFlowLinked, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Input, mNode->GetName());

	lea	rdx, QWORD PTR $T45[rbp-256]
	mov	rcx, QWORD PTR [r12+8]
	call	?GetName@Node@AINBFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; AINBFile::Node::GetName
	mov	r8d, edi
	inc	edi
	mov	DWORD PTR CurrentId$1$[rsp], edi
	mulss	xmm6, xmm7
	cvttss2si rcx, xmm6
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], r14d
	mov	DWORD PTR [rsp+40], 6
	mov	DWORD PTR [rsp+32], ecx
	movzx	r9d, BYTE PTR [r12+264]
	lea	rdx, QWORD PTR HeaderRect$50[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin

; 91   :         ImGui::PopStyleVar();

	lea	ecx, QWORD PTR [r14+1]
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 92   :         mPins.insert({ CurrentId - 1, Pin { .Kind = ed::PinKind::Input, .Type = UIAINBNodeBase::PinType::Flow, .Node = mNode } });

	lea	rcx, QWORD PTR [r12+120]
	mov	DWORD PTR $T29[rbp-256], r14d
	mov	DWORD PTR $T29[rbp-252], 6
	mov	rax, QWORD PTR [r12+8]
	mov	QWORD PTR $T29[rbp-248], rax
	mov	QWORD PTR $T29[rbp-240], r14
	mov	DWORD PTR $T29[rbp-232], r15d
	mov	WORD PTR $T29[rbp-228], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T44[rbp-256], ebx
	movups	xmm0, XMMWORD PTR $T29[rbp-256]
	movups	XMMWORD PTR $T44[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T29[rbp-240]
	movups	XMMWORD PTR $T44[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T44[rbp-256]
	lea	rdx, QWORD PTR $T63[rbp-256]
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 94   :         mNodeShapeInfo.HeaderMin = ImVec2(HeaderRect.GetTL().x - 32 - ImGui::GetStyle().ItemSpacing.x - 1, HeaderRect.GetTL().y - 14);

	movss	xmm0, DWORD PTR HeaderRect$50[rbp-252]
	subss	xmm0, DWORD PTR __real@41600000
	movss	xmm1, DWORD PTR HeaderRect$50[rbp-256]
	subss	xmm1, DWORD PTR __real@42000000
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	subss	xmm1, DWORD PTR [rax+14628]
	subss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [r12+24], xmm1
	movss	DWORD PTR [r12+28], xmm0

; 95   :         mNodeShapeInfo.HeaderMax = ImVec2(mNodeShapeInfo.HeaderMin.x + mNodeShapeInfo.FrameWidth + 10, HeaderRect.GetBR().y + 12);

	movss	xmm2, DWORD PTR HeaderRect$50[rbp-244]
	addss	xmm2, DWORD PTR __real@41400000

; 96   :     } else {

	jmp	$LN1865@Render
$LN28@Render:

; 97   :         ImGui::Text(mNode->GetName().c_str());

	mov	rdx, QWORD PTR [r12+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	movzx	eax, WORD PTR [rdx]
	lea	rcx, QWORD PTR $T72[rbp-256]
	test	ax, ax
	jne	SHORT $LN1614@Render

; 2909 : 		return this->Name;

	add	rdx, 32					; 00000020H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN1866@Render
$LN1614@Render:

; 2910 : 
; 2911 : 	return AINBFile::NodeTypeToString((AINBFile::NodeTypes)this->Type);

	movzx	edx, ax
	call	?NodeTypeToString@AINBFile@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4NodeTypes@1@@Z ; AINBFile::NodeTypeToString
$LN1866@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 97   :         ImGui::Text(mNode->GetName().c_str());

	mov	esi, 262144				; 00040000H
	mov	DWORD PTR $T16[rsp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T72[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T72[rbp-232], 16
	cmovae	rcx, QWORD PTR $T72[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 97   :         ImGui::Text(mNode->GetName().c_str());

	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T72[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5637 :     return g.LastItemData.Rect.Min;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm0, DWORD PTR [rax+18632]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 98   :         mNodeShapeInfo.HeaderMin = ImVec2(ImGui::GetItemRectMin().x - 1 - ImGui::GetStyle().ItemSpacing.x, ImGui::GetItemRectMin().y - 9);

	subss	xmm0, DWORD PTR __real@41100000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5637 :     return g.LastItemData.Rect.Min;

	movss	xmm1, DWORD PTR [rax+18628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 98   :         mNodeShapeInfo.HeaderMin = ImVec2(ImGui::GetItemRectMin().x - 1 - ImGui::GetStyle().ItemSpacing.x, ImGui::GetItemRectMin().y - 9);

	subss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR [rax+14628]
	movss	DWORD PTR [r12+24], xmm1
	movss	DWORD PTR [r12+28], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5643 :     return g.LastItemData.Rect.Max;

	movss	xmm2, DWORD PTR [rax+18640]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 99   :         mNodeShapeInfo.HeaderMax = ImVec2(mNodeShapeInfo.HeaderMin.x + mNodeShapeInfo.FrameWidth + 10, ImGui::GetItemRectMax().y + 8);

	addss	xmm2, xmm12
$LN1865@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	r11d, 32				; 00000020H
	mov	rbx, r12
	addss	xmm1, DWORD PTR [r12+20]
	mov	rax, r12
	addss	xmm1, DWORD PTR __real@41200000
	movss	DWORD PTR [rbx+r11], xmm1
	movss	DWORD PTR [rax+36], xmm2
	xorps	xmm8, xmm8
	mov	DWORD PTR $T19[rsp], 0
	mov	DWORD PTR $T19[rsp+4], 1090519040	; 41000000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 102  :     ImGui::Dummy(ImVec2(0, 8));

	lea	rcx, QWORD PTR $T19[rsp]
	call	?Dummy@ImGui@@YAXAEBUImVec2@@@Z		; ImGui::Dummy

; 103  : 
; 104  :     mNodeShapeInfo.HeaderMax.x += 8;

	movss	xmm0, DWORD PTR [rbx+r11]
	addss	xmm0, xmm12
	movss	DWORD PTR [rbx+r11], xmm0

; 105  : 
; 106  :         for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r13b, r13b
	movss	xmm13, DWORD PTR __real@bf800000
	npad	10
$LL4@Render:

; 107  :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	mov	rcx, QWORD PTR [r12+8]
	movzx	eax, r13b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdx, QWORD PTR [rax+rax*2]
	mov	QWORD PTR tv10350[rsp], rdx
	mov	rax, QWORD PTR [rcx+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 107  :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	mov	r15, QWORD PTR [rax+rdx*8]
	mov	rax, QWORD PTR [rax+rdx*8+8]
	mov	QWORD PTR <end>$L0$1$[rbp-256], rax
	cmp	r15, rax
	je	$LN2@Render
	lea	r14d, DWORD PTR [rdi-1]
	mov	DWORD PTR tv9712[rsp], r14d
	lea	rdi, QWORD PTR [r15+160]
	npad	1
$LL7@Render:

; 108  : 
; 109  :             // Input param (-> Name [Value])
; 110  :             float Alpha = ImGui::GetStyle().Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm6, DWORD PTR [rax+14552]

; 111  :             ImGui::PushStyleVar(ImGuiStyleVar_Alpha, Alpha);

	movaps	xmm1, xmm6
	xor	ecx, ecx
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 112  :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	cmp	r13b, 5
	jne	$LN49@Render
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T15[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T15[rsp+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T15[rsp+24], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rdi-112]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r12, QWORD PTR [rdi-128]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi-104], 16
	jb	SHORT $LN1495@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [r12]
$LN1495@Render:

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rax
	ja	$LN1655@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r14, 16
	jae	SHORT $LN1501@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T15[rsp+16], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T15[rsp+24], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T15[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN1517@Render
$LN1501@Render:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rax

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN1512@Render

; 4716 :             return _Max;

	mov	rbx, rax
	jmp	SHORT $LN1511@Render
$LN1512@Render:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN1511@Render:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T15[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T15[rsp+16], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T15[rsp+24], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
$LN1517@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 112  :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	lea	rbx, QWORD PTR $T15[rsp]
	or	esi, 1
	mov	r12, QWORD PTR this$GSCopy$1$[rbp-256]
	mov	r14d, DWORD PTR tv9712[rsp]
	jmp	SHORT $LN1867@Render
$LN49@Render:
	movzx	r8d, r13b
	lea	rdx, QWORD PTR $T55[rbp-256]
	call	?GetValueTypeName@UIAINBNodeBase@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z ; UIAINBNodeBase::GetValueTypeName
	mov	rbx, rax
	or	esi, 2
$LN1867@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T16[rsp], esi
	mov	rax, QWORD PTR [rdi-144]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	sub	rcx, rax
	cmp	rcx, 2
	jb	$LN1656@Render

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi-136], 16
	jb	SHORT $LN1456@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN1456@Render:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rcx, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR $T71[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	esi, 17
	mov	DWORD PTR $T16[rsp], esi

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rbx
	lea	r8, QWORD PTR $T71[rbp-256]
	lea	rcx, QWORD PTR $T43[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	esi, 15
	mov	DWORD PTR $T16[rsp], esi

; 3292 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	lea	rcx, QWORD PTR $T43[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T36[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
	mov	QWORD PTR $T36[rbp-240], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T36[rbp-232], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T36[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T36[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r10

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], r10b

; 4998 :     return _STD move(_Left.append(_Right));

	bts	esi, 16
	mov	DWORD PTR $T16[rsp], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 112  :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	movzx	edx, r13b
	call	?ValueTypeToPinType@UIAINBNodeBase@@QEAA?AW4PinType@1@E@Z ; UIAINBNodeBase::ValueTypeToPinType
	mov	ebx, eax
	mulss	xmm6, xmm7
	cvttss2si rax, xmm6
	cmp	WORD PTR [rdi-96], r10w
	jge	SHORT $LN1838@Render
	mov	rcx, QWORD PTR [rdi]
	cmp	QWORD PTR [rdi-8], rcx
	jne	SHORT $LN1838@Render
	xor	r9d, r9d
	jmp	SHORT $LN52@Render
$LN1838@Render:
	mov	r9b, 1
$LN52@Render:
	mov	ecx, DWORD PTR CurrentId$1$[rsp]
	mov	r8d, ecx
	inc	ecx
	mov	DWORD PTR CurrentId$1$[rsp], ecx
	inc	r14d
	mov	DWORD PTR tv9712[rsp], r14d
	lea	rcx, QWORD PTR $T36[rbp-256]
	mov	QWORD PTR [rsp+56], rcx
	mov	DWORD PTR [rsp+48], r10d
	mov	DWORD PTR [rsp+40], ebx
	mov	DWORD PTR [rsp+32], eax
	lea	rdx, QWORD PTR $T49[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T43[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T71[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 112  :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	test	sil, 2
	je	SHORT $LN1461@Render
	and	esi, -3
	mov	DWORD PTR $T16[rsp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T55[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
$LN1461@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 112  :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	test	sil, 1
	je	SHORT $LN1527@Render
	and	esi, -2
	mov	DWORD PTR $T16[rsp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T15[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1527@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 113  :             ImGui::PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12+72]
	mov	rcx, QWORD PTR tv10350[rsp]
	lea	rcx, QWORD PTR [rax+rcx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 114  :             mInputParameters[i].push_back(CurrentId - 1);

	mov	DWORD PTR $T32[rbp-256], r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN1328@Render

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], r14d

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN1327@Render
$LN1328@Render:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T32[rbp-256]
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
$LN1327@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 115  :             mPins.insert({ CurrentId - 1, Pin { .Kind = ed::PinKind::Input, .Type = ValueTypeToPinType(i), .Node = mNode, .ObjectPtr = &Input } });

	lea	rcx, QWORD PTR [r12+120]
	mov	DWORD PTR $T28[rbp-256], 0
	mov	DWORD PTR $T28[rbp-252], ebx
	mov	rax, QWORD PTR [r12+8]
	mov	QWORD PTR $T28[rbp-248], rax
	mov	QWORD PTR $T28[rbp-240], r15
	mov	rax, -1
	mov	DWORD PTR $T28[rbp-232], eax
	mov	WORD PTR $T28[rbp-228], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T42[rbp-256], r14d
	movups	xmm0, XMMWORD PTR $T28[rbp-256]
	movups	XMMWORD PTR $T42[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T28[rbp-240]
	movups	XMMWORD PTR $T42[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T42[rbp-256]
	lea	rdx, QWORD PTR $T59[rbp-256]
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 116  :             ImGui::SameLine();

	movaps	xmm1, xmm13
	movaps	xmm0, xmm8
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 117  :             if (Input.NodeIndex == -1 && Input.Sources.empty()) { // Input param is not linked to any output param, so the value has to be set directly

	cmp	WORD PTR [rdi-96], -1
	jne	$LN1837@Render
	mov	rax, QWORD PTR [rdi]
	cmp	QWORD PTR [rdi-8], rax
	jne	$LN1837@Render
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T67[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T67[rbp-240], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T67[rbp-232], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rdi-144]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi-136], 16
	jb	SHORT $LN1542@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [r15]
$LN1542@Render:

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rax
	ja	$LN1657@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T67[rbp-232], 15
	cmp	r14, 16
	jae	SHORT $LN1548@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T67[rbp-240], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T67[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN1556@Render
$LN1548@Render:

; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T67[rbp-256]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T67[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T67[rbp-240], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T67[rbp-232], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
$LN1556@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 118  :                 DrawParameterValue(static_cast<AINBFile::ValueType>(i), Input.Name, CurrentId, (void*)&Input.Value);

	lea	rax, QWORD PTR [rdi-56]
	movzx	edx, r13b
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR CurrentId$1$[rsp]
	lea	r8, QWORD PTR $T67[rbp-256]
	mov	r12, QWORD PTR this$GSCopy$1$[rbp-256]
	mov	rcx, r12
	call	?DrawParameterValue@UIAINBNodeBase@@QEAAXW4ValueType@AINBFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPEAX@Z ; UIAINBNodeBase::DrawParameterValue

; 119  :             } else {

	mov	r14d, DWORD PTR tv9712[rsp]
	jmp	SHORT $LN5@Render
$LN1837@Render:

; 120  :                 if (i == (int)AINBFile::ValueType::UserDefined) {

	cmp	r13b, 5
	jne	SHORT $LN32@Render

; 121  :                     ImGui::NewLine();

	call	?NewLine@ImGui@@YAXXZ			; ImGui::NewLine

; 122  :                 } else {

	jmp	SHORT $LN5@Render
$LN32@Render:

; 123  :                     ImGui::Dummy(ImVec2(GetParamValueWidth(i), 0));

	movzx	edx, r13b
	mov	rcx, r12
	call	?GetParamValueWidth@UIAINBNodeBase@@QEAAME@Z ; UIAINBNodeBase::GetParamValueWidth
	movss	DWORD PTR $T24[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T24[rbp-252], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 123  :                     ImGui::Dummy(ImVec2(GetParamValueWidth(i), 0));

	lea	rcx, QWORD PTR $T24[rbp-256]
	call	?Dummy@ImGui@@YAXAEBUImVec2@@@Z		; ImGui::Dummy
$LN5@Render:

; 107  :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	add	r15, 240				; 000000f0H
	add	rdi, 240				; 000000f0H
	cmp	r15, QWORD PTR <end>$L0$1$[rbp-256]
	jne	$LL7@Render
	mov	edi, DWORD PTR CurrentId$1$[rsp]
$LN2@Render:

; 105  : 
; 106  :         for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	mov	DWORD PTR tv9699[rsp], edi
	mov	r15d, edi
	mov	DWORD PTR $T18[rsp], edi
	inc	r13b
	cmp	r13b, 6
	jb	$LL4@Render

; 124  :                 }
; 125  :             }
; 126  :         }
; 127  :     }
; 128  : 
; 129  :     bool HasDefaultLink = false;

	xor	dil, dil
	mov	BYTE PTR HasDefaultLink$1$[rsp], dil
	xor	eax, eax
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR HasLink$[rbp-256], xmm1
	mov	QWORD PTR HasLink$[rbp-240], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 131  :     for (AINBFile::LinkedNodeInfo& Info : mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink]) {

	mov	rax, QWORD PTR [r12+8]
	mov	r14, QWORD PTR [rax+440]
	mov	r13, QWORD PTR [rax+448]
	lea	rax, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	cmp	r14, r13
	je	$LN9@Render

; 124  :                 }
; 125  :             }
; 126  :         }
; 127  :     }
; 128  : 
; 129  :     bool HasDefaultLink = false;

	lea	rbx, QWORD PTR [r14+40]
	npad	8
$LL10@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN1840@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN1840@Render:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	QWORD PTR [rbx+16], 7
	jne	SHORT $LN34@Render

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8d, 7
	mov	rdx, rax
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN34@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 133  :             HasDefaultLink = true;

	mov	dil, 1
	mov	BYTE PTR HasDefaultLink$1$[rsp], dil

; 134  :             continue;

	jmp	SHORT $LN8@Render
$LN34@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 90   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	call	QWORD PTR __imp__errno
	mov	r15, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdi, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN1839@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rbx]
$LN1839@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 93   :     _Errno_ref      = 0;

	mov	DWORD PTR [rax], 0

; 94   :     const long _Ans = _CSTD strtol(_Ptr, &_Eptr, _Base);

	mov	r8d, 10
	lea	rdx, QWORD PTR _Eptr$61[rbp-256]
	mov	rcx, rdi
	call	QWORD PTR __imp_strtol

; 95   : 
; 96   :     if (_Ptr == _Eptr) {

	cmp	rdi, QWORD PTR _Eptr$61[rbp-256]
	je	$LN1658@Render

; 98   :     }
; 99   : 
; 100  :     if (_Errno_ref == ERANGE) {

	cmp	DWORD PTR [r15], 34			; 00000022H
	je	$LN1659@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 137  :         HasLink.push_back(std::stoi(Info.Condition));

	mov	DWORD PTR $T31[rbp-256], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR HasLink$[rbp-248]
	cmp	rdx, QWORD PTR HasLink$[rbp-240]
	je	SHORT $LN1466@Render

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], eax

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR HasLink$[rbp-248], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN1868@Render
$LN1466@Render:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T31[rbp-256]
	lea	rcx, QWORD PTR HasLink$[rbp-256]
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
$LN1868@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 131  :     for (AINBFile::LinkedNodeInfo& Info : mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink]) {

	movzx	edi, BYTE PTR HasDefaultLink$1$[rsp]
$LN8@Render:
	add	r14, 312				; 00000138H
	add	rbx, 312				; 00000138H
	cmp	r14, r13
	lea	rax, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	jne	$LL10@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2620 :         if (_Count > max_size()) {

	mov	r15d, DWORD PTR $T18[rsp]
$LN9@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10264:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR [rbx+16408]

; 10265:     return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;

	movss	xmm6, DWORD PTR [rax+312]
	subss	xmm6, DWORD PTR [rax+80]
	addss	xmm6, DWORD PTR [rax+184]

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	xor	r13d, r13d
	mov	QWORD PTR [rsp+56], r13
	mov	QWORD PTR [rsp+48], r13
	lea	rax, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm13
	movss	xmm9, DWORD PTR __real@7f7fffff
	movaps	xmm3, xmm9
	movss	xmm2, DWORD PTR [rbx+15696]
	lea	rdx, QWORD PTR text_size$20[rbp-256]
	mov	rcx, QWORD PTR [rbx+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 140  :     ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize("Default").x + 18 + ImGui::GetStyle().ItemSpacing.x));

	addss	xmm6, DWORD PTR [r12+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$20[rbp-256]
	movss	xmm10, DWORD PTR __real@3f7fff58
	addss	xmm0, xmm10
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 140  :     ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize("Default").x + 18 + ImGui::GetStyle().ItemSpacing.x));

	addss	xmm1, xmm12
	movss	xmm11, DWORD PTR __real@41900000
	addss	xmm1, xmm11
	addss	xmm1, DWORD PTR [rbx+14628]
	subss	xmm6, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10285:     window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;

	movss	xmm0, DWORD PTR [rax+80]
	subss	xmm0, DWORD PTR [rax+184]
	addss	xmm0, xmm6
	movss	DWORD PTR [rax+312], xmm0

; 10286:     //window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
; 10287:     window->DC.IsSetPos = true;

	mov	BYTE PTR [rax+377], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 141  :     float Alpha = ImGui::GetStyle().Alpha;

	movss	xmm6, DWORD PTR [rbx+14552]

; 142  :     ImGui::PushStyleVar(ImGuiStyleVar_Alpha, Alpha);

	movaps	xmm1, xmm6
	xor	ecx, ecx
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 143  :     DrawPin(CurrentId++, HasDefaultLink, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Output, "Default");

	mov	r14d, DWORD PTR CurrentId$1$[rsp]
	mov	ebx, r14d
	inc	r14d
	mov	DWORD PTR CurrentId$1$[rsp], r14d
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T70[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T70[rbp-240], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T70[rbp-232], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r13+7]
	lea	rdx, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	lea	rcx, QWORD PTR $T70[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 143  :     DrawPin(CurrentId++, HasDefaultLink, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Output, "Default");

	mulss	xmm6, xmm7
	cvttss2si rax, xmm6
	mov	QWORD PTR tv9710[rbp-256], rax
	lea	rcx, QWORD PTR $T70[rbp-256]
	mov	QWORD PTR [rsp+56], rcx
	mov	DWORD PTR [rsp+48], 1
	mov	DWORD PTR [rsp+40], 6
	mov	DWORD PTR [rsp+32], eax
	movzx	r9d, dil
	mov	r8d, ebx
	lea	rdx, QWORD PTR $T58[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin

; 144  :     mPins.insert({ CurrentId - 1, UIAINBNodeBase::Pin { .Kind = ed::PinKind::Output, .Type = UIAINBNodeBase::PinType::Flow, .Node = mNode, .ObjectPtr = (void*)0x1, .ParameterIndex = 0, .AllowMultipleLinks = false, .AlreadyLinked = HasDefaultLink } });

	mov	DWORD PTR $T27[rbp-256], 1
	mov	DWORD PTR $T27[rbp-252], 6
	mov	rax, QWORD PTR [r12+8]
	mov	QWORD PTR $T27[rbp-248], rax
	mov	QWORD PTR $T27[rbp-240], 1
	mov	DWORD PTR $T27[rbp-232], r13d
	mov	BYTE PTR $T27[rbp-228], r13b
	mov	BYTE PTR $T27[rbp-227], dil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T41[rbp-256], r15d
	movups	xmm0, XMMWORD PTR $T27[rbp-256]
	movups	XMMWORD PTR $T41[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T27[rbp-240]
	movups	XMMWORD PTR $T41[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T41[rbp-256]
	lea	rdx, QWORD PTR $T57[rbp-256]
	lea	rcx, QWORD PTR [r12+120]
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 145  :     mPinIdDefault = CurrentId - 1;

	mov	DWORD PTR [r12+360], r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rdi, QWORD PTR [r12+336]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 147  :     for (auto Iter = mConditions.begin(); Iter != mConditions.end(); ) {

	cmp	rdi, QWORD PTR [r12+344]
	je	$LN12@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm6, XMMWORD PTR __xmm@3f8000003d8f5c293d8f5c293ef0a3d7

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T30[rbp-252], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	lea	rax, QWORD PTR [rdi+4]
	mov	QWORD PTR tv9700[rsp], rax
	npad	4
$LL11@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 124  :         return const_cast<_Ty*>(

	mov	r8d, DWORD PTR [rdi]
	mov	rdx, QWORD PTR HasLink$[rbp-248]
	mov	rcx, QWORD PTR HasLink$[rbp-256]
	call	__std_find_trivial_4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 148  :         bool Linked = std::find(HasLink.begin(), HasLink.end(), *Iter) != HasLink.end();

	cmp	rax, QWORD PTR HasLink$[rbp-248]
	setne	BYTE PTR Linked$1$[rsp]

; 149  :         std::string Text = "= " + std::to_string(*Iter);

	mov	edx, DWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 482  :     if (_Val < 0) {

	lea	rcx, QWORD PTR _Buff$73[rbp-235]
	test	edx, edx
	jns	SHORT $LN1202@Render

; 483  :         _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);

	neg	edx
	call	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>

; 484  :         *--_RNext = '-';

	dec	rax
	mov	BYTE PTR [rax], 45			; 0000002dH

; 485  :     } else {

	jmp	SHORT $LN1203@Render
$LN1659@Render:

; 101  :         _Xout_of_range("stoi argument out of range");

	lea	rcx, OFFSET FLAT:??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN1658@Render:

; 97   :         _Xinvalid_argument("invalid stoi argument");

	lea	rcx, OFFSET FLAT:??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
	call	QWORD PTR __imp_?_Xinvalid_argument@std@@YAXPEBD@Z
	int	3
$LN1202@Render:

; 486  :         _RNext = _UIntegral_to_buff(_RNext, _UVal);

	call	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
$LN1203@Render:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T54[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r15d, r15d
	mov	QWORD PTR $T54[rbp-240], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T54[rbp-232], r15

; 2574 :         if (_UFirst == _ULast) {

	lea	rcx, QWORD PTR _Buff$73[rbp-235]
	cmp	rax, rcx
	jne	SHORT $LN1208@Render

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T54[rbp-240], r15

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T54[rbp-232], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T54[rbp-256], r15b

; 2577 :         } else {

	jmp	SHORT $LN1209@Render
$LN1208@Render:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$73[rbp-235]
	sub	r8, rax
	mov	rdx, rax
	lea	rcx, QWORD PTR $T54[rbp-256]
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN1209@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 505  :     return _Integral_to_string<char>(_Val);

	or	esi, 24576				; 00006000H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 2
	lea	r8, OFFSET FLAT:??_C@_02LJIJHEIM@?$DN?5@
	lea	rcx, QWORD PTR $T54[rbp-256]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Text$66[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR Text$66[rbp-240], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR Text$66[rbp-232], r15

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR Text$66[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR Text$66[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r15

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], 0

; 4986 :     return _STD move(_Right.insert(0, _Left));

	bts	esi, 12

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T54[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Text$66[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Text$66[rbp-232], 16
	cmovae	rax, QWORD PTR Text$66[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5409 : 
; 5410 :     const char* text_display_end;
; 5411 :     if (hide_text_after_double_hash)
; 5412 :         text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
; 5413 :     else
; 5414 :         text_display_end = text_end;
; 5415 : 
; 5416 :     ImFont* font = g.Font;
; 5417 :     const float font_size = g.FontSize;
; 5418 :     if (text == text_display_end)

	test	rax, rax
	jne	SHORT $LN805@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm3, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN802@Render
$LN805@Render:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r15
	mov	QWORD PTR [rsp+48], r15
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm13
	movaps	xmm3, xmm9
	movss	xmm2, DWORD PTR [rbx+15696]
	lea	rdx, QWORD PTR text_size$21[rbp-256]
	mov	rcx, QWORD PTR [rbx+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$21[rbp-256]
	addss	xmm0, xmm10
	cvttss2si eax, xmm0
	movd	xmm3, eax
	cvtdq2ps xmm3, xmm3
	movss	DWORD PTR text_size$21[rbp-256], xmm3
$LN802@Render:

; 10264:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 150  :         ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize(Text.c_str()).x + 18 + 2 * ImGui::GetStyle().ItemSpacing.x + ImGui::GetFrameHeight()));

	movss	xmm1, DWORD PTR [rbx+14628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm0, DWORD PTR [rbx+14616]

; 10265:     return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;

	movss	xmm2, DWORD PTR [rax+312]
	subss	xmm2, DWORD PTR [rax+80]
	addss	xmm2, DWORD PTR [rax+184]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 150  :         ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize(Text.c_str()).x + 18 + 2 * ImGui::GetStyle().ItemSpacing.x + ImGui::GetFrameHeight()));

	addss	xmm2, DWORD PTR [r12+20]
	addss	xmm1, xmm1
	addss	xmm3, xmm12
	addss	xmm3, xmm11
	addss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	addss	xmm0, xmm0
	addss	xmm0, DWORD PTR [rbx+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 150  :         ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (8 + ImGui::CalcTextSize(Text.c_str()).x + 18 + 2 * ImGui::GetStyle().ItemSpacing.x + ImGui::GetFrameHeight()));

	addss	xmm1, xmm0
	subss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10285:     window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;

	movss	xmm0, DWORD PTR [rax+80]
	subss	xmm0, DWORD PTR [rax+184]
	addss	xmm0, xmm2
	movss	DWORD PTR [rax+312], xmm0

; 10286:     //window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
; 10287:     window->DC.IsSetPos = true;

	mov	BYTE PTR [rax+377], 1

; 3135 :     backup.Col = idx;

	mov	DWORD PTR backup$11[rsp], r15d

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+14776]
	movups	XMMWORD PTR backup$11[rsp+4], xmm0

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
	lea	rdx, QWORD PTR backup$11[rsp]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	movups	XMMWORD PTR [rbx+14776], xmm6

; 10420:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm0, DWORD PTR [rax+14616]
	addss	xmm0, xmm0
	addss	xmm0, DWORD PTR [rax+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T30[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 152  :         bool WantRemove = ImGui::Button(("-##S32Selector" + std::to_string(mNode->NodeIndex) + ";" + std::to_string(*Iter)).c_str(), ImVec2(ImGui::GetFrameHeight(), 0));

	mov	edx, DWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 482  :     if (_Val < 0) {

	lea	rcx, QWORD PTR _Buff$74[rbp-235]
	test	edx, edx
	jns	SHORT $LN840@Render

; 483  :         _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);

	neg	edx
	call	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>

; 484  :         *--_RNext = '-';

	dec	rax
	mov	BYTE PTR [rax], 45			; 0000002dH

; 485  :     } else {

	jmp	SHORT $LN841@Render
$LN840@Render:

; 486  :         _RNext = _UIntegral_to_buff(_RNext, _UVal);

	call	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
$LN841@Render:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T26[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T26[rbp-240], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T26[rbp-232], r15

; 2574 :         if (_UFirst == _ULast) {

	lea	rcx, QWORD PTR _Buff$74[rbp-235]
	cmp	rax, rcx
	jne	SHORT $LN846@Render

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T26[rbp-240], r15

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T26[rbp-232], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T26[rbp-256], 0

; 2577 :         } else {

	jmp	SHORT $LN847@Render
$LN846@Render:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$74[rbp-235]
	sub	r8, rax
	mov	rdx, rax
	lea	rcx, QWORD PTR $T26[rbp-256]
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN847@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 505  :     return _Integral_to_string<char>(_Val);

	or	esi, 48					; 00000030H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 152  :         bool WantRemove = ImGui::Button(("-##S32Selector" + std::to_string(mNode->NodeIndex) + ";" + std::to_string(*Iter)).c_str(), ImVec2(ImGui::GetFrameHeight(), 0));

	mov	rax, QWORD PTR [r12+8]
	movzx	edx, WORD PTR [rax+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 486  :         _RNext = _UIntegral_to_buff(_RNext, _UVal);

	lea	rcx, QWORD PTR _Buff$76[rbp-235]
	call	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T14[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T14[rsp+16], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T14[rsp+24], r15

; 2574 :         if (_UFirst == _ULast) {

	lea	rcx, QWORD PTR _Buff$76[rbp-235]
	cmp	rax, rcx
	jne	SHORT $LN870@Render

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T14[rsp+16], r15

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T14[rsp+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T14[rsp], 0

; 2577 :         } else {

	jmp	SHORT $LN871@Render
$LN870@Render:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$76[rbp-235]
	sub	r8, rax
	mov	rdx, rax
	lea	rcx, QWORD PTR $T14[rsp]
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN871@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 505  :     return _Integral_to_string<char>(_Val);

	or	esi, 192				; 000000c0H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 14
	lea	r8, OFFSET FLAT:??_C@_0P@NGILPLHN@?9?$CD?$CDS32Selector@
	lea	rcx, QWORD PTR $T14[rsp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T69[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T69[rbp-240], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T69[rbp-232], r15

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T69[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T69[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r15

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], 0

; 4986 :     return _STD move(_Right.insert(0, _Left));

	bts	esi, 8

; 3292 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01ICJEACDI@?$DL@
	lea	rcx, QWORD PTR $T69[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T40[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T40[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r15

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], 0

; 4998 :     return _STD move(_Left.append(_Right));

	bts	esi, 9

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	lea	r9, QWORD PTR $T26[rbp-256]
	lea	r8, QWORD PTR $T40[rbp-256]
	lea	rcx, QWORD PTR $T35[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	esi, 10

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T35[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T35[rbp-232], 16
	cmovae	rcx, QWORD PTR $T35[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T30[rbp-256]
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
	mov	BYTE PTR WantRemove$1$[rsp], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T35[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN976@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T35[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN976@Render:

; 4839 :         }
; 4840 : 
; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T35[rbp-240], r15

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T35[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T35[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T40[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN984@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T40[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1
$LN984@Render:

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T69[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T14[rsp+24]
	cmp	r8, 16
	jb	SHORT $LN992@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T14[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN992@Render:

; 4839 :         }
; 4840 : 
; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T14[rsp+16], r15

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T14[rsp+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T14[rsp], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T26[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1000@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T26[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1000@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 153  :         ImGui::PopStyleColor();

	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor

; 154  :         ImGui::SameLine();

	movaps	xmm1, xmm13
	movaps	xmm0, xmm8
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 155  :         DrawPin(CurrentId++, Linked, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Output, Text);

	mov	r13d, r14d
	inc	r14d
	mov	DWORD PTR CurrentId$1$[rsp], r14d
	inc	DWORD PTR tv9699[rsp]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T13[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T13[rsp+16], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T13[rsp+24], r15

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR Text$66[rbp-240]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r15, QWORD PTR Text$66[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Text$66[rbp-232], 16
	cmovae	r15, QWORD PTR Text$66[rbp-256]

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rax
	ja	$LN1662@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T13[rsp+24], 15
	cmp	r14, 16
	jae	SHORT $LN1021@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T13[rsp+16], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T13[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN1037@Render
$LN1021@Render:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	rbx, r14
	or	rbx, 15

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	rbx, rax

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN1032@Render

; 4716 :             return _Max;

	mov	rbx, rax
	jmp	SHORT $LN1031@Render
$LN1032@Render:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN1031@Render:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T13[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T13[rsp+16], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T13[rsp+24], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
$LN1037@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 155  :         DrawPin(CurrentId++, Linked, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Output, Text);

	lea	rax, QWORD PTR $T13[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], 1
	mov	DWORD PTR [rsp+40], 6
	mov	rax, QWORD PTR tv9710[rbp-256]
	mov	DWORD PTR [rsp+32], eax
	movzx	ebx, BYTE PTR Linked$1$[rsp]
	movzx	r9d, bl
	mov	r8d, r13d
	lea	rdx, QWORD PTR $T56[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin

; 156  :         mPins.insert({ CurrentId - 1, UIAINBNodeBase::Pin { .Kind = ed::PinKind::Output, .Type = UIAINBNodeBase::PinType::Flow, .Node = mNode, .ParameterIndex = *Iter, .AllowMultipleLinks = false, .AlreadyLinked = Linked } });

	mov	DWORD PTR $T34[rbp-256], 1
	mov	DWORD PTR $T34[rbp-252], 6
	mov	rax, QWORD PTR [r12+8]
	mov	QWORD PTR $T34[rbp-248], rax
	mov	QWORD PTR $T34[rbp-240], 0
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR $T34[rbp-232], eax
	mov	BYTE PTR $T34[rbp-228], 0
	mov	BYTE PTR $T34[rbp-227], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	ebx, DWORD PTR tv9699[rsp]
	mov	DWORD PTR $T39[rbp-256], ebx
	movups	xmm0, XMMWORD PTR $T34[rbp-256]
	movups	XMMWORD PTR $T39[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T34[rbp-240]
	movups	XMMWORD PTR $T39[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T39[rbp-256]
	lea	rdx, QWORD PTR $T60[rbp-256]
	lea	rcx, QWORD PTR [r12+120]
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR $T17[rsp], eax
	mov	DWORD PTR $T17[rsp+4], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T17[rsp]
	lea	rdx, QWORD PTR $T53[rbp-256]
	lea	rcx, QWORD PTR [r12+272]
	call	??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::emplace<std::pair<int const ,unsigned int> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 158  :         if (WantRemove) {

	cmp	BYTE PTR WantRemove$1$[rsp], 0
	je	$LN35@Render

; 159  :             for (auto LinkIter = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].begin(); LinkIter != mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].end();) {

	mov	rax, QWORD PTR [r12+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rbx, QWORD PTR [rax+440]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 159  :             for (auto LinkIter = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].begin(); LinkIter != mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].end();) {

	cmp	rbx, QWORD PTR [rax+448]
	je	$LN15@Render
	mov	r13, QWORD PTR this$GSCopy$1$[rbp-256]
	npad	7
$LL14@Render:

; 160  :                 if (LinkIter->Condition == std::to_string(*Iter)) {

	mov	edx, DWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 482  :     if (_Val < 0) {

	lea	rcx, QWORD PTR _Buff$75[rbp-235]
	test	edx, edx
	jns	SHORT $LN762@Render

; 483  :         _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);

	neg	edx
	call	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>

; 484  :         *--_RNext = '-';

	dec	rax
	mov	BYTE PTR [rax], 45			; 0000002dH

; 485  :     } else {

	jmp	SHORT $LN763@Render
$LN762@Render:

; 486  :         _RNext = _UIntegral_to_buff(_RNext, _UVal);

	call	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
$LN763@Render:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T25[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	ecx, ecx
	mov	QWORD PTR $T25[rbp-240], rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T25[rbp-232], rcx

; 2574 :         if (_UFirst == _ULast) {

	lea	rdx, QWORD PTR _Buff$75[rbp-235]
	cmp	rax, rdx
	jne	SHORT $LN768@Render

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	r14d, 15
	mov	QWORD PTR $T25[rbp-232], r14

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T25[rbp-256], cl

; 2577 :         } else {

	jmp	SHORT $LN769@Render
$LN768@Render:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$75[rbp-235]
	sub	r8, rax
	mov	rdx, rax
	lea	rcx, QWORD PTR $T25[rbp-256]
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
	mov	r14, QWORD PTR $T25[rbp-232]
	mov	rcx, QWORD PTR $T25[rbp-240]
$LN769@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 505  :     return _Integral_to_string<char>(_Val);

	or	esi, 12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T25[rbp-256]

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r14, 16
	setae	BYTE PTR $T9[rsp]

; 2236 :         if (_Large_string_engaged()) {

	mov	r15, QWORD PTR $T25[rbp-256]
	cmovae	rdx, r15

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+56]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR [rbx+40]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+64], 16
	jb	SHORT $LN747@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN747@Render:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rcx
	jne	SHORT $LN753@Render

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rcx, rax
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN753@Render
	mov	r12b, 1
	jmp	SHORT $LN754@Render
$LN753@Render:
	xor	r12b, r12b
$LN754@Render:

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	BYTE PTR $T9[rsp], 0
	je	SHORT $LN720@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [r14+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r15

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN732@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r15, QWORD PTR [r15-8]
	sub	rax, r15

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN729@Render
$LN732@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r15
	call	??3@YAXPEAX_K@Z				; operator delete
$LN720@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 160  :                 if (LinkIter->Condition == std::to_string(*Iter)) {

	mov	rcx, QWORD PTR [r13+8]
	test	r12b, r12b
	jne	SHORT $LN1661@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 79   :         ++_Ptr;

	add	rbx, 312				; 00000138H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 159  :             for (auto LinkIter = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].begin(); LinkIter != mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].end();) {

	cmp	rbx, QWORD PTR [rcx+448]
	jne	$LL14@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2620 :         if (_Count > max_size()) {

	jmp	SHORT $LN1869@Render
$LN1661@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 161  :                     mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].erase(LinkIter);

	add	rcx, 440				; 000001b8H
	mov	r8, rbx
	lea	rdx, QWORD PTR $T48[rbp-256]
	call	?erase@?$vector@ULinkedNodeInfo@AINBFile@@V?$allocator@ULinkedNodeInfo@AINBFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULinkedNodeInfo@AINBFile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULinkedNodeInfo@AINBFile@@@std@@@std@@@2@@Z ; std::vector<AINBFile::LinkedNodeInfo,std::allocator<AINBFile::LinkedNodeInfo> >::erase
$LN1869@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1729 :         _STD _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

	mov	r12, r13
$LN15@Render:
	mov	r8, QWORD PTR [r12+344]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, QWORD PTR tv9700[rsp]

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, QWORD PTR tv9700[rsp]
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1732 :         --_Mylast;

	add	QWORD PTR [r12+344], -4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 168  :         } else {

	jmp	SHORT $LN1322@Render
$LN35@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 79   :         ++_Ptr;

	add	rdi, 4
	add	QWORD PTR tv9700[rsp], 4
$LN1322@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR Text$66[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN677@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR Text$66[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN689@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN686@Render
$LN689@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN677@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 147  :     for (auto Iter = mConditions.begin(); Iter != mConditions.end(); ) {

	cmp	rdi, QWORD PTR [r12+344]
	je	SHORT $LN12@Render
	mov	r14d, DWORD PTR CurrentId$1$[rsp]
	jmp	$LL11@Render
$LN729@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN686@Render:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN12@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 173  :     ImGui::PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm6, XMMWORD PTR __xmm@3f800000000000003f80000000000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3133 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3134 :     ImGuiColorMod backup;
; 3135 :     backup.Col = idx;

	xor	edi, edi
	mov	DWORD PTR backup$10[rsp], edi

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+14776]
	movups	XMMWORD PTR backup$10[rsp+4], xmm0

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
	lea	rdx, QWORD PTR backup$10[rsp]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	movups	XMMWORD PTR [rbx+14776], xmm6

; 10420:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm0, DWORD PTR [rax+14616]
	addss	xmm0, xmm0
	addss	xmm0, DWORD PTR [rax+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T23[rbp-256], xmm0
	mov	DWORD PTR $T23[rbp-252], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 176  :     if (ImGui::Button(("+##S32Selector" + std::to_string(mNode->NodeIndex)).c_str(), ImVec2(ImGui::GetFrameHeight(), 0))) {

	mov	rax, QWORD PTR [r12+8]
	movzx	edx, WORD PTR [rax+2]
	lea	rcx, QWORD PTR $T38[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r9d, QWORD PTR [rdi+14]
	lea	r8, OFFSET FLAT:??_C@_0P@PEHBCPIP@?$CL?$CD?$CDS32Selector@
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T33[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T33[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T33[rbp-232], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T33[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T33[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rdi

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], dil

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T33[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T33[rbp-232], 16
	cmovae	rcx, QWORD PTR $T33[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T23[rbp-256]
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T33[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T38[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 176  :     if (ImGui::Button(("+##S32Selector" + std::to_string(mNode->NodeIndex)).c_str(), ImVec2(ImGui::GetFrameHeight(), 0))) {

	test	bl, bl
	je	$LN1307@Render

; 177  :         PopupAINBElementSelector::Open("Condition: signed 32-bit number", "signed 32-bit number", "Add condition", this, [](void* ThisPtr, std::string Number) {

	lea	rax, QWORD PTR $T52[rbp-256]
	mov	QWORD PTR $T47[rbp-256], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T52[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T52[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T52[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+13]
	lea	rdx, OFFSET FLAT:??_C@_0O@EPJALJIO@Add?5condition@
	lea	rcx, QWORD PTR $T52[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 177  :         PopupAINBElementSelector::Open("Condition: signed 32-bit number", "signed 32-bit number", "Add condition", this, [](void* ThisPtr, std::string Number) {

	lea	rax, QWORD PTR $T52[rbp-256]
	mov	QWORD PTR $T62[rbp-256], rax
	lea	rax, QWORD PTR $T12[rsp]
	mov	QWORD PTR $T22[rbp-256], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T12[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T12[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+20]
	lea	rdx, OFFSET FLAT:??_C@_0BF@GDLLHGNJ@signed?532?9bit?5number@
	lea	rcx, QWORD PTR $T12[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 177  :         PopupAINBElementSelector::Open("Condition: signed 32-bit number", "signed 32-bit number", "Add condition", this, [](void* ThisPtr, std::string Number) {

	lea	rax, QWORD PTR $T12[rsp]
	mov	QWORD PTR $T37[rbp-256], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T65[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T65[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T65[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+31]
	lea	rdx, OFFSET FLAT:??_C@_0CA@NFBKPPAJ@Condition?3?5signed?532?9bit?5number@
	lea	rcx, QWORD PTR $T65[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 177  :         PopupAINBElementSelector::Open("Condition: signed 32-bit number", "signed 32-bit number", "Add condition", this, [](void* ThisPtr, std::string Number) {

	lea	rax, QWORD PTR $T65[rbp-256]
	mov	QWORD PTR $T46[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupAINBElementSelector.cpp

; 52   :     Func = Callback;

	lea	rax, OFFSET FLAT:?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; `UIAINBNodeS32Selector::Render'::`45'::<lambda_1>::<lambda_invoker_cdecl>
	mov	QWORD PTR ?Func@PopupAINBElementSelector@@3P6AXPEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ZEA, rax ; PopupAINBElementSelector::Func
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T12[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T12[rsp+24], 16
	cmovae	rdx, QWORD PTR $T12[rsp]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR $T12[rsp+16]
	lea	rcx, OFFSET FLAT:?Key@PopupAINBElementSelector@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; PopupAINBElementSelector::Key
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, OFFSET FLAT:?Value@PopupAINBElementSelector@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; PopupAINBElementSelector::Value
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupAINBElementSelector.cpp

; 55   :     IsOpen = true;

	mov	BYTE PTR ?IsOpen@PopupAINBElementSelector@@3_NA, 1 ; PopupAINBElementSelector::IsOpen
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T65[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T65[rbp-232], 16
	cmovae	rdx, QWORD PTR $T65[rbp-256]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR $T65[rbp-240]
	lea	rcx, OFFSET FLAT:?PopupTitle@PopupAINBElementSelector@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; PopupAINBElementSelector::PopupTitle
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T52[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T52[rbp-232], 16
	cmovae	rdx, QWORD PTR $T52[rbp-256]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR $T52[rbp-240]
	lea	rcx, OFFSET FLAT:?ConfirmButtonText@PopupAINBElementSelector@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; PopupAINBElementSelector::ConfirmButtonText
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupAINBElementSelector.cpp

; 58   :     PopupAINBElementSelector::ThisPtr = ThisPtr;

	mov	QWORD PTR ?ThisPtr@PopupAINBElementSelector@@3PEAXEA, r12 ; PopupAINBElementSelector::ThisPtr
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T65[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T12[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T52[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1307@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 185  :     ImGui::PopStyleColor();

	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10258:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [r10+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm7, DWORD PTR [rax+316]
	subss	xmm7, DWORD PTR [rax+84]
	movss	xmm6, DWORD PTR [rax+312]
	subss	xmm6, DWORD PTR [rax+80]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm7, DWORD PTR [rax+188]
	addss	xmm6, DWORD PTR [rax+184]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 188  :     bool HasImmediate = false;

	mov	BYTE PTR HasImmediate$1$[rsp], 0

; 189  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	dl, dl
	mov	rax, QWORD PTR [r12+8]
	mov	r8, QWORD PTR [rax+152]
	npad	15
$LL19@Render:

; 190  :         if (!mNode->ImmediateParameters[i].empty()) {

	movzx	eax, dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rax+rax*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 190  :         if (!mNode->ImmediateParameters[i].empty()) {

	mov	rax, QWORD PTR [r8+rcx*8+8]
	cmp	QWORD PTR [r8+rcx*8], rax
	jne	SHORT $LN1663@Render

; 189  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	dl
	cmp	dl, 6
	jb	SHORT $LL19@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2620 :         if (_Count > max_size()) {

	jmp	SHORT $LN40@Render
$LN1663@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 191  :             HasImmediate = true;

	mov	BYTE PTR HasImmediate$1$[rsp], 1

; 192  :             break;
; 193  :         }
; 194  :     }
; 195  : 
; 196  :     if (HasImmediate)
; 197  :         ImGui::NewLine();

	call	?NewLine@ImGui@@YAXXZ			; ImGui::NewLine
$LN40@Render:

; 198  : 
; 199  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r8b, r8b
	mov	BYTE PTR i$1$[rsp], r8b
	lea	rsi, OFFSET FLAT:__ImageBase
	npad	12
$LL22@Render:

; 200  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	rdx, QWORD PTR [r12+8]
	movzx	eax, r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [rdx+152]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 200  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	r14, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR [rax+rcx*8+8]
	mov	QWORD PTR <end>$L2$1$[rbp-256], rax
	cmp	r14, rax
	je	$LN20@Render
	lea	rbx, QWORD PTR [r14+64]
	movzx	r13d, r8b
$LL25@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx-40], 16
	jb	SHORT $LN1843@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN1843@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 256  :     TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+1]
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 203  :             ImGui::SameLine();

	movaps	xmm1, xmm13
	movaps	xmm0, xmm8
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rdx, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 205  :             bool ValueTypeMismatch = Immediate.ValueType != Immediate.Value.index();

	movsxd	rax, DWORD PTR [rbx+8]

; 206  :             if (ValueTypeMismatch) {

	cmp	rax, rdx
	je	$LN293@Render

; 207  :                 switch (i) {

	mov	ecx, r13d
	test	r13d, r13d
	je	$LN42@Render
	sub	ecx, 1
	je	$LN44@Render
	sub	ecx, 1
	je	$LN43@Render
	sub	ecx, 1
	je	SHORT $LN45@Render
	cmp	ecx, 1
	jne	$LN293@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 4
	jne	SHORT $LN295@Render

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	movaps	xmm0, xmm8
	unpcklps xmm0, xmm8
	movsd	QWORD PTR [rbx-32], xmm0
	movss	DWORD PTR [rbx-24], xmm8

; 1034 :         } else {

	jmp	$LN293@Render
$LN295@Render:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1857@Render[rsi+rdx*4+4]
	add	rax, rsi
	jmp	rax
$LN315@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN333@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 391  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movaps	xmm0, xmm8
	unpcklps xmm0, xmm8
	movsd	QWORD PTR [rbx-32], xmm0
	movss	DWORD PTR [rbx-24], xmm8

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 4
	jmp	$LN293@Render
$LN45@Render:

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 3
	jne	SHORT $LN383@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rcx, QWORD PTR [rbx-32]
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1034 :         } else {

	jmp	$LN293@Render
$LN383@Render:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR _Temp$68[rbp-256], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR _Temp$68[rbp-240], rdi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR _Temp$68[rbp-232], 15

; 2631 : 
; 2632 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2633 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2635 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2636 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR _Temp$68[rbp-256], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1856@Render[rsi+rdx*4+4]
	add	rax, rsi
	jmp	rax
$LN448@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN466@Render:

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR _Temp$68[rbp-256]
	movups	XMMWORD PTR [rbx-32], xmm0
	movups	xmm1, XMMWORD PTR _Temp$68[rbp-240]
	movups	XMMWORD PTR [rbx-16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 219  :                     break;

	jmp	SHORT $LN293@Render
$LN43@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 2
	je	SHORT $LN1870@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1855@Render[rsi+rdx*4+4]
	add	rax, rsi
	jmp	rax
$LN185@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN203@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR [rbx-32], edi

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 213  :                     break;

	jmp	SHORT $LN293@Render
$LN44@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 1
	je	SHORT $LN1871@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1854@Render[rsi+rdx*4+4]
	add	rax, rsi
	jmp	rax
$LN620@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN638@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 1
$LN1871@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 216  :                     break;

	mov	rcx, -32				; ffffffffffffffe0H
	mov	rax, rbx
	mov	BYTE PTR [rbx+rcx], 0
	jmp	SHORT $LN293@Render
$LN42@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	test	dl, dl
	je	SHORT $LN1870@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1853@Render[rsi+rdx*4+4]
	add	rax, rsi
	jmp	rax
$LN261@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN279@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 0
$LN1870@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	mov	DWORD PTR [rbx-32], edi
$LN293@Render:
	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T64[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T64[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T64[rbp-232], rdi

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rbx-48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx-40], 16
	jb	SHORT $LN1842@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [r14]
$LN1842@Render:

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rax
	ja	$LN1665@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T64[rbp-232], 15
	cmp	rsi, 16
	jae	SHORT $LN99@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T64[rbp-240], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T64[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN115@Render
$LN99@Render:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15
	cmp	rdi, rax

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN110@Render

; 4716 :             return _Max;

	mov	rdi, rax
	jmp	SHORT $LN109@Render
$LN110@Render:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	mov	eax, 22
	cmovb	rdi, rax
$LN109@Render:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T64[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T64[rbp-240], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T64[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	xor	edi, edi
$LN115@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 226  :             DrawParameterValue(static_cast<AINBFile::ValueType>(i), Immediate.Name, CurrentId, (void*)&Immediate.Value);

	lea	rax, QWORD PTR [rbx-32]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR CurrentId$1$[rsp]
	lea	r8, QWORD PTR $T64[rbp-256]
	mov	edx, r13d
	mov	rcx, r12
	call	?DrawParameterValue@UIAINBNodeBase@@QEAAXW4ValueType@AINBFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPEAX@Z ; UIAINBNodeBase::DrawParameterValue

; 200  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	add	r14, 200				; 000000c8H
	add	rbx, 200				; 000000c8H
	cmp	r14, QWORD PTR <end>$L2$1$[rbp-256]
	lea	rsi, OFFSET FLAT:__ImageBase
	jne	$LL25@Render
	movzx	r8d, BYTE PTR i$1$[rsp]
$LN20@Render:

; 198  : 
; 199  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r8b
	mov	BYTE PTR i$1$[rsp], r8b
	cmp	r8b, 6
	jb	$LL22@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp

; 193  :     s_Editor->GetNodeBuilder().End();

	mov	rcx, QWORD PTR ?s_Editor@@3PEAUEditorContext@Detail@NodeEditor@ax@@EA
	add	rcx, 1032				; 00000408H
	call	?End@NodeBuilder@Detail@NodeEditor@ax@@QEAAXXZ ; ax::NodeEditor::Detail::NodeBuilder::End
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 231  :     ed::PopStyleVar();

	call	?PopStyleVar@NodeEditor@ax@@YAXH@Z	; ax::NodeEditor::PopStyleVar

; 232  : 
; 233  :     DrawNodeHeader();

	mov	rcx, r12
	call	?DrawNodeHeader@UIAINBNodeBase@@QEAAXXZ	; UIAINBNodeBase::DrawNodeHeader

; 234  :     if (HasImmediate)

	cmp	BYTE PTR HasImmediate$1$[rsp], 0
	je	SHORT $LN47@Render

; 235  :         DrawImmediateSeperator(CursorPos);

	movaps	xmm0, xmm6
	unpcklps xmm0, xmm7
	movq	rdx, xmm0
	mov	rcx, r12
	call	?DrawImmediateSeperator@UIAINBNodeBase@@QEAAXUImVec2@@@Z ; UIAINBNodeBase::DrawImmediateSeperator
	npad	1
$LN47@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR HasLink$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN137@Render

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR HasLink$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN155@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN155@Render
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN328@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN461@Render:
$LN198@Render:
$LN633@Render:
$LN274@Render:
$LN155@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN137@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 236  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+704]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN1665@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1655@Render:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1657@Render:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1656@Render:

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1662@Render:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1864@Render:
	npad	2
$LN1857@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 236  : }

	DD	$LN333@Render
	DD	$LN333@Render
	DD	$LN333@Render
	DD	$LN333@Render
	DD	$LN315@Render
	DD	$LN333@Render
$LN1856@Render:
	DD	$LN466@Render
	DD	$LN466@Render
	DD	$LN466@Render
	DD	$LN466@Render
	DD	$LN448@Render
	DD	$LN466@Render
$LN1855@Render:
	DD	$LN203@Render
	DD	$LN203@Render
	DD	$LN203@Render
	DD	$LN203@Render
	DD	$LN185@Render
	DD	$LN203@Render
$LN1854@Render:
	DD	$LN638@Render
	DD	$LN638@Render
	DD	$LN638@Render
	DD	$LN638@Render
	DD	$LN620@Render
	DD	$LN638@Render
$LN1853@Render:
	DD	$LN279@Render
	DD	$LN279@Render
	DD	$LN279@Render
	DD	$LN279@Render
	DD	$LN261@Render
	DD	$LN279@Render
?Render@UIAINBNodeS32Selector@@UEAAXXZ ENDP		; UIAINBNodeS32Selector::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$1@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$1
	lea	rcx, QWORD PTR $T72[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$2@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T16[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN56@dtor$2
	and	DWORD PTR $T16[rbp], -2
	lea	rcx, QWORD PTR $T15[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN56@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$3@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T16[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN58@dtor$3
	and	DWORD PTR $T16[rbp], -3
	lea	rcx, QWORD PTR $T55[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN58@dtor$3:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$4@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$4
	lea	rcx, QWORD PTR $T71[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$5@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$5
	lea	rcx, QWORD PTR $T43[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$8@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$8
	lea	rcx, QWORD PTR HasLink$[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$8@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$10@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$10
	lea	rcx, QWORD PTR $T54[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$11@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$11
	lea	rcx, QWORD PTR Text$66[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$12@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$12
	lea	rcx, QWORD PTR $T26[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$13@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$13
	lea	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$13@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$14@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$14
	lea	rcx, QWORD PTR $T69[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$14@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$15@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$15
	lea	rcx, QWORD PTR $T40[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$15@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$16@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$16
	lea	rcx, QWORD PTR $T35[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$19@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$19
	lea	rcx, QWORD PTR $T38[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$19@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$20@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$20
	lea	rcx, QWORD PTR $T33[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$20@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$21@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$21
	mov	rcx, QWORD PTR $T47[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$21@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$22@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$22
	mov	rcx, QWORD PTR $T22[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$22@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$111@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$111
	mov	rcx, QWORD PTR $T62[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$111@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$111
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$112@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$112
	mov	rcx, QWORD PTR $T37[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$112@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$112
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
HasDefaultLink$1$ = 64
WantRemove$1$ = 64
Linked$1$ = 65
$T9 = 65
HasImmediate$1$ = 65
tv9712 = 68
tv9699 = 68
backup$10 = 72
backup$11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 104
$T17 = 104
CurrentId$1$ = 112
$T18 = 120
tv10350 = 120
tv9700 = 120
$T19 = 120
text_size$20 = 128
text_size$21 = 128
$T22 = 128
$T23 = 128
$T24 = 128
$T25 = 136
$T26 = 136
$T27 = 136
$T28 = 136
$T29 = 136
$T30 = 168
$T31 = 168
$T32 = 168
$T33 = 176
$T34 = 176
$T35 = 176
$T36 = 176
this$GSCopy$1$ = 208
$T37 = 208
$T38 = 216
$T39 = 216
$T40 = 216
$T41 = 216
$T42 = 216
$T43 = 216
$T44 = 216
$T45 = 216
$T46 = 256
$T47 = 256
$T48 = 256
$T49 = 256
HeaderRect$50 = 256
$T51 = 256
$T52 = 272
$T53 = 272
$T54 = 304
$T55 = 304
$T56 = 336
$T57 = 336
$T58 = 336
$T59 = 336
$T60 = 352
<end>$L2$1$ = 368
<end>$L0$1$ = 368
tv9710 = 368
_Eptr$61 = 368
$T62 = 368
$T63 = 368
$T64 = 384
$T65 = 384
Text$66 = 384
$T67 = 384
_Temp$68 = 416
$T69 = 416
$T70 = 416
$T71 = 416
$T72 = 416
HasLink$ = 448
_Buff$73 = 472
_Buff$74 = 496
_Buff$75 = 520
_Buff$76 = 544
__$ArrayPad$ = 568
this$ = 752
?dtor$113@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA PROC ; `UIAINBNodeS32Selector::Render'::`1'::dtor$113
	mov	rcx, QWORD PTR $T46[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$113@?0??Render@UIAINBNodeS32Selector@@UEAAXXZ@4HA ENDP ; `UIAINBNodeS32Selector::Render'::`1'::dtor$113
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
;	COMDAT ?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
Number$GSCopy$ = 40
__$ArrayPad$ = 48
ThisPtr$ = 96
Number$ = 104
?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; `UIAINBNodeS32Selector::Render'::`45'::<lambda_1>::<lambda_invoker_cdecl>, COMDAT

; 183  :         });

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbp, rdx
	mov	rbx, rcx

; 177  :         PopupAINBElementSelector::Open("Condition: signed 32-bit number", "signed 32-bit number", "Add condition", this, [](void* ThisPtr, std::string Number) {

	mov	QWORD PTR Number$GSCopy$[rsp], rdx

; 178  :             uint32_t Num = std::stoi(Number);

	mov	rcx, rdx
	call	?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoi
	mov	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 124  :         return const_cast<_Ty*>(

	mov	r8d, eax
	mov	rdx, QWORD PTR [rbx+344]
	mov	rcx, QWORD PTR [rbx+336]
	call	__std_find_trivial_4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rdx, QWORD PTR [rbx+344]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 179  :             if (std::find(((UIAINBNodeS32Selector*)ThisPtr)->mConditions.begin(), ((UIAINBNodeS32Selector*)ThisPtr)->mConditions.end(), Num) != ((UIAINBNodeS32Selector*)ThisPtr)->mConditions.end())

	cmp	rax, rdx
	jne	SHORT $LN42@

; 180  :                 return;
; 181  : 
; 182  :             ((UIAINBNodeS32Selector*)ThisPtr)->mConditions.push_back(Num);

	mov	DWORD PTR $T1[rsp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR [rbx+352]
	je	SHORT $LN43@

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], esi

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [rbx+344], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN42@
$LN43@:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR [rbx+336]
	call	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAH$$QEAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
	npad	1
$LN42@:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbp
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 183  :         });

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; `UIAINBNodeS32Selector::Render'::`45'::<lambda_1>::<lambda_invoker_cdecl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
Number$GSCopy$ = 40
__$ArrayPad$ = 48
ThisPtr$ = 96
Number$ = 104
?dtor$0@?0??<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; ``UIAINBNodeS32Selector::Render'::`45'::<lambda_1>::<lambda_invoker_cdecl>'::`1'::dtor$0
	mov	rcx, QWORD PTR Number$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??<lambda_invoker_cdecl>@<lambda_1>@?CN@??Render@UIAINBNodeS32Selector@@UEAAXXZ@SA@PEAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; ``UIAINBNodeS32Selector::Render'::`45'::<lambda_1>::<lambda_invoker_cdecl>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
;	COMDAT ?PostProcessLinkedNodeInfo@UIAINBNodeS32Selector@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 80
StartPin$ = 88
Info$ = 96
?PostProcessLinkedNodeInfo@UIAINBNodeS32Selector@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z PROC ; UIAINBNodeS32Selector::PostProcessLinkedNodeInfo, COMDAT

; 239  : {

$LN49:
	push	rbx
	sub	rsp, 64					; 00000040H

; 240  :     if (StartPin.ObjectPtr == (void*)0x1) {

	cmp	QWORD PTR [rdx+16], 1
	lea	rbx, QWORD PTR [r8+40]
	jne	SHORT $LN2@PostProces
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 7
	lea	rdx, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	mov	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 245  : }

	add	rsp, 64					; 00000040H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	jmp	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@PostProces:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 243  :         Info.Condition = std::to_string(StartPin.ParameterIndex);

	mov	edx, DWORD PTR [rdx+24]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	mov	rdx, rax
	mov	rcx, rbx
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T1[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN24@PostProces
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@PostProces

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN36@PostProces
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN36@PostProces:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN24@PostProces:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 245  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN46@PostProces:
?PostProcessLinkedNodeInfo@UIAINBNodeS32Selector@@UEAAXAEAUPin@UIAINBNodeBase@@AEAULinkedNodeInfo@AINBFile@@@Z ENDP ; UIAINBNodeS32Selector::PostProcessLinkedNodeInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
;	COMDAT ?RenderLinks@UIAINBNodeS32Selector@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 72
$T7 = 72
tv1625 = 96
$T8 = 96
$T9 = 112
$T10 = 112
$T11 = 128
$T12 = 128
$T13 = 144
this$ = 256
Nodes$ = 264
i$1$ = 272
$T14 = 272
j$1$ = 280
?RenderLinks@UIAINBNodeS32Selector@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z PROC ; UIAINBNodeS32Selector::RenderLinks, COMDAT

; 248  : {

$LN197:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rdx
	mov	QWORD PTR [rax+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 184				; 000000b8H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	r8, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 250  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	xor	r15d, r15d
	mov	r12d, DWORD PTR [rcx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r13, 8040888442386214807		; 6f96f96f96f96f97H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 248  : {

	movaps	XMMWORD PTR [rax-88], xmm6

; 249  :     uint32_t CurrentLinkId = mEditorId + 500; // Link start at +500

	add	r12d, 500				; 000001f4H

; 250  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	movss	xmm6, DWORD PTR __real@3f800000
	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r8+448]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 248  : {

	mov	r9, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, QWORD PTR [r8+440]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 250  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	mov	edi, r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
	imul	rax, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 250  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	test	rax, rax
	je	$LN3@RenderLink
	mov	ecx, r15d
$LL4@RenderLink:

; 251  :         if (mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex == -1 || mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex >= Nodes.size())

	mov	rdx, QWORD PTR [r8+440]
	mov	r14d, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rbx, rcx, 312				; 00000138H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 251  :         if (mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex == -1 || mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex >= Nodes.size())

	mov	eax, DWORD PTR [rdx+rbx+4]
	cmp	eax, -1					; ffffffffH
	je	$LN2@RenderLink
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rsi+8]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 251  :         if (mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex == -1 || mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex >= Nodes.size())

	cmp	rax, rcx
	jae	$LN2@RenderLink

; 254  :         uint32_t StartPinId = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].Condition == "Default" ? mPinIdDefault : mPinIds[std::stoi(mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].Condition)];

	lea	rcx, QWORD PTR [rbx+40]
	add	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN113@RenderLink

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN113@RenderLink:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	QWORD PTR [rcx+16], 7
	jne	SHORT $LN18@RenderLink

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	cmp	DWORD PTR [rax], 1634100548		; 61666544H
	jne	SHORT $LN18@RenderLink
	cmp	WORD PTR [rax+4], 27765			; 00006c75H
	jne	SHORT $LN18@RenderLink
	cmp	BYTE PTR [rax+6], 116			; 00000074H
	jne	SHORT $LN18@RenderLink
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 254  :         uint32_t StartPinId = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].Condition == "Default" ? mPinIdDefault : mPinIds[std::stoi(mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].Condition)];

	mov	r10d, DWORD PTR [r9+360]
	jmp	SHORT $LN19@RenderLink
$LN18@RenderLink:
	call	?stoi@std@@YAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoi
	mov	rcx, QWORD PTR this$[rbp-153]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 265  :         return this->_Try_emplace(_STD move(_Keyval)).first->_Myval.second;

	lea	r8, QWORD PTR $T14[rbp-153]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 254  :         uint32_t StartPinId = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].Condition == "Default" ? mPinIdDefault : mPinIds[std::stoi(mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].Condition)];

	add	rcx, 272				; 00000110H
	mov	DWORD PTR $T14[rbp-153], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 265  :         return this->_Try_emplace(_STD move(_Keyval)).first->_Myval.second;

	lea	rdx, QWORD PTR $T1[rbp-153]
	call	??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Try_emplace<int>
	mov	r9, QWORD PTR this$[rbp-153]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 254  :         uint32_t StartPinId = mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].Condition == "Default" ? mPinIdDefault : mPinIds[std::stoi(mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].Condition)];

	mov	rcx, QWORD PTR [rax]
	mov	r10d, DWORD PTR [rcx+20]
$LN19@RenderLink:

; 256  :         ed::Link(CurrentLinkId++, StartPinId, Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mEditorId + 1, GetValueTypeColor(6));

	mov	r8b, 6
	lea	rdx, QWORD PTR $T10[rbp-153]
	call	?GetValueTypeColor@UIAINBNodeBase@@QEAA?AUImColor@@E@Z ; UIAINBNodeBase::GetValueTypeColor
	mov	edx, r10d
	movss	DWORD PTR [rsp+32], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 256  :         ed::Link(CurrentLinkId++, StartPinId, Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mEditorId + 1, GetValueTypeColor(6));

	mov	rax, QWORD PTR [r9+8]
	lea	r9, QWORD PTR $T8[rbp-153]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T8[rbp-153], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 256  :         ed::Link(CurrentLinkId++, StartPinId, Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mEditorId + 1, GetValueTypeColor(6));

	mov	rcx, QWORD PTR [rax+440]
	mov	rax, QWORD PTR [rsi]
	mov	ecx, DWORD PTR [rcx+rbx+4]
	mov	rcx, QWORD PTR [rax+rcx*8]
	mov	r8d, DWORD PTR [rcx+16]
	mov	ecx, r12d
	inc	r8d
	inc	r12d
	call	?Link@NodeEditor@ax@@YA_NULinkId@12@UPinId@12@1AEBUImVec4@@M@Z ; ax::NodeEditor::Link
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rcx, QWORD PTR this$[rbp-153]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T7[rbp-153]
	lea	rdx, QWORD PTR $T12[rbp-153]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T7[rbp-153], r14d
	mov	DWORD PTR $T7[rbp-137], 1
	mov	WORD PTR $T7[rbp-133], r15w
	mov	rax, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 257  :         mLinks.insert({ CurrentLinkId - 1, Link { .ObjectPtr = mNode, .Type = LinkType::Flow, .ParameterIndex = (uint16_t)i } });

	add	rcx, 184				; 000000b8H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T7[rbp-145], rax
	mov	WORD PTR $T7[rbp-131], di
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IULink@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIULink@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Link,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Link> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Link> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 258  :         Nodes[mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink][i].NodeIndex]->mFlowLinked = true;

	mov	r9, QWORD PTR this$[rbp-153]
	mov	rax, QWORD PTR [r9+8]
	mov	rcx, QWORD PTR [rax+440]
	mov	rax, QWORD PTR [rsi]
	mov	ecx, DWORD PTR [rcx+rbx+4]
	mov	rcx, QWORD PTR [rax+rcx*8]
	mov	BYTE PTR [rcx+264], 1
$LN2@RenderLink:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	r8, QWORD PTR [r9+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 250  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	inc	edi
	movsxd	rcx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r8+448]
	sub	rax, QWORD PTR [r8+440]
	sar	rax, 3
	imul	rax, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 250  :     for (int i = 0; i < mNode->LinkedNodes[(int)AINBFile::LinkedNodeMapping::StandardLink].size(); i++) {

	cmp	rcx, rax
	jb	$LL4@RenderLink
$LN3@RenderLink:

; 259  :     }
; 260  : 
; 261  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r11b, r11b
	mov	r14, r15
	mov	BYTE PTR i$1$[rbp-153], r11b
	mov	rdx, -1229782938247303441		; eeeeeeeeeeeeeeefH
	npad	11
$LL7@RenderLink:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r8+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 262  :         for (uint16_t j = 0; j < mNode->InputParameters[i].size(); j++) {

	movzx	r10d, r15w
	mov	WORD PTR j$1$[rbp-153], r15w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [r14+rax+8]
	sub	rcx, QWORD PTR [r14+rax]
	sar	rcx, 4
	imul	rcx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 262  :         for (uint16_t j = 0; j < mNode->InputParameters[i].size(); j++) {

	test	rcx, rcx
	je	$LN5@RenderLink
	lea	r13, QWORD PTR [r9+184]
	mov	rdx, r15
	mov	QWORD PTR tv1625[rbp-153], r13
	npad	8
$LL10@RenderLink:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r8+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 264  :             if (Input.NodeIndex >= 0) { // Single link

	lea	r15, QWORD PTR [rdx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rdi, rdx, 240				; 000000f0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 263  :             AINBFile::InputEntry& Input = mNode->InputParameters[i][j];

	mov	ebx, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rdi, QWORD PTR [rax+r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 264  :             if (Input.NodeIndex >= 0) { // Single link

	cmp	WORD PTR [rdi+64], 0
	jl	$LN180@RenderLink

; 265  :                 ed::Link(CurrentLinkId++, Nodes[Input.NodeIndex]->mOutputParameters[i][Input.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	movzx	r8d, r11b
	lea	rdx, QWORD PTR $T11[rbp-153]
	call	?GetValueTypeColor@UIAINBNodeBase@@QEAA?AUImColor@@E@Z ; UIAINBNodeBase::GetValueTypeColor
	movss	DWORD PTR [rsp+32], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 265  :                 ed::Link(CurrentLinkId++, Nodes[Input.NodeIndex]->mOutputParameters[i][Input.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	mov	rax, QWORD PTR [r9+72]
	lea	r9, QWORD PTR $T5[rbp-153]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T5[rbp-153], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 265  :                 ed::Link(CurrentLinkId++, Nodes[Input.NodeIndex]->mOutputParameters[i][Input.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR [rsi]
	mov	r8d, DWORD PTR [rcx+r15]
	movsx	rcx, WORD PTR [rdi+64]
	mov	rcx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR [rcx+48]
	movsx	rcx, WORD PTR [rdi+66]
	mov	rax, QWORD PTR [rax+r14]
	mov	edx, DWORD PTR [rax+rcx*4]
	mov	ecx, r12d
	inc	r12d
	call	?Link@NodeEditor@ax@@YA_NULinkId@12@UPinId@12@1AEBUImVec4@@M@Z ; ax::NodeEditor::Link
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	movzx	eax, WORD PTR [rdi+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T4[rbp-153]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	WORD PTR $T4[rbp-133], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	rdx, QWORD PTR $T9[rbp-153]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	movzx	eax, WORD PTR [rdi+66]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	mov	rcx, r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	WORD PTR $T4[rbp-131], ax
	mov	DWORD PTR $T4[rbp-153], ebx
	mov	QWORD PTR $T4[rbp-145], rdi
	mov	DWORD PTR $T4[rbp-137], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IULink@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIULink@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Link,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Link> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Link> >
	mov	r9, QWORD PTR this$[rbp-153]
	movzx	r10d, WORD PTR j$1$[rbp-153]
	movzx	r11d, BYTE PTR i$1$[rbp-153]
$LN180@RenderLink:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 268  :             for (AINBFile::MultiEntry& Entry : Input.Sources) { // Multi link

	mov	r13, QWORD PTR [rdi+160]
	mov	rsi, QWORD PTR [rdi+152]
	cmp	rsi, r13
	je	$LN8@RenderLink
	npad	4
$LL13@RenderLink:

; 269  :                 ed::Link(CurrentLinkId++, Nodes[Entry.NodeIndex]->mOutputParameters[i][Entry.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	movzx	r8d, r11b
	lea	rdx, QWORD PTR $T13[rbp-153]
	mov	ebx, r12d
	call	?GetValueTypeColor@UIAINBNodeBase@@QEAA?AUImColor@@E@Z ; UIAINBNodeBase::GetValueTypeColor
	movss	DWORD PTR [rsp+32], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 269  :                 ed::Link(CurrentLinkId++, Nodes[Entry.NodeIndex]->mOutputParameters[i][Entry.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	mov	rax, QWORD PTR [r9+72]
	lea	r9, QWORD PTR $T3[rbp-153]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T3[rbp-153], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 269  :                 ed::Link(CurrentLinkId++, Nodes[Entry.NodeIndex]->mOutputParameters[i][Entry.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR Nodes$[rbp-153]
	mov	r8d, DWORD PTR [rcx+r15]
	mov	rax, QWORD PTR [rax]
	movzx	ecx, WORD PTR [rsi]
	mov	rcx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR [rcx+48]
	movzx	ecx, WORD PTR [rsi+2]
	mov	rax, QWORD PTR [rax+r14]
	mov	edx, DWORD PTR [rax+rcx*4]
	mov	ecx, r12d
	inc	r12d
	call	?Link@NodeEditor@ax@@YA_NULinkId@12@UPinId@12@1AEBUImVec4@@M@Z ; ax::NodeEditor::Link
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	movzx	eax, WORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T2[rbp-153]
	mov	rcx, QWORD PTR tv1625[rbp-153]
	lea	rdx, QWORD PTR $T6[rbp-153]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	WORD PTR $T2[rbp-133], ax
	movzx	eax, WORD PTR [rsi+2]
	mov	WORD PTR $T2[rbp-131], ax
	mov	DWORD PTR $T2[rbp-153], ebx
	mov	QWORD PTR $T2[rbp-145], rdi
	mov	DWORD PTR $T2[rbp-137], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IULink@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIULink@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Link,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Link> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Link> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 268  :             for (AINBFile::MultiEntry& Entry : Input.Sources) { // Multi link

	mov	r9, QWORD PTR this$[rbp-153]
	add	rsi, 96					; 00000060H
	movzx	r11d, BYTE PTR i$1$[rbp-153]
	cmp	rsi, r13
	jne	$LL13@RenderLink
	movzx	r10d, WORD PTR j$1$[rbp-153]
$LN8@RenderLink:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [r9+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 262  :         for (uint16_t j = 0; j < mNode->InputParameters[i].size(); j++) {

	lea	r13, QWORD PTR [r9+184]
	movzx	r11d, BYTE PTR i$1$[rbp-153]
	inc	r10w
	mov	rsi, QWORD PTR Nodes$[rbp-153]
	movzx	edx, r10w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r8+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 262  :         for (uint16_t j = 0; j < mNode->InputParameters[i].size(); j++) {

	mov	WORD PTR j$1$[rbp-153], r10w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [r14+rax+8]
	sub	rcx, QWORD PTR [r14+rax]
	mov	rax, -1229782938247303441		; eeeeeeeeeeeeeeefH
	sar	rcx, 4
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 262  :         for (uint16_t j = 0; j < mNode->InputParameters[i].size(); j++) {

	cmp	rdx, rcx
	jb	$LL10@RenderLink
	xor	r15d, r15d
	mov	rdx, rax
$LN5@RenderLink:

; 259  :     }
; 260  : 
; 261  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r11b
	add	r14, 24
	mov	BYTE PTR i$1$[rbp-153], r11b
	cmp	r11b, 6
	jb	$LL7@RenderLink

; 270  :                 mLinks.insert({ CurrentLinkId - 1, Link { .ObjectPtr = &Input, .Type = LinkType::Parameter, .NodeIndex = Entry.NodeIndex, .ParameterIndex = Entry.ParameterIndex } });
; 271  :             }
; 272  :         }
; 273  :     }
; 274  : }

	movaps	xmm6, XMMWORD PTR [rsp+160]
	add	rsp, 184				; 000000b8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?RenderLinks@UIAINBNodeS32Selector@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z ENDP ; UIAINBNodeS32Selector::RenderLinks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp
;	COMDAT ?GetHeaderColor@UIAINBNodeS32Selector@@UEAA?AUImColor@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?GetHeaderColor@UIAINBNodeS32Selector@@UEAA?AUImColor@@XZ PROC ; UIAINBNodeS32Selector::GetHeaderColor, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	mov	DWORD PTR [rdx], 1055977714		; 3ef0f0f2H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 278  :     return ImColor(120, 20, 20);

	mov	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	mov	DWORD PTR [rdx+4], 1033937057		; 3da0a0a1H
	mov	DWORD PTR [rdx+8], 1033937057		; 3da0a0a1H
	mov	DWORD PTR [rdx+12], 1065353216		; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeS32Selector.cpp

; 279  : }

	ret	0
?GetHeaderColor@UIAINBNodeS32Selector@@UEAA?AUImColor@@XZ ENDP ; UIAINBNodeS32Selector::GetHeaderColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA?AV01@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
__formal$dead$ = 24
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator++, COMDAT

; 289  :         _Vector_iterator _Tmp = *this;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 79   :         ++_Ptr;

	add	rax, 4
	mov	QWORD PTR [rcx], rax

; 290  :         _Mybase::operator++();
; 291  :         return _Tmp;

	mov	rax, rdx

; 292  :     }

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAAEAHXZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAAEAHXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*, COMDAT

; 268  :         return const_cast<reference>(_Mybase::operator*());

	mov	rax, QWORD PTR [rcx]

; 269  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAAEAHXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT

; 1762 :         auto& _My_data    = _Mypair._Myval2;
; 1763 :         pointer& _Myfirst = _My_data._Myfirst;
; 1764 :         pointer& _Mylast  = _My_data._Mylast;
; 1765 : 
; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rcx]
	cmp	rax, QWORD PTR [rcx+8]
	je	SHORT $LN1@clear

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN1@clear:

; 1777 :     }

	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Where$ = 64
?erase@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT

; 1717 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

$LN23:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rsi, rdx

; 1729 :         _STD _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

	mov	r8, QWORD PTR [rcx+8]
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1729 :         _STD _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

	lea	rdx, QWORD PTR [rbx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1732 :         --_Mylast;

	add	QWORD PTR [rdi+8], -4

; 1733 :         return iterator(_Whereptr, _STD addressof(_My_data));

	mov	rax, rsi

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rsi], rbx

; 1734 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?erase@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??A?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAAEAI$$QEAH@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Keyval$ = 72
??A?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAAEAI$$QEAH@Z PROC ; std::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >::operator[], COMDAT

; 264  :     mapped_type& operator[](key_type&& _Keyval) {

$LN4:
	sub	rsp, 56					; 00000038H

; 265  :         return this->_Try_emplace(_STD move(_Keyval)).first->_Myval.second;

	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Try_emplace<int>
	mov	rax, QWORD PTR [rax]
	add	rax, 20

; 266  :     }

	add	rsp, 56					; 00000038H
	ret	0
??A?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAAEAI$$QEAH@Z ENDP ; std::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >, COMDAT

; 107  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN70:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	xor	edi, edi
	mov	DWORD PTR [rcx], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rdi+24]
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	lea	rcx, QWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR [rbx+48], 7
	mov	QWORD PTR [rbx+56], 8

; 377  :         // construct empty hash table
; 378  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [rbx], 1065353216		; 3f800000H

; 379  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, QWORD PTR [rbx+8]
	lea	edx, QWORD PTR [rdi+16]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Assign_grow
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 107  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::~list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >
?dtor$1@?0???0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$2@?0???0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >
?dtor$2@?0???0?$unordered_map@HIU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >::unordered_map<int,unsigned int,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,unsigned int> > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::clear, COMDAT

; 1150 :     void clear() noexcept {

$LN79:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 1151 :         // TRANSITION, ABI:
; 1152 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1153 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1154 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1155 :         //   (2) The hash function operator() may throw exceptions, and
; 1156 :         //   (3) clear() is a noexcept function.
; 1157 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1158 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 1159 :         if (_Oldsize == 0) {

	test	rcx, rcx
	je	$LN1@clear

; 1160 :             return;
; 1161 :         }
; 1162 : 
; 1163 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1164 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1165 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1166 :             // as many buckets as elements, remove element-by-element.
; 1167 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rax, QWORD PTR [rdi+56]
	shr	rax, 3
	cmp	rax, rcx
	jbe	SHORT $LN3@clear

; 1168 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	rdx, QWORD PTR [rdi+8]

; 1169 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	rcx, rdi
	mov	r8, rdx
	mov	rdx, QWORD PTR [rdx]

; 1177 :     }

	add	rsp, 48					; 00000030H
	pop	rdi

; 1169 :                 _Unchecked_erase(_Head->_Next, _Head);

	jmp	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Unchecked_erase
$LN3@clear:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1490 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rcx, QWORD PTR [rdi+8]

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rcx, QWORD PTR [rcx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rcx, rcx
	je	SHORT $LN9@clear
	mov	QWORD PTR [rsp+72], rbx
	npad	10
$LL10@clear:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 24
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL10@clear
	mov	rbx, QWORD PTR [rsp+72]
$LN9@clear:

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	r8, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	QWORD PTR [rax], rax

; 1492 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rax+8], rax

; 1493 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rdi+16], 0

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	mov	rdx, QWORD PTR [rdi+32]
	mov	rcx, QWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR $T1[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >
$LN1@clear:

; 1177 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?insert@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHI@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Val$ = 64
?insert@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHI@2@@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::insert, COMDAT

; 937  :     conditional_t<_Multi, iterator, pair<iterator, bool>> insert(value_type&& _Val) {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::emplace<std::pair<int const ,unsigned int> >
	mov	rax, rbx

; 939  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?insert@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHI@2@@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator++, COMDAT

; 72   : #if _ITERATOR_DEBUG_LEVEL != 0
; 73   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 74   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 75   :         _STL_VERIFY(_Mycont, "can't increment invalidated vector iterator");
; 76   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 77   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 78   : 
; 79   :         ++_Ptr;

	add	QWORD PTR [rcx], 4

; 80   :         return *this;

	mov	rax, rcx

; 81   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAAEBHXZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAAEBHXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*, COMDAT

; 48   : #if _ITERATOR_DEBUG_LEVEL != 0
; 49   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 50   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 51   :         _STL_VERIFY(_Mycont, "can't dereference invalidated vector iterator");
; 52   :         _STL_VERIFY(
; 53   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 54   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 55   : 
; 56   :         return *_Ptr;

	mov	rax, QWORD PTR [rcx]

; 57   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAAEBHXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
tv925 = 32
tv921 = 40
_Bucket_bounds$1$ = 48
this$ = 112
_First$ = 120
_Last$ = 128
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Unchecked_erase, COMDAT

; 1026 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN206:
	mov	rax, rsp
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rbp, r8
	mov	r14, rdx
	mov	rsi, rcx

; 1027 :         if (_First == _Last) {

	cmp	rdx, r8
	je	$LN203@Unchecked_

; 1032 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	rdx, QWORD PTR [rcx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	mov	r8, 1099511628211			; 00000100000001b3H
	mov	QWORD PTR [rax+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1006 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	rbx, r14
	mov	QWORD PTR [rax+24], rdi
	mov	QWORD PTR [rax+32], r12

; 1028 :             return _Last;
; 1029 :         }
; 1030 : 
; 1031 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	r12, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [r14+16]
	mov	QWORD PTR [rax-32], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1006 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	r13, QWORD PTR [r14+8]
	mov	QWORD PTR [rax-40], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r15, QWORD PTR [rsi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rcx, rax
	movzx	eax, BYTE PTR [r14+17]

; 2346 :         _Val *= _FNV_prime;

	imul	rcx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1032 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	QWORD PTR _Bucket_bounds$1$[rsp], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rcx, rax
	movzx	eax, BYTE PTR [r14+18]

; 2346 :         _Val *= _FNV_prime;

	imul	rcx, r8
	xor	rcx, rax
	movzx	eax, BYTE PTR [r14+19]
	imul	rcx, r8
	xor	rcx, rax
	imul	rcx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	r15, rcx

; 1033 :         _Range_eraser _Eraser{_List, _First};
; 1034 :         {
; 1035 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1036 :             const auto _Predecessor = _First->_Prev;
; 1037 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws
; 1038 :             // nothrow hereafter this block
; 1039 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	r15, 4
	add	r15, rdx

; 1040 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1041 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

	mov	rax, QWORD PTR [r15]
	mov	QWORD PTR tv925[rsp], rax

; 1042 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR [r15+8]
	mov	QWORD PTR tv921[rsp], rax
	npad	8
$LL2@Unchecked_:

; 1009 :             const auto _Oldnext = _Next;

	mov	rcx, rbx

; 1043 :             for (;;) { // remove elements until we hit the end of the bucket
; 1044 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rdi, rbx

; 1010 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 24
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1012 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [rsi+16]

; 1045 :                 _Eraser._Bump_erased();
; 1046 :                 if (_At_bucket_back) {

	cmp	rdi, QWORD PTR tv921[rsp]
	je	SHORT $LN167@Unchecked_

; 1047 :                     break;
; 1048 :                 }
; 1049 : 
; 1050 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, rbp
	jne	SHORT $LL2@Unchecked_

; 1051 :                     if (_Update_lo) {

	cmp	QWORD PTR tv925[rsp], r14
	jne	SHORT $LN189@Unchecked_
$LN170@Unchecked_:

; 1016 :             _Predecessor->_Next = _Next;

	mov	QWORD PTR [r15], rbx
$LN189@Unchecked_:
	mov	r12, QWORD PTR [rsp+136]
	mov	rdi, QWORD PTR [rsp+128]
	mov	r15, QWORD PTR [rsp+64]
	mov	QWORD PTR [r13], rbx

; 1017 :             _Next->_Prev        = _Predecessor;

	mov	QWORD PTR [rbx+8], r13
	mov	r13, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+120]
$LN203@Unchecked_:

; 1093 :         }
; 1094 : 
; 1095 :         return _Last;
; 1096 :     }

	mov	rax, rbp
	add	rsp, 80					; 00000050H
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN167@Unchecked_:

; 1052 :                         // erased the bucket's prefix
; 1053 :                         _Bucket_lo = _Eraser._Next;
; 1054 :                     }
; 1055 : 
; 1056 :                     return _Last;
; 1057 :                 }
; 1058 :             }
; 1059 : 
; 1060 :             if (_Update_lo) {

	cmp	QWORD PTR tv925[rsp], r14
	jne	SHORT $LN14@Unchecked_

; 1061 :                 // emptied the bucket
; 1062 :                 _Bucket_lo = _End;

	mov	QWORD PTR [r15], r12

; 1063 :                 _Bucket_hi = _End;

	mov	rax, r12

; 1064 :             } else {

	jmp	SHORT $LN163@Unchecked_
$LN14@Unchecked_:

; 1065 :                 _Bucket_hi = _Predecessor;

	mov	rax, r13
$LN163@Unchecked_:

; 1066 :             }
; 1067 :         }
; 1068 : 
; 1069 :         // hereafter we are always erasing buckets' prefixes
; 1070 :         while (_Eraser._Next != _Last) {

	mov	QWORD PTR [r15+8], rax
	cmp	rbx, rbp
	je	SHORT $LN189@Unchecked_
	npad	5
$LL5@Unchecked_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rbx+16]

; 2346 :         _Val *= _FNV_prime;

	mov	rdx, 1099511628211			; 00000100000001b3H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r15, QWORD PTR [rsi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+17]

; 2346 :         _Val *= _FNV_prime;

	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+18]
	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+19]
	imul	rcx, rdx
	xor	rcx, rax
	imul	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	r15, rcx

; 1071 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws
; 1072 :             // nothrow hereafter this block
; 1073 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	r15, 4
	add	r15, QWORD PTR _Bucket_bounds$1$[rsp]

; 1074 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1075 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	r14, QWORD PTR [r15+8]
	npad	12
$LL7@Unchecked_:

; 1009 :             const auto _Oldnext = _Next;

	mov	rcx, rbx

; 1076 :             for (;;) { // remove elements until we hit the end of the bucket
; 1077 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rdi, rbx

; 1010 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 24
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1012 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [rsi+16]

; 1078 :                 _Eraser._Bump_erased();
; 1079 :                 if (_At_bucket_back) {

	cmp	rdi, r14
	je	SHORT $LN169@Unchecked_

; 1080 :                     break;
; 1081 :                 }
; 1082 : 
; 1083 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, rbp
	jne	SHORT $LL7@Unchecked_

; 1084 :                     // erased the bucket's prefix
; 1085 :                     _Bucket_lo = _Eraser._Next;
; 1086 :                     return _Last;
; 1087 :                 }
; 1088 :             }

	jmp	$LN170@Unchecked_
$LN169@Unchecked_:

; 1089 : 
; 1090 :             // emptied the bucket
; 1091 :             _Bucket_lo = _End;

	mov	QWORD PTR [r15], r12

; 1092 :             _Bucket_hi = _End;

	mov	QWORD PTR [r15+8], r12
	cmp	rbx, rbp
	jne	$LL5@Unchecked_

; 1066 :             }
; 1067 :         }
; 1068 : 
; 1069 :         // hereafter we are always erasing buckets' prefixes
; 1070 :         while (_Eraser._Next != _Last) {

	jmp	$LN189@Unchecked_
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::bucket_count, COMDAT

; 846  :         return _Maxidx;

	mov	rax, QWORD PTR [rcx+56]

; 847  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Unchecked_end, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 811  :         return _List._Unchecked_end();

	mov	rax, rdx

; 812  :     }

	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$ = 56
_Al$dead$ = 64
??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >, COMDAT

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN60:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	edi, edi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rdi+24]
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	lea	rcx, QWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR [rbx+48], 7
	mov	QWORD PTR [rbx+56], 8

; 377  :         // construct empty hash table
; 378  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [rbx], 1065353216		; 3f800000H

; 379  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, QWORD PTR [rbx+8]
	lea	edx, QWORD PTR [rdi+16]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Assign_grow
	npad	1

; 380  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 381  :         _Stl_internal_check_container_invariants();
; 382  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 383  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Parg$ = 56
_Al$dead$ = 64
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::~list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Parg$ = 56
_Al$dead$ = 64
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::clear, COMDAT

; 1487 :     void clear() noexcept { // erase all

$LN64:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1488 :         auto& _My_data = _Mypair._Myval2;
; 1489 :         _My_data._Orphan_non_end();
; 1490 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]
	mov	rdi, rcx

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rcx, QWORD PTR [rdx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rcx, rcx
	je	SHORT $LN5@clear
	mov	QWORD PTR [rsp+56], rbx
	npad	12
$LL6@clear:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 24
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL6@clear
	mov	rbx, QWORD PTR [rsp+56]
$LN5@clear:

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rax], rax

; 1492 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rax+8], rax

; 1493 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rdi+8], 0

; 1494 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?clear@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHI@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CBHI@std@@@std@@QEAA@XZ PROC	; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@U?$pair@$$CBHI@std@@@std@@QEAA@XZ ENDP	; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 1016 :             _Predecessor->_Next = _Next;

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rdx], rax

; 1017 :             _Next->_Prev        = _Predecessor;

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+8], rax

; 1018 :         }

	ret	0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 1008 :         void _Bump_erased() noexcept {

$LN52:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1009 :             const auto _Oldnext = _Next;

	mov	rcx, QWORD PTR [rcx+16]

; 1010 :             _Next               = _Oldnext->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rbx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1012 :             --_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rbx]
	dec	QWORD PTR [rax+8]

; 1013 :         }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_List_$ = 16
_First_$ = 24
??0_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 1006 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 64
_Cells$ = 72
_Val$ = 80
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Assign_grow, COMDAT

; 287  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN88:
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	r14
	sub	rsp, 40					; 00000028H
	mov	r14, rcx
	mov	rbx, r8

; 273  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, rcx
	mov	r9, QWORD PTR [r14]
	sub	rax, r9
	sar	rax, 3

; 288  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 289  :         const auto _Oldsize = size();
; 290  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 291  :         auto& _Alvec = _Mypair._Get_first();
; 292  :         if (_Oldsize < _Cells) {

	cmp	rax, rdx
	jae	$LN2@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR [rsp+88], rsi
	mov	QWORD PTR [rsp+32], rdi
	cmp	rdx, rax
	ja	$LN71@Assign_gro

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rsi, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN16@Assign_gro

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN71@Assign_gro

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN51@Assign_gro

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN14@Assign_gro
$LN16@Assign_gro:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN17@Assign_gro

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN14@Assign_gro
$LN17@Assign_gro:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN14@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3

; 293  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws
; 294  :             // nothrow hereafter
; 295  :             const auto _Oldcapacity = capacity();
; 296  :             if (_Oldcapacity != 0) {

	test	rax, rax
	je	SHORT $LN42@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN54@Assign_gro

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN51@Assign_gro

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN54@Assign_gro:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN42@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 302  :             const auto _Newend       = _Newvec + _Cells;

	lea	rax, QWORD PTR [rsi+rdi]
	mov	QWORD PTR [r14], rdi

; 303  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	QWORD PTR [r14+8], rax

; 304  :             _Mypair._Myval2._Myend   = _Newend;

	mov	QWORD PTR [r14+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1602 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rdi, rax

; 2002 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN84@Assign_gro
	npad	4
$LL58@Assign_gro:

; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	QWORD PTR [rdi], rbx

; 1617 :         ++_Last;

	add	rdi, 8

; 2002 :         while (_Backout._Last != _ULast) {

	cmp	rdi, rax
	jne	SHORT $LL58@Assign_gro
$LN84@Assign_gro:
	mov	rsi, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 309  :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rbx
	ret	0
$LN51@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 307  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	mov	rdx, rcx
	lea	r8, QWORD PTR _Val$[rsp]
	mov	rcx, r9
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >

; 309  :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rbx
	ret	0
$LN71@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN85@Assign_gro:
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Max_bucket_size, COMDAT

; 1801 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, rcx

; 1802 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z
_TEXT	SEGMENT
this$ = 8
_Keyval$ = 16
?bucket@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::bucket, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]

; 2346 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
	imul	r8, r9
	xor	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR [rcx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	imul	r8, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	rax, r8

; 856  :     }

	ret	0
?bucket@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBA_KAEBH@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >::_Orphan_non_end, COMDAT

; 378  : #if _ITERATOR_DEBUG_LEVEL == 2
; 379  :         _Lockit _Lock(_LOCK_DEBUG);
; 380  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 381  :         const auto _Head          = _Myhead;
; 382  :         while (*_Pnext) {
; 383  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 384  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 385  :                 _Pnext = _Pnextnext;
; 386  :             } else { // orphan the iterator
; 387  :                 (*_Pnext)->_Myproxy = nullptr;
; 388  :                 *_Pnext             = *_Pnextnext;
; 389  :             }
; 390  :         }
; 391  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 392  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Unchecked_end, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1114 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	mov	rax, rdx

; 1115 :     }

	ret	0
?_Unchecked_end@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$dead$ = 56
??0?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >, COMDAT

; 803  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN41:
	push	rbx
	sub	rsp, 32					; 00000020H

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax

; 803  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rcx

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+24]
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx], rax

; 804  :         _Alloc_sentinel_and_proxy();
; 805  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??0?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Traits$ = 16
??0?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z PROC ; std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0>::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0>, COMDAT

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??0?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ENDP ; std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0>::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx

; 39   :         this->_Adopt(_Plist);
; 40   :     }

	mov	rax, rcx
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::size, COMDAT

; 273  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 274  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1832 :     void _Alloc_sentinel_and_proxy() {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 24
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx], rax

; 1840 :         _Proxy._Release();
; 1841 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$dead$ = 16
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >::allocate, COMDAT

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 24
	jmp	??2@YAPEAX_K@Z				; operator new
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBH@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_First$ = 56
_Last$ = 64
_Val$ = 72
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBH@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >,int>, COMDAT

; 5846 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r10, r8
	mov	r11, rdx

; 124  :         return const_cast<_Ty*>(

	mov	r8d, DWORD PTR [r9]

; 5846 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

	mov	rbx, rcx

; 124  :         return const_cast<_Ty*>(

	mov	rdx, r10
	mov	rcx, r11
	call	__std_find_trivial_4

; 5847 :     _Adl_verify_range(_First, _Last);
; 5848 :     if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
; 5849 :         return _Find_vbool(_First, _Last, _Val);
; 5850 :     } else {
; 5851 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
; 5852 :         return _First;

	mov	QWORD PTR [rbx], rax
	mov	rax, rbx

; 5853 :     }
; 5854 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBH@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAHI$0A@@?$pair@$$CBHI@std@@QEAA@AEAH$$QEAI@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAHI$0A@@?$pair@$$CBHI@std@@QEAA@AEAH$$QEAI@Z PROC ; std::pair<int const ,unsigned int>::pair<int const ,unsigned int><int &,unsigned int,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx+4], eax

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAHI$0A@@?$pair@$$CBHI@std@@QEAA@AEAH$$QEAI@Z ENDP ; std::pair<int const ,unsigned int>::pair<int const ,unsigned int><int &,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@I@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBI@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_First$ = 56
_Last$ = 64
_Val$ = 72
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@I@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBI@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,unsigned int>, COMDAT

; 5846 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r10, r8
	mov	r11, rdx

; 124  :         return const_cast<_Ty*>(

	mov	r8d, DWORD PTR [r9]

; 5846 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

	mov	rbx, rcx

; 124  :         return const_cast<_Ty*>(

	mov	rdx, r10
	mov	rcx, r11
	call	__std_find_trivial_4

; 5847 :     _Adl_verify_range(_First, _Last);
; 5848 :     if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
; 5849 :         return _Find_vbool(_First, _Last, _Val);
; 5850 :     } else {
; 5851 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
; 5852 :         return _First;

	mov	QWORD PTR [rbx], rax
	mov	rax, rbx

; 5853 :     }
; 5854 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@I@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBI@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Move_unchecked@PEAHPEAH@std@@YAPEAHPEAH00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Move_unchecked@PEAHPEAH@std@@YAPEAHPEAH00@Z PROC	; std::_Move_unchecked<int *,int *>, COMDAT

; 4886 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

$LN16:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4887 :     // move [_First, _Last) to [_Dest, ...)
; 4888 :     // note: _Move_unchecked has callers other than the move family
; 4889 :     if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4890 : #if _HAS_CXX20
; 4891 :         if (!_STD is_constant_evaluated())
; 4892 : #endif // _HAS_CXX20
; 4893 :         {
; 4894 :             return _Copy_memmove(_First, _Last, _Dest);
; 4895 :         }
; 4896 :     }
; 4897 : 
; 4898 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4899 :         *_Dest = _STD move(*_First);
; 4900 :     }
; 4901 : 
; 4902 :     return _Dest;
; 4903 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Move_unchecked@PEAHPEAH@std@@YAPEAHPEAH00@Z ENDP	; std::_Move_unchecked<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$dead$ = 16
??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>, COMDAT

; 725  : #if _HAS_CXX20
; 726  :         _STD destroy_at(_Ptr);
; 727  : #else // _HAS_CXX20
; 728  :         _Ptr->~_Uty();
; 729  : #endif // _HAS_CXX20
; 730  :     }

	ret	0
??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z
_TEXT	SEGMENT
$T1 = 32
_Newnode$ = 32
this$ = 112
__$ReturnUdt$ = 120
_Keyval_arg$ = 128
??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Try_emplace<int>, COMDAT

; 693  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval_arg, _Mappedty&&... _Mapval) {

$LN184:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r13, r8
	mov	r14, rdx
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r12d, BYTE PTR [r8]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r12, rax

; 2346 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	imul	r12, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+1]
	xor	r12, rax

; 2346 :         _Val *= _FNV_prime;

	imul	r12, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+2]
	xor	r12, rax

; 2346 :         _Val *= _FNV_prime;

	imul	r12, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+3]
	xor	r12, rax

; 2346 :         _Val *= _FNV_prime;

	imul	r12, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, QWORD PTR [rsi+48]
	and	rcx, r12

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rax, QWORD PTR [rsi+24]
	mov	rbx, QWORD PTR [rax+rcx*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	lea	rdx, QWORD PTR [rsi+8]
	mov	r15, QWORD PTR [rdx]

; 1570 :         if (_Where == _End) {

	cmp	rbx, r15
	jne	SHORT $LN25@Try_emplac

; 1571 :             return {_End, _Nodeptr{}};

	mov	rbx, r15
	mov	rbp, r15
	jmp	SHORT $LN2@Try_emplac
$LN25@Try_emplac:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rax+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	eax, DWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	eax, DWORD PTR [rbx+16]
	je	SHORT $LN154@Try_emplac
$LL22@Try_emplac:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rcx
	je	SHORT $LN155@Try_emplac

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	eax, DWORD PTR [rbx+16]
	jne	SHORT $LL22@Try_emplac
$LN154@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rbx
	mov	BYTE PTR [r14+8], 0
$LN181@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 711  :     }

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+136]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN155@Try_emplac:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	r15, rbx
	mov	rbp, rbx
$LN2@Try_emplac:

; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	QWORD PTR [rsi+16], rax
	jne	SHORT $LN36@Try_emplac

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN36@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR _Newnode$[rsp], rdx

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR _Newnode$[rsp+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 24
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR _Newnode$[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	eax, DWORD PTR [r13]
	mov	DWORD PTR [rdi+16], eax
	xor	r13d, r13d
	mov	DWORD PTR [rdi+20], r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rsi+16]

; 1654 :         const auto _Newsize      = _Oldsize + 1;

	add	rcx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN175@Try_emplac
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN176@Try_emplac
$LN175@Try_emplac:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN176@Try_emplac:
	mov	rcx, QWORD PTR [rsi+56]
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN173@Try_emplac
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN174@Try_emplac
$LN173@Try_emplac:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN174@Try_emplac:
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [rsi]
	seta	al

; 694  :         const auto& _Keyval = _Keyval_arg;
; 695  :         const auto _Hashval = _Traitsobj(_Keyval);
; 696  :         auto _Target        = _Find_last(_Keyval, _Hashval);
; 697  :         if (_Target._Duplicate) {
; 698  :             return {_Target._Duplicate, false};
; 699  :         }
; 700  : 
; 701  :         _Check_max_size();
; 702  :         _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), piecewise_construct,
; 703  :             _STD forward_as_tuple(_STD forward<_Keyty>(_Keyval_arg)),
; 704  :             _STD forward_as_tuple(_STD forward<_Mappedty>(_Mapval)...));
; 705  :         if (_Check_rehash_required_1()) {

	test	al, al
	je	SHORT $LN3@Try_emplac

; 706  :             _Rehash_for_1();

	mov	rcx, rsi
	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rehash_for_1

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, QWORD PTR [rsi+48]
	and	rcx, r12

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rdx, QWORD PTR [rsi+24]
	mov	rax, QWORD PTR [rdx+rcx*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rbx, QWORD PTR [rsi+8]

; 1570 :         if (_Where == _End) {

	cmp	rax, rbx
	je	SHORT $LN178@Try_emplac

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdx, QWORD PTR [rdx+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	ecx, DWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	ecx, DWORD PTR [rax+16]
	je	SHORT $LN156@Try_emplac
$LL139@Try_emplac:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	mov	rbx, rax
	cmp	rax, rdx
	je	SHORT $LN157@Try_emplac

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	ecx, DWORD PTR [rax+16]
	jne	SHORT $LL139@Try_emplac
$LN156@Try_emplac:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rbx, QWORD PTR [rax]
$LN178@Try_emplac:

; 707  :             _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	QWORD PTR $T1[rsp], rbx
$LN179@Try_emplac:
	mov	rbp, rbx
	mov	r15, QWORD PTR $T1[rsp]
$LN3@Try_emplac:

; 1615 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rdx, QWORD PTR [rbx+8]

; 1616 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [rsi+16]

; 1617 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rdi], r15

; 1618 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rdi+8], rdx

; 1619 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [rdx], rdi

; 1620 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [rbx+8], rdi

; 1621 : 
; 1622 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1623 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rcx, QWORD PTR [rsi+24]

; 1624 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR [rsi+48]
	and	rax, r12

; 1625 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rax, rax

; 1626 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1627 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r8, QWORD PTR [rcx+rax*8]
	cmp	r8, QWORD PTR [rsi+8]
	jne	SHORT $LN102@Try_emplac

; 1628 :             // bucket is empty, set both
; 1629 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rdi

; 1630 :             _Bucket_hi._Ptr = _Newnode;

	jmp	SHORT $LN180@Try_emplac
$LN157@Try_emplac:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rax
	jmp	SHORT $LN179@Try_emplac
$LN102@Try_emplac:

; 1631 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r8, rbp
	jne	SHORT $LN104@Try_emplac

; 1632 :             // new node is the lowest element in the bucket
; 1633 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rdi
	jmp	SHORT $LN106@Try_emplac
$LN104@Try_emplac:

; 1634 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rcx+rax*8+8], rdx
	jne	SHORT $LN106@Try_emplac
$LN180@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rcx+rax*8+8], rdi
$LN106@Try_emplac:
	mov	QWORD PTR [r14], rdi
	mov	BYTE PTR [r14+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 710  :         return {_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()), true};

	jmp	$LN181@Try_emplac
$LN177@Try_emplac:
??$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Try_emplace<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$ = 32
this$ = 112
__$ReturnUdt$ = 120
_Keyval_arg$ = 128
?dtor$1@?0???$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Try_emplace<int>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
?dtor$1@?0???$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Try_emplace<int>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$ = 32
this$ = 112
__$ReturnUdt$ = 120
_Keyval_arg$ = 128
?dtor$0@?0???$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Try_emplace<int>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
?dtor$0@?0???$_Try_emplace@H$$V@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@1@$$QEAH@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Try_emplace<int>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Val$ = 32
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >, COMDAT

; 5032 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN21:
	sub	rsp, 8
	mov	r10, rdx
	xor	eax, eax
	sub	rdx, rcx
	mov	r9, rcx
	add	rdx, 7
	shr	rdx, 3
	cmp	rcx, r10
	cmova	rdx, rax

; 5033 :     // copy _Val through [_First, _Last)
; 5034 :     _Adl_verify_range(_First, _Last);
; 5035 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5036 :         _Fill_vbool(_First, _Last, _Val);
; 5037 :     } else {
; 5038 :         auto _UFirst      = _Get_unwrapped(_First);
; 5039 :         const auto _ULast = _Get_unwrapped(_Last);
; 5040 : #if _HAS_CXX20
; 5041 :         if (!_STD is_constant_evaluated())
; 5042 : #endif // _HAS_CXX20
; 5043 :         {
; 5044 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5045 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5046 :                 return;
; 5047 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5048 :                 if (_Is_all_bits_zero(_Val)) {
; 5049 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5050 :                     return;
; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	test	rdx, rdx
	je	SHORT $LN10@fill
	cmp	rdx, 2
	jb	SHORT $LN10@fill

; 5056 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	add	rcx, -8
	lea	rcx, QWORD PTR [rcx+rdx*8]
	cmp	r9, r8
	ja	SHORT $LN11@fill

; 5032 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

	cmp	rcx, r8
	jae	SHORT $LN10@fill
$LN11@fill:
	mov	QWORD PTR [rsp], rdi
	and	rdx, -2
	mov	rdi, r9
	lea	rdx, QWORD PTR [rdx*8]
	mov	rcx, rdx
	shr	rcx, 3
	rep stosq
	add	r9, rdx
	mov	rdi, QWORD PTR [rsp]
$LN10@fill:

; 5033 :     // copy _Val through [_First, _Last)
; 5034 :     _Adl_verify_range(_First, _Last);
; 5035 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5036 :         _Fill_vbool(_First, _Last, _Val);
; 5037 :     } else {
; 5038 :         auto _UFirst      = _Get_unwrapped(_First);
; 5039 :         const auto _ULast = _Get_unwrapped(_Last);
; 5040 : #if _HAS_CXX20
; 5041 :         if (!_STD is_constant_evaluated())
; 5042 : #endif // _HAS_CXX20
; 5043 :         {
; 5044 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5045 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5046 :                 return;
; 5047 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5048 :                 if (_Is_all_bits_zero(_Val)) {
; 5049 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5050 :                     return;
; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r9, r10
	je	SHORT $LN3@fill
	npad	9
$LL9@fill:

; 5056 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [r9], rax
	add	r9, 8
	cmp	r9, r10
	jne	SHORT $LL9@fill
$LN3@fill:

; 5057 :         }
; 5058 :     }
; 5059 : }

	add	rsp, 8
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$pair@$$CBHI@std@@@std@@YA$$QEAU?$pair@$$CBHI@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$pair@$$CBHI@std@@@std@@YA$$QEAU?$pair@$$CBHI@0@AEAU10@@Z PROC ; std::move<std::pair<int const ,unsigned int> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$pair@$$CBHI@std@@@std@@YA$$QEAU?$pair@$$CBHI@0@AEAU10@@Z ENDP ; std::move<std::pair<int const ,unsigned int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z
_TEXT	SEGMENT
$T1 = 32
_Newnode$2 = 32
this$ = 112
__$ReturnUdt$ = 120
<_Vals_0>$ = 128
??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::emplace<std::pair<int const ,unsigned int> >, COMDAT

; 589  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN182:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r13, r8
	mov	r14, rdx
	mov	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	esi, BYTE PTR [r8]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	imul	rsi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+1]
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rsi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+2]
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rsi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+3]
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, QWORD PTR [rbp+48]
	and	rcx, rsi

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rax, QWORD PTR [rbp+24]
	mov	rbx, QWORD PTR [rax+rcx*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	lea	rdx, QWORD PTR [rbp+8]
	mov	r12, QWORD PTR [rdx]

; 1570 :         if (_Where == _End) {

	cmp	rbx, r12
	jne	SHORT $LN25@emplace

; 1571 :             return {_End, _Nodeptr{}};

	mov	rbx, r12
	mov	r15, r12
	jmp	SHORT $LN2@emplace
$LN25@emplace:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rax+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	eax, DWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	eax, DWORD PTR [rbx+16]
	je	SHORT $LN152@emplace
$LL22@emplace:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rcx
	je	SHORT $LN153@emplace

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	eax, DWORD PTR [rbx+16]
	jne	SHORT $LL22@emplace
$LN152@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rbx
	mov	BYTE PTR [r14+8], 0
$LN179@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 639  :     }

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+136]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN153@emplace:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	r12, rbx
	mov	r15, rbx
$LN2@emplace:

; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	QWORD PTR [rbp+16], rax
	jne	SHORT $LN44@emplace

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN44@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR _Newnode$2[rsp], rdx

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR _Newnode$2[rsp+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 24
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR _Newnode$2[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 586  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	rax, QWORD PTR [r13]
	mov	QWORD PTR [rdi+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rbp+16]

; 1654 :         const auto _Newsize      = _Oldsize + 1;

	add	rcx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN173@emplace
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN174@emplace
$LN173@emplace:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN174@emplace:
	mov	rcx, QWORD PTR [rbp+56]
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN171@emplace
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN172@emplace
$LN171@emplace:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN172@emplace:
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [rbp]
	seta	al

; 590  :         // try to insert value_type(_Vals...)
; 591  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 592  :         if constexpr (_Multi) {
; 593  :             _Check_max_size();
; 594  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 595  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 596  :             const auto _Hashval = _Traitsobj(_Keyval);
; 597  :             if (_Check_rehash_required_1()) {
; 598  :                 _Rehash_for_1();
; 599  :             }
; 600  : 
; 601  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 602  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 603  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 604  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);
; 605  :             const auto _Hashval = _Traitsobj(_Keyval);
; 606  :             auto _Target        = _Find_last(_Keyval, _Hashval);
; 607  :             if (_Target._Duplicate) {
; 608  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 609  :             }
; 610  : 
; 611  :             _Check_max_size();
; 612  :             // invalidates _Keyval:
; 613  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 614  :             if (_Check_rehash_required_1()) {

	test	al, al
	je	SHORT $LN3@emplace

; 615  :                 _Rehash_for_1();

	mov	rcx, rbp
	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rehash_for_1

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, rsi
	and	rcx, QWORD PTR [rbp+48]

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rdx, QWORD PTR [rbp+24]
	mov	rax, QWORD PTR [rdx+rcx*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rbx, QWORD PTR [rbp+8]

; 1570 :         if (_Where == _End) {

	cmp	rax, rbx
	jne	SHORT $LN140@emplace

; 1571 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp+8], 0
	jmp	SHORT $LN176@emplace
$LN140@emplace:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdx, QWORD PTR [rdx+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	ecx, DWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	ecx, DWORD PTR [rax+16]
	je	SHORT $LN154@emplace
	npad	5
$LL137@emplace:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	mov	rbx, rax
	cmp	rax, rdx
	je	SHORT $LN155@emplace

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	ecx, DWORD PTR [rax+16]
	jne	SHORT $LL137@emplace
$LN154@emplace:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rbx, QWORD PTR [rax]
$LN176@emplace:

; 616  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	QWORD PTR $T1[rsp], rbx
$LN177@emplace:
	mov	r15, rbx
	mov	r12, QWORD PTR $T1[rsp]
$LN3@emplace:

; 1615 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rcx, QWORD PTR [rbx+8]

; 1616 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [rbp+16]

; 1617 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rdi], r12

; 1618 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rdi+8], rcx

; 1619 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [rcx], rdi

; 1620 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [rbx+8], rdi

; 1621 : 
; 1622 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1623 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rbp+24]

; 1624 :         const size_type _Bucket         = _Hashval & _Mask;

	and	rsi, QWORD PTR [rbp+48]

; 1625 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rsi, rsi

; 1626 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1627 :         if (_Bucket_lo._Ptr == _Head) {

	mov	rdx, QWORD PTR [rax+rsi*8]
	cmp	rdx, QWORD PTR [rbp+8]
	jne	SHORT $LN92@emplace

; 1628 :             // bucket is empty, set both
; 1629 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rax+rsi*8], rdi

; 1630 :             _Bucket_hi._Ptr = _Newnode;

	jmp	SHORT $LN178@emplace
$LN155@emplace:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rax
	mov	QWORD PTR $T1[rsp+8], 0
	jmp	SHORT $LN177@emplace
$LN92@emplace:

; 1631 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	rdx, r15
	jne	SHORT $LN94@emplace

; 1632 :             // new node is the lowest element in the bucket
; 1633 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rax+rsi*8], rdi
	jmp	SHORT $LN96@emplace
$LN94@emplace:

; 1634 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rax+rsi*8+8], rcx
	jne	SHORT $LN96@emplace
$LN178@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rax+rsi*8+8], rdi
$LN96@emplace:
	mov	QWORD PTR [r14], rdi
	mov	BYTE PTR [r14+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 619  :             return {

	jmp	$LN179@emplace
$LN175@emplace:
??$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::emplace<std::pair<int const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$2 = 32
this$ = 112
__$ReturnUdt$ = 120
<_Vals_0>$ = 128
?dtor$1@?0???$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::emplace<std::pair<int const ,unsigned int> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
?dtor$1@?0???$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::emplace<std::pair<int const ,unsigned int> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$2 = 32
this$ = 112
__$ReturnUdt$ = 120
<_Vals_0>$ = 128
?dtor$0@?0???$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::emplace<std::pair<int const ,unsigned int> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$2[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
?dtor$0@?0???$emplace@U?$pair@$$CBHI@std@@@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHI@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::emplace<std::pair<int const ,unsigned int> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??$_Kfn@$$CBHI@?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBHI@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBHI@?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBHI@1@@Z PROC ; std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0>::_Kfn<int const ,unsigned int>, COMDAT

; 56   :         return _Val.first;

	mov	rax, rcx

; 57   :     }

	ret	0
??$_Kfn@$$CBHI@?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@SAAEBHAEBU?$pair@$$CBHI@1@@Z ENDP ; std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0>::_Kfn<int const ,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > ><std::allocator<std::pair<int const ,unsigned int> > const &,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 267  :     }

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > ><std::allocator<std::pair<int const ,unsigned int> > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >, COMDAT

; 1602 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rcx, rdx

; 1987 :     // copy _Val throughout raw [_First, _Last)
; 1988 :     _Adl_verify_range(_First, _Last);
; 1989 :     auto _UFirst      = _Get_unwrapped(_First);
; 1990 :     const auto _ULast = _Get_unwrapped(_Last);
; 1991 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1992 :         _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1993 :     } else {
; 1994 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1995 :             if (_Is_all_bits_zero(_Val)) {
; 1996 :                 _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1997 :                 return;
; 1998 :             }
; 1999 :         }
; 2000 : 
; 2001 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 2002 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN3@uninitiali
	npad	11
$LL2@uninitiali:

; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax

; 1617 :         ++_Last;

	add	rcx, 8

; 1987 :     // copy _Val throughout raw [_First, _Last)
; 1988 :     _Adl_verify_range(_First, _Last);
; 1989 :     auto _UFirst      = _Get_unwrapped(_First);
; 1990 :     const auto _ULast = _Get_unwrapped(_Last);
; 1991 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1992 :         _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1993 :     } else {
; 1994 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1995 :             if (_Is_all_bits_zero(_Val)) {
; 1996 :                 _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1997 :                 return;
; 1998 :             }
; 1999 :         }
; 2000 : 
; 2001 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 2002 :         while (_Backout._Last != _ULast) {

	cmp	rcx, rdx
	jne	SHORT $LL2@uninitiali
$LN3@uninitiali:

; 2003 :             _Backout._Emplace_back(_Val);
; 2004 :         }
; 2005 : 
; 2006 :         _Backout._Release();
; 2007 :     }
; 2008 : }

	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,1><std::allocator<std::pair<int const ,unsigned int> > const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,1><std::allocator<std::pair<int const ,unsigned int> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::_Release, COMDAT

; 1621 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1622 :         return _Last;
; 1623 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>, COMDAT

; 1610 :         _Destroy_range(_First, _Last);
; 1611 :     }

	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>, COMDAT

; 1602 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map@HU?$pair@$$CBHI@std@@@std@@SAAEBHAEBU?$pair@$$CBHI@2@@Z
_TEXT	SEGMENT
_Val$ = 8
?_Extract@?$_In_place_key_extract_map@HU?$pair@$$CBHI@std@@@std@@SAAEBHAEBU?$pair@$$CBHI@2@@Z PROC ; std::_In_place_key_extract_map<int,std::pair<int const ,unsigned int> >::_Extract, COMDAT

; 2113 :         return _Val.first;

	mov	rax, rcx

; 2114 :     }

	ret	0
?_Extract@?$_In_place_key_extract_map@HU?$pair@$$CBHI@std@@@std@@SAAEBHAEBU?$pair@$$CBHI@2@@Z ENDP ; std::_In_place_key_extract_map<int,std::pair<int const ,unsigned int> >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1156 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN11@List_node_

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 24
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN11@List_node_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 593  :     }

	ret	0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_Release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1148 :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rehash_for_1, COMDAT

; 1658 :     void _Rehash_for_1() {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1659 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;
; 1660 :         const auto _Newsize = _Oldsize + 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	rdi, rcx
	add	rdx, 1

; 1688 :         const size_type _Old_buckets = bucket_count();

	mov	rbx, QWORD PTR [rcx+56]

; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	js	SHORT $LN14@Rehash_for
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN15@Rehash_for
$LN14@Rehash_for:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN15@Rehash_for:
	divss	xmm0, DWORD PTR [rcx]
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	ecx, ecx
	comiss	xmm0, xmm1
	jb	SHORT $LN13@Rehash_for
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN13@Rehash_for
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN13@Rehash_for:
	cvttss2si rax, xmm0
	add	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 8
	cmp	rax, rcx
	cmova	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1690 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rbx, rcx
	jae	SHORT $LN3@Rehash_for

; 1691 :             // we already have enough buckets so there's no need to change the count
; 1692 :             return _Old_buckets;
; 1693 :         }
; 1694 : 
; 1695 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rbx, 512				; 00000200H
	jae	SHORT $LN5@Rehash_for
	lea	rbx, QWORD PTR [rbx*8]
	cmp	rbx, rcx
	jae	SHORT $LN3@Rehash_for
$LN5@Rehash_for:

; 1696 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1697 :             return _Old_buckets * 8;
; 1698 :         }
; 1699 : 
; 1700 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1701 :         return _Req_buckets;

	mov	rbx, rcx
$LN3@Rehash_for:

; 1661 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, rbx
	mov	rcx, rdi

; 1662 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1661 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	jmp	?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Forced_rehash
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Check_rehash_required_1, COMDAT

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1654 :         const auto _Newsize      = _Oldsize + 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	r8, rcx
	add	rdx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN7@Check_reha
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN8@Check_reha
$LN7@Check_reha:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN8@Check_reha:
	mov	rcx, QWORD PTR [rcx+56]
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN5@Check_reha
	cvtsi2ss xmm1, rcx
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [r8]
	seta	al

; 1656 :     }

	ret	0
$LN5@Check_reha:

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [r8]
	seta	al

; 1656 :     }

	ret	0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Check_max_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Check_max_size, COMDAT

; 1645 :     void _Check_max_size() const {

$LN6:
	sub	rsp, 40					; 00000028H

; 1646 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	QWORD PTR [rcx+16], rax
	jne	SHORT $LN2@Check_max_

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2@Check_max_:

; 1649 :         }
; 1650 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@Check_max_:
?_Check_max_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
this$ = 8
_Hashval$ = 16
_Insert_before$ = 24
_Newnode$ = 32
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Insert_new_node_before, COMDAT

; 1615 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	r11, QWORD PTR [r8+8]
	mov	rax, r9

; 1616 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [rcx+16]
	mov	r10, rcx
	mov	r9, rdx

; 1617 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rax], r8

; 1618 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rax+8], r11

; 1619 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [r11], rax

; 1620 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [r8+8], rax

; 1621 : 
; 1622 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1623 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rdx, QWORD PTR [rcx+24]

; 1624 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rcx, QWORD PTR [rcx+48]
	and	rcx, r9

; 1625 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rcx, rcx

; 1626 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1627 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r9, QWORD PTR [rdx+rcx*8]
	cmp	r9, QWORD PTR [r10+8]
	jne	SHORT $LN2@Insert_new

; 1628 :             // bucket is empty, set both
; 1629 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rdx+rcx*8], rax

; 1635 :             // new node is the highest element in the bucket
; 1636 :             _Bucket_hi._Ptr = _Newnode;
; 1637 :         }
; 1638 : 
; 1639 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1640 :         _Stl_internal_check_container_invariants();
; 1641 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1642 :         return _Newnode;
; 1643 :     }

	mov	QWORD PTR [rdx+rcx*8+8], rax
	ret	0
$LN2@Insert_new:

; 1630 :             _Bucket_hi._Ptr = _Newnode;
; 1631 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r9, r8
	jne	SHORT $LN4@Insert_new

; 1632 :             // new node is the lowest element in the bucket
; 1633 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rdx+rcx*8], rax

; 1635 :             // new node is the highest element in the bucket
; 1636 :             _Bucket_hi._Ptr = _Newnode;
; 1637 :         }
; 1638 : 
; 1639 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1640 :         _Stl_internal_check_container_invariants();
; 1641 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1642 :         return _Newnode;
; 1643 :     }

	ret	0
$LN4@Insert_new:

; 1634 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rdx+rcx*8+8], r11
	jne	SHORT $LN8@Insert_new

; 1635 :             // new node is the highest element in the bucket
; 1636 :             _Bucket_hi._Ptr = _Newnode;
; 1637 :         }
; 1638 : 
; 1639 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1640 :         _Stl_internal_check_container_invariants();
; 1641 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1642 :         return _Newnode;
; 1643 :     }

	mov	QWORD PTR [rdx+rcx*8+8], rax
$LN8@Insert_new:
	ret	0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >, COMDAT

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@@Z PROC ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Make_iter, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], r8

; 1122 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, rdx

; 1123 :     }

	ret	0
?_Make_iter@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@@Z ENDP ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >, COMDAT

; 1156 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@Alloc_cons

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 24
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN8@Alloc_cons:

; 1157 :             _Al.deallocate(_Ptr, 1);
; 1158 :         }
; 1159 :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Buckets$ = 72
?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Forced_rehash, COMDAT

; 1708 :     void _Forced_rehash(size_type _Buckets) {

$LN141:
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 42   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1708 :     void _Forced_rehash(size_type _Buckets) {

	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 42   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1716 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	edi, 1
	mov	eax, edi
	shl	rax, cl

; 1717 :         if (_Buckets > _Max_storage_buckets) {

	cmp	rdx, rax
	jbe	SHORT $LN8@Forced_reh

; 1718 :             _Xlength_error("invalid hash bucket count");

	lea	rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN8@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	lea	rax, QWORD PTR [rdx-1]
	mov	QWORD PTR [rsp+80], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rbx, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 26   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	rax, rdi

; 42   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1728 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	r8, rbx
	mov	QWORD PTR [rsp+32], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1725 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	shl	rdi, cl

; 1728 :         _Vec._Assign_grow(_Buckets << 1, _End);

	lea	rcx, QWORD PTR [rsi+24]
	lea	rdx, QWORD PTR [rdi+rdi]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Assign_grow

; 1729 :         _Mask   = _Buckets - 1;

	lea	rax, QWORD PTR [rdi-1]

; 1730 :         _Maxidx = _Buckets;

	mov	QWORD PTR [rsi+56], rdi
	mov	QWORD PTR [rsi+48], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rsi+8]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	je	$LN137@Forced_reh
	mov	QWORD PTR [rsp+88], rbp
	mov	rdi, 1099511628211			; 00000100000001b3H
	mov	rbp, -3750763034362895579		; cbf29ce484222325H
	npad	5
$LL4@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	edx, BYTE PTR [rax+17]
	movzx	r11d, BYTE PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 51   :         _Ptr = _Ptr->_Next;

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	r11, rbp

; 2346 :         _Val *= _FNV_prime;

	imul	r11, rdi
	xor	r11, rdx
	movzx	edx, BYTE PTR [rax+18]
	imul	r11, rdi
	xor	r11, rdx
	movzx	edx, BYTE PTR [rax+19]
	imul	r11, rdi
	xor	r11, rdx
	imul	r11, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	r11, QWORD PTR [rsi+48]

; 1738 :             ++_Next_inserted;
; 1739 : 
; 1740 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);
; 1741 :             const size_type _Bucket = bucket(_Inserted_key);
; 1742 : 
; 1743 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1744 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1745 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	shl	r11, 4
	add	r11, QWORD PTR [rsi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	mov	r9, QWORD PTR [r11]
	cmp	r9, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1748 :             if (_Bucket_lo == _End) {

	jne	SHORT $LN9@Forced_reh

; 1749 :                 // The bucket was empty, set it to the inserted element.
; 1750 :                 _Bucket_lo = _Inserted;

	mov	QWORD PTR [r11], rax

; 1751 :                 _Bucket_hi = _Inserted;

	mov	QWORD PTR [r11+8], rax

; 1752 :                 continue;

	jmp	SHORT $LN2@Forced_reh
$LN9@Forced_reh:

; 1753 :             }
; 1754 : 
; 1755 :             // Search the bucket for the insertion location and move element if necessary.
; 1756 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	mov	rdx, QWORD PTR [r11+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	r8d, DWORD PTR [rax+16]
	cmp	r8d, DWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1757 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	jne	SHORT $LN10@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 51   :         _Ptr = _Ptr->_Next;

	mov	r10, QWORD PTR [rdx]
	cmp	r10, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1761 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	je	SHORT $LN127@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r9, QWORD PTR [rax+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r9], rcx

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r8, QWORD PTR [rcx+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r8], r10

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	rdx, QWORD PTR [r10+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rdx], rax

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [r10+8], r8

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r9

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], rdx
$LN127@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1765 :                 _Bucket_hi = _Inserted;

	mov	QWORD PTR [r11+8], rax

; 1766 :                 continue;

	jmp	SHORT $LN2@Forced_reh
$LN10@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1772 :                 if (_Bucket_lo == _Insert_before) {

	je	SHORT $LN112@Forced_reh
	npad	1
$LL5@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 62   :         _Ptr = _Ptr->_Prev;

	mov	rdx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	r8d, DWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1782 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

	je	SHORT $LN113@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1772 :                 if (_Bucket_lo == _Insert_before) {

	jne	SHORT $LL5@Forced_reh
$LN112@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r10, QWORD PTR [rax+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r10], rcx

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r9, QWORD PTR [rcx+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r9], rdx

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	r8, QWORD PTR [rdx+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [r8], rax

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rdx+8], r9

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r10

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1778 :                     _Bucket_lo = _Inserted;

	mov	QWORD PTR [r11], rax
$LN2@Forced_reh:

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	jne	$LL4@Forced_reh
	mov	rbp, QWORD PTR [rsp+88]
$LN137@Forced_reh:
	mov	rbx, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+32]

; 1798 :     }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
$LN113@Forced_reh:

; 1783 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1784 :                     ++_Insert_before;
; 1785 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1786 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1787 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r10, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r9, QWORD PTR [rax+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r9], rcx

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r8, QWORD PTR [rcx+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r8], r10

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	rdx, QWORD PTR [r10+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rdx], rax

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [r10+8], r8

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r9

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], rdx
	jmp	SHORT $LN2@Forced_reh
$LN138@Forced_reh:
?_Forced_rehash@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 48
_For_size$ = 56
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Desired_grow_bucket_count, COMDAT

; 1687 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN21:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1688 :         const size_type _Old_buckets = bucket_count();

	mov	rbx, QWORD PTR [rcx+56]

; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN12@Desired_gr
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN13@Desired_gr
$LN12@Desired_gr:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN13@Desired_gr:
	divss	xmm0, DWORD PTR [rcx]
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	eax, eax
	comiss	xmm0, xmm1
	jb	SHORT $LN11@Desired_gr
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN11@Desired_gr
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	rax, rcx
$LN11@Desired_gr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	edx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	cvttss2si rcx, xmm0
	add	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmp	rcx, rdx
	cmova	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1690 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rbx, rdx
	jb	SHORT $LN2@Desired_gr

; 1691 :             // we already have enough buckets so there's no need to change the count
; 1692 :             return _Old_buckets;

	mov	rax, rbx

; 1696 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1697 :             return _Old_buckets * 8;
; 1698 :         }
; 1699 : 
; 1700 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1701 :         return _Req_buckets;
; 1702 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Desired_gr:

; 1693 :         }
; 1694 : 
; 1695 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rbx, 512				; 00000200H
	jae	SHORT $LN3@Desired_gr
	lea	rax, QWORD PTR [rbx*8]
	cmp	rax, rdx
	cmovae	rdx, rax
$LN3@Desired_gr:

; 1696 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1697 :             return _Old_buckets * 8;
; 1698 :         }
; 1699 : 
; 1700 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1701 :         return _Req_buckets;
; 1702 :     }

	mov	rax, rdx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?max_load_factor@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::max_load_factor, COMDAT

; 911  :         return _Max_bucket_size();

	movss	xmm0, DWORD PTR [rcx]

; 912  :     }

	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::max_size, COMDAT

; 1193 :         return (_STD min)(

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 1194 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1195 :     }

	ret	0
?max_size@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Clear_guard@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 483  :             if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?clear@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::clear

; 484  :                 _Target->clear();
; 485  :             }
; 486  :         }

	ret	0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Target_$ = 16
??0_Clear_guard@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 477  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::operator++, COMDAT

; 51   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 108  :         _Mybase::operator++();
; 109  :         return *this;

	mov	rax, rcx

; 51   :         _Ptr = _Ptr->_Next;

	mov	QWORD PTR [rcx], rdx

; 110  :     }

	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHI@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHI@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::operator*, COMDAT

; 43   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 100  :         return const_cast<reference>(_Mybase::operator*());
; 101  :     }

	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHI@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator==, COMDAT

; 73   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 74   :     }

	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator--, COMDAT

; 62   :         _Ptr = _Ptr->_Prev;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax+8]

; 63   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 64   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator++, COMDAT

; 51   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 52   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 53   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBHI@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBHI@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator*, COMDAT

; 43   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 44   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBHI@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::max_size, COMDAT

; 277  :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 278  :             _Aliter_traits::max_size(_Mypair._Get_first()));
; 279  :     }

	ret	0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$ = 8
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Max_bucket_size, COMDAT

; 1805 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, rcx

; 1806 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 48
_For_size$ = 56
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Min_load_factor_buckets, COMDAT

; 1682 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN10:
	sub	rsp, 40					; 00000028H

; 1683 :         // returns the minimum number of buckets necessary for the elements in _List
; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN6@Min_load_f
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN7@Min_load_f
$LN6@Min_load_f:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN7@Min_load_f:
	divss	xmm0, DWORD PTR [rcx]
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	ecx, ecx
	comiss	xmm0, xmm1
	jb	SHORT $LN5@Min_load_f
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN5@Min_load_f
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN5@Min_load_f:
	cvttss2si rax, xmm0
	add	rax, rcx

; 1685 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Unchecked_begin, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rcx+8]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 803  :         return _List._Unchecked_begin();

	mov	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 804  :     }

	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_Before$ = 8
_First$ = 16
_Last$ = 24
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >::_Unchecked_splice, COMDAT

; 470  :         // splice [_First, _Last) before _Before; returns _Last
; 471  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 472  :         // 3 reads and 6 writes
; 473  : 
; 474  :         // fixup the _Next values
; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r10, QWORD PTR [rdx+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r10], r8

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r9, QWORD PTR [r8+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r9], rcx

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR [rcx+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rax], rdx

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rcx+8], r9

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [r8+8], r10

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rdx+8], rax

; 486  : 
; 487  :         return _Last;

	mov	rax, r8

; 488  :     }

	ret	0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Getal, COMDAT

; 1852 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1853 :     }

	ret	0
?_Getal@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Unchecked_begin, COMDAT

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rcx]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, rdx

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx

; 1107 :     }

	ret	0
?_Unchecked_begin@?$list@U?$pair@$$CBHI@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<int const ,unsigned int>,std::allocator<std::pair<int const ,unsigned int> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHI@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U?$pair@$$CBHI@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> ><std::pair<int const ,unsigned int> >, COMDAT

; 962  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0U?$pair@$$CBHI@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> >::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> ><std::pair<int const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Find_unchecked@PEAIH@std@@YAPEAIPEAIQEAIAEBH@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Find_unchecked@PEAIH@std@@YAPEAIPEAIQEAIAEBH@Z PROC	; std::_Find_unchecked<unsigned int *,int>, COMDAT

; 124  :         return const_cast<_Ty*>(

	mov	r8d, DWORD PTR [r8]
	jmp	__std_find_trivial_4
??$_Find_unchecked@PEAIH@std@@YAPEAIPEAIQEAIAEBH@Z ENDP	; std::_Find_unchecked<unsigned int *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Find_unchecked@PEAHI@std@@YAPEAHPEAHQEAHAEBI@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Find_unchecked@PEAHI@std@@YAPEAHPEAHQEAHAEBI@Z PROC	; std::_Find_unchecked<int *,unsigned int>, COMDAT

; 124  :         return const_cast<_Ty*>(

	mov	r8d, DWORD PTR [r8]
	jmp	__std_find_trivial_4
??$_Find_unchecked@PEAHI@std@@YAPEAHPEAHQEAHAEBI@Z ENDP	; std::_Find_unchecked<int *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$_Find_last@H@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBH_K@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Keyval$ = 24
_Hashval$ = 32
??$_Find_last@H@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBH_K@Z PROC ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Find_last<int>, COMDAT

; 1565 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

	mov	r11, r8

; 1566 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	r8, QWORD PTR [rcx+48]
	and	r8, r9

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	r9, QWORD PTR [rcx+8]
	shl	r8, 4
	add	r8, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [r8+8]

; 1570 :         if (_Where == _End) {

	cmp	rax, r9
	jne	SHORT $LN5@Find_last

; 1571 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR [rdx], r9

; 1592 :         }
; 1593 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx+8], 0
	ret	0
$LN5@Find_last:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	ecx, DWORD PTR [r11]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r8, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	ecx, DWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN15@Find_last
	npad	7
$LL2@Find_last:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rax, r8
	je	SHORT $LN16@Find_last

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	ecx, DWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL2@Find_last
$LN15@Find_last:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rdx+8], rax

; 1592 :         }
; 1593 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx], rcx
	ret	0
$LN16@Find_last:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR [rdx], rax

; 1592 :         }
; 1593 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx+8], 0
	ret	0
??$_Find_last@H@?$_Hash@V?$_Umap_traits@HIV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBH_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,unsigned int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Find_last<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
<_Args_0>$ = 16
??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z PROC ; std::forward_as_tuple<int>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx

; 1026 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 1027 : }

	ret	0
??$forward_as_tuple@H@std@@YA?AV?$tuple@$$QEAH@0@$$QEAH@Z ENDP ; std::forward_as_tuple<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >, COMDAT

; 584  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN50:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r9
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], 0

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 24
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	edx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+16], edx
	mov	DWORD PTR [rax+20], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 587  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > ><std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned int>,void *> * &,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned int>,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool><std::_List_node<std::pair<int const ,unsigned int>,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$pair@$$CBHI@std@@@std@@YA$$QEAU?$pair@$$CBHI@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@$$CBHI@std@@@std@@YA$$QEAU?$pair@$$CBHI@0@AEAU10@@Z PROC ; std::forward<std::pair<int const ,unsigned int> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$pair@$$CBHI@std@@@std@@YA$$QEAU?$pair@$$CBHI@0@AEAU10@@Z ENDP ; std::forward<std::pair<int const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > ><std::pair<int const ,unsigned int> >, COMDAT

; 584  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN40:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+24]
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 586  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rax+16], rcx

; 587  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > ><std::pair<int const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
?dtor$0@?0???$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > ><std::pair<int const ,unsigned int> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
?dtor$0@?0???$?0U?$pair@$$CBHI@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHI@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > ><std::pair<int const ,unsigned int> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@$$QEA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@$$QEA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBHI@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBHI@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<int const ,unsigned int> > const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBHI@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<int const ,unsigned int> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >,1><std::allocator<std::pair<int const ,unsigned int> > const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBHI@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >,1><std::allocator<std::pair<int const ,unsigned int> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &>, COMDAT

; 1615 :         // construct a new element at *_Last and increment
; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1617 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1618 :     }

	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<int const ,unsigned int>,void *> *>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<int const ,unsigned int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<int const ,unsigned int>,void *> * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<int const ,unsigned int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * const &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_Allocate, COMDAT

; 1150 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 24
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rbx+8], rax

; 1153 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >, COMDAT

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 0
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHI@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U?$pair@$$CBHI@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > ><std::pair<int const ,unsigned int> >, COMDAT

; 962  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0U?$pair@$$CBHI@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > ><std::pair<int const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Could_compare_equal_to_value_type@PEAIH@std@@YA_NAEBH@Z
_TEXT	SEGMENT
_Val$dead$ = 8
??$_Could_compare_equal_to_value_type@PEAIH@std@@YA_NAEBH@Z PROC ; std::_Could_compare_equal_to_value_type<unsigned int *,int>, COMDAT

; 5747 :     // check whether _Val is within the limits of _Elem
; 5748 :     _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);
; 5749 : 
; 5750 :     if constexpr (disjunction_v<
; 5751 : #ifdef __cpp_lib_byte
; 5752 :                       is_same<_Ty, byte>,
; 5753 : #endif // __cpp_lib_byte
; 5754 :                       is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
; 5755 :         return true;
; 5756 :     } else {
; 5757 :         using _Elem = _Iter_value_t<_InIt>;
; 5758 :         _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);
; 5759 : 
; 5760 :         if constexpr (is_same_v<_Elem, bool>) {
; 5761 :             return _Val == true || _Val == false;
; 5762 :         } else if constexpr (is_signed_v<_Elem>) {
; 5763 :             // use instead of numeric_limits::min/max; avoid <limits> dependency
; 5764 :             constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * CHAR_BIT - 1));
; 5765 :             constexpr _Elem _Max = static_cast<_Elem>(~_Min);
; 5766 : 
; 5767 :             if constexpr (is_signed_v<_Ty>) {
; 5768 :                 // signed _Elem, signed _Ty
; 5769 :                 return _Min <= _Val && _Val <= _Max;
; 5770 :             } else {
; 5771 :                 // signed _Elem, unsigned _Ty
; 5772 :                 if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
; 5773 :                     // negative values of _Elem can compare equal to values of _Ty
; 5774 :                     return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
; 5775 :                 } else {
; 5776 :                     // negative values of _Elem cannot compare equal to values of _Ty
; 5777 :                     return _Val <= _Max;
; 5778 :                 }
; 5779 :             }
; 5780 :         } else {
; 5781 :             constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});
; 5782 : 
; 5783 :             if constexpr (is_unsigned_v<_Ty>) {
; 5784 :                 // unsigned _Elem, unsigned _Ty
; 5785 :                 return _Val <= _Max;
; 5786 :             } else {
; 5787 :                 // unsigned _Elem, signed _Ty
; 5788 :                 if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
; 5789 :                     // negative values of _Ty can compare equal to values of _Elem
; 5790 :                     return _Val <= _Max;

	mov	al, 1

; 5791 :                 } else {
; 5792 :                     // negative values of _Ty cannot compare equal to values of _Elem
; 5793 :                     return 0 <= _Val && _Val <= _Max;
; 5794 :                 }
; 5795 :             }
; 5796 :         }
; 5797 :     }
; 5798 : }

	ret	0
??$_Could_compare_equal_to_value_type@PEAIH@std@@YA_NAEBH@Z ENDP ; std::_Could_compare_equal_to_value_type<unsigned int *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$__std_find_trivial@IH@@YAPEAIPEAI0H@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$__std_find_trivial@IH@@YAPEAIPEAI0H@Z PROC		; __std_find_trivial<unsigned int,int>, COMDAT

; 115  :     if constexpr (_STD is_pointer_v<_TVal> || _STD is_null_pointer_v<_TVal>) {
; 116  :         return __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
; 117  :     } else if constexpr (sizeof(_Ty) == 1) {
; 118  :         return const_cast<_Ty*>(
; 119  :             static_cast<const _Ty*>(__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 120  :     } else if constexpr (sizeof(_Ty) == 2) {
; 121  :         return const_cast<_Ty*>(
; 122  :             static_cast<const _Ty*>(__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 123  :     } else if constexpr (sizeof(_Ty) == 4) {
; 124  :         return const_cast<_Ty*>(

	jmp	__std_find_trivial_4
??$__std_find_trivial@IH@@YAPEAIPEAI0H@Z ENDP		; __std_find_trivial<unsigned int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Could_compare_equal_to_value_type@PEAHI@std@@YA_NAEBI@Z
_TEXT	SEGMENT
_Val$dead$ = 8
??$_Could_compare_equal_to_value_type@PEAHI@std@@YA_NAEBI@Z PROC ; std::_Could_compare_equal_to_value_type<int *,unsigned int>, COMDAT

; 5747 :     // check whether _Val is within the limits of _Elem
; 5748 :     _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);
; 5749 : 
; 5750 :     if constexpr (disjunction_v<
; 5751 : #ifdef __cpp_lib_byte
; 5752 :                       is_same<_Ty, byte>,
; 5753 : #endif // __cpp_lib_byte
; 5754 :                       is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
; 5755 :         return true;
; 5756 :     } else {
; 5757 :         using _Elem = _Iter_value_t<_InIt>;
; 5758 :         _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);
; 5759 : 
; 5760 :         if constexpr (is_same_v<_Elem, bool>) {
; 5761 :             return _Val == true || _Val == false;
; 5762 :         } else if constexpr (is_signed_v<_Elem>) {
; 5763 :             // use instead of numeric_limits::min/max; avoid <limits> dependency
; 5764 :             constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * CHAR_BIT - 1));
; 5765 :             constexpr _Elem _Max = static_cast<_Elem>(~_Min);
; 5766 : 
; 5767 :             if constexpr (is_signed_v<_Ty>) {
; 5768 :                 // signed _Elem, signed _Ty
; 5769 :                 return _Min <= _Val && _Val <= _Max;
; 5770 :             } else {
; 5771 :                 // signed _Elem, unsigned _Ty
; 5772 :                 if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
; 5773 :                     // negative values of _Elem can compare equal to values of _Ty
; 5774 :                     return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;

	mov	al, 1

; 5775 :                 } else {
; 5776 :                     // negative values of _Elem cannot compare equal to values of _Ty
; 5777 :                     return _Val <= _Max;
; 5778 :                 }
; 5779 :             }
; 5780 :         } else {
; 5781 :             constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});
; 5782 : 
; 5783 :             if constexpr (is_unsigned_v<_Ty>) {
; 5784 :                 // unsigned _Elem, unsigned _Ty
; 5785 :                 return _Val <= _Max;
; 5786 :             } else {
; 5787 :                 // unsigned _Elem, signed _Ty
; 5788 :                 if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
; 5789 :                     // negative values of _Ty can compare equal to values of _Elem
; 5790 :                     return _Val <= _Max;
; 5791 :                 } else {
; 5792 :                     // negative values of _Ty cannot compare equal to values of _Elem
; 5793 :                     return 0 <= _Val && _Val <= _Max;
; 5794 :                 }
; 5795 :             }
; 5796 :         }
; 5797 :     }
; 5798 : }

	ret	0
??$_Could_compare_equal_to_value_type@PEAHI@std@@YA_NAEBI@Z ENDP ; std::_Could_compare_equal_to_value_type<int *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$__std_find_trivial@HI@@YAPEAHPEAH0I@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$__std_find_trivial@HI@@YAPEAHPEAH0I@Z PROC		; __std_find_trivial<int,unsigned int>, COMDAT

; 115  :     if constexpr (_STD is_pointer_v<_TVal> || _STD is_null_pointer_v<_TVal>) {
; 116  :         return __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
; 117  :     } else if constexpr (sizeof(_Ty) == 1) {
; 118  :         return const_cast<_Ty*>(
; 119  :             static_cast<const _Ty*>(__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 120  :     } else if constexpr (sizeof(_Ty) == 2) {
; 121  :         return const_cast<_Ty*>(
; 122  :             static_cast<const _Ty*>(__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 123  :     } else if constexpr (sizeof(_Ty) == 4) {
; 124  :         return const_cast<_Ty*>(

	jmp	__std_find_trivial_4
??$__std_find_trivial@HI@@YAPEAHPEAH0I@Z ENDP		; __std_find_trivial<int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z
_TEXT	SEGMENT
this$ = 8
_This_arg$ = 16
??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z PROC	; std::tuple<int &&>::tuple<int &&><int,0>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx

; 363  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

	mov	rax, rcx
	ret	0
??$?0H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@$$QEAH@Z ENDP	; std::tuple<int &&>::tuple<int &&><int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z PROC ; std::forward<std::tuple<int &&> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z ENDP ; std::forward<std::tuple<int &&> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBHI@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@QEAU?$pair@$$CBHI@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$dead$ = 24
<_Args_1>$ = 32
<_Args_2>$dead$ = 40
??$construct@U?$pair@$$CBHI@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@QEAU?$pair@$$CBHI@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::construct<std::pair<int const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [r9]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	ecx, DWORD PTR [rax]
	mov	DWORD PTR [rdx], ecx
	mov	DWORD PTR [rdx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@U?$pair@$$CBHI@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@QEAU?$pair@$$CBHI@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@$$QEAH@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::construct<std::pair<int const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<int const ,unsigned int>,void *> *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<int const ,unsigned int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBHI@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@QEAU?$pair@$$CBHI@1@$$QEAU31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$pair@$$CBHI@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@QEAU?$pair@$$CBHI@1@$$QEAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::construct<std::pair<int const ,unsigned int>,std::pair<int const ,unsigned int> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@U?$pair@$$CBHI@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@1@QEAU?$pair@$$CBHI@1@$$QEAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,unsigned int>,void *> > >::construct<std::pair<int const ,unsigned int>,std::pair<int const ,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<int const ,unsigned int>,void *> * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<int const ,unsigned int>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHI@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<int const ,unsigned int>,void *> *,std::_List_node<std::pair<int const ,unsigned int>,void *> * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_This_arg$ = 24
??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z PROC ; std::tuple<int &&>::tuple<int &&><std::_Exact_args_t,int,0>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], r8

; 317  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	mov	rax, rcx
	ret	0
??$?0U_Exact_args_t@std@@H$$V$0A@@?$tuple@$$QEAH@std@@QEAA@U_Exact_args_t@1@$$QEAH@Z ENDP ; std::tuple<int &&>::tuple<int &&><std::_Exact_args_t,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBHI@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBHI@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@$$QEAH@0@$$QEAV?$tuple@$$V@0@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
<_Args_2>$dead$ = 32
??$construct_at@U?$pair@$$CBHI@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBHI@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@$$QEAH@0@$$QEAV?$tuple@$$V@0@@Z PROC ; std::construct_at<std::pair<int const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	edx, DWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rcx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@U?$pair@$$CBHI@std@@AEBUpiecewise_construct_t@2@V?$tuple@$$QEAH@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBHI@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@$$QEAH@0@$$QEAV?$tuple@$$V@0@@Z ENDP ; std::construct_at<std::pair<int const ,unsigned int>,std::piecewise_construct_t const &,std::tuple<int &&>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBHI@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBHI@0@QEAU10@$$QEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@U?$pair@$$CBHI@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBHI@0@QEAU10@$$QEAU10@@Z PROC ; std::construct_at<std::pair<int const ,unsigned int>,std::pair<int const ,unsigned int>,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@U?$pair@$$CBHI@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBHI@0@QEAU10@$$QEAU10@@Z ENDP ; std::construct_at<std::pair<int const ,unsigned int>,std::pair<int const ,unsigned int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z PROC ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHI@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ENDP ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,unsigned int> > > > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z PROC		; std::tuple<int &&>::tuple<int &&>, COMDAT

; 366  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0?$tuple@$$QEAH@std@@QEAA@$$QEAV01@@Z ENDP		; std::tuple<int &&>::tuple<int &&>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0$$QEAH$$Z$$V@?$pair@$$CBHI@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$ = 24
_Val2$dead$ = 32
??$?0$$QEAH$$Z$$V@?$pair@$$CBHI@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z PROC ; std::pair<int const ,unsigned int>::pair<int const ,unsigned int><int &&>, COMDAT

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, QWORD PTR [r8]
	mov	edx, DWORD PTR [rax]

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	mov	rax, rcx

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rcx+4], 0

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	ret	0
??$?0$$QEAH$$Z$$V@?$pair@$$CBHI@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@$$QEAH@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<int const ,unsigned int>::pair<int const ,unsigned int><int &&>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z
_TEXT	SEGMENT
this$ = 8
_Arg$ = 16
??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z PROC	; std::_Tuple_val<int &&>::_Tuple_val<int &&><int>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??$?0H@?$_Tuple_val@$$QEAH@std@@QEAA@$$QEAH@Z ENDP	; std::_Tuple_val<int &&>::_Tuple_val<int &&><int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHI@std@@QEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$dead$ = 24
__formal$dead$ = 32
__formal$dead$ = 40
??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHI@std@@QEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z PROC ; std::pair<int const ,unsigned int>::pair<int const ,unsigned int><std::tuple<int &&>,std::tuple<>,0>, COMDAT

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, QWORD PTR [rdx]
	mov	edx, DWORD PTR [rax]
	mov	rax, rcx
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rcx+4], 0
	ret	0
??$?0V?$tuple@$$QEAH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHI@std@@QEAA@AEAV?$tuple@$$QEAH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ENDP ; std::pair<int const ,unsigned int>::pair<int const ,unsigned int><std::tuple<int &&>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$_Tuple_get@$0A@$$QEAH@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAH@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$_Tuple_get@$0A@$$QEAH@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAH@0@@Z PROC ; std::_Tuple_get<0,int &&>, COMDAT

; 971  :     // used by pair's piecewise constructor
; 972  :     using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
; 973  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 974  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

	mov	rax, QWORD PTR [rcx]

; 975  : }

	ret	0
??$_Tuple_get@$0A@$$QEAH@std@@YA$$QEA_P$$QEAV?$tuple@$$QEAH@0@@Z ENDP ; std::_Tuple_get<0,int &&>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z PROC ; std::move<std::tuple<int &&> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$tuple@$$QEAH@std@@@std@@YA$$QEAV?$tuple@$$QEAH@0@AEAV10@@Z ENDP ; std::move<std::tuple<int &&> &>
_TEXT	ENDS
END
