; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_01GFHCPBMG@C@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_08PJIJFDMO@FmdbName@			; `string'
PUBLIC	??_C@_0BB@GHJIGDCO@ModelProjectName@		; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP@				; `string'
PUBLIC	??_C@_08KPEPEALH@?4pack?4zs@			; `string'
PUBLIC	??_C@_0M@KLNJNMKE@Pack?1Actor?1@		; `string'
PUBLIC	??_C@_0EE@LHNPHJCH@Could?5not?5open?5CollisionActorPa@ ; `string'
PUBLIC	??_C@_0BG@DAKEMMDK@ActorCollisionCreator@	; `string'
PUBLIC	??_C@_0BM@GKEBGDGD@Could?5not?5decode?5actor?5pack@ ; `string'
PUBLIC	??_C@_0BF@NEMOFKGI@Component?1ModelInfo?1@	; `string'
PUBLIC	??_C@_0BC@IAEKHNID@Phive?1ShapeParam?1@		; `string'
PUBLIC	??_C@_09HMGNIAEA@Renaming?5@			; `string'
PUBLIC	??_C@_0CB@JNPNCPPB@?4engine__actor__ActorParam?4bgym@ ; `string'
PUBLIC	??_C@_06CEPBAGLB@Actor?1@			; `string'
PUBLIC	??_C@_0BK@EEDODEGP@Phive?1ControllerSetParam?1@	; `string'
PUBLIC	??_C@_0BM@EPCOBMAC@ControllerEntityNamePathAry@	; `string'
PUBLIC	??_C@_04FABLJDN@Name@				; `string'
PUBLIC	??_C@_04MJIIEFNN@Body@				; `string'
PUBLIC	??_C@_0BA@FFIMANGF@Save?1Pack?1Actor@		; `string'
PUBLIC	??_C@_0BB@CPJBCBLH@Save?1Pack?1Actor?1@		; `string'
PUBLIC	??_C@_0P@PBLGDOKE@?4rstbl?4byml?4zs@		; `string'
PUBLIC	??_C@_0BI@KLODAJAF@RSDB?1ActorInfo?4Product?4@	; `string'
PUBLIC	??_C@_04HIBGFPH@NULL@				; `string'
PUBLIC	??_C@_07BBFAJBAL@__RowId@			; `string'
PUBLIC	??_C@_09GOLCEHOP@Save?1RSDB@			; `string'
PUBLIC	??_C@_0BN@CEOGAKHF@Save?1RSDB?1ActorInfo?4Product?4@ ; `string'
PUBLIC	??_C@_0CF@LPEEJBMK@No?5need?5to?5regenerate?5ActorInfo@ ; `string'
PUBLIC	??_C@_0CE@KOIOFOEB@Could?5not?5regenerate?5ActorInfo?5@ ; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QEBAPEBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QEBAPEBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp___stdio_common_vsprintf_s:PROC
EXTRN	__imp___std_exception_copy:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exceptions@std@@YAHXZ:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	__imp_calloc:PROC
EXTRN	__imp__Mbrtowc:PROC
EXTRN	__imp___std_exception_destroy:PROC
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KOIOFOEB@Could?5not?5regenerate?5ActorInfo?5@
CONST	SEGMENT
??_C@_0CE@KOIOFOEB@Could?5not?5regenerate?5ActorInfo?5@ DB 'Could not reg'
	DB	'enerate ActorInfo RSDB', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LPEEJBMK@No?5need?5to?5regenerate?5ActorInfo@
CONST	SEGMENT
??_C@_0CF@LPEEJBMK@No?5need?5to?5regenerate?5ActorInfo@ DB 'No need to re'
	DB	'generate ActorInfo RSDB', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CEOGAKHF@Save?1RSDB?1ActorInfo?4Product?4@
CONST	SEGMENT
??_C@_0BN@CEOGAKHF@Save?1RSDB?1ActorInfo?4Product?4@ DB 'Save/RSDB/ActorI'
	DB	'nfo.Product.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09GOLCEHOP@Save?1RSDB@
CONST	SEGMENT
??_C@_09GOLCEHOP@Save?1RSDB@ DB 'Save/RSDB', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BBFAJBAL@__RowId@
CONST	SEGMENT
??_C@_07BBFAJBAL@__RowId@ DB '__RowId', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL@
CONST	SEGMENT
??_C@_04HIBGFPH@NULL@ DB 'NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KLODAJAF@RSDB?1ActorInfo?4Product?4@
CONST	SEGMENT
??_C@_0BI@KLODAJAF@RSDB?1ActorInfo?4Product?4@ DB 'RSDB/ActorInfo.Product'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PBLGDOKE@?4rstbl?4byml?4zs@
CONST	SEGMENT
??_C@_0P@PBLGDOKE@?4rstbl?4byml?4zs@ DB '.rstbl.byml.zs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CPJBCBLH@Save?1Pack?1Actor?1@
CONST	SEGMENT
??_C@_0BB@CPJBCBLH@Save?1Pack?1Actor?1@ DB 'Save/Pack/Actor/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FFIMANGF@Save?1Pack?1Actor@
CONST	SEGMENT
??_C@_0BA@FFIMANGF@Save?1Pack?1Actor@ DB 'Save/Pack/Actor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MJIIEFNN@Body@
CONST	SEGMENT
??_C@_04MJIIEFNN@Body@ DB 'Body', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FABLJDN@Name@
CONST	SEGMENT
??_C@_04FABLJDN@Name@ DB 'Name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EPCOBMAC@ControllerEntityNamePathAry@
CONST	SEGMENT
??_C@_0BM@EPCOBMAC@ControllerEntityNamePathAry@ DB 'ControllerEntityNameP'
	DB	'athAry', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EEDODEGP@Phive?1ControllerSetParam?1@
CONST	SEGMENT
??_C@_0BK@EEDODEGP@Phive?1ControllerSetParam?1@ DB 'Phive/ControllerSetPa'
	DB	'ram/', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06CEPBAGLB@Actor?1@
CONST	SEGMENT
??_C@_06CEPBAGLB@Actor?1@ DB 'Actor/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JNPNCPPB@?4engine__actor__ActorParam?4bgym@
CONST	SEGMENT
??_C@_0CB@JNPNCPPB@?4engine__actor__ActorParam?4bgym@ DB '.engine__actor_'
	DB	'_ActorParam.bgyml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HMGNIAEA@Renaming?5@
CONST	SEGMENT
??_C@_09HMGNIAEA@Renaming?5@ DB 'Renaming ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IAEKHNID@Phive?1ShapeParam?1@
CONST	SEGMENT
??_C@_0BC@IAEKHNID@Phive?1ShapeParam?1@ DB 'Phive/ShapeParam/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NEMOFKGI@Component?1ModelInfo?1@
CONST	SEGMENT
??_C@_0BF@NEMOFKGI@Component?1ModelInfo?1@ DB 'Component/ModelInfo/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GKEBGDGD@Could?5not?5decode?5actor?5pack@
CONST	SEGMENT
??_C@_0BM@GKEBGDGD@Could?5not?5decode?5actor?5pack@ DB 'Could not decode '
	DB	'actor pack', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DAKEMMDK@ActorCollisionCreator@
CONST	SEGMENT
??_C@_0BG@DAKEMMDK@ActorCollisionCreator@ DB 'ActorCollisionCreator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LHNPHJCH@Could?5not?5open?5CollisionActorPa@
CONST	SEGMENT
??_C@_0EE@LHNPHJCH@Could?5not?5open?5CollisionActorPa@ DB 'Could not open'
	DB	' CollisionActorParent pack, error while decompressing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KLNJNMKE@Pack?1Actor?1@
CONST	SEGMENT
??_C@_0M@KLNJNMKE@Pack?1Actor?1@ DB 'Pack/Actor/', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KPEPEALH@?4pack?4zs@
CONST	SEGMENT
??_C@_08KPEPEALH@?4pack?4zs@ DB '.pack.zs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHJIGDCO@ModelProjectName@
CONST	SEGMENT
??_C@_0BB@GHJIGDCO@ModelProjectName@ DB 'ModelProjectName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PJIJFDMO@FmdbName@
CONST	SEGMENT
??_C@_08PJIJFDMO@FmdbName@ DB 'FmdbName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C@
CONST	SEGMENT
??_C@_01GFHCPBMG@C@ DB 'C', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??$forward@PEAVNode@BymlFile@@@std@@YA$$QEAPEAVNode@BymlFile@@AEAPEAV12@@Z ; std::forward<BymlFile::Node *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@std@@QEAA@PEAVNode@BymlFile@@00@Z ; std::_Vector_val<std::_Simple_types<BymlFile::Node> >::_Vector_val<std::_Simple_types<BymlFile::Node> >
PUBLIC	??$?0V?$allocator@VNode@BymlFile@@@std@@PEAVNode@BymlFile@@PEAV23@PEAV23@@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VNode@BymlFile@@@1@$$QEAPEAVNode@BymlFile@@22@Z ; std::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1>::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1><std::allocator<BymlFile::Node>,BymlFile::Node *,BymlFile::Node *,BymlFile::Node *>
PUBLIC	??$exchange@PEAVNode@BymlFile@@$$T@std@@YAPEAVNode@BymlFile@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<BymlFile::Node *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@VNode@BymlFile@@@std@@@std@@YA$$QEAV?$allocator@VNode@BymlFile@@@0@AEAV10@@Z ; std::move<std::allocator<BymlFile::Node> &>
PUBLIC	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
PUBLIC	??0Node@BymlFile@@QEAA@$$QEAV01@@Z		; BymlFile::Node::Node
PUBLIC	??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Uninitialized_copy<BymlFile::Node *,BymlFile::Node *,std::allocator<BymlFile::Node> >
PUBLIC	??$_Unwrap_sent@PEAVNode@BymlFile@@PEAV12@@ranges@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z ; std::ranges::_Unwrap_sent<BymlFile::Node *,BymlFile::Node *>
PUBLIC	??$_Unwrap_iter@PEAVNode@BymlFile@@PEAV12@@ranges@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z ; std::ranges::_Unwrap_iter<BymlFile::Node *,BymlFile::Node *>
PUBLIC	??$forward@AEBQEAVNode@BymlFile@@@std@@YAAEBQEAVNode@BymlFile@@AEBQEAV12@@Z ; std::forward<BymlFile::Node * const &>
PUBLIC	??$forward@V?$allocator@VNode@BymlFile@@@std@@@std@@YA$$QEAV?$allocator@VNode@BymlFile@@@0@AEAV10@@Z ; std::forward<std::allocator<BymlFile::Node> >
PUBLIC	??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z	; std::construct_at<unsigned char,unsigned char,0>
PUBLIC	??$construct_at@VNode@BymlFile@@V12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@$$QEAV12@@Z ; std::construct_at<BymlFile::Node,BymlFile::Node,0>
PUBLIC	?_Buy_nonzero@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Buy_nonzero
PUBLIC	??1?$_Tidy_guard@V?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > >::~_Tidy_guard<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > >
PUBLIC	??0Entry@SarcFile@@QEAA@AEBU01@@Z		; SarcFile::Entry::Entry
PUBLIC	??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Construct_n<BymlFile::Node * const &,BymlFile::Node * const &>
PUBLIC	??$?0V?$allocator@VNode@BymlFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VNode@BymlFile@@@1@@Z ; std::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1>::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1><std::allocator<BymlFile::Node> >
PUBLIC	??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z	; std::construct_at<unsigned char,unsigned char &,0>
PUBLIC	??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z	; std::construct_at<unsigned char,0>
PUBLIC	??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
PUBLIC	??$forward@E@std@@YA$$QEAEAEAE@Z		; std::forward<unsigned char>
PUBLIC	??$construct@VNode@BymlFile@@V12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@$$QEAV34@@Z ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node>
PUBLIC	??$forward@VNode@BymlFile@@@std@@YA$$QEAVNode@BymlFile@@AEAV12@@Z ; std::forward<BymlFile::Node>
PUBLIC	??$construct_at@VNode@BymlFile@@AEAV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEAV12@@Z ; std::construct_at<BymlFile::Node,BymlFile::Node &,0>
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SA?AV?$allocator@VNode@BymlFile@@@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::select_on_container_copy_construction
PUBLIC	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
PUBLIC	??0Node@BymlFile@@QEAA@AEBV01@@Z		; BymlFile::Node::Node
PUBLIC	??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>
PUBLIC	??$forward@AEAE@std@@YAAEAEAEAE@Z		; std::forward<unsigned char &>
PUBLIC	??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>
PUBLIC	??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>
PUBLIC	??$move@AEAE@std@@YA$$QEAEAEAE@Z		; std::move<unsigned char &>
PUBLIC	??$_Emplace_back@VNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX$$QEAVNode@BymlFile@@@Z ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Emplace_back<BymlFile::Node>
PUBLIC	??$move@AEAVNode@BymlFile@@@std@@YA$$QEAVNode@BymlFile@@AEAV12@@Z ; std::move<BymlFile::Node &>
PUBLIC	??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z ; std::construct_at<BymlFile::Node,BymlFile::Node const &,0>
PUBLIC	??$construct@VNode@BymlFile@@AEAV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEAV34@@Z ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node &>
PUBLIC	??$forward@AEAVNode@BymlFile@@@std@@YAAEAVNode@BymlFile@@AEAV12@@Z ; std::forward<BymlFile::Node &>
PUBLIC	??_GEntry@SarcFile@@QEAAPEAXI@Z			; SarcFile::Entry::`scalar deleting destructor'
PUBLIC	??1Entry@SarcFile@@QEAA@XZ			; SarcFile::Entry::~Entry
PUBLIC	??$destroy_at@UEntry@SarcFile@@@std@@YAXQEAUEntry@SarcFile@@@Z ; std::destroy_at<SarcFile::Entry>
PUBLIC	??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &,0>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$to_address@E@std@@YAPEAEQEAE@Z		; std::to_address<unsigned char>
PUBLIC	??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>
PUBLIC	??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z	; std::_Get_unwrapped<unsigned char * const &>
PUBLIC	??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Uninitialized_move<BymlFile::Node *,std::allocator<BymlFile::Node> >
PUBLIC	??$_Get_unwrapped@AEBQEAVNode@BymlFile@@@std@@YA?A_TAEBQEAVNode@BymlFile@@@Z ; std::_Get_unwrapped<BymlFile::Node * const &>
PUBLIC	??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node const &>
PUBLIC	??$_Emplace_back@AEAVNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEAVNode@BymlFile@@@Z ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Emplace_back<BymlFile::Node &>
PUBLIC	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
PUBLIC	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
PUBLIC	?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Change_array
PUBLIC	?_Orphan_range@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBAXPEAVNode@BymlFile@@0@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Orphan_range
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@PEAUEntry@SarcFile@@AEAV?$allocator@UEntry@SarcFile@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::~_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@PEAVNode@BymlFile@@AEAV?$allocator@VNode@BymlFile@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::~_Uninitialized_backout_al<std::allocator<BymlFile::Node> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::__autoclassinit2
PUBLIC	??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z		; std::_Get_size_of_n<88>
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>
PUBLIC	??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z	; std::construct_at<char,0>
PUBLIC	??$_Unfancy@E@std@@YAPEAEPEAE@Z			; std::_Unfancy<unsigned char>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z ; std::construct_at<char *,char * &,0>
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * &>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$destroy@UEntry@SarcFile@@@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@@Z ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::destroy<SarcFile::Entry>
PUBLIC	??$_Unfancy@UEntry@SarcFile@@@std@@YAPEAUEntry@SarcFile@@PEAU12@@Z ; std::_Unfancy<SarcFile::Entry>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z	; std::_To_address<unsigned char *>
PUBLIC	??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ; std::ranges::_Unwrap_sent<unsigned char *,unsigned char *>
PUBLIC	??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ; std::ranges::_Unwrap_iter<unsigned char *,unsigned char *>
PUBLIC	??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z	; std::forward<unsigned char * const &>
PUBLIC	??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z	; std::forward<unsigned char *>
PUBLIC	??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ; std::forward<std::allocator<unsigned char> >
PUBLIC	??$_Copy_n_unchecked4@PEAE_KPEAE@std@@YAPEAEPEAE_K0@Z ; std::_Copy_n_unchecked4<unsigned char *,unsigned __int64,unsigned char *>
PUBLIC	??$_Copy_memmove_n@PEAEPEAE@std@@YAPEAEPEAE_K0@Z ; std::_Copy_memmove_n<unsigned char *,unsigned char *>
PUBLIC	??$_Uninitialized_copy_n@PEAEV?$allocator@E@std@@@std@@YAPEAEPEAE_K0AEAV?$allocator@E@0@@Z ; std::_Uninitialized_copy_n<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Get_unwrapped@PEAE@std@@YA?A_T$$QEAPEAE@Z	; std::_Get_unwrapped<unsigned char *>
PUBLIC	??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z	; std::move<unsigned char * &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_reallocate<BymlFile::Node const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_back_with_unused_capacity<BymlFile::Node const &>
PUBLIC	??$forward@AEBVNode@BymlFile@@@std@@YAAEBVNode@BymlFile@@AEBV12@@Z ; std::forward<BymlFile::Node const &>
PUBLIC	??$_Copy_n_unchecked4@PEAVNode@BymlFile@@_KPEAV12@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0@Z ; std::_Copy_n_unchecked4<BymlFile::Node *,unsigned __int64,BymlFile::Node *>
PUBLIC	??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Uninitialized_copy_n<BymlFile::Node *,std::allocator<BymlFile::Node> >
PUBLIC	??$_Get_unwrapped@PEAVNode@BymlFile@@@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z ; std::_Get_unwrapped<BymlFile::Node *>
PUBLIC	??$move@AEAPEAVNode@BymlFile@@@std@@YA$$QEAPEAVNode@BymlFile@@AEAPEAV12@@Z ; std::move<BymlFile::Node * &>
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
PUBLIC	??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z	; std::_UIntegral_to_buff<char,unsigned __int64>
PUBLIC	??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
PUBLIC	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z	; std::_UIntegral_to_buff<char,unsigned int>
PUBLIC	?allocate@?$allocator@E@std@@QEAAPEAE_K@Z	; std::allocator<unsigned char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
PUBLIC	?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z ; std::allocator<BymlFile::Node>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SA_KAEBV?$allocator@VNode@BymlFile@@@2@@Z ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::max_size
PUBLIC	?capacity@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEBA_KXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::capacity
PUBLIC	?allocate@?$allocator@UEntry@SarcFile@@@std@@QEAAPEAUEntry@SarcFile@@_K@Z ; std::allocator<SarcFile::Entry>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UEntry@SarcFile@@@2@@Z ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::max_size
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>::operator()
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
PUBLIC	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?max_size@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEBA_KXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::max_size
PUBLIC	?_Calculate_growth@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBA_K_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Xlength
PUBLIC	?max_size@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::max_size
PUBLIC	?_Xlength@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@CAXXZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Xlength
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Clear_and_reserve_geometric
PUBLIC	?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero
PUBLIC	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Clear_and_reserve_geometric
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<BymlFile::Node> >::_Vector_val<std::_Simple_types<BymlFile::Node> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<SarcFile::Entry> >::_Vector_val<std::_Simple_types<SarcFile::Entry> >
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
PUBLIC	??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z		; std::_Get_size_of_n<56>
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
PUBLIC	??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
PUBLIC	??$_Destroy_range@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAXPEAUEntry@SarcFile@@QEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z ; std::_Destroy_range<std::allocator<SarcFile::Entry> >
PUBLIC	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char * const &,unsigned char * const &>
PUBLIC	??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >
PUBLIC	??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>
PUBLIC	??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z ; std::exchange<unsigned char *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ; std::move<std::allocator<unsigned char> &>
PUBLIC	??$_Pocma@V?$allocator@E@std@@@std@@YAXAEAV?$allocator@E@0@0@Z ; std::_Pocma<std::allocator<unsigned char> >
PUBLIC	??$addressof@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPEAV?$vector@EV?$allocator@E@std@@@0@AEAV10@@Z ; std::addressof<std::vector<unsigned char,std::allocator<unsigned char> > >
PUBLIC	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>
PUBLIC	??$_Pocca@V?$allocator@E@std@@@std@@YAXAEAV?$allocator@E@0@AEBV10@@Z ; std::_Pocca<std::allocator<unsigned char> >
PUBLIC	??$addressof@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPEBV?$vector@EV?$allocator@E@std@@@0@AEBV10@@Z ; std::addressof<std::vector<unsigned char,std::allocator<unsigned char> > const >
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z	; std::_Unfancy_maybe_null<unsigned char>
PUBLIC	??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_one_at_back<BymlFile::Node const &>
PUBLIC	??$_Assign_counted_range@PEAVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXPEAVNode@BymlFile@@_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Assign_counted_range<BymlFile::Node *>
PUBLIC	??$_Pocca@V?$allocator@VNode@BymlFile@@@std@@@std@@YAXAEAV?$allocator@VNode@BymlFile@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<BymlFile::Node> >
PUBLIC	??$addressof@$$CBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@YAPEBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > const >
PUBLIC	??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z	; std::_Get_unwrapped<char * &>
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$GetValue@M@Node@BymlFile@@QEAAMXZ		; BymlFile::Node::GetValue<float>
PUBLIC	??$GetValue@_J@Node@BymlFile@@QEAA_JXZ		; BymlFile::Node::GetValue<__int64>
PUBLIC	??$GetValue@H@Node@BymlFile@@QEAAHXZ		; BymlFile::Node::GetValue<int>
PUBLIC	??$GetValue@_K@Node@BymlFile@@QEAA_KXZ		; BymlFile::Node::GetValue<unsigned __int64>
PUBLIC	??$GetValue@I@Node@BymlFile@@QEAAIXZ		; BymlFile::Node::GetValue<unsigned int>
PUBLIC	??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>
PUBLIC	??$_UIntegral_to_string@D_K@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_K@Z ; std::_UIntegral_to_string<char,unsigned __int64>
PUBLIC	??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z ; std::_Integral_to_string<char,__int64>
PUBLIC	??$_UIntegral_to_string@DI@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@I@Z ; std::_UIntegral_to_string<char,unsigned int>
PUBLIC	??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z		; std::end<char,21>
PUBLIC	??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
PUBLIC	?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UEntry@SarcFile@@@2@XZ ; std::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1>::_Get_first
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@VNode@BymlFile@@@2@XZ ; std::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@UEntry@SarcFile@@@std@@QEAAXQEAUEntry@SarcFile@@_K@Z ; std::allocator<SarcFile::Entry>::deallocate
PUBLIC	?_Getal@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UEntry@SarcFile@@@2@XZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UEntry@SarcFile@@@2@XZ ; std::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1>::_Get_first
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NV12@@Z ; std::basic_string_view<char,std::char_traits<char> >::starts_with
PUBLIC	?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NQEBD@Z ; std::basic_string_view<char,std::char_traits<char> >::starts_with
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?_Take_contents@?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAAXAEAV12@@Z ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Take_contents
PUBLIC	?_Getal@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBAAEBV?$allocator@VNode@BymlFile@@@2@XZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Getal
PUBLIC	?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Tidy
PUBLIC	?_Getal@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UEntry@SarcFile@@@2@XZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Getal
PUBLIC	??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD@Z ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
PUBLIC	??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD_K@Z ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??B?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string_view@DU?$char_traits@D@std@@@1@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator std::basic_string_view<char,std::char_traits<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NV?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::starts_with
PUBLIC	?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::starts_with
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
PUBLIC	??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::data
PUBLIC	?_Unchecked_begin@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Unchecked_end
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
PUBLIC	??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
PUBLIC	?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::push_back
PUBLIC	??4?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::operator=
PUBLIC	?_Unchecked_begin@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Unchecked_end
PUBLIC	??1?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::~vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >
PUBLIC	?_Unchecked_begin@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Unchecked_end
PUBLIC	??4Node@BymlFile@@QEAAAEAV01@AEBV01@@Z		; BymlFile::Node::operator=
PUBLIC	?__autoclassinit2@Node@BymlFile@@QEAAX_K@Z	; BymlFile::Node::__autoclassinit2
PUBLIC	?__autoclassinit2@BymlFile@@QEAAX_K@Z		; BymlFile::__autoclassinit2
PUBLIC	?__autoclassinit2@SarcFile@@QEAAX_K@Z		; SarcFile::__autoclassinit2
PUBLIC	??1SarcFile@@QEAA@XZ				; SarcFile::~SarcFile
PUBLIC	??1Result@ZStdFile@@QEAA@XZ			; ZStdFile::Result::~Result
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2
PUBLIC	??$GetValue@_N@Node@BymlFile@@QEAA_NXZ		; BymlFile::Node::GetValue<bool>
PUBLIC	??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; BymlFile::Node::GetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@M@Z ; std::to_string
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z ; std::to_string
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::to_string
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z ; std::to_string
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::to_string
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	_scprintf
PUBLIC	sprintf_s
PUBLIC	_vscprintf_l
PUBLIC	_vsprintf_s_l
PUBLIC	__local_stdio_printf_options
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Node@BymlFile@@QEAA@$$QEAV01@@Z DD imagerel $LN65
	DD	imagerel $LN65+144
	DD	imagerel $unwind$??0Node@BymlFile@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z DD imagerel $LN252
	DD	imagerel $LN252+128
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@VNode@BymlFile@@V12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@$$QEAV12@@Z DD imagerel $LN68
	DD	imagerel $LN68+144
	DD	imagerel $unwind$??$construct_at@VNode@BymlFile@@V12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@$$QEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN10
	DD	imagerel $LN10+71
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Entry@SarcFile@@QEAA@AEBU01@@Z DD imagerel $LN7
	DD	imagerel $LN7+55
	DD	imagerel $unwind$??0Entry@SarcFile@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z DD imagerel $LN112
	DD	imagerel $LN112+195
	DD	imagerel $unwind$??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN123
	DD	imagerel $LN123+252
	DD	imagerel $unwind$??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Node@BymlFile@@QEAA@AEBV01@@Z DD imagerel $LN8
	DD	imagerel $LN8+76
	DD	imagerel $unwind$??0Node@BymlFile@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@VNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX$$QEAVNode@BymlFile@@@Z DD imagerel $LN72
	DD	imagerel $LN72+165
	DD	imagerel $unwind$??$_Emplace_back@VNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX$$QEAVNode@BymlFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z DD imagerel $LN10
	DD	imagerel $LN10+76
	DD	imagerel $unwind$??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GEntry@SarcFile@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??_GEntry@SarcFile@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Entry@SarcFile@@QEAA@XZ DD imagerel $LN39
	DD	imagerel $LN39+97
	DD	imagerel $unwind$??1Entry@SarcFile@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+49
	DD	imagerel $unwind$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z DD imagerel $LN111
	DD	imagerel $LN111+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z DD imagerel $LN111+20
	DD	imagerel $LN111+223
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z DD imagerel $LN111+223
	DD	imagerel $LN111+228
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z DD imagerel $LN12
	DD	imagerel $LN12+84
	DD	imagerel $unwind$??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEAVNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEAVNode@BymlFile@@@Z DD imagerel $LN424
	DD	imagerel $LN424+29
	DD	imagerel $unwind$??$_Emplace_back@AEAVNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEAVNode@BymlFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD imagerel $LN44
	DD	imagerel $LN44+78
	DD	imagerel $unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD imagerel $LN44+78
	DD	imagerel $LN44+177
	DD	imagerel $chain$0$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD imagerel $LN44+177
	DD	imagerel $LN44+183
	DD	imagerel $chain$1$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+132
	DD	imagerel $unwind$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z DD imagerel $LN184
	DD	imagerel $LN184+39
	DD	imagerel $unwind$?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z DD imagerel $LN184+39
	DD	imagerel $LN184+134
	DD	imagerel $chain$0$?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z DD imagerel $LN184+134
	DD	imagerel $LN184+215
	DD	imagerel $chain$1$?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ DD imagerel $LN22
	DD	imagerel $LN22+50
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ DD imagerel $LN188
	DD	imagerel $LN188+68
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+34
	DD	imagerel $unwind$??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD imagerel $LN148
	DD	imagerel $LN148+61
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD imagerel $LN148+61
	DD	imagerel $LN148+373
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD imagerel $LN148+373
	DD	imagerel $LN148+379
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD imagerel $LN148+379
	DD	imagerel $LN148+385
	DD	imagerel $chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+59
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+49
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAE_KPEAE@std@@YAPEAEPEAE_K0@Z DD imagerel $LN16
	DD	imagerel $LN16+45
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAE_KPEAE@std@@YAPEAEPEAE_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_n@PEAEPEAE@std@@YAPEAEPEAE_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+45
	DD	imagerel $unwind$??$_Copy_memmove_n@PEAEPEAE@std@@YAPEAEPEAE_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAEV?$allocator@E@std@@@std@@YAPEAEPEAE_K0AEAV?$allocator@E@0@@Z DD imagerel $LN25
	DD	imagerel $LN25+45
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAEV?$allocator@E@std@@@std@@YAPEAEPEAE_K0AEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+41
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN99
	DD	imagerel $LN99+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN99+34
	DD	imagerel $LN99+237
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN99+237
	DD	imagerel $LN99+243
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN99+243
	DD	imagerel $LN99+249
	DD	imagerel $chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z DD imagerel $LN31
	DD	imagerel $LN31+337
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$3@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA DD imagerel ?catch$3@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA
	DD	imagerel ?catch$3@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA+52
	DD	imagerel $unwind$?catch$3@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z DD imagerel $LN14
	DD	imagerel $LN14+102
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAVNode@BymlFile@@_KPEAV12@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0@Z DD imagerel $LN481
	DD	imagerel $LN481+73
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAVNode@BymlFile@@_KPEAV12@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z DD imagerel $LN252
	DD	imagerel $LN252+129
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD imagerel $LN103
	DD	imagerel $LN103+440
	DD	imagerel $unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+59
	DD	imagerel $unwind$?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD imagerel $LN19
	DD	imagerel $LN19+66
	DD	imagerel $unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD imagerel $LN28
	DD	imagerel $LN28+89
	DD	imagerel $unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+108
	DD	imagerel $unwind$?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UEntry@SarcFile@@@std@@QEAAPEAUEntry@SarcFile@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+108
	DD	imagerel $unwind$?allocate@?$allocator@UEntry@SarcFile@@@std@@QEAAPEAUEntry@SarcFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z DD imagerel $LN39
	DD	imagerel $LN39+86
	DD	imagerel $unwind$??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN82
	DD	imagerel $LN82+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN82+48
	DD	imagerel $LN82+197
	DD	imagerel $chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN82+197
	DD	imagerel $LN82+235
	DD	imagerel $chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD imagerel $LN35
	DD	imagerel $LN35+116
	DD	imagerel $unwind$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$?_Buy_raw@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN11
	DD	imagerel $LN11+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+36
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z DD imagerel $LN77
	DD	imagerel $LN77+281
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD imagerel $LN19
	DD	imagerel $LN19+67
	DD	imagerel $unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+159
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD imagerel $LN7
	DD	imagerel $LN7+34
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN43
	DD	imagerel $LN43+45
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN43+45
	DD	imagerel $LN43+225
	DD	imagerel $chain$0$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN43+225
	DD	imagerel $LN43+232
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN43+232
	DD	imagerel $LN43+238
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN18
	DD	imagerel $LN18+133
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+62
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+34
	DD	imagerel $unwind$??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN25
	DD	imagerel $LN25+89
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD imagerel $LN128
	DD	imagerel $LN128+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD imagerel $LN128+56
	DD	imagerel $LN128+379
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD imagerel $LN128+379
	DD	imagerel $LN128+385
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD imagerel $LN128+385
	DD	imagerel $LN128+391
	DD	imagerel $chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD imagerel $LN89
	DD	imagerel $LN89+43
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD imagerel $LN89+43
	DD	imagerel $LN89+286
	DD	imagerel $chain$1$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD imagerel $LN89+286
	DD	imagerel $LN89+299
	DD	imagerel $chain$3$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD imagerel $LN89+299
	DD	imagerel $LN89+305
	DD	imagerel $chain$4$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN104
	DD	imagerel $LN104+48
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN104+48
	DD	imagerel $LN104+343
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN104+343
	DD	imagerel $LN104+349
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN104+349
	DD	imagerel $LN104+355
	DD	imagerel $chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAXPEAUEntry@SarcFile@@QEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z DD imagerel $LN21
	DD	imagerel $LN21+49
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAXPEAUEntry@SarcFile@@QEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN47
	DD	imagerel $LN47+167
	DD	imagerel $unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN44
	DD	imagerel $LN44+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN44+78
	DD	imagerel $LN44+177
	DD	imagerel $chain$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN44+177
	DD	imagerel $LN44+183
	DD	imagerel $chain$1$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DD imagerel $LN66
	DD	imagerel $LN66+73
	DD	imagerel $unwind$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DD imagerel $LN66+73
	DD	imagerel $LN66+169
	DD	imagerel $chain$0$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DD imagerel $LN66+169
	DD	imagerel $LN66+175
	DD	imagerel $chain$1$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN28
	DD	imagerel $LN28+199
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN39+37
	DD	imagerel $LN39+91
	DD	imagerel $chain$0$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD imagerel $LN39+91
	DD	imagerel $LN39+98
	DD	imagerel $chain$1$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z DD imagerel $LN83
	DD	imagerel $LN83+161
	DD	imagerel $unwind$??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN36
	DD	imagerel $LN36+125
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z DD imagerel $LN17
	DD	imagerel $LN17+134
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXPEAVNode@BymlFile@@_K@Z DD imagerel $LN330
	DD	imagerel $LN330+483
	DD	imagerel $unwind$??$_Assign_counted_range@PEAVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXPEAVNode@BymlFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN105
	DD	imagerel $LN105+461
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+59
	DD	imagerel $unwind$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD imagerel $LN49
	DD	imagerel $LN49+109
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD imagerel $LN23
	DD	imagerel $LN23+99
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD imagerel $LN49
	DD	imagerel $LN49+109
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_UIntegral_to_string@D_K@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+188
	DD	imagerel $unwind$??$_UIntegral_to_string@D_K@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z DD imagerel $LN43
	DD	imagerel $LN43+252
	DD	imagerel $unwind$??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_UIntegral_to_string@DI@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@I@Z DD imagerel $LN32
	DD	imagerel $LN32+172
	DD	imagerel $unwind$??$_UIntegral_to_string@DI@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD imagerel $LN43
	DD	imagerel $LN43+236
	DD	imagerel $unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z DD imagerel $LN25
	DD	imagerel $LN25+33
	DD	imagerel $unwind$?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN33
	DD	imagerel $LN33+23
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD imagerel $LN7
	DD	imagerel $LN7+21
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UEntry@SarcFile@@@std@@QEAAXQEAUEntry@SarcFile@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+63
	DD	imagerel $unwind$?deallocate@?$allocator@UEntry@SarcFile@@@std@@QEAAXQEAUEntry@SarcFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN15
	DD	imagerel $LN15+23
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NV12@@Z DD imagerel $LN8
	DD	imagerel $LN8+42
	DD	imagerel $unwind$?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NQEBD@Z DD imagerel $LN15
	DD	imagerel $LN15+57
	DD	imagerel $unwind$?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN28
	DD	imagerel $LN28+89
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN30
	DD	imagerel $LN30+80
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z DD imagerel $LN29
	DD	imagerel $LN29+72
	DD	imagerel $unwind$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN43
	DD	imagerel $LN43+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN43+35
	DD	imagerel $LN43+98
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN43+98
	DD	imagerel $LN43+128
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z DD imagerel $LN17
	DD	imagerel $LN17+42
	DD	imagerel $unwind$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN130
	DD	imagerel $LN130+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN130+139
	DD	imagerel $LN130+330
	DD	imagerel $chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN130+330
	DD	imagerel $LN130+343
	DD	imagerel $chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN130+343
	DD	imagerel $LN130+349
	DD	imagerel $chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z DD imagerel $LN17
	DD	imagerel $LN17+57
	DD	imagerel $unwind$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ DD imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ DD imagerel $LN47+21
	DD	imagerel $LN47+98
	DD	imagerel $chain$0$?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ DD imagerel $LN47+98
	DD	imagerel $LN47+158
	DD	imagerel $chain$1$?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN64
	DD	imagerel $LN64+209
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN17
	DD	imagerel $LN17+55
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel $LN77
	DD	imagerel $LN77+95
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel $LN77+95
	DD	imagerel $LN77+194
	DD	imagerel $chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel $LN77+194
	DD	imagerel $LN77+200
	DD	imagerel $chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN63
	DD	imagerel $LN63+140
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN14
	DD	imagerel $LN14+42
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD imagerel $LN16
	DD	imagerel $LN16+79
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+53
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN35
	DD	imagerel $LN35+89
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NV?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DD imagerel $LN17
	DD	imagerel $LN17+70
	DD	imagerel $unwind$?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NV?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD imagerel $LN24
	DD	imagerel $LN24+73
	DD	imagerel $unwind$?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN45
	DD	imagerel $LN45+53
	DD	imagerel $unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN45+53
	DD	imagerel $LN45+100
	DD	imagerel $chain$0$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN45+100
	DD	imagerel $LN45+120
	DD	imagerel $chain$1$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+24
	DD	imagerel $LN39+130
	DD	imagerel $chain$0$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+130
	DD	imagerel $LN39+144
	DD	imagerel $chain$1$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+144
	DD	imagerel $LN39+151
	DD	imagerel $chain$2$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+41
	DD	imagerel $unwind$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z DD imagerel $LN38
	DD	imagerel $LN38+125
	DD	imagerel $unwind$?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z DD imagerel $LN19
	DD	imagerel $LN19+127
	DD	imagerel $unwind$?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??4?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4Node@BymlFile@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN24
	DD	imagerel $LN24+135
	DD	imagerel $unwind$??4Node@BymlFile@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Result@ZStdFile@@QEAA@XZ DD imagerel $LN36
	DD	imagerel $LN36+88
	DD	imagerel $unwind$??1Result@ZStdFile@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel $LN553
	DD	imagerel $LN553+1284
	DD	imagerel $unwind$??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@M@Z DD imagerel $LN19
	DD	imagerel $LN19+120
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z DD imagerel $LN15
	DD	imagerel $LN15+108
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD imagerel $LN36
	DD	imagerel $LN36+188
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z DD imagerel $LN47
	DD	imagerel $LN47+252
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z DD imagerel $LN36
	DD	imagerel $LN36+172
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD imagerel $LN47
	DD	imagerel $LN47+236
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+61
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN10
	DD	imagerel $LN10+61
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN16
	DD	imagerel $LN16+67
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN13
	DD	imagerel $LN13+67
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+67
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_scprintf DD imagerel $LN6
	DD	imagerel $LN6+91
	DD	imagerel $unwind$_scprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf_s DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$sprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vscprintf_l DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$_vscprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_s_l DD imagerel $LN4
	DD	imagerel $LN4+101
	DD	imagerel $unwind$_vsprintf_s_l
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_s_l DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vscprintf_l DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf_s DD 051201H
	DD	0700e6212H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_scprintf DD 031a01H
	DD	07016621aH
	DD	03015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z DD 061201H
	DD	036812H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@M@Z DD 060f01H
	DD	03680fH
	DD	0c340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 010H
	DB	0eeH
	DB	00H
	DB	0a8H
	DB	02H
	DB	0a0H
	DB	04H
	DB	'=', 08H
	DB	00H
	DB	0aeH
	DB	04H
	DB	'1', 03H
	DB	06H
	DB	0e4H
	DB	00H
	DB	'Z'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 06H
	DB	0aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0d0H
	DB	062H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DB 028H
	DD	imagerel $stateUnwindMap$??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	imagerel $ip2state$??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0b2c19H
	DD	01f641eH
	DD	01e341eH
	DD	016011eH
	DD	0e010f012H
	DD	0700cc00eH
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	0aaH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Result@ZStdFile@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4Node@BymlFile@@QEAAAEAV01@AEBV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z DB 06H
	DB	'N'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0??push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z
	DD	imagerel $ip2state$?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z DD 060f11H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020021H
	DD	086400H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020521H
	DD	086405H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+53
	DD	imagerel $unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z DD 020521H
	DD	087405H
	DD	imagerel $LN45
	DD	imagerel $LN45+53
	DD	imagerel $unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NV?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 021H
	DD	imagerel $LN77
	DD	imagerel $LN77+95
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 020521H
	DD	0a3405H
	DD	imagerel $LN77
	DD	imagerel $LN77+95
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 040801H
	DD	070043208H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 060d01H
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ DD 020521H
	DD	077405H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN130
	DD	imagerel $LN130+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020021H
	DD	0d6400H
	DD	imagerel $LN130
	DD	imagerel $LN130+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	0d6405H
	DD	imagerel $LN130
	DD	imagerel $LN130+139
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 060c01H
	DD	0f008320cH
	DD	07004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	083405H
	DD	imagerel $LN43
	DD	imagerel $LN43+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NQEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NV12@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UEntry@SarcFile@@@std@@QEAAXQEAUEntry@SarcFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_UIntegral_to_string@DI@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@I@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_UIntegral_to_string@D_K@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_K@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0cH
	DB	0d6H
	DB	00H
	DB	'\'
	DB	02H
	DB	0baH
	DB	06H
	DB	0deH
	DB	04H
	DB	'L'
	DB	00H
	DB	'R'
	DB	0aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	09dH, 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0aH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 081619H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXPEAVNode@BymlFile@@_K@Z DD 081001H
	DD	0d3410H
	DD	0f00c3210H
	DD	07008e00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z DB 06H
	DB	'N'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z
	DD	imagerel $ip2state$??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z DD 060f11H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z DD 075201H
	DD	045452H
	DD	0e006420aH
	DD	060037004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 020521H
	DD	057405H
	DD	imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z DD 040d01H
	DD	0e009520dH
	DD	030066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+73
	DD	imagerel $unwind$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DD 020521H
	DD	093405H
	DD	imagerel $LN66
	DD	imagerel $LN66+73
	DD	imagerel $unwind$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DD 040801H
	DD	070043208H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 020521H
	DD	043405H
	DD	imagerel $LN44
	DD	imagerel $LN44+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 050a01H
	DD	0e006420aH
	DD	060037004H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 060c01H
	DD	0b340cH
	DD	07008320cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAXPEAUEntry@SarcFile@@QEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 021H
	DD	imagerel $LN104
	DD	imagerel $LN104+48
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 060021H
	DD	04c400H
	DD	0c7400H
	DD	0b5400H
	DD	imagerel $LN104
	DD	imagerel $LN104+48
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 064521H
	DD	0c7445H
	DD	04c40eH
	DD	0b5405H
	DD	imagerel $LN104
	DD	imagerel $LN104+48
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 050b01H
	DD	0f007420bH
	DD	06003e005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD 021H
	DD	imagerel $LN89
	DD	imagerel $LN89+43
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD 040021H
	DD	045400H
	DD	0c3400H
	DD	imagerel $LN89
	DD	imagerel $LN89+43
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD 043521H
	DD	0c3435H
	DD	045405H
	DD	imagerel $LN89
	DD	imagerel $LN89+43
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z DD 050b01H
	DD	0f007420bH
	DD	07003e005H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD 021H
	DD	imagerel $LN128
	DD	imagerel $LN128+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD 060021H
	DD	04e400H
	DD	057400H
	DD	0e5400H
	DD	imagerel $LN128
	DD	imagerel $LN128+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD 064521H
	DD	057445H
	DD	04e411H
	DD	0e5405H
	DD	imagerel $LN128
	DD	imagerel $LN128+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD 060d01H
	DD	0f009520dH
	DD	0c005d007H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'h'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 04H
	DB	'X'
	DB	00H
	DB	'\'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0cH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+45
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD 020021H
	DD	086400H
	DD	imagerel $LN43
	DD	imagerel $LN43+45
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	086405H
	DD	imagerel $LN43
	DD	imagerel $LN43+45
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z DD 0a1401H
	DD	0d3414H
	DD	0f0103214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 021H
	DD	imagerel $LN82
	DD	imagerel $LN82+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 041521H
	DD	096415H
	DD	083405H
	DD	imagerel $LN82
	DD	imagerel $LN82+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 061001H
	DD	0be410H
	DD	0a7410H
	DD	0f00c5210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UEntry@SarcFile@@@std@@QEAAPEAUEntry@SarcFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 0cH
	DB	0aeH
	DB	00H
	DB	'\'
	DB	02H
	DB	0aeH
	DB	06H
	DB	0eaH
	DB	04H
	DB	'L'
	DB	00H
	DB	'P'
	DB	0aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DB	'M', 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 0aH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 081619H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z DB 04H
	DB	092H
	DB	02H
	DB	'F'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z DD 061e19H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAVNode@BymlFile@@_KPEAV12@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z DB 06H
	DB	'B'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z
	DD	imagerel $ip2state$??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z DD 060f11H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$3@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z DB 0aH
	DB	'm', 02H
	DB	00H
	DB	'`'
	DB	02H
	DB	','
	DB	04H
	DB	01cH
	DB	06H
	DB	0b8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$3@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z DB 02H
	DB	00H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z DB 08H
	DB	08H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	050H
	DB	036H
	DD	imagerel ?dtor$1@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA
	DB	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z DD 081019H
	DD	0f00c5210H
	DD	0d008e00aH
	DD	07004c006H
	DD	030026003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040021H
	DD	0b7400H
	DD	0a5400H
	DD	imagerel $LN99
	DD	imagerel $LN99+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN99
	DD	imagerel $LN99+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 041e21H
	DD	0b741eH
	DD	0a5405H
	DD	imagerel $LN99
	DD	imagerel $LN99+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040901H
	DD	0e0053209H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAEV?$allocator@E@std@@@std@@YAPEAEPEAE_K0AEAV?$allocator@E@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_n@PEAEPEAE@std@@YAPEAEPEAE_K0@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAE_KPEAE@std@@YAPEAEPEAE_K0@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD 021H
	DD	imagerel $LN148
	DD	imagerel $LN148+61
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD 060021H
	DD	04f400H
	DD	057400H
	DD	0e5400H
	DD	imagerel $LN148
	DD	imagerel $LN148+61
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD 064521H
	DD	057445H
	DD	04f40eH
	DD	0e5405H
	DD	imagerel $LN148
	DD	imagerel $LN148+61
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD 060d01H
	DD	0e009520dH
	DD	0c005d007H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z DD 021H
	DD	imagerel $LN184
	DD	imagerel $LN184+39
	DD	imagerel $unwind$?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z DD 020521H
	DD	096405H
	DD	imagerel $LN184
	DD	imagerel $LN184+39
	DD	imagerel $unwind$?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0700be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+78
	DD	imagerel $unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD 020521H
	DD	043405H
	DD	imagerel $LN44
	DD	imagerel $LN44+78
	DD	imagerel $unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD 050a01H
	DD	0e006420aH
	DD	060037004H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEAVNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEAVNode@BymlFile@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z DB 06H
	DB	'@'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z
	DD	imagerel $ip2state$??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z DD 021H
	DD	imagerel $LN111
	DD	imagerel $LN111+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z DD 020521H
	DD	037405H
	DD	imagerel $LN111
	DD	imagerel $LN111+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Entry@SarcFile@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GEntry@SarcFile@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z DB 06H
	DB	'*'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z
	DD	imagerel $ip2state$??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z DD 040a11H
	DD	07340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@VNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX$$QEAVNode@BymlFile@@@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Node@BymlFile@@QEAA@AEBV01@@Z DB 06H
	DB	'*'
	DB	00H
	DB	'*'
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Node@BymlFile@@QEAA@AEBV01@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$1@?0???0Node@BymlFile@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0Node@BymlFile@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0Node@BymlFile@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0Node@BymlFile@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Node@BymlFile@@QEAA@AEBV01@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0Node@BymlFile@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z DB 06H
	DB	0d0H
	DB	00H
	DB	09cH
	DB	04H
	DB	'L'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z DD 082119H
	DD	0115412H
	DD	0103412H
	DD	0e00e9212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z DB 06H
	DB	084H
	DB	00H
	DB	08eH
	DB	04H
	DB	'F'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z
	DD	imagerel $ip2state$??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z DD 062319H
	DD	0f0109214H
	DD	0700ce00eH
	DD	0300a600bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Entry@SarcFile@@QEAA@AEBU01@@Z DB 04H
	DB	'*'
	DB	00H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Entry@SarcFile@@QEAA@AEBU01@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0Entry@SarcFile@@QEAA@AEBU01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0Entry@SarcFile@@QEAA@AEBU01@@Z
	DD	imagerel $ip2state$??0Entry@SarcFile@@QEAA@AEBU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Entry@SarcFile@@QEAA@AEBU01@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0Entry@SarcFile@@QEAA@AEBU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@VNode@BymlFile@@V12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@$$QEAV12@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z DB 04H
	DB	092H
	DB	02H
	DB	'D'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z DD 061e19H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Node@BymlFile@@QEAA@$$QEAV01@@Z DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsprintf_s_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vsprintf_s_l PROC					; COMDAT

; 1490 :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

	call	__local_stdio_printf_options
	mov	r10, QWORD PTR _ArgList$[rsp]
	mov	r9, rdi
	mov	QWORD PTR [rsp+40], r10
	mov	r8, rsi
	mov	rdx, rbp
	mov	QWORD PTR [rsp+32], rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vsprintf_s

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;
; 1496 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vscprintf_l
_TEXT	SEGMENT
_Format$ = 64
_Locale$dead$ = 72
_ArgList$ = 80
_vscprintf_l PROC					; COMDAT

; 1651 :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r8
	mov	rdi, rcx

; 1652 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rdi
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], 0
	xor	edx, edx
	mov	rcx, QWORD PTR [rax]
	or	rcx, 2
	call	QWORD PTR __imp___stdio_common_vsprintf

; 1653 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1654 :             NULL, 0, _Format, _Locale, _ArgList);
; 1655 : 
; 1656 :         return _Result < 0 ? -1 : _Result;
; 1657 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	ecx, -1
	test	eax, eax
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vscprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT sprintf_s
_TEXT	SEGMENT
_Buffer$ = 96
_BufferCount$ = 104
_Format$ = 112
sprintf_s PROC						; COMDAT

; 1823 :         {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H
	mov	rsi, r8

; 1824 :             int _Result;
; 1825 :             va_list _ArgList;
; 1826 :             __crt_va_start(_ArgList, _Format);

	lea	rbp, QWORD PTR _Format$[rsp+8]
	mov	rdi, rdx
	mov	rbx, rcx

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbp
	mov	r9, rsi
	mov	r8, rdi
	mov	QWORD PTR [rsp+32], 0
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vsprintf_s

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

	test	eax, eax
	mov	ecx, -1
	cmovs	eax, ecx

; 1827 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1828 :             __crt_va_end(_ArgList);
; 1829 :             return _Result;
; 1830 :         }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _scprintf
_TEXT	SEGMENT
_Format$ = 80
_scprintf PROC						; COMDAT

; 2083 :     {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rdi
	sub	rsp, 56					; 00000038H
	mov	rbx, rcx

; 2084 :         int _Result;
; 2085 :         va_list _ArgList;
; 2086 :         __crt_va_start(_ArgList, _Format);

	lea	rdi, QWORD PTR _Format$[rsp+8]

; 1652 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rdi
	mov	r9, rbx
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], 0
	xor	edx, edx
	mov	rcx, QWORD PTR [rax]
	or	rcx, 2
	call	QWORD PTR __imp___stdio_common_vsprintf

; 1653 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1654 :             NULL, 0, _Format, _Locale, _ArgList);
; 1655 : 
; 1656 :         return _Result < 0 ? -1 : _Result;

	test	eax, eax
	mov	ecx, -1
	cmovs	eax, ecx

; 2087 :         _Result = _vscprintf_l(_Format, NULL, _ArgList);
; 2088 :         __crt_va_end(_ArgList);
; 2089 :         return _Result;
; 2090 :     }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rbx
	ret	0
_scprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 650  :         return LLONG_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 651  :     }

	ret	0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
__formal$ = 24
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 67   :         _Data._What = _Message;
; 68   :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0
	lea	rdx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy

; 74   :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rdx, QWORD PTR [rcx+8]
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	test	rdx, rdx
	cmovne	rax, rdx

; 96   :     }

	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN6@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN6@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 130  :     {

	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@

; 65   :         : _Data()

	mov	QWORD PTR [rcx+16], 0

; 130  :     {

	mov	QWORD PTR [rcx], rax

; 131  :     }

	mov	rax, rcx

; 67   :         _Data._What = _Message;

	mov	QWORD PTR [rcx+8], rdx

; 131  :     }

	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN9@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN9@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 67   :         _Data._What = _Message;

	lea	rax, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rax

; 141  :     {

	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rcx], rax

; 142  :     }

	mov	rax, rcx
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN12@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN12@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 331  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN4:
	sub	rsp, 72					; 00000048H

; 332  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN3@Throw_bad_:
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 72   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 71   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]

; 72   :     {

	mov	QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 72   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 71   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]

; 72   :     {

	mov	QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 8
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1169 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1170 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1434 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	rax, rcx
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1437 :     _CONSTEXPR20 void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2311 : [[noreturn]] inline void _Xlen_string() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2312 :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen_strin:
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
_Buff$1 = 48
__$ArrayPad$ = 72
__$ReturnUdt$ = 96
_Val$ = 104
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z PROC ; std::to_string, COMDAT

; 504  : _EXPORT_STD _NODISCARD inline string to_string(int _Val) {

$LN47:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	xor	r10d, r10d
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 482  :     if (_Val < 0) {

	lea	r9, QWORD PTR _Buff$1[rsp+21]

; 504  : _EXPORT_STD _NODISCARD inline string to_string(int _Val) {

	mov	r8d, edx
	mov	rbx, rcx

; 482  :     if (_Val < 0) {

	test	edx, edx
	jns	SHORT $LL19@to_string

; 447  :     auto _UVal_trunc = _UVal;

	neg	r8d
	npad	1
$LL14@to_string:

; 448  : #else // ^^^ _WIN64 / !_WIN64 vvv
; 449  : 
; 450  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 451  :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 452  :         while (_UVal > 0xFFFFFFFFU) {
; 453  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 454  :             _UVal /= 1000000000;
; 455  : 
; 456  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 457  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 458  :                 _UVal_chunk /= 10;
; 459  :             }
; 460  :         }
; 461  :     }
; 462  : 
; 463  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 464  : #endif // _WIN64
; 465  : 
; 466  :     do {
; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 469  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL14@to_string

; 484  :         *--_RNext = '-';

	dec	r9
	mov	BYTE PTR [r9], 45			; 0000002dH

; 485  :     } else {

	jmp	SHORT $LN7@to_string
	npad	13
$LL19@to_string:

; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 469  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL19@to_string
$LN7@to_string:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2574 :         if (_UFirst == _ULast) {

	lea	rax, QWORD PTR _Buff$1[rsp+21]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], r10

; 2574 :         if (_UFirst == _ULast) {

	cmp	r9, rax
	jne	SHORT $LN22@to_string

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r10

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r10b

; 2577 :         } else {

	jmp	SHORT $LN44@to_string
$LN22@to_string:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$1[rsp+21]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, rbx
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN44@to_string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 506  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
_Buff$1 = 48
__$ArrayPad$ = 72
__$ReturnUdt$ = 96
_Val$ = 104
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z PROC ; std::to_string, COMDAT

; 508  : _EXPORT_STD _NODISCARD inline string to_string(unsigned int _Val) {

$LN36:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r8d, edx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	rbx, rcx

; 500  :     _Elem* const _RNext    = _UIntegral_to_buff(_Buff_end, _Val);

	lea	r9, QWORD PTR _Buff$1[rsp+21]

; 508  : _EXPORT_STD _NODISCARD inline string to_string(unsigned int _Val) {

	xor	r10d, r10d
	npad	8
$LL12@to_string:

; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 469  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL12@to_string
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2574 :         if (_UFirst == _ULast) {

	lea	rax, QWORD PTR _Buff$1[rsp+21]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], r10

; 2574 :         if (_UFirst == _ULast) {

	cmp	r9, rax
	jne	SHORT $LN15@to_string

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r10

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r10b

; 2577 :         } else {

	jmp	SHORT $LN33@to_string
$LN15@to_string:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$1[rsp+21]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, rbx
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN33@to_string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 510  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
_Buff$1 = 48
__$ArrayPad$ = 72
__$ReturnUdt$ = 96
_Val$ = 104
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z PROC ; std::to_string, COMDAT

; 520  : _EXPORT_STD _NODISCARD inline string to_string(long long _Val) {

$LN47:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	xor	r11d, r11d
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 482  :     if (_Val < 0) {

	lea	r9, QWORD PTR _Buff$1[rsp+21]

; 520  : _EXPORT_STD _NODISCARD inline string to_string(long long _Val) {

	mov	r8, rdx
	mov	rbx, rcx

; 482  :     if (_Val < 0) {

	mov	r10, -3689348814741910323		; cccccccccccccccdH
	test	rdx, rdx
	jns	SHORT $LL19@to_string

; 447  :     auto _UVal_trunc = _UVal;

	neg	r8
	npad	6
$LL14@to_string:

; 448  : #else // ^^^ _WIN64 / !_WIN64 vvv
; 449  : 
; 450  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 451  :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 452  :         while (_UVal > 0xFFFFFFFFU) {
; 453  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 454  :             _UVal /= 1000000000;
; 455  : 
; 456  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 457  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 458  :                 _UVal_chunk /= 10;
; 459  :             }
; 460  :         }
; 461  :     }
; 462  : 
; 463  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 464  : #endif // _WIN64
; 465  : 
; 466  :     do {
; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	rax, r10
	mul	r8
	shr	rdx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8, rdx

; 469  :     } while (_UVal_trunc != 0);

	test	rdx, rdx
	jne	SHORT $LL14@to_string

; 484  :         *--_RNext = '-';

	dec	r9
	mov	BYTE PTR [r9], 45			; 0000002dH

; 485  :     } else {

	jmp	SHORT $LN7@to_string
	npad	13
$LL19@to_string:

; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	rax, r10
	mul	r8
	shr	rdx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8, rdx

; 469  :     } while (_UVal_trunc != 0);

	test	rdx, rdx
	jne	SHORT $LL19@to_string
$LN7@to_string:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2574 :         if (_UFirst == _ULast) {

	lea	rax, QWORD PTR _Buff$1[rsp+21]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], r11

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], r11

; 2574 :         if (_UFirst == _ULast) {

	cmp	r9, rax
	jne	SHORT $LN22@to_string

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r11

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r11b

; 2577 :         } else {

	jmp	SHORT $LN44@to_string
$LN22@to_string:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$1[rsp+21]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, rbx
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN44@to_string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 522  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
_Buff$1 = 48
__$ArrayPad$ = 72
__$ReturnUdt$ = 96
_Val$ = 104
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z PROC ; std::to_string, COMDAT

; 524  : _EXPORT_STD _NODISCARD inline string to_string(unsigned long long _Val) {

$LN36:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r8, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	rbx, rcx

; 500  :     _Elem* const _RNext    = _UIntegral_to_buff(_Buff_end, _Val);

	lea	r9, QWORD PTR _Buff$1[rsp+21]

; 524  : _EXPORT_STD _NODISCARD inline string to_string(unsigned long long _Val) {

	xor	r10d, r10d

; 447  :     auto _UVal_trunc = _UVal;

	mov	r11, -3689348814741910323		; cccccccccccccccdH
	npad	14
$LL12@to_string:

; 448  : #else // ^^^ _WIN64 / !_WIN64 vvv
; 449  : 
; 450  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 451  :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 452  :         while (_UVal > 0xFFFFFFFFU) {
; 453  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 454  :             _UVal /= 1000000000;
; 455  : 
; 456  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 457  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 458  :                 _UVal_chunk /= 10;
; 459  :             }
; 460  :         }
; 461  :     }
; 462  : 
; 463  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 464  : #endif // _WIN64
; 465  : 
; 466  :     do {
; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	rax, r11
	mul	r8
	shr	rdx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8, rdx

; 469  :     } while (_UVal_trunc != 0);

	test	rdx, rdx
	jne	SHORT $LL12@to_string
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2574 :         if (_UFirst == _ULast) {

	lea	rax, QWORD PTR _Buff$1[rsp+21]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], r10

; 2574 :         if (_UFirst == _ULast) {

	cmp	r9, rax
	jne	SHORT $LN15@to_string

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r10

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r10b

; 2577 :         } else {

	jmp	SHORT $LN33@to_string
$LN15@to_string:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$1[rsp+21]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, rbx
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN33@to_string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 526  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 80
_Val$ = 88
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z PROC ; std::to_string, COMDAT

; 528  : _EXPORT_STD _NODISCARD inline string to_string(double _Val) {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rbx, rcx
	movaps	XMMWORD PTR [rsp+48], xmm6

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	movq	rdx, xmm1
	movaps	xmm6, xmm1
	call	_scprintf
	movsxd	rdi, eax

; 530  :     string _Str(_Len, '\0');

	mov	rcx, rbx
	mov	rdx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@to_string

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN8@to_string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rdi+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s

; 532  :     return _Str;
; 533  : }

	movaps	xmm6, XMMWORD PTR [rsp+48]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@M@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 80
_Val$ = 88
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@M@Z PROC ; std::to_string, COMDAT

; 535  : _EXPORT_STD _NODISCARD inline string to_string(float _Val) {

$LN19:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	movaps	XMMWORD PTR [rsp+48], xmm6
	mov	rbx, rcx

; 536  :     return _STD to_string(static_cast<double>(_Val));

	xorps	xmm6, xmm6
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	cvtss2sd xmm6, xmm1

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	movaps	xmm1, xmm6
	movq	rdx, xmm6
	call	_scprintf
	movsxd	rdi, eax

; 530  :     string _Str(_Len, '\0');

	mov	rcx, rbx
	mov	rdx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@to_string

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN12@to_string:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rdi+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s

; 537  : }

	movaps	xmm6, XMMWORD PTR [rsp+48]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@M@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
;	COMDAT ??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
Value$8 = 64
__$ReturnUdt$GSCopy$ = 64
Input$ = 80
Number$9 = 104
Result$ = 136
__$ArrayPad$ = 168
this$ = 224
__$ReturnUdt$ = 232
??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; BymlFile::Node::GetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 57   :         {

$LN553:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 176				; 000000b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-121], rax
	mov	r15, rdx
	mov	r14, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-121], rdx
	xor	r12d, r12d
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Input$[rbp-121], xmm1
	mov	QWORD PTR Input$[rbp-105], r12

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [rcx+8]
	sub	rbx, QWORD PTR [rcx]

; 2065 :         if (_Count != 0) {

	je	SHORT $LN540@GetValue

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rbx, rax
	ja	$LN550@GetValue
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN140@GetValue

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN551@GetValue

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN43@GetValue

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN138@GetValue
$LN140@GetValue:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN138@GetValue:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR Input$[rbp-121], rdi

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR Input$[rbp-113], rdi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rdi+rbx]
	mov	QWORD PTR Input$[rbp-105], rax

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [r14+8]
	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR Input$[rbp-113], rax
$LN540@GetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 60   :             if (this->m_Type != BymlFile::Type::StringIndex)

	movzx	eax, BYTE PTR [r14+24]
	mov	esi, 15
	cmp	al, 160					; 000000a0H
	je	$LN542@GetValue
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Number$9[rbp-121], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	rdi, r12
	mov	QWORD PTR Number$9[rbp-105], r12

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Number$9[rbp-97], rsi

; 2631 : 
; 2632 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2633 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2635 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2636 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR Number$9[rbp-121], dil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 63   :                 switch (this->m_Type)

	add	eax, -208				; ffffffffffffff30H
	cmp	eax, 5
	ja	SHORT $LN2@GetValue
	cdqe
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN539@GetValue[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN8@GetValue:

; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [r14]

; 64   :                 {
; 65   :                 case BymlFile::Type::UInt32:
; 66   :                     Number = std::to_string(this->GetValue<uint32_t>());

	mov	edx, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T7[rbp-121]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::to_string
	mov	rdx, rax
	lea	rcx, QWORD PTR Number$9[rbp-121]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T7[rbp-97]
	cmp	rdx, 16
	jb	SHORT $LN541@GetValue

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T7[rbp-121]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN324@GetValue

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN324@GetValue
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN324@GetValue:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN541@GetValue:
	mov	rdi, QWORD PTR Number$9[rbp-105]
$LN2@GetValue:
	mov	rdx, QWORD PTR Input$[rbp-113]
	mov	rcx, QWORD PTR Input$[rbp-121]
	sub	rdx, rcx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdi, rdx
	jae	$LN238@GetValue

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdi+rcx]
	mov	QWORD PTR Input$[rbp-113], rax

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;

	jmp	$LN239@GetValue
$LN9@GetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [r14]

; 67   :                     break;
; 68   :                 case BymlFile::Type::UInt64:
; 69   :                     Number = std::to_string(this->GetValue<uint64_t>());

	mov	rdx, QWORD PTR [rax]
	lea	rcx, QWORD PTR $T6[rbp-121]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::to_string
	mov	rdx, rax
	lea	rcx, QWORD PTR Number$9[rbp-121]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T6[rbp-97]
	cmp	rdx, 16
	jb	SHORT $LN541@GetValue

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T6[rbp-121]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN324@GetValue

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN324@GetValue
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@GetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [r14]

; 70   :                     break;
; 71   :                 case BymlFile::Type::Int32:
; 72   :                     Number = std::to_string(this->GetValue<int32_t>());

	mov	edx, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T5[rbp-121]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	mov	rdx, rax
	lea	rcx, QWORD PTR Number$9[rbp-121]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T5[rbp-97]
	cmp	rdx, 16
	jb	$LN541@GetValue

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T5[rbp-121]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	$LN324@GetValue

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN324@GetValue
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@GetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [r14]

; 73   :                     break;
; 74   :                 case BymlFile::Type::Int64:
; 75   :                     Number = std::to_string(this->GetValue<int64_t>());

	mov	rdx, QWORD PTR [rax]
	lea	rcx, QWORD PTR $T4[rbp-121]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_J@Z ; std::to_string
	mov	rdx, rax
	lea	rcx, QWORD PTR Number$9[rbp-121]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T4[rbp-97]
	cmp	rdx, 16
	jb	$LN541@GetValue

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T4[rbp-121]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	$LN324@GetValue

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN324@GetValue
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN12@GetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [r14]
	mov	ecx, DWORD PTR [rax]
	mov	DWORD PTR Value$8[rbp-121], ecx

; 76   :                     break;
; 77   :                 case BymlFile::Type::Float:
; 78   :                     Number = std::to_string(this->GetValue<float>());

	movss	xmm1, DWORD PTR Value$8[rbp-121]
	lea	rcx, QWORD PTR $T3[rbp-121]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@M@Z ; std::to_string
	mov	rdx, rax
	lea	rcx, QWORD PTR Number$9[rbp-121]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T3[rbp-97]
	cmp	rdx, 16
	jb	$LN541@GetValue

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T3[rbp-121]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	$LN324@GetValue

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN324@GetValue
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN13@GetValue:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 81   :                     return this->GetValue<bool>() ? "true" : "false";

	lea	rcx, OFFSET FLAT:??_C@_04LOAJBDKD@true@
	lea	rdx, OFFSET FLAT:??_C@_05LAPONLG@false@
	cmp	BYTE PTR [rax], 0
	cmovne	rdx, rcx
	mov	rcx, r15
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Input$[rbp-121]
	test	rcx, rcx
	je	$LN34@GetValue

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Input$[rbp-105]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	$LN412@GetValue

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN43@GetValue
	jmp	$LN412@GetValue
$LN238@GetValue:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN239@GetValue

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR Input$[rbp-105]
	sub	rax, rcx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdi, rax
	jbe	SHORT $LN240@GetValue

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rdi
	lea	rcx, QWORD PTR Input$[rbp-121]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN548@GetValue
$LN240@GetValue:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	r8, rdi
	sub	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	mov	rcx, QWORD PTR Input$[rbp-113]
	lea	rbx, QWORD PTR [rcx+r8]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR Input$[rbp-113], rbx
$LN548@GetValue:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rcx, QWORD PTR Input$[rbp-121]
$LN239@GetValue:
	lea	rdx, QWORD PTR Number$9[rbp-121]

; 2227 :         if (_Large_string_engaged()) {

	mov	rbx, QWORD PTR Number$9[rbp-121]
	mov	r14, QWORD PTR Number$9[rbp-97]
	cmp	r14, 16
	cmovae	rdx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 85   :                 memcpy(Input.data(), Number.data(), Number.length());

	mov	r8, rdi
	call	memcpy
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	r14, 16
	jb	SHORT $LN542@GetValue

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [r14+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rbx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN293@GetValue

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rbx, QWORD PTR [rbx-8]
	sub	rax, rbx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN293@GetValue
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN293@GetValue:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN542@GetValue:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Result$[rbp-121], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	rcx, r12
	mov	QWORD PTR Result$[rbp-105], rcx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Result$[rbp-97], rsi

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Result$[rbp-121], cl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 89   :             for (char Character : Input)

	mov	rdi, QWORD PTR Input$[rbp-113]
	mov	rbx, QWORD PTR Input$[rbp-121]
	cmp	rbx, rdi
	je	SHORT $LN5@GetValue
	npad	2
$LL6@GetValue:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3236 :         push_back(_Ch);

	movzx	r9d, BYTE PTR [rbx]

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	cmp	rcx, rsi

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN55@GetValue

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR Result$[rbp-105], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Result$[rbp-121]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	cmovae	rax, QWORD PTR Result$[rbp-121]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 4053 :             return;

	jmp	SHORT $LN4@GetValue
$LN55@GetValue:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR Result$[rbp-121]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN4@GetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 89   :             for (char Character : Input)

	inc	rbx
	cmp	rbx, rdi
	je	SHORT $LN546@GetValue
	mov	rsi, QWORD PTR Result$[rbp-97]
	mov	rcx, QWORD PTR Result$[rbp-105]
	jmp	SHORT $LL6@GetValue
$LN546@GetValue:
	mov	rbx, QWORD PTR Input$[rbp-121]
$LN5@GetValue:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR Result$[rbp-121]
	movups	XMMWORD PTR [r15], xmm0
	movups	xmm1, XMMWORD PTR Result$[rbp-105]
	movups	XMMWORD PTR [r15+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN34@GetValue

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Input$[rbp-105]
	sub	rdx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rbx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN46@GetValue

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rbx, QWORD PTR [rbx-8]
	sub	rax, rbx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN46@GetValue
$LN43@GetValue:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@GetValue:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
$LN412@GetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 93   :             return Result;

	call	??3@YAXPEAX_K@Z				; operator delete
$LN34@GetValue:
	mov	rax, r15

; 94   :         }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-121]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN551@GetValue:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN550@GetValue:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN547@GetValue:
$LN539@GetValue:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 94   :         }

	DD	$LN13@GetValue
	DD	$LN10@GetValue
	DD	$LN12@GetValue
	DD	$LN8@GetValue
	DD	$LN11@GetValue
	DD	$LN9@GetValue
??$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; BymlFile::Node::GetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
Value$8 = 64
__$ReturnUdt$GSCopy$ = 64
Input$ = 80
Number$9 = 104
Result$ = 136
__$ArrayPad$ = 168
this$ = 224
__$ReturnUdt$ = 232
?dtor$0@?0???$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `BymlFile::Node::GetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
	lea	rcx, QWORD PTR Input$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `BymlFile::Node::GetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
Value$8 = 64
__$ReturnUdt$GSCopy$ = 64
Input$ = 80
Number$9 = 104
Result$ = 136
__$ArrayPad$ = 168
this$ = 224
__$ReturnUdt$ = 232
?dtor$1@?0???$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `BymlFile::Node::GetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$1
	lea	rcx, QWORD PTR Number$9[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `BymlFile::Node::GetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
Value$8 = 64
__$ReturnUdt$GSCopy$ = 64
Input$ = 80
Number$9 = 104
Result$ = 136
__$ArrayPad$ = 168
this$ = 224
__$ReturnUdt$ = 232
?dtor$8@?0???$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `BymlFile::Node::GetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$8
	lea	rcx, QWORD PTR Result$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0???$GetValue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Node@BymlFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `BymlFile::Node::GetValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
;	COMDAT ??$GetValue@_N@Node@BymlFile@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 8
??$GetValue@_N@Node@BymlFile@@QEAA_NXZ PROC		; BymlFile::Node::GetValue<bool>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h

; 98   :             return this->m_Value[0];

	cmp	BYTE PTR [rax], 0
	setne	al

; 99   :         }

	ret	0
??$GetValue@_N@Node@BymlFile@@QEAA_NXZ ENDP		; BymlFile::Node::GetValue<bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 46   :     // return larger of _Left and _Right
; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 48   : }

	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1Result@ZStdFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Result@ZStdFile@@QEAA@XZ PROC			; ZStdFile::Result::~Result, COMDAT
$LN36:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN6@Result

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@Result

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@Result

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@Result:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN6@Result:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@Result:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN33@Result:
??1Result@ZStdFile@@QEAA@XZ ENDP			; ZStdFile::Result::~Result
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1SarcFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1SarcFile@@QEAA@XZ PROC				; SarcFile::~SarcFile, COMDAT
	add	rcx, 8

; 767  :         _Tidy();

	jmp	?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Tidy
??1SarcFile@@QEAA@XZ ENDP				; SarcFile::~SarcFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@SarcFile@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@SarcFile@@QEAAX_K@Z PROC		; SarcFile::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	ret	0
?__autoclassinit2@SarcFile@@QEAAX_K@Z ENDP		; SarcFile::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@BymlFile@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@BymlFile@@QEAAX_K@Z PROC		; BymlFile::__autoclassinit2, COMDAT
	xor	edx, edx
	mov	r8d, 224				; 000000e0H
	jmp	memset
?__autoclassinit2@BymlFile@@QEAAX_K@Z ENDP		; BymlFile::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@Node@BymlFile@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@Node@BymlFile@@QEAAX_K@Z PROC		; BymlFile::Node::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	mov	QWORD PTR [rcx+80], rax
	ret	0
?__autoclassinit2@Node@BymlFile@@QEAAX_K@Z ENDP		; BymlFile::Node::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4Node@BymlFile@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4Node@BymlFile@@QEAAAEAV01@AEBV01@@Z PROC		; BymlFile::Node::operator=, COMDAT
$LN24:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN3@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rdi+8]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>
$LN3@operator:
	movzx	eax, BYTE PTR [rdi+24]
	lea	rdx, QWORD PTR [rdi+32]
	lea	rcx, QWORD PTR [rbx+32]
	mov	BYTE PTR [rbx+24], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN6@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN10@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN6@operator:
	lea	r8, QWORD PTR [rdi+64]
	lea	rcx, QWORD PTR [rbx+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN17@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	rax, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXPEAVNode@BymlFile@@_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Assign_counted_range<BymlFile::Node *>
$LN17@operator:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4Node@BymlFile@@QEAAAEAV01@AEBV01@@Z ENDP		; BymlFile::Node::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::~vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >, COMDAT

; 767  :         _Tidy();

	jmp	?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Tidy
??1?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::~vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rax, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXPEAVNode@BymlFile@@_K@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Assign_counted_range<BymlFile::Node *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
_Val$ = 56
?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::push_back, COMDAT

; 872  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN19:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rbx, QWORD PTR [rcx+8]
	cmp	rbx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rbx
	mov	rcx, rbx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rsi+24]
	mov	BYTE PTR [rbx+24], al
	lea	rcx, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR [rsi+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+64]
	lea	rdx, QWORD PTR [rsi+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rdi+8], 88			; 00000058H

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rsi
	mov	rdx, rbx

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_reallocate<BymlFile::Node const &>
?push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
_Val$ = 56
?dtor$0@?0??push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::push_back'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0??push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::push_back'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
_Val$ = 56
?dtor$1@?0??push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::push_back'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??push_back@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEBVNode@BymlFile@@@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::push_back'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	add	rax, rdx

; 1890 :     }

	ret	0
??A?$vector@EV?$allocator@E@std@@@std@@QEAAAEAE_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]

; 1870 :     }

	ret	0
?size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::data, COMDAT

; 1787 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx]

; 1788 :     }

	ret	0
?data@?$vector@EV?$allocator@E@std@@@std@@QEAAPEAEXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN38:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rbx, rdx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rcx]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rdi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rcx, rsi
	sub	rcx, rdx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rbx, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rbx]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;

	jmp	SHORT $LN35@resize
$LN4@resize:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rdx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rbx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rbx
	mov	rcx, rdi

; 1593 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8, rbx
	mov	rcx, rsi
	call	memset

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
$LN35@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1593 :     }

	mov	QWORD PTR [rdi+8], rax
$LN5@resize:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdx]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=, COMDAT

; 736  :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN39:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 737  :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN36@operator

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rsi
	xor	esi, esi
	test	rcx, rcx
	je	SHORT $LN5@operator

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN23@operator

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN20@operator

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN23@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx], rsi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rsi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rsi
$LN5@operator:

; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rbx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rbx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	mov	QWORD PTR [rdi], rsi

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rsi

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rsi
	mov	rsi, QWORD PTR [rsp+64]
$LN36@operator:

; 764  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN20@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN35@operator:
??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 683  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN45:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 683  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rbx, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax

; 683  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 684  :         const auto& _Right_data = _Right._Mypair._Myval2;
; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rdx, QWORD PTR [rdx+8]
	sub	rdx, QWORD PTR [rbx]

; 2065 :         if (_Count != 0) {

	je	SHORT $LN32@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN43@vector
	mov	QWORD PTR [rsp+64], rdi

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rcx, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi+8], rcx
$LN32@vector:

; 686  :         _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
; 687  :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN43@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN41@vector:
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@operator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]

; 4024 : #if _CONTAINER_DEBUG_LEVEL > 0
; 4025 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 4026 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 4027 :         return _Mypair._Myval2._Myptr()[_Off];

	add	rax, rdx

; 4028 :     }

	ret	0
$LN8@operator:

; 4024 : #if _CONTAINER_DEBUG_LEVEL > 0
; 4025 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 4026 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 4027 :         return _Mypair._Myval2._Myptr()[_Off];

	lea	rax, QWORD PTR [rcx+rdx]

; 4028 :     }

	ret	0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2226 :         value_type* _Result = _Bx._Buf;
; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2232 :     }

	ret	0
$LN6@Myptr:

; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

	mov	rax, rcx

; 2232 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::starts_with, COMDAT

; 4676 :     _NODISCARD constexpr bool starts_with(const _Elem* const _Right) const noexcept /* strengthened */ {

$LN24:
	sub	rsp, 40					; 00000028H

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@starts_wit

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN4@starts_wit:

; 400  :             return __builtin_strlen(_First);

	mov	r8, -1
	npad	8
$LL21@starts_wit:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL21@starts_wit

; 1420 :         if (_Mysize < _Rightsize) {

	cmp	QWORD PTR [rcx+16], r8
	jae	SHORT $LN17@starts_wit

; 4677 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);

	xor	al, al

; 4678 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@starts_wit:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rcx, rax
	call	memcmp

; 1423 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
	sete	al

; 4678 :     }

	add	rsp, 40					; 00000028H
	ret	0
?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::starts_with
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NV?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NV?$basic_string_view@DU?$char_traits@D@std@@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::starts_with, COMDAT

; 4668 :     _NODISCARD constexpr bool starts_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {

$LN17:
	sub	rsp, 40					; 00000028H

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@starts_wit

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN4@starts_wit:

; 4669 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);

	movaps	xmm1, XMMWORD PTR [rdx]

; 1420 :         if (_Mysize < _Rightsize) {

	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	movq	r8, xmm0
	cmp	QWORD PTR [rcx+16], r8
	jae	SHORT $LN11@starts_wit

; 4669 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);

	xor	al, al

; 4670 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN11@starts_wit:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	movq	rdx, xmm1
	mov	rcx, rax
	call	memcmp

; 1423 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
	sete	al

; 4670 :     }

	add	rsp, 40					; 00000028H
	ret	0
?starts_with@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NV?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::starts_with
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
this$ = 64
__$ReturnUdt$ = 72
_Off$ = 80
_Count$ = 88
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT

; 4570 :     {

$LN35:
	push	rbx
	sub	rsp, 48					; 00000030H
	xor	eax, eax
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xorps	xmm0, xmm0
	mov	rbx, rdx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], rax

; 2260 :         if (_Mysize < _Off) {

	mov	rax, QWORD PTR [rcx+16]
	cmp	rax, r8
	jb	SHORT $LN33@substr

; 2278 :         return (_STD min)(_Size, _Mysize - _Off);

	sub	rax, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmp	rax, r9
	cmovb	r9, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN24@substr

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN24@substr:

; 2511 :         _Construct<_Construct_strategy::_From_ptr>(

	lea	rdx, QWORD PTR [rcx+r8]
	mov	r8, r9
	mov	rcx, rbx
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 4571 :         // return [_Off, _Off + _Count) as new string, default-constructing its allocator
; 4572 :         return basic_string{*this, _Off, _Count};

	mov	rax, rbx

; 4573 :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN33@substr:

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	int	3
$LN31@substr:
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
_Off$ = 80
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT

; 4341 :     _NODISCARD _CONSTEXPR20 size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {

$LN15:
	sub	rsp, 56					; 00000038H

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 4342 :         // look for _Right beginning at or after _Off
; 4343 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	r9, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@find

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN4@find:

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 4342 :         // look for _Right beginning at or after _Off
; 4343 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rax, QWORD PTR [rcx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@find

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN9@find:

; 4342 :         // look for _Right beginning at or after _Off
; 4343 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	QWORD PTR [rsp+32], r9
	mov	r9, rdx
	mov	rdx, rax
	call	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >

; 4344 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
; 4345 :     }

	add	rsp, 56					; 00000038H
	ret	0
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT

; 4228 :         return _Mypair._Myval2._Mysize == 0;

	cmp	QWORD PTR [rcx+16], 0
	sete	al

; 4229 :     }

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 4125 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rcx+16]

; 4126 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT

; 4121 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rcx+16]

; 4122 :     }

	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@data

; 4116 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 4117 :     }

	ret	0
$LN8@data:

; 4116 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 4117 :     }

	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@c_str

; 4107 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 4108 :     }

	ret	0
$LN8@c_str:

; 4107 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 4108 :     }

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??B?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string_view@DU?$char_traits@D@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
??B?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string_view@DU?$char_traits@D@std@@@1@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator std::basic_string_view<char,std::char_traits<char> >, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@basic_stri

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN4@basic_stri:

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR [rdx], rax
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rdx+8], rax

; 4040 :         // return a string_view around *this's character-type sequence
; 4041 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};

	mov	rax, rdx

; 4042 :     }

	ret	0
??B?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string_view@DU?$char_traits@D@std@@@1@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator std::basic_string_view<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 400  :             return __builtin_strlen(_First);

	mov	r8, -1
	npad	9
$LL5@append:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL5@append

; 3292 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 3235 :     _CONSTEXPR20 basic_string& operator+=(_Elem _Ch) {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	r8, QWORD PTR [rcx+16]

; 3235 :     _CONSTEXPR20 basic_string& operator+=(_Elem _Ch) {

	mov	rbx, rcx

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	r9, QWORD PTR [rcx+24]
	cmp	r8, r9
	jae	SHORT $LN4@operator

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rcx, QWORD PTR [r8+1]

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	mov	QWORD PTR [rbx+16], rcx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r9, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN7@operator:

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+r8], dl

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+r8+1], 0

; 3236 :         push_back(_Ch);
; 3237 :         return *this;
; 3238 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@operator:

; 4056 :         _Reallocate_grow_by(

	movzx	r9d, dl
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>

; 3236 :         push_back(_Ch);
; 3237 :         return *this;
; 3238 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 3155 :     _CONSTEXPR20 basic_string& operator=(const basic_string& _Right) {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN11@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3157 :             return *this;
; 3158 :         }
; 3159 : 
; 3160 :         auto& _Al             = _Getal();
; 3161 :         const auto& _Right_al = _Right._Getal();
; 3162 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3163 :             if (_Al != _Right_al) {
; 3164 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3165 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3166 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3167 : 
; 3168 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3169 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3170 :                     const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3171 :                     auto _Right_al_non_const = _Right_al;
; 3172 :                     const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity + 1); // throws
; 3173 : 
; 3174 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_size + 1);
; 3175 : 
; 3176 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3177 :                     _Tidy_deallocate();
; 3178 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3179 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3180 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3181 :                 } else {
; 3182 :                     _Copy_assign_val_from_small(_Right);
; 3183 :                 }
; 3184 : 
; 3185 :                 _Pocca(_Al, _Right_al);
; 3186 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3187 :                 return *this;
; 3188 :             }
; 3189 :         }
; 3190 : 
; 3191 :         _Pocca(_Al, _Right_al);
; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN5@operator:

; 3157 :             return *this;
; 3158 :         }
; 3159 : 
; 3160 :         auto& _Al             = _Getal();
; 3161 :         const auto& _Right_al = _Right._Getal();
; 3162 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3163 :             if (_Al != _Right_al) {
; 3164 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3165 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3166 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3167 : 
; 3168 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3169 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3170 :                     const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3171 :                     auto _Right_al_non_const = _Right_al;
; 3172 :                     const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity + 1); // throws
; 3173 : 
; 3174 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_size + 1);
; 3175 : 
; 3176 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3177 :                     _Tidy_deallocate();
; 3178 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3179 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3180 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3181 :                 } else {
; 3182 :                     _Copy_assign_val_from_small(_Right);
; 3183 :                 }
; 3184 : 
; 3185 :                 _Pocca(_Al, _Right_al);
; 3186 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3187 :                 return *this;
; 3188 :             }
; 3189 :         }
; 3190 : 
; 3191 :         _Pocca(_Al, _Right_al);
; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN11@operator:

; 3193 :         return *this;
; 3194 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 2960 :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN63:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 2961 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN60@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN13@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@operator

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN22@operator

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN25@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15
	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], al

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rbx], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rbx+16], xmm1

; 2962 :             return *this;
; 2963 :         }
; 2964 : 
; 2965 :         auto& _Al                 = _Getal();
; 2966 :         auto& _Right_al           = _Right._Getal();
; 2967 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
; 2968 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 2969 :             if (_Al != _Right_al) {
; 2970 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2971 :                 _Mypair._Myval2._Orphan_all();
; 2972 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 2973 :             }
; 2974 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 2975 :             if (_Al != _Right_al) {
; 2976 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2977 :                 return *this;
; 2978 :             }
; 2979 :         }
; 2980 : 
; 2981 :         _Tidy_deallocate();
; 2982 :         _Pocma(_Al, _Right_al);
; 2983 :         _Take_contents(_Right);
; 2984 :         return *this;

	mov	QWORD PTR [rdi+16], rax
	mov	QWORD PTR [rdi+24], 15
	mov	BYTE PTR [rdi], al
$LN60@operator:

; 2985 :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN59@operator:
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 2760 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2761 :         _Take_contents(_Right);
; 2762 :     }

	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], al
	mov	rax, rcx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Ch$dead$ = 80
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2556 :         : _Mypair(_Zero_then_variadic_args_t{}) { // construct from _Count * _Ch

$LN77:
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2620 :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2556 :         : _Mypair(_Zero_then_variadic_args_t{}) { // construct from _Count * _Ch

	mov	rsi, rdx
	mov	rdi, rcx

; 2620 :         if (_Count > max_size()) {

	cmp	rdx, rbp
	ja	$LN75@basic_stri

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 15
	cmp	rdx, 16
	jae	SHORT $LN13@basic_stri

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rdx

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, rdx
	xor	edx, edx
	call	memset

; 2557 :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
; 2558 :     }

	mov	rax, rdi

; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rsi+rdi], 0

; 2557 :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
; 2558 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN13@basic_stri:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rsi
	mov	QWORD PTR [rsp+80], rbx
	or	rax, 15
	cmp	rax, rbp

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN32@basic_stri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
$LN32@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, -1
	mov	rdx, rbp
	add	rdx, 1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, rsi

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rdi], rax

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	xor	edx, edx

; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rdi+16], rsi

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	rcx, rax

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbp
	mov	rbx, rax

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	call	memset

; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rbx+rsi], 0

; 2557 :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
; 2558 :     }

	mov	rax, rdi

; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	rbx, QWORD PTR [rsp+80]

; 2557 :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
; 2558 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN75@basic_stri:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN73@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2539 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN17:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2539 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	mov	rbx, rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 400  :             return __builtin_strlen(_First);

	mov	r8, -1
$LL13@basic_stri:
	inc	r8
	cmp	BYTE PTR [rdx+r8], al
	jne	SHORT $LL13@basic_stri

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 2541 :     }

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2491 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN64:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2491 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	r14, rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2491 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rbx, rcx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@basic_stri

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdx]
$LN12@basic_stri:

; 2620 :         if (_Count > max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rdi
	ja	$LN62@basic_stri

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 15
	cmp	rsi, 16
	jae	SHORT $LN18@basic_stri

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rsi

; 2493 :     }

	mov	rax, rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [rcx], xmm0

; 2493 :     }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN18@basic_stri:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rsi
	or	rax, 15
	cmp	rax, rdi

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN28@basic_stri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rdi, rax
	cmp	rax, rcx
	cmovb	rdi, rcx
$LN28@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, -1
	mov	rdx, rdi
	add	rdx, 1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]
	mov	QWORD PTR [rbx], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2493 :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN62@basic_stri:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN60@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2480 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

	xorps	xmm0, xmm0

; 2481 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2482 :         _Tidy_init();
; 2483 :     }

	mov	rax, rcx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 2481 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2482 :         _Tidy_init();
; 2483 :     }

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD_K@Z
_TEXT	SEGMENT
this$ = 8
_Cts$ = 16
_Count$ = 24
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD_K@Z PROC ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >, COMDAT

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR [rcx], rdx

; 1210 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1211 :         _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
; 1212 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1213 :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD_K@Z ENDP ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ntcts$ = 16
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD@Z PROC ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >, COMDAT

; 1201 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}

	mov	QWORD PTR [rcx], rdx

; 400  :             return __builtin_strlen(_First);

	mov	rax, -1
	npad	6
$LL5@basic_stri:
	inc	rax
	cmp	BYTE PTR [rdx+rax], 0
	jne	SHORT $LL5@basic_stri

; 1201 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}

	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD@Z ENDP ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UEntry@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UEntry@SarcFile@@@2@XZ PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UEntry@SarcFile@@@2@XZ ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Tidy
	mov	QWORD PTR [rsp+56], rdi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Tidy
$LL7@Tidy:
	mov	rcx, rbx
	call	??1Entry@SarcFile@@QEAA@XZ
	add	rbx, 56					; 00000038H
	cmp	rbx, rdi
	jne	SHORT $LL7@Tidy
$LN6@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 56				; 00000038H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN2@Tidy:

; 2053 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN29@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@Tidy:
?_Tidy@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXXZ ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBAAEBV?$allocator@VNode@BymlFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBAAEBV?$allocator@VNode@BymlFile@@@2@XZ PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBAAEBV?$allocator@VNode@BymlFile@@@2@XZ ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Take_contents@?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Take_contents@?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAAXAEAV12@@Z PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Take_contents, COMDAT

; 411  :         this->_Swap_proxy_and_iterators(_Right);
; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdx], rax

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdx+8], rax

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdx+16], rax

; 419  :     }

	ret	0
?_Take_contents@?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction, COMDAT

; 737  :         return _Al;

	mov	rax, rcx

; 738  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4862 :         return _Mypair._Get_first();

	mov	rax, rcx

; 4863 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT

; 4819 :         // initialize basic_string data members
; 4820 :         auto& _My_data   = _Mypair._Myval2;
; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 4827 :     }

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
_TEXT	SEGMENT
this$ = 8
_Ch$ = 16
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	r8, QWORD PTR [rcx+16]

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	r9, QWORD PTR [rcx+24]
	cmp	r8, r9
	jae	SHORT $LN2@push_back

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [r8+1]
	mov	QWORD PTR [rcx+16], rax

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r9, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@push_back

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN5@push_back:

; 4050 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rcx+r8], dl

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rcx+r8+1], 0

; 4057 :             1,
; 4058 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 4059 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 4060 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 4061 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 4062 :             },
; 4063 :             _Ch);
; 4064 :     }

	ret	0
$LN2@push_back:

; 4053 :             return;
; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	movzx	r9d, dl
	jmp	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ch$ = 80
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator(), COMDAT

; 4058 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {

$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rbx, rdx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rax
	mov	rcx, rbx
	mov	r8, r9

; 4058 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {

	mov	rdi, r9

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 4059 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 4060 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	movzx	eax, BYTE PTR _Ch$[rsp]
	mov	BYTE PTR [rdi+rbx], al

; 4061 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rdi+rbx+1], 0

; 4062 :             },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 3374 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN130:
	push	rbx
	push	rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 3375 :         // assign [_Ptr, _Ptr + _Count)
; 3376 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	rbp, QWORD PTR [rcx+24]
	mov	r14, r8
	mov	r15, rdx
	mov	rbx, rcx
	cmp	r8, rbp
	ja	SHORT $LN2@assign

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rdi, rcx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@assign

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rcx]
$LN5@assign:

; 3377 :             _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _Count);
; 3378 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3379 :             _Mypair._Myval2._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r14

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rdi
	call	memmove

; 3390 :             },
; 3391 :             _Ptr);
; 3392 :     }

	mov	rax, rbx
	mov	BYTE PTR [r14+rdi], 0
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN2@assign:

; 4734 :         if (_New_size > max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rdi
	ja	$LN127@assign

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, r14
	or	rcx, 15
	cmp	rcx, rdi

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN31@assign

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, rbp
	mov	rax, rdi
	shr	rdx, 1
	sub	rax, rdx
	cmp	rbp, rax
	ja	SHORT $LN31@assign

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rdi, rcx
	cmp	rcx, rax
	cmovb	rdi, rax
$LN31@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rcx, rdi
	mov	QWORD PTR [rsp+104], rsi
	add	rcx, 1
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN41@assign

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN128@assign

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN83@assign

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rsi, QWORD PTR [rax+39]
	and	rsi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rsi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN39@assign
$LN41@assign:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN42@assign

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN39@assign
$LN42@assign:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	esi, esi
$LN39@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, r14

; 4746 :         _Mypair._Myval2._Mysize = _New_size;

	mov	QWORD PTR [rbx+16], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15

; 4747 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rsi
	call	memcpy

; 3389 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [r14+rsi], 0

; 4749 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	rbp, 16
	jb	SHORT $LN26@assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4750 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN86@assign

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN83@assign

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN86@assign:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3385 :         return _Reallocate_for(

	mov	QWORD PTR [rbx], rsi

; 3390 :             },
; 3391 :             _Ptr);
; 3392 :     }

	mov	rax, rbx
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN83@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN128@assign:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN127@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4735 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN124@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Count$ = 64
_Ptr$ = 72
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator(), COMDAT

; 3387 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rbx
	mov	rdx, r9
	call	memcpy

; 3388 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3389 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [rbx+rdi], 0

; 3390 :             },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD10@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 3268 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN43:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	rsi, r8

; 3269 :         // append [_Ptr, _Ptr + _Count)
; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	r8, QWORD PTR [rdi+24]
	mov	rax, r8
	sub	rax, rcx
	cmp	rsi, rax
	ja	SHORT $LN2@append
	mov	QWORD PTR [rsp+64], rbx

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+rsi]
	mov	QWORD PTR [rdi+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	r8, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@append

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN5@append:

; 3274 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3275 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	rbx, QWORD PTR [rax+rcx]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rsi
	mov	rcx, rbx
	call	memmove

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+rsi], 0

; 3277 :             return *this;

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+64]

; 3281 :             _Count,
; 3282 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3283 :                 const size_type _Count) {
; 3284 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3285 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3287 :             },
; 3288 :             _Ptr, _Count);
; 3289 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@append:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	r9, rdx
	mov	QWORD PTR [rsp+32], rsi
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>

; 3281 :             _Count,
; 3282 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3283 :                 const size_type _Count) {
; 3284 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3285 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3287 :             },
; 3288 :             _Ptr, _Count);
; 3289 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ptr$ = 80
_Count$ = 88
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator(), COMDAT

; 3283 :                 const size_type _Count) {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rbx, rdx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rax
	mov	rcx, rbx
	mov	r8, r9

; 3283 :                 const size_type _Count) {

	mov	rdi, r9

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
	mov	rdx, QWORD PTR _Ptr$[rsp]

; 3284 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3285 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	add	rdi, rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rbx, QWORD PTR _Count$[rsp]
	mov	rcx, rdi
	mov	r8, rbx
	call	memcpy

; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0

; 3287 :             },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 3003 :         // assign by stealing _Right's buffer
; 3004 :         // pre: this != &_Right
; 3005 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3006 :         // pre: *this owns no memory, iterators orphaned
; 3007 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3008 :         auto& _My_data    = _Mypair._Myval2;
; 3009 :         auto& _Right_data = _Right._Mypair._Myval2;
; 3010 : 
; 3011 : #if !defined(_INSERT_STRING_ANNOTATION)
; 3012 :         if constexpr (_Can_memcpy_val) {
; 3013 : #if _HAS_CXX20
; 3014 :             if (!_STD is_constant_evaluated())
; 3015 : #endif // _HAS_CXX20
; 3016 :             {
; 3017 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3018 :                 if (_Right_data._Large_string_engaged()) {
; 3019 :                     // take ownership of _Right's iterators along with its buffer
; 3020 :                     _Swap_proxy_and_iterators(_Right);
; 3021 :                 } else {
; 3022 :                     _Right_data._Orphan_all();
; 3023 :                 }
; 3024 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3025 : 
; 3026 :                 _Memcpy_val_from(_Right);
; 3027 :                 _Right._Tidy_init();
; 3028 :                 return;
; 3029 :             }
; 3030 :         }
; 3031 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 3032 : 
; 3033 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 3034 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 3035 :             _Right_data._Bx._Ptr = nullptr;
; 3036 :             _Swap_proxy_and_iterators(_Right);
; 3037 :         } else { // copy small string buffer
; 3038 :             _My_data._Activate_SSO_buffer();
; 3039 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 3040 :             _Right_data._Orphan_all();
; 3041 :         }
; 3042 : 
; 3043 :         _My_data._Myres  = _Right_data._Myres;
; 3044 :         _My_data._Mysize = _Right_data._Mysize;
; 3045 : 
; 3046 :         _Right._Tidy_init();
; 3047 :     }

	mov	QWORD PTR [rdx+16], 0
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], 0
	ret	0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
_Roff$ = 64
_Count$ = 72
_Al$dead$ = 80
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2509 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2509 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

	mov	rbx, rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2260 :         if (_Mysize < _Off) {

	mov	rax, QWORD PTR [rdx+16]
	cmp	rax, r8
	jb	SHORT $LN28@basic_stri

; 2278 :         return (_STD min)(_Size, _Mysize - _Off);

	sub	rax, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmp	rax, r9
	cmovb	r9, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN20@basic_stri

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN20@basic_stri:

; 2510 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 2511 :         _Construct<_Construct_strategy::_From_ptr>(

	add	rdx, r8
	mov	r8, r9
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 2512 :             _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
; 2513 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN28@basic_stri:

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	int	3
$LN26@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 737  :         return _Al;

	mov	rax, rcx

; 738  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN28:
	sub	rsp, 40					; 00000028H

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN5@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN27@allocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN14@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN14@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@allocate:

; 244  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN6@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN6@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN27@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN25@allocate:
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NQEBD@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NQEBD@Z PROC ; std::basic_string_view<char,std::char_traits<char> >::starts_with, COMDAT

; 1430 :     _NODISCARD constexpr bool starts_with(const _Elem* const _Right) const noexcept /* strengthened */ {

$LN15:
	sub	rsp, 40					; 00000028H

; 400  :             return __builtin_strlen(_First);

	mov	r8, -1
	npad	5
$LL12@starts_wit:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL12@starts_wit

; 1420 :         if (_Mysize < _Rightsize) {

	cmp	QWORD PTR [rcx+8], r8
	jae	SHORT $LN8@starts_wit

; 1431 :         return starts_with(basic_string_view(_Right));

	xor	al, al

; 1432 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@starts_wit:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rcx, QWORD PTR [rcx]
	call	memcmp

; 1423 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
	sete	al

; 1432 :     }

	add	rsp, 40					; 00000028H
	ret	0
?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NQEBD@Z ENDP ; std::basic_string_view<char,std::char_traits<char> >::starts_with
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NV12@@Z PROC ; std::basic_string_view<char,std::char_traits<char> >::starts_with, COMDAT

; 1418 :     _NODISCARD constexpr bool starts_with(const basic_string_view _Right) const noexcept {

$LN8:
	sub	rsp, 40					; 00000028H

; 1419 :         const auto _Rightsize = _Right._Mysize;

	mov	r8, QWORD PTR [rdx+8]

; 1420 :         if (_Mysize < _Rightsize) {

	cmp	QWORD PTR [rcx+8], r8
	jae	SHORT $LN2@starts_wit

; 1421 :             return false;

	xor	al, al

; 1424 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@starts_wit:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rdx, QWORD PTR [rdx]
	mov	rcx, QWORD PTR [rcx]
	call	memcmp

; 1422 :         }
; 1423 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
	sete	al

; 1424 :     }

	add	rsp, 40					; 00000028H
	ret	0
?starts_with@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NV12@@Z ENDP ; std::basic_string_view<char,std::char_traits<char> >::starts_with
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 474  :         return static_cast<int_type>(EOF);

	mov	eax, -1

; 475  :     }

	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 466  :         return _Left == _Right;

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	sete	al

; 467  :     }

	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 388  :         // find length of null-terminated string
; 389  : #if _HAS_CXX17
; 390  : #ifdef __cpp_char8_t
; 391  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 392  : #if _HAS_U8_INTRINSICS
; 393  :             return __builtin_u8strlen(_First);
; 394  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 395  :             return _Primary_char_traits::length(_First);
; 396  : #endif // _HAS_U8_INTRINSICS
; 397  :         } else
; 398  : #endif // __cpp_char8_t
; 399  :         {
; 400  :             return __builtin_strlen(_First);

	mov	rax, -1
$LL3@length:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL3@length

; 401  :         }
; 402  : #else // _HAS_CXX17
; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 404  : #endif // _HAS_CXX17
; 405  :     }

	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 50   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 51   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 52   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 53   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 54   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 55   : #if _HAS_CXX20
; 56   :         if (_STD is_constant_evaluated()) {
; 57   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 58   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 59   :                 _First1[_Idx] = _First2[_Idx];
; 60   :             }
; 61   : 
; 62   :             return _First1;
; 63   :         }
; 64   : #endif // _HAS_CXX20
; 65   : 
; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 67   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 68   : 
; 69   :         return _First1;

	mov	rax, rbx

; 70   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UEntry@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UEntry@SarcFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UEntry@SarcFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UEntry@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UEntry@SarcFile@@@2@XZ PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UEntry@SarcFile@@@2@XZ ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UEntry@SarcFile@@@std@@QEAAXQEAUEntry@SarcFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UEntry@SarcFile@@@std@@QEAAXQEAUEntry@SarcFile@@_K@Z PROC ; std::allocator<SarcFile::Entry>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, r8, 56				; 00000038H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UEntry@SarcFile@@@std@@QEAAXQEAUEntry@SarcFile@@_K@Z ENDP ; std::allocator<SarcFile::Entry>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@VNode@BymlFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@VNode@BymlFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@VNode@BymlFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Right$dead$ = 16
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 4854 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 4855 :     }

	ret	0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT

; 2994 :         _STL_INTERNAL_CHECK(_Can_memcpy_val);
; 2995 :         const auto _My_data_mem =
; 2996 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2997 :         const auto _Right_data_mem =
; 2998 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 3000 :     }

	ret	0
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
_Size$ = 24
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT

; 2278 :         return (_STD min)(_Size, _Mysize - _Off);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmp	rax, r8
	cmovb	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2278 :         return (_STD min)(_Size, _Mysize - _Off);

	mov	rax, r8

; 2279 :     }

	ret	0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 2258 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

$LN7:
	sub	rsp, 40					; 00000028H

; 2259 :         // checks whether _Off is in the bounds of [0, size()]
; 2260 :         if (_Mysize < _Off) {

	cmp	QWORD PTR [rcx+16], rdx
	jb	SHORT $LN6@Check_offs

; 2262 :         }
; 2263 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Check_offs:

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	int	3
$LN4@Check_offs:
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Ch$dead$ = 24
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 430  :         // assign _Count * _Ch to [_First, ...)
; 431  : #if _HAS_CXX20
; 432  :         if (_STD is_constant_evaluated()) {
; 433  :             return _Primary_char_traits::assign(_First, _Count, _Ch);
; 434  :         }
; 435  : #endif // _HAS_CXX20
; 436  : 
; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, rdx
	xor	edx, edx
	jmp	memset
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 81   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 82   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 83   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 84   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 85   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 86   : #if _HAS_CXX20
; 87   :         if (_STD is_constant_evaluated()) {
; 88   :             // dest: [_First1, _First1 + _Count)
; 89   :             // src: [_First2, _First2 + _Count)
; 90   :             // We need to handle overlapping ranges.
; 91   :             // If _First1 is in the src range, we need a backward loop.
; 92   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 93   : 
; 94   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 95   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 96   :             bool _Loop_forward = true;
; 97   : 
; 98   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 99   :                 if (_First1 == _Src) {
; 100  :                     _Loop_forward = false;
; 101  :                     break;
; 102  :                 }
; 103  :             }
; 104  : 
; 105  :             if (_Loop_forward) {
; 106  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 107  :                     _First1[_Idx] = _First2[_Idx];
; 108  :                 }
; 109  :             } else {
; 110  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 111  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 112  :                 }
; 113  :             }
; 114  : 
; 115  :             return _First1;
; 116  :         }
; 117  : #endif // _HAS_CXX20
; 118  : 
; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	memmove

; 120  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 121  : 
; 122  :         return _First1;

	mov	rax, rbx

; 123  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UEntry@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UEntry@SarcFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UEntry@SarcFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2272 :     [[noreturn]] static void _Xran() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2273 :         _Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN3@Xran:
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$dead$ = 64
?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 164  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 165  :         // assign _Count * _Ch to [_First, ...)
; 166  : #if _HAS_CXX20
; 167  :         if (_STD is_constant_evaluated()) {
; 168  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {
; 169  :                 _STD construct_at(_Next, _Ch);
; 170  :             }
; 171  :         } else
; 172  : #endif // _HAS_CXX20
; 173  :         {
; 174  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {

	test	rdx, rdx
	je	SHORT $LN21@assign

; 164  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

	mov	r8, rdx
	xor	edx, edx
	call	memset
$LN21@assign:

; 175  :                 *_Next = _Ch;
; 176  :             }
; 177  :         }
; 178  : 
; 179  :         return _First;
; 180  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
_Buff$ = 48
__$ArrayPad$ = 72
__$ReturnUdt$ = 96
_Val$ = 104
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z PROC ; std::_Integral_to_string<char,int>, COMDAT

; 474  : _NODISCARD basic_string<_Elem> _Integral_to_string(const _Ty _Val) {

$LN43:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	xor	r10d, r10d
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 475  :     // convert _Val to string
; 476  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 477  :     using _UTy = make_unsigned_t<_Ty>;
; 478  :     _Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
; 479  :     _Elem* const _Buff_end = _STD end(_Buff);
; 480  :     _Elem* _RNext          = _Buff_end;
; 481  :     const auto _UVal       = static_cast<_UTy>(_Val);
; 482  :     if (_Val < 0) {

	lea	r9, QWORD PTR _Buff$[rsp+21]
	mov	r8d, edx
	mov	rbx, rcx
	test	edx, edx
	jns	SHORT $LL15@Integral_t

; 447  :     auto _UVal_trunc = _UVal;

	neg	r8d
	npad	1
$LL10@Integral_t:

; 448  : #else // ^^^ _WIN64 / !_WIN64 vvv
; 449  : 
; 450  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 451  :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 452  :         while (_UVal > 0xFFFFFFFFU) {
; 453  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 454  :             _UVal /= 1000000000;
; 455  : 
; 456  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 457  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 458  :                 _UVal_chunk /= 10;
; 459  :             }
; 460  :         }
; 461  :     }
; 462  : 
; 463  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 464  : #endif // _WIN64
; 465  : 
; 466  :     do {
; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 469  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL10@Integral_t

; 483  :         _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);
; 484  :         *--_RNext = '-';

	dec	r9
	mov	BYTE PTR [r9], 45			; 0000002dH

; 485  :     } else {

	jmp	SHORT $LN3@Integral_t
	npad	13
$LL15@Integral_t:

; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 469  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL15@Integral_t
$LN3@Integral_t:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2574 :         if (_UFirst == _ULast) {

	lea	rax, QWORD PTR _Buff$[rsp+21]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], r10

; 2574 :         if (_UFirst == _ULast) {

	cmp	r9, rax
	jne	SHORT $LN18@Integral_t

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r10

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r10b

; 2577 :         } else {

	jmp	SHORT $LN40@Integral_t
$LN18@Integral_t:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$[rsp+21]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, rbx
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN40@Integral_t:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 490  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ENDP ; std::_Integral_to_string<char,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z
_TEXT	SEGMENT
_Array$ = 8
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z PROC		; std::end<char,21>, COMDAT

; 1810 :     return _Array + _Size;

	lea	rax, QWORD PTR [rcx+21]

; 1811 : }

	ret	0
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z ENDP		; std::end<char,21>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ??$_UIntegral_to_string@DI@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@I@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
_Buff$ = 48
__$ArrayPad$ = 72
__$ReturnUdt$ = 96
_Val$ = 104
??$_UIntegral_to_string@DI@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@I@Z PROC ; std::_UIntegral_to_string<char,unsigned int>, COMDAT

; 494  : _NODISCARD basic_string<_Elem> _UIntegral_to_string(const _Ty _Val) {

$LN32:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r8d, edx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	rbx, rcx

; 495  :     // convert _Val to string
; 496  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 497  :     static_assert(is_unsigned_v<_Ty>, "_Ty must be unsigned");
; 498  :     _Elem _Buff[21]; // can hold 2^64 - 1, plus NUL
; 499  :     _Elem* const _Buff_end = _STD end(_Buff);
; 500  :     _Elem* const _RNext    = _UIntegral_to_buff(_Buff_end, _Val);

	lea	r9, QWORD PTR _Buff$[rsp+21]
	xor	r10d, r10d
	npad	8
$LL8@UIntegral_:

; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 469  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL8@UIntegral_
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2574 :         if (_UFirst == _ULast) {

	lea	rax, QWORD PTR _Buff$[rsp+21]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], r10

; 2574 :         if (_UFirst == _ULast) {

	cmp	r9, rax
	jne	SHORT $LN11@UIntegral_

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r10

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r10b

; 2577 :         } else {

	jmp	SHORT $LN29@UIntegral_
$LN11@UIntegral_:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$[rsp+21]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, rbx
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN29@UIntegral_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 502  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
??$_UIntegral_to_string@DI@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@I@Z ENDP ; std::_UIntegral_to_string<char,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
_Buff$ = 48
__$ArrayPad$ = 72
__$ReturnUdt$ = 96
_Val$ = 104
??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z PROC ; std::_Integral_to_string<char,__int64>, COMDAT

; 474  : _NODISCARD basic_string<_Elem> _Integral_to_string(const _Ty _Val) {

$LN43:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	xor	r11d, r11d
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 475  :     // convert _Val to string
; 476  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 477  :     using _UTy = make_unsigned_t<_Ty>;
; 478  :     _Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
; 479  :     _Elem* const _Buff_end = _STD end(_Buff);
; 480  :     _Elem* _RNext          = _Buff_end;
; 481  :     const auto _UVal       = static_cast<_UTy>(_Val);
; 482  :     if (_Val < 0) {

	lea	r9, QWORD PTR _Buff$[rsp+21]
	mov	r8, rdx
	mov	rbx, rcx
	mov	r10, -3689348814741910323		; cccccccccccccccdH
	test	rdx, rdx
	jns	SHORT $LL15@Integral_t

; 447  :     auto _UVal_trunc = _UVal;

	neg	r8
	npad	6
$LL10@Integral_t:

; 448  : #else // ^^^ _WIN64 / !_WIN64 vvv
; 449  : 
; 450  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 451  :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 452  :         while (_UVal > 0xFFFFFFFFU) {
; 453  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 454  :             _UVal /= 1000000000;
; 455  : 
; 456  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 457  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 458  :                 _UVal_chunk /= 10;
; 459  :             }
; 460  :         }
; 461  :     }
; 462  : 
; 463  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 464  : #endif // _WIN64
; 465  : 
; 466  :     do {
; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	rax, r10
	mul	r8
	shr	rdx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8, rdx

; 469  :     } while (_UVal_trunc != 0);

	test	rdx, rdx
	jne	SHORT $LL10@Integral_t

; 483  :         _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);
; 484  :         *--_RNext = '-';

	dec	r9
	mov	BYTE PTR [r9], 45			; 0000002dH

; 485  :     } else {

	jmp	SHORT $LN3@Integral_t
	npad	13
$LL15@Integral_t:

; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	rax, r10
	mul	r8
	shr	rdx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8, rdx

; 469  :     } while (_UVal_trunc != 0);

	test	rdx, rdx
	jne	SHORT $LL15@Integral_t
$LN3@Integral_t:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2574 :         if (_UFirst == _ULast) {

	lea	rax, QWORD PTR _Buff$[rsp+21]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], r11

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], r11

; 2574 :         if (_UFirst == _ULast) {

	cmp	r9, rax
	jne	SHORT $LN18@Integral_t

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r11

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r11b

; 2577 :         } else {

	jmp	SHORT $LN40@Integral_t
$LN18@Integral_t:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$[rsp+21]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, rbx
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN40@Integral_t:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 490  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
??$_Integral_to_string@D_J@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_J@Z ENDP ; std::_Integral_to_string<char,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ??$_UIntegral_to_string@D_K@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
_Buff$ = 48
__$ArrayPad$ = 72
__$ReturnUdt$ = 96
_Val$ = 104
??$_UIntegral_to_string@D_K@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_K@Z PROC ; std::_UIntegral_to_string<char,unsigned __int64>, COMDAT

; 494  : _NODISCARD basic_string<_Elem> _UIntegral_to_string(const _Ty _Val) {

$LN32:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r8, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	rbx, rcx

; 495  :     // convert _Val to string
; 496  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 497  :     static_assert(is_unsigned_v<_Ty>, "_Ty must be unsigned");
; 498  :     _Elem _Buff[21]; // can hold 2^64 - 1, plus NUL
; 499  :     _Elem* const _Buff_end = _STD end(_Buff);
; 500  :     _Elem* const _RNext    = _UIntegral_to_buff(_Buff_end, _Val);

	lea	r9, QWORD PTR _Buff$[rsp+21]
	xor	r10d, r10d

; 447  :     auto _UVal_trunc = _UVal;

	mov	r11, -3689348814741910323		; cccccccccccccccdH
	npad	14
$LL8@UIntegral_:

; 448  : #else // ^^^ _WIN64 / !_WIN64 vvv
; 449  : 
; 450  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 451  :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 452  :         while (_UVal > 0xFFFFFFFFU) {
; 453  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 454  :             _UVal /= 1000000000;
; 455  : 
; 456  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 457  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 458  :                 _UVal_chunk /= 10;
; 459  :             }
; 460  :         }
; 461  :     }
; 462  : 
; 463  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 464  : #endif // _WIN64
; 465  : 
; 466  :     do {
; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	rax, r11
	mul	r8
	shr	rdx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8, rdx

; 469  :     } while (_UVal_trunc != 0);

	test	rdx, rdx
	jne	SHORT $LL8@UIntegral_
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2574 :         if (_UFirst == _ULast) {

	lea	rax, QWORD PTR _Buff$[rsp+21]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], r10

; 2574 :         if (_UFirst == _ULast) {

	cmp	r9, rax
	jne	SHORT $LN11@UIntegral_

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], r10

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r10b

; 2577 :         } else {

	jmp	SHORT $LN29@UIntegral_
$LN11@UIntegral_:

; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	r8, QWORD PTR _Buff$[rsp+21]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, rbx
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
$LN29@UIntegral_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 502  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
??$_UIntegral_to_string@D_K@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@_K@Z ENDP ; std::_UIntegral_to_string<char,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
;	COMDAT ??$GetValue@I@Node@BymlFile@@QEAAIXZ
_TEXT	SEGMENT
this$ = 8
??$GetValue@I@Node@BymlFile@@QEAAIXZ PROC		; BymlFile::Node::GetValue<unsigned int>, COMDAT

; 51   :             T Value;
; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [rcx]

; 53   :             return Value;

	mov	eax, DWORD PTR [rax]

; 54   :         }

	ret	0
??$GetValue@I@Node@BymlFile@@QEAAIXZ ENDP		; BymlFile::Node::GetValue<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
;	COMDAT ??$GetValue@_K@Node@BymlFile@@QEAA_KXZ
_TEXT	SEGMENT
this$ = 8
??$GetValue@_K@Node@BymlFile@@QEAA_KXZ PROC		; BymlFile::Node::GetValue<unsigned __int64>, COMDAT

; 51   :             T Value;
; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [rcx]

; 53   :             return Value;

	mov	rax, QWORD PTR [rax]

; 54   :         }

	ret	0
??$GetValue@_K@Node@BymlFile@@QEAA_KXZ ENDP		; BymlFile::Node::GetValue<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
;	COMDAT ??$GetValue@H@Node@BymlFile@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
??$GetValue@H@Node@BymlFile@@QEAAHXZ PROC		; BymlFile::Node::GetValue<int>, COMDAT

; 51   :             T Value;
; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [rcx]

; 53   :             return Value;

	mov	eax, DWORD PTR [rax]

; 54   :         }

	ret	0
??$GetValue@H@Node@BymlFile@@QEAAHXZ ENDP		; BymlFile::Node::GetValue<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
;	COMDAT ??$GetValue@_J@Node@BymlFile@@QEAA_JXZ
_TEXT	SEGMENT
this$ = 8
??$GetValue@_J@Node@BymlFile@@QEAA_JXZ PROC		; BymlFile::Node::GetValue<__int64>, COMDAT

; 51   :             T Value;
; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [rcx]

; 53   :             return Value;

	mov	rax, QWORD PTR [rax]

; 54   :         }

	ret	0
??$GetValue@_J@Node@BymlFile@@QEAA_JXZ ENDP		; BymlFile::Node::GetValue<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Byml.h
;	COMDAT ??$GetValue@M@Node@BymlFile@@QEAAMXZ
_TEXT	SEGMENT
Value$ = 8
this$ = 8
??$GetValue@M@Node@BymlFile@@QEAAMXZ PROC		; BymlFile::Node::GetValue<float>, COMDAT

; 51   :             T Value;
; 52   :             memcpy(&Value, this->m_Value.data(), sizeof(Value));

	mov	rax, QWORD PTR [rcx]
	mov	ecx, DWORD PTR [rax]
	mov	DWORD PTR Value$[rsp], ecx

; 53   :             return Value;

	movss	xmm0, DWORD PTR Value$[rsp]

; 54   :         }

	ret	0
??$GetValue@M@Node@BymlFile@@QEAAMXZ ENDP		; BymlFile::Node::GetValue<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4997 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

$LN49:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, r8
	mov	r9, rdx

; 400  :             return __builtin_strlen(_First);

	mov	r8, -1

; 4997 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	mov	rbx, rcx
	xor	edi, edi
	npad	4
$LL45@operator:

; 400  :             return __builtin_strlen(_First);

	inc	r8
	cmp	BYTE PTR [rax+r8], dil
	jne	SHORT $LL45@operator

; 3292 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rax
	mov	rcx, r9
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rbx], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rbx+16], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], dil
	mov	rax, rbx

; 4999 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 5016 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

$LN21:
	sub	rsp, 40					; 00000028H

; 400  :             return __builtin_strlen(_First);

	mov	rax, -1
	npad	5
$LL18@operator:
	inc	rax
	cmp	BYTE PTR [rdx+rax], 0
	jne	SHORT $LL18@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	r8, QWORD PTR [rcx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN8@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rax
	jne	SHORT $LN14@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN14@operator

; 5017 :     return _Left._Equal(_Right);

	mov	al, 1

; 5018 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN14@operator:

; 5017 :     return _Left._Equal(_Right);

	xor	al, al

; 5018 : }

	add	rsp, 40					; 00000028H
	ret	0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4912 :     _In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

$LN23:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rbx, rcx

; 400  :             return __builtin_strlen(_First);

	mov	r9, -1
$LL15@operator:
	inc	r9
	cmp	BYTE PTR [rdx+r9], 0
	jne	SHORT $LL15@operator

; 4913 :     using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
; 4914 :     const auto _Left_size  = _Convert_size<_Size_type>(_Traits::length(_Left));
; 4915 :     const auto _Right_size = _Right.size();
; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rcx, QWORD PTR [r8+16]
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	sub	rax, rcx
	cmp	rax, r9
	jb	SHORT $LN21@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [r8+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN11@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [r8]
$LN11@operator:

; 4918 :     }
; 4919 : 
; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], r8
	mov	QWORD PTR [rsp+32], r9
	mov	r9, rdx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, rbx

; 4921 : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN21@operator:

; 4917 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN19@operator:
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4985 :     _In_z_ const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

$LN49:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, r8
	mov	rbx, rcx
	xor	edi, edi

; 400  :             return __builtin_strlen(_First);

	mov	r9, -1
	npad	7
$LL45@operator:
	inc	r9
	cmp	BYTE PTR [rdx+r9], dil
	jne	SHORT $LL45@operator

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8, rdx
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rbx], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rbx+16], xmm1

; 4986 :     return _STD move(_Right.insert(0, _Left));

	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], dil
	mov	rax, rbx

; 4987 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 767  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

$LN105:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r15, rdx
	mov	rsi, rcx

; 768  :     // insert NTBS into char stream
; 769  :     using _Elem = char;
; 770  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 771  : 
; 772  :     ios_base::iostate _State = ios_base::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR _State$[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 400  :             return __builtin_strlen(_First);

	mov	r14, -1
	npad	7
$LL96@operator:
	inc	r14
	cmp	BYTE PTR [rdx+r14], bl
	jne	SHORT $LL96@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 774  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	rax, QWORD PTR [rcx]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase

; 290  :         return _Wide;

	mov	rdi, QWORD PTR [rcx+rsi+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 774  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	test	rdi, rdi
	jle	SHORT $LN17@operator
	cmp	rdi, r14
	jle	SHORT $LN17@operator
	sub	rdi, r14
	jmp	SHORT $LN18@operator
$LN17@operator:
	xor	edi, edi
$LN18@operator:

; 76   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	r12, rsi
	mov	QWORD PTR _Ok$[rsp], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+rsi+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 78   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN69@operator

; 79   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN69@operator:

; 98   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN100@operator

; 99   :                 _Ok = false;
; 100  :                 return;
; 101  :             }
; 102  : 
; 103  :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 69   :         return _Tiestr;

	mov	rcx, QWORD PTR [rcx+rsi+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 104  :             if (!_Tied || _Tied == &_Ostr) {

	test	rcx, rcx
	je	SHORT $LN65@operator
	cmp	rcx, rsi
	je	SHORT $LN65@operator

; 106  :                 return;
; 107  :             }
; 108  : 
; 109  :             _Tied->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 110  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	jmp	SHORT $LN100@operator
$LN65@operator:

; 105  :                 _Ok = true;

	mov	al, 1
$LN100@operator:

; 111  :         }

	mov	BYTE PTR _Ok$[rsp+8], al

; 775  :     const typename _Myos::sentry _Ok(_Ostr);
; 776  : 
; 777  :     if (!_Ok) {

	test	al, al
	jne	SHORT $LN8@operator

; 778  :         _State |= ios_base::badbit;

	mov	ebx, 4

; 779  :     } else { // state okay, insert

	jmp	$LN22@operator
$LN8@operator:

; 781  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase

; 249  :         return _Fmtfl;

	mov	eax, DWORD PTR [rcx+rsi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 781  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN93@operator
	npad	6
$LL4@operator:

; 782  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	rdi, rdi
	jle	SHORT $LN93@operator

; 783  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	jne	SHORT $LN2@operator

; 784  :                     _State |= ios_base::badbit; // insertion failed, quit

	lea	ebx, QWORD PTR [rax+5]

; 785  :                     break;

	jmp	SHORT $LN102@operator
$LN2@operator:

; 782  :             for (; 0 < _Pad; --_Pad) { // pad on left

	dec	rdi
	jmp	SHORT $LL4@operator
$LN93@operator:

; 786  :                 }
; 787  :             }
; 788  :         }
; 789  : 
; 790  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	r8, r14
	mov	rdx, r15
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
	cmp	rax, r14
	jne	SHORT $LN101@operator
$LL97@operator:

; 791  :             _State |= ios_base::badbit;
; 792  :         }
; 793  : 
; 794  :         if (_State == ios_base::goodbit) {
; 795  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	rdi, rdi
	jle	SHORT $LN6@operator

; 796  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	je	SHORT $LN101@operator

; 791  :             _State |= ios_base::badbit;
; 792  :         }
; 793  : 
; 794  :         if (_State == ios_base::goodbit) {
; 795  :             for (; 0 < _Pad; --_Pad) { // pad on right

	dec	rdi
	jmp	SHORT $LL97@operator
$LN101@operator:

; 797  :                     _State |= ios_base::badbit; // insertion failed, quit
; 798  :                     break;
; 799  :                 }
; 800  :             }
; 801  :         }
; 802  : 
; 803  :         _Ostr.width(0);

	or	ebx, 4
$LN102@operator:
	mov	DWORD PTR _State$[rsp], ebx
$LN6@operator:
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase

; 296  :         _Wide                      = _Newwidth;

	mov	QWORD PTR [rcx+rsi+40], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
	jmp	SHORT $LN22@operator
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase
	mov	rsi, QWORD PTR _Ostr$[rsp]
	mov	ebx, DWORD PTR _State$[rsp]
	mov	r12, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 807  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	mov	edx, ebx
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1

; 120  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

	call	QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 121  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 122  : 
; 123  :             if (_Zero_uncaught_exceptions) {

	test	eax, eax
	jne	SHORT $LN25@operator

; 124  :                 this->_Myostr._Osfx();

	mov	rcx, r12
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN25@operator:

; 84   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [r12]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+r12+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 85   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN98@operator

; 86   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN98@operator:

; 808  :     return _Ostr;
; 809  : }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$11@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$11
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$11@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$17

; 804  :         _CATCH_IO_(ios_base, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$17
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Ostr$ = 8
_Str$ = 16
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 5187 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN6@operator:

; 5187 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	jmp	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1011 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1012 :     _Ostr.put(_Ostr.widen('\n'));

	mov	rax, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	dl, 10
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
	movzx	edx, al
	mov	rcx, rbx
	call	QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z

; 1013 :     _Ostr.flush();

	mov	rcx, rbx
	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1014 :     return _Ostr;

	mov	rax, rbx

; 1015 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z PROC	; std::_Get_unwrapped<char * &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ENDP	; std::_Get_unwrapped<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@YAPEBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@YAPEBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@YAPEBV?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@VNode@BymlFile@@@std@@@std@@YAXAEAV?$allocator@VNode@BymlFile@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@VNode@BymlFile@@@std@@@std@@YAXAEAV?$allocator@VNode@BymlFile@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<BymlFile::Node> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@VNode@BymlFile@@@std@@@std@@YAXAEAV?$allocator@VNode@BymlFile@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXPEAVNode@BymlFile@@_K@Z
_TEXT	SEGMENT
this$ = 80
_First$ = 88
_Newsize$ = 96
??$_Assign_counted_range@PEAVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXPEAVNode@BymlFile@@_K@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Assign_counted_range<BymlFile::Node *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN330:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	r14, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	r15, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	sub	rcx, rbx
	mov	rsi, r8
	sar	rcx, 3
	mov	rdi, rdx
	imul	rcx, r15

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou

; 1658 :         if (_Newsize > max_size()) {

	mov	rbp, 209622091746699450			; 02e8ba2e8ba2e8baH
	cmp	r8, rbp
	ja	$LN328@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, rbp
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbp, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbp, r8
	cmovb	rbp, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, QWORD PTR [r14+8]
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@VNode@BymlFile@@@std@@@std@@YAXPEAVNode@BymlFile@@QEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Destroy_range<std::allocator<BymlFile::Node> >

; 1666 :             _ASAN_VECTOR_REMOVE;
; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 88				; 00000058H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN33@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN36@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [r14], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [r14+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [r14+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbp
	call	?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z ; std::allocator<BymlFile::Node>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, r14

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	imul	r8, rbp, 88				; 00000058H
	mov	QWORD PTR [r14+8], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdx, rsi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	r8, rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rcx, rdi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [r14+16], r8

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r8, rax
	call	??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Uninitialized_copy_n<BymlFile::Node *,std::allocator<BymlFile::Node> >
	mov	QWORD PTR [r14+8], rax

; 1441 :     }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN33@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [r14+8]
	mov	rbp, r8
	sub	rbp, rbx
	sar	rbp, 3
	imul	rbp, r15

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	rsi, rbp
	jbe	SHORT $LN6@Assign_cou

; 1408 :             bool _Copied = false;
; 1409 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1410 : #if _HAS_CXX20
; 1411 :                 if (!_STD is_constant_evaluated())
; 1412 : #endif // _HAS_CXX20
; 1413 :                 {
; 1414 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
; 1415 :                     _First += _Oldsize;
; 1416 :                     _Copied = true;
; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rbx, r8
	je	SHORT $LN3@Assign_cou
	npad	6
$LL4@Assign_cou:

; 1422 :                     *_Mid = *_First;

	mov	rdx, rdi
	mov	rcx, rbx
	call	??4Node@BymlFile@@QEAAAEAV01@AEBV01@@Z
	mov	r8, QWORD PTR [r14+8]
	add	rbx, 88					; 00000058H
	add	rdi, 88					; 00000058H
	cmp	rbx, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rsi, rbp
	mov	r9, r14
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Uninitialized_copy_n<BymlFile::Node *,std::allocator<BymlFile::Node> >
	mov	QWORD PTR [r14+8], rax

; 1441 :     }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN6@Assign_cou:

; 1432 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1433 :             }
; 1434 :         } else {
; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rbp, rsi, 88				; 00000058H
	add	rbp, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rsi, rsi
	je	SHORT $LN89@Assign_cou
	npad	2
$LL90@Assign_cou:

; 4573 :         *_Dest = *_First;

	mov	rdx, rdi
	mov	rcx, rbx
	call	??4Node@BymlFile@@QEAAAEAV01@AEBV01@@Z
	add	rbx, 88					; 00000058H
	add	rdi, 88					; 00000058H
	sub	rsi, 1
	jne	SHORT $LL90@Assign_cou
$LN89@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rsi, QWORD PTR [r14+8]
	mov	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rsi
	je	SHORT $LN157@Assign_cou
$LL158@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rdi+64]
	call	?_Tidy@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rdi+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rdi
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 88					; 00000058H
	cmp	rdi, rsi
	jne	SHORT $LL158@Assign_cou
$LN157@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1441 :     }

	mov	rbx, QWORD PTR [rsp+104]
	mov	QWORD PTR [r14+8], rbp
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN328@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Xlength
	int	3
$LN326@Assign_cou:
??$_Assign_counted_range@PEAVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXPEAVNode@BymlFile@@_K@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Assign_counted_range<BymlFile::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
<_Val_0>$ = 56
??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_one_at_back<BymlFile::Node const &>, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN17:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rbx, rcx

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdi, QWORD PTR [rcx+8]
	cmp	rdi, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdi
	mov	rcx, rdi
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rsi+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rsi+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rsi+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+88]
	mov	QWORD PTR [rbx+8], rcx

; 786  :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rsi
	mov	rdx, rdi

; 786  :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_reallocate<BymlFile::Node const &>
??$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_one_at_back<BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
<_Val_0>$ = 56
?dtor$0@?0???$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_one_at_back<BymlFile::Node const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_one_at_back<BymlFile::Node const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
<_Val_0>$ = 56
?dtor$1@?0???$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_one_at_back<BymlFile::Node const &>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$_Emplace_one_at_back@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_one_at_back<BymlFile::Node const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z PROC		; std::_Unfancy_maybe_null<unsigned char>, COMDAT

; 434  :     return _Ptr;

	mov	rax, rcx

; 435  : }

	ret	0
??$_Unfancy_maybe_null@E@std@@YAPEAEPEAE@Z ENDP		; std::_Unfancy_maybe_null<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN36:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rbx, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	rdi, rcx
	mov	rcx, rsi
	sub	rcx, rdx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rbx, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rbx]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;

	jmp	SHORT $LN33@Resize
$LN2@Resize:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rdx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rbx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rbx
	mov	rcx, rdi

; 1587 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8, rbx
	mov	rcx, rsi
	call	memset

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
$LN33@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1587 :     }

	mov	QWORD PTR [rdi+8], rax
$LN3@Resize:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPEBV?$vector@EV?$allocator@E@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPEBV?$vector@EV?$allocator@E@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<unsigned char,std::allocator<unsigned char> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPEBV?$vector@EV?$allocator@E@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<unsigned char,std::allocator<unsigned char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@E@std@@@std@@YAXAEAV?$allocator@E@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@E@std@@@std@@YAXAEAV?$allocator@E@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<unsigned char> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@E@std@@@std@@YAXAEAV?$allocator@E@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z
_TEXT	SEGMENT
this$ = 80
_First$ = 88
_Newsize$ = 96
??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN83:
	push	rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, r8
	mov	rax, QWORD PTR [rcx+16]
	mov	r14, rdx
	sub	rax, rbx
	mov	rsi, rcx

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rax
	jbe	SHORT $LN5@Assign_cou

; 1395 :             _Clear_and_reserve_geometric(_Newsize);

	mov	rdx, r8
	call	?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Clear_and_reserve_geometric

; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rbx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdi
	mov	rcx, rbx
	mov	rdx, r14
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1441 :     }

	mov	QWORD PTR [rsi+8], rax
	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN5@Assign_cou:
	mov	QWORD PTR [rsp+32], rbp

; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1402 :             }
; 1403 :             return;
; 1404 :         }
; 1405 : 
; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbp, QWORD PTR [rcx+8]

; 1407 :         if (_Newsize > _Oldsize) {

	mov	rcx, rbx
	sub	rbp, rbx
	cmp	rdi, rbp
	jbe	SHORT $LN6@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbp
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1416 :                     _Copied = true;

	mov	rbx, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR [r14+rbp]

; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {
; 1422 :                     *_Mid = *_First;
; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rbx
	mov	r8, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1434 :         } else {

	jmp	SHORT $LN80@Assign_cou
$LN6@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rbx+rdi]
$LN80@Assign_cou:

; 1441 :     }

	mov	QWORD PTR [rsi+8], rax
	mov	rbp, QWORD PTR [rsp+32]
	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPEAV?$vector@EV?$allocator@E@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPEAV?$vector@EV?$allocator@E@std@@@0@AEAV10@@Z PROC ; std::addressof<std::vector<unsigned char,std::allocator<unsigned char> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPEAV?$vector@EV?$allocator@E@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::vector<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@E@std@@@std@@YAXAEAV?$allocator@E@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocma@V?$allocator@E@std@@@std@@YAXAEAV?$allocator@E@0@0@Z PROC ; std::_Pocma<std::allocator<unsigned char> >, COMDAT

; 1067 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1068 :         _Left = _STD move(_Right);
; 1069 :     }
; 1070 : }

	ret	0
??$_Pocma@V?$allocator@E@std@@@std@@YAXAEAV?$allocator@E@0@0@Z ENDP ; std::_Pocma<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z PROC ; std::move<std::allocator<unsigned char> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ENDP ; std::move<std::allocator<unsigned char> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z PROC	; std::exchange<unsigned char *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAE$$T@std@@YAPEAEAEAPEAE$$QEA$$T@Z ENDP	; std::exchange<unsigned char *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@E@std@@PEAEPEAEPEAE@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@$$QEAPEAE22@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char>,unsigned char *,unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@E@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char * const &,unsigned char * const &>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN39:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN35@Construct_
	push	rbx
	push	rsi
	push	r14
	sub	rsp, 48					; 00000030H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r14, r9
	mov	rbx, r8
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN37@Construct_
	mov	QWORD PTR [rsp+40], rdi

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+40]
	mov	QWORD PTR [rsi+8], rax

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbx
$LN35@Construct_:
	ret	0
$LN37@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN34@Construct_:
??$_Construct_n@AEBQEAEAEBQEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBQEAE1@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char * const &,unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 69   :     // return smaller of _Left and _Right
; 70   :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rdx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 71   : }

	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
_TEXT	SEGMENT
_Haystack$ = 64
_Hay_size$ = 72
_Start_at$ = 80
_Needle$ = 88
_Needle_size$ = 96
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 575  :     const size_t _Needle_size) noexcept {

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 576  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 577  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	mov	rdi, QWORD PTR _Needle_size$[rsp]
	mov	rsi, r9
	mov	r15, rcx
	cmp	rdi, rdx
	ja	SHORT $LN6@Traits_fin
	mov	rax, rdx
	sub	rax, rdi
	cmp	r8, rax
	ja	SHORT $LN6@Traits_fin

; 587  :     }
; 588  : 
; 589  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

	test	rdi, rdi
	jne	SHORT $LN7@Traits_fin

; 590  :         return _Start_at;

	mov	rax, r8
	jmp	SHORT $LN3@Traits_fin
$LN7@Traits_fin:

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	movsx	r14d, BYTE PTR [r9]

; 591  :     }
; 592  : 
; 593  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
; 594  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	add	rcx, r8
	mov	rbp, r15
	sub	rbp, rdi
	add	rbp, rdx

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, r14d

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [rbp+1]
	sub	r8, rcx

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	call	memchr
	mov	rbx, rax

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	je	SHORT $LN6@Traits_fin
	npad	12
$LL4@Traits_fin:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, rbx
	call	memcmp

; 597  :             return static_cast<size_t>(-1);
; 598  :         }
; 599  : 
; 600  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	test	eax, eax
	je	SHORT $LN17@Traits_fin

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	inc	rbx
	lea	r8, QWORD PTR [rbp+1]
	sub	r8, rbx

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	rcx, rbx
	mov	edx, r14d
	call	memchr
	mov	rbx, rax

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	jne	SHORT $LL4@Traits_fin
$LN6@Traits_fin:

; 578  :         // xpos cannot exist, report failure
; 579  :         // N4950 [string.view.find]/3 says:
; 580  :         // 1. _Start_at <= xpos
; 581  :         // 2. xpos + _Needle_size <= _Hay_size;
; 582  :         // therefore:
; 583  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 584  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 585  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 586  :         return static_cast<size_t>(-1);

	mov	rax, -1
$LN3@Traits_fin:

; 602  :         }
; 603  :     }
; 604  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN17@Traits_fin:

; 601  :             return static_cast<size_t>(_Match_try - _Haystack);

	sub	rbx, r15
	mov	rax, rbx
	jmp	SHORT $LN3@Traits_fin
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1105 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1106 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1107 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1108 : 
; 1109 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1110 :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 1111 :             _Xlength_error("size is too long for _Size_type");
; 1112 :         }
; 1113 :     }
; 1114 : 
; 1115 :     return static_cast<_Size_type>(_Len);

	mov	rax, rcx

; 1116 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1067 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1068 :         _Left = _STD move(_Right);
; 1069 :     }
; 1070 : }

	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
_TEXT	SEGMENT
this$ = 64
_Arg$dead$ = 72
_Count$ = 80
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>, COMDAT

; 2610 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN66:
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2611 :         auto& _My_data = _Mypair._Myval2;
; 2612 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2613 : 
; 2614 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2615 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2616 :         } else {
; 2617 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2618 :         }
; 2619 : 
; 2620 :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	mov	rdi, r8
	mov	rsi, rcx
	cmp	r8, rbp
	ja	$LN64@Construct

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 15
	cmp	r8, 16
	jae	SHORT $LN3@Construct

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	xor	edx, edx

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r8

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	call	memset

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;
; 2631 : 
; 2632 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2633 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rdi+rsi], 0

; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@Construct:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rdi
	mov	QWORD PTR [rsp+72], rbx
	or	rax, 15
	cmp	rax, rbp

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN22@Construct
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
$LN22@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, -1
	mov	rdx, rbp
	add	rdx, 1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, rdi

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rax

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	xor	edx, edx

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rdi

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	rcx, rax

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp
	mov	rbx, rax

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	call	memset

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0
	mov	rbx, QWORD PTR [rsp+72]

; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN64@Construct:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN62@Construct:
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
this$ = 80
_Arg$ = 88
_Count$ = 96
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 2610 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN44:
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H

; 2611 :         auto& _My_data = _Mypair._Myval2;
; 2612 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2613 : 
; 2614 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2615 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2616 :         } else {
; 2617 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2618 :         }
; 2619 : 
; 2620 :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	mov	rdi, r8
	mov	r14, rdx
	mov	rsi, rcx
	cmp	r8, rbp
	ja	$LN42@Construct

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 15
	cmp	r8, 16
	jae	SHORT $LN3@Construct

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r8

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;
; 2631 : 
; 2632 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2633 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2635 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2636 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rdi+rsi], 0

; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@Construct:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rdi
	mov	QWORD PTR [rsp+32], rbx
	or	rax, 15
	cmp	rax, rbp

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN13@Construct
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
$LN13@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, -1
	mov	rdx, rbp
	add	rdx, 1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp
	mov	rbx, rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0
	mov	rbx, QWORD PTR [rsp+32]

; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN42@Construct:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN40@Construct:
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
this$ = 64
_Arg$ = 72
_Count$ = 80
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT

; 2610 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN47:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2611 :         auto& _My_data = _Mypair._Myval2;
; 2612 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2613 : 
; 2614 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2615 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2616 :         } else {
; 2617 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2618 :         }
; 2619 : 
; 2620 :         if (_Count > max_size()) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rdi, r8
	mov	rbp, rdx
	mov	rsi, rcx
	cmp	r8, rbx
	ja	SHORT $LN45@Construct

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 15
	cmp	r8, 16
	jae	SHORT $LN3@Construct

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r8

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0

; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@Construct:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rdi
	or	rax, 15
	cmp	rax, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN13@Construct
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbx, rax
	cmp	rax, rcx
	cmovb	rbx, rcx
$LN13@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, -1
	mov	rdx, rbx
	add	rdx, 1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]
	mov	QWORD PTR [rsi], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbp

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbx

; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	jmp	memcpy
$LN45@Construct:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN43@Construct:
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAXPEAUEntry@SarcFile@@QEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAXPEAUEntry@SarcFile@@QEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SarcFile::Entry> >, COMDAT

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN21:

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN18@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {

	mov	rcx, rbx
	call	??1Entry@SarcFile@@QEAA@XZ
	add	rbx, 56					; 00000038H
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN18@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAXPEAUEntry@SarcFile@@QEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SarcFile::Entry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
_TEXT	SEGMENT
this$ = 80
_Size_increase$dead$ = 88
_Fn$dead$ = 96
<_Args_0>$ = 104
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>, COMDAT

; 4761 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN104:
	push	rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 4762 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4763 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4764 :         auto& _My_data            = _Mypair._Myval2;
; 4765 :         const size_type _Old_size = _My_data._Mysize;

	mov	r14, QWORD PTR [rcx+16]

; 4766 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rbx
	movzx	r15d, r9b
	sub	rax, r14
	mov	rsi, rcx
	cmp	rax, 1
	jb	$LN101@Reallocate

; 4768 :         }
; 4769 : 
; 4770 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4771 :         const size_type _Old_capacity = _My_data._Myres;

	mov	QWORD PTR [rsp+88], rbp
	mov	rbp, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+32], r12
	lea	r12, QWORD PTR [r14+1]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdx, r12
	or	rdx, 15
	cmp	rdx, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rbp
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	rbp, rax
	ja	SHORT $LN8@Reallocate

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax
$LN8@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4774 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rcx, rbx
	mov	QWORD PTR [rsp+96], rdi
	add	rcx, 1
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN18@Reallocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN102@Reallocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN60@Reallocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN19@Reallocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN19@Reallocate:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4779 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], r12

; 4780 :         _My_data._Myres       = _New_capacity;
; 4781 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4782 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	r8, r14
	mov	QWORD PTR [rsi+24], rbx
	mov	rcx, rdi
	cmp	rbp, 16
	jb	SHORT $LN3@Reallocate

; 4783 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy

; 4784 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4785 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [rbp+1]

; 4060 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	BYTE PTR [r14+rdi], r15b

; 4061 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [r14+rdi+1], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN63@Reallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN60@Reallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rcx
$LN63@Reallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4787 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN60@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	call	memcpy

; 4060 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	BYTE PTR [r14+rdi], r15b

; 4061 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [r14+rdi+1], 0
$LN4@Reallocate:

; 4788 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4789 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4790 :         }
; 4791 : 
; 4792 :         _ASAN_STRING_CREATE(*this);
; 4793 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+32]

; 4794 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
	ret	0
$LN102@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN101@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4767 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN99@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z
_TEXT	SEGMENT
this$ = 80
_New_size$ = 88
_Fn$dead$ = 96
<_Args_0>$ = 104
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>, COMDAT

; 4731 :     _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

$LN89:
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 4732 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4733 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4734 :         if (_New_size > max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	mov	r15, r9
	mov	r14, rdx
	mov	rsi, rcx
	cmp	rdx, rdi
	ja	$LN86@Reallocate

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rdx, 15
	mov	QWORD PTR [rsp+32], rbp

; 4736 :         }
; 4737 : 
; 4738 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	rbp, QWORD PTR [rcx+24]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	rdx, rdi

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rbp
	mov	rax, rdi
	shr	rcx, 1
	sub	rax, rcx
	cmp	rbp, rax
	ja	SHORT $LN8@Reallocate

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rdi, rdx
	cmp	rdx, rax
	cmovb	rdi, rax
$LN8@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rcx, rdi
	mov	QWORD PTR [rsp+96], rbx
	add	rcx, 1
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN18@Reallocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN87@Reallocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN60@Reallocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN19@Reallocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN19@Reallocate:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	ebx, ebx
$LN16@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, r14

; 4742 : 
; 4743 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 4744 :         _Mypair._Myval2._Orphan_all();
; 4745 :         _ASAN_STRING_REMOVE(*this);
; 4746 :         _Mypair._Myval2._Mysize = _New_size;

	mov	QWORD PTR [rsi+16], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15

; 4747 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rbx
	call	memcpy

; 3389 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [r14+rbx], 0

; 4748 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4749 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	rbp, 16
	jb	SHORT $LN3@Reallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4750 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN63@Reallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN60@Reallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN63@Reallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN3@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4757 :         return *this;

	mov	QWORD PTR [rsi], rbx
	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+32]

; 4758 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN60@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN87@Reallocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN86@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4735 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN84@Reallocate:
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEBD0@Z@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
<_Args_1>$ = 128
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>, COMDAT

; 4761 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN128:
	push	rbx
	push	rsi
	push	r12
	push	r13
	push	r15
	sub	rsp, 48					; 00000030H

; 4762 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4763 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4764 :         auto& _My_data            = _Mypair._Myval2;
; 4765 :         const size_type _Old_size = _My_data._Mysize;

	mov	r15, QWORD PTR [rcx+16]

; 4766 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	r12, QWORD PTR <_Args_1>$[rsp]
	mov	rax, rbx
	sub	rax, r15
	mov	r13, r9
	mov	rsi, rcx
	cmp	rax, rdx
	jb	$LN125@Reallocate

; 4768 :         }
; 4769 : 
; 4770 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	QWORD PTR [rsp+112], rbp
	lea	rbp, QWORD PTR [rdx+r15]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdx, rbp
	mov	QWORD PTR [rsp+32], r14

; 4771 :         const size_type _Old_capacity = _My_data._Myres;

	mov	r14, QWORD PTR [rcx+24]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rdx, 15
	cmp	rdx, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, r14
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	r14, rax
	ja	SHORT $LN8@Reallocate

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax
$LN8@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4774 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], rdi
	add	rcx, 1
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN18@Reallocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN126@Reallocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN66@Reallocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN19@Reallocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN19@Reallocate:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4779 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], rbp

; 4780 :         _My_data._Myres       = _New_capacity;

	lea	rbp, QWORD PTR [r15+rdi]
	mov	QWORD PTR [rsi+24], rbx

; 4781 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4782 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	r8, r15
	mov	rcx, rdi
	cmp	r14, 16
	jb	SHORT $LN3@Reallocate

; 4783 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy
	mov	r8, r12
	mov	rdx, r13
	mov	rcx, rbp
	call	memcpy

; 4784 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4785 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [r14+1]

; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [r12+rbp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN69@Reallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN66@Reallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rcx
$LN69@Reallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4787 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN66@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	call	memcpy
	mov	r8, r12
	mov	rdx, r13
	mov	rcx, rbp
	call	memcpy

; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [r12+rbp], 0
$LN4@Reallocate:

; 4788 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4789 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4790 :         }
; 4791 : 
; 4792 :         _ASAN_STRING_CREATE(*this);
; 4793 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi
	mov	rdi, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+112]
	mov	r14, QWORD PTR [rsp+32]

; 4794 :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r13
	pop	r12
	pop	rsi
	pop	rbx
	ret	0
$LN126@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN125@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4767 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN123@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 8
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 66   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 67   : 
; 68   :     if constexpr (_Overflow_is_possible) {
; 69   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 70   :         if (_Count > _Max_possible) {
; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	mov	rax, rcx

; 76   : }

	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 231  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN25:
	sub	rsp, 40					; 00000028H

; 232  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 233  : #if defined(_M_IX86) || defined(_M_X64)
; 234  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 235  :     if (!_STD is_constant_evaluated())
; 236  : #endif // _HAS_CXX20
; 237  :     {
; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN3@Allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN24@Allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN12@Allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 249  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Allocate:

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN4@Allocate

; 249  : }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN4@Allocate:

; 245  :         return _Traits::_Allocate(_Bytes);
; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax

; 249  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN24@Allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN22@Allocate:
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<56>, COMDAT

; 65   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 66   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 67   : 
; 68   :     if constexpr (_Overflow_is_possible) {
; 69   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 70   :         if (_Count > _Max_possible) {

	mov	rax, 329406144173384850			; 0492492492492492H
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	imul	rax, rcx, 56				; 00000038H

; 76   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 71   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<56>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@EV?$allocator@E@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >::~_Tidy_guard<std::vector<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 130  :             return _Ok;

	movzx	eax, BYTE PTR [rcx+8]

; 131  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 114  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 115  : #if !_HAS_EXCEPTIONS
; 116  :             const bool _Zero_uncaught_exceptions = true;
; 117  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 118  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909
; 119  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 120  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

	call	QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 121  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 122  : 
; 123  :             if (_Zero_uncaught_exceptions) {

	test	eax, eax
	jne	SHORT $LN2@sentry

; 124  :                 this->_Myostr._Osfx();

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN2@sentry:

; 84   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rcx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rdx+rcx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 85   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN11@sentry

; 86   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN11@sentry:

; 125  :             }
; 126  :         }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 97   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN18:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 76   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	QWORD PTR [rcx], rdx

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [r8+rdx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 78   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN8@sentry

; 79   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN8@sentry:

; 98   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN1@sentry

; 99   :                 _Ok = false;
; 100  :                 return;
; 101  :             }
; 102  : 
; 103  :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 69   :         return _Tiestr;

	mov	rcx, QWORD PTR [rcx+rbx+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 104  :             if (!_Tied || _Tied == &_Ostr) {

	test	rcx, rcx
	je	SHORT $LN4@sentry
	cmp	rcx, rbx
	je	SHORT $LN4@sentry

; 106  :                 return;
; 107  :             }
; 108  : 
; 109  :             _Tied->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 110  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	jmp	SHORT $LN1@sentry
$LN4@sentry:

; 105  :                 _Ok = true;

	mov	al, 1
$LN1@sentry:

; 111  :         }

	mov	BYTE PTR [rdi+8], al
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Ostr$ = 56
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<SarcFile::Entry> >::_Vector_val<std::_Simple_types<SarcFile::Entry> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<SarcFile::Entry> >::_Vector_val<std::_Simple_types<SarcFile::Entry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<BymlFile::Node> >::_Vector_val<std::_Simple_types<BymlFile::Node> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<BymlFile::Node> >::_Vector_val<std::_Simple_types<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN43:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	rdi, 209622091746699450			; 02e8ba2e8ba2e8baH
	mov	rbx, rcx
	cmp	rdx, rdi
	ja	$LN41@Clear_and_

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r9, QWORD PTR [rcx]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rdi

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, r9
	mov	QWORD PTR [rsp+64], rsi
	sar	rcx, 3
	mov	rsi, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	imul	rcx, rsi

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rcx
	shr	r8, 1
	sub	rax, r8
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rdi, QWORD PTR [r8+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rdi, rdx
	cmovb	rdi, rdx
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	r9, r9
	je	SHORT $LN3@Clear_and_

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, r9
	call	??$_Destroy_range@V?$allocator@VNode@BymlFile@@@std@@@std@@YAXPEAVNode@BymlFile@@QEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Destroy_range<std::allocator<BymlFile::Node> >

; 1666 :             _ASAN_VECTOR_REMOVE;
; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rbx+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 88				; 00000058H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rdi
	call	?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z ; std::allocator<BymlFile::Node>::allocate
	mov	rsi, QWORD PTR [rsp+64]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rbx], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rbx+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	imul	rcx, rdi, 88				; 00000058H
	add	rcx, rax
	mov	QWORD PTR [rbx+16], rcx

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN24@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN41@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Xlength
	int	3
$LN39@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@PEAE00@Z ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN7:
	sub	rsp, 40					; 00000028H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN6@Buy_nonzer

; 2011 :     }

	add	rsp, 40					; 00000028H

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	jmp	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
$LN6@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN4@Buy_nonzer:
?_Buy_nonzero@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN40:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	mov	r8, rdx
	mov	rbx, rcx
	cmp	rdx, rdi
	ja	SHORT $LN38@Clear_and_

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rdi

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, rdx
	shr	r9, 1
	sub	rax, r9
	cmp	rdx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rdi, QWORD PTR [r9+rdx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rdi, r8
	cmovb	rdi, r8
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN3@Clear_and_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN3@Clear_and_:

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);

	mov	rdx, rdi
	mov	rcx, rbx

; 1675 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);

	jmp	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
$LN24@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN38@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN36@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Requested$ = 16
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4727 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, QWORD PTR [rcx+24]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rdx, 15
	mov	r9, 9223372036854775807			; 7fffffffffffffffH
	cmp	rdx, r9

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN4@Calculate_
$LN9@Calculate_:

; 4728 :     }

	mov	rax, r9
	ret	0
$LN4@Calculate_:

; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r8, rax
	mov	rcx, r9
	shr	r8, 1
	sub	rcx, r8
	cmp	rax, rcx
	ja	SHORT $LN9@Calculate_

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rcx, QWORD PTR [r8+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmp	rdx, rcx
	cmovb	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4727 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, rdx

; 4728 :     }

	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT

; 4588 :     _CONSTEXPR20 bool _Equal(_In_z_ const _Elem* const _Ptr) const noexcept {

$LN19:
	sub	rsp, 40					; 00000028H

; 400  :             return __builtin_strlen(_First);

	mov	rax, -1
	npad	5
$LL16@Equal:
	inc	rax
	cmp	BYTE PTR [rdx+rax], 0
	jne	SHORT $LL16@Equal

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 4589 :         // compare [0, size()) with _Ptr for equality
; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	r8, QWORD PTR [rcx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Equal

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN6@Equal:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rax
	jne	SHORT $LN12@Equal

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN12@Equal

; 4589 :         // compare [0, size()) with _Ptr for equality
; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	al, 1

; 4591 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Equal:

; 4589 :         // compare [0, size()) with _Ptr for equality
; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	xor	al, al

; 4591 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 4129 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 4130 :         const size_type _Storage_max = // can always store small string
; 4131 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4132 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 4133 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4134 :         );
; 4135 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@data

; 4111 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 4112 :     }

	ret	0
$LN8@data:

; 4111 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 4112 :     }

	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
_Ptr$ = 24
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 400  :             return __builtin_strlen(_First);

	mov	r9, -1
	npad	9
$LL5@insert:
	inc	r9
	cmp	BYTE PTR [r8+r9], 0
	jne	SHORT $LL5@insert

; 3536 :         // insert [_Ptr, <null>) at _Off
; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	jmp	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z
_TEXT	SEGMENT
this$ = 96
__formal$dead$ = 104
_Source_of_al$dead$ = 112
_Left_ptr$ = 120
_Left_size$ = 128
_Right_ptr$ = 136
_Right_size$ = 144
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2783 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

$LN77:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r14, QWORD PTR _Left_size$[rsp]

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	edx, edx

; 2784 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2785 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2786 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2787 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

	mov	r15, QWORD PTR _Right_size$[rsp]
	xorps	xmm0, xmm0
	mov	r13, QWORD PTR _Right_ptr$[rsp]

; 2788 :         size_type _New_capacity = _BUF_SIZE - 1;

	mov	edi, 15

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2783 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

	mov	r12, r9

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rdx

; 2784 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2785 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2786 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2787 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

	lea	rbp, QWORD PTR [r14+r15]

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rdx

; 2783 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

	mov	rsi, rcx

; 2789 :         auto& _My_data          = _Mypair._Myval2;
; 2790 :         _Elem* _Ptr             = _My_data._Bx._Buf;

	mov	rbx, rcx

; 2791 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2792 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2793 : 
; 2794 :         if (_New_capacity < _New_size) {

	cmp	rbp, rdi
	jbe	SHORT $LN2@basic_stri

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rbp
	or	rax, rdi
	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	cmp	rax, rdi

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN24@basic_stri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rdi, rax
	cmp	rax, rcx
	cmovb	rdi, rcx
$LN24@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2796 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

	mov	rcx, rdi
	mov	rax, -1
	add	rcx, 1
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN34@basic_stri

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN75@basic_stri

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN43@basic_stri

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN32@basic_stri
$LN43@basic_stri:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN34@basic_stri:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN35@basic_stri

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN32@basic_stri
$LN35@basic_stri:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	mov	rbx, rdx
$LN32@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2798 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

	mov	QWORD PTR [rsi], rbx
$LN2@basic_stri:

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, r14

; 2799 : 
; 2800 :             _Start_element_lifetimes(_Ptr, _New_capacity + 1);
; 2801 :         }
; 2802 : 
; 2803 :         _My_data._Mysize = _New_size;

	mov	QWORD PTR [rsi+16], rbp

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12

; 2804 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rbx
	call	memcpy

; 2805 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2806 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

	lea	rcx, QWORD PTR [r14+rbx]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, r15
	mov	rdx, r13
	call	memcpy

; 2807 :         _Traits::assign(_Ptr[_New_size], _Elem());

	mov	BYTE PTR [rbx+rbp], 0

; 2810 :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN75@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN73@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z
_TEXT	SEGMENT
_Ptr$dead$ = 8
_Size$dead$ = 16
?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes, COMDAT

; 2593 :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 2594 :         // but likely more impactful to throughput.
; 2595 : #if _HAS_CXX20
; 2596 :         if (_STD is_constant_evaluated()) {
; 2597 :             for (size_type _Idx = 0; _Idx < _Size; ++_Idx) {
; 2598 :                 _STD construct_at(_Ptr + _Idx);
; 2599 :             }
; 2600 :         }
; 2601 : #else // ^^^ C++20-or-later / pre-C++20 vvv
; 2602 :         (void) _Ptr;
; 2603 :         (void) _Size;
; 2604 : #endif // _HAS_CXX20
; 2605 :     }

	ret	0
?_Start_element_lifetimes@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXQEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Start_element_lifetimes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 :     };
; 2291 :     _Bxty _Bx;
; 2292 : 
; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 :     };
; 2291 :     _Bxty _Bx;
; 2292 : 
; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Ch$ = 24
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::find, COMDAT

; 408  :         const _Elem& _Ch) noexcept /* strengthened */ {

	mov	rax, rdx

; 409  :         // look for _Ch in [_First, _First + _Count)
; 410  : #if _HAS_CXX17
; 411  : #ifdef __cpp_char8_t
; 412  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 413  : #if _HAS_U8_INTRINSICS
; 414  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 415  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 416  :             return _Primary_char_traits::find(_First, _Count, _Ch);
; 417  : #endif // _HAS_U8_INTRINSICS
; 418  :         } else
; 419  : #endif // __cpp_char8_t
; 420  :         {
; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	movsx	edx, BYTE PTR [r8]
	mov	r8, rax
	jmp	memchr
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 83   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN9:
	sub	rsp, 40					; 00000028H

; 84   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rdx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 85   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN2@Sentry_bas

; 86   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 87   :             }
; 88   :         }

	add	rsp, 40					; 00000028H
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 76   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rcx], rdx
	mov	rbx, rcx

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [r8+rdx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 78   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN7@Sentry_bas

; 79   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
$LN7@Sentry_bas:

; 80   :             }
; 81   :         }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@CAXXZ PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@CAXXZ ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 329406144173384850			; 0492492492492492H

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 1980 :         // allocate array with _Newcapacity elements
; 1981 :         auto& _My_data    = _Mypair._Myval2;
; 1982 :         pointer& _Myfirst = _My_data._Myfirst;
; 1983 :         pointer& _Mylast  = _My_data._Mylast;
; 1984 :         pointer& _Myend   = _My_data._Myend;
; 1985 : 
; 1986 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1987 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1988 : 
; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z ; std::allocator<BymlFile::Node>::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	imul	rdx, rbx, 88				; 00000058H

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi], rax
	add	rdx, rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rdx
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Buy_raw@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]
	mov	rax, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	sub	r8, QWORD PTR [rcx]
	sar	r8, 3
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 209622091746699450			; 02e8ba2e8ba2e8baH
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 209622091746699450			; 02e8ba2e8ba2e8baH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN7@Buy_raw

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN34@Buy_raw

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@Buy_raw

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN5@Buy_raw
$LN16@Buy_raw:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@Buy_raw:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN8@Buy_raw

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN5@Buy_raw
$LN8@Buy_raw:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN5@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN34@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN32@Buy_raw:
?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax
	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Requested$ = 8
_Old$ = 16
_Max$ = 24
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rcx, 15
	cmp	rcx, r8

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN7@Calculate_

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r9, rdx
	mov	rax, r8
	shr	r9, 1
	sub	rax, r9
	cmp	rdx, rax
	ja	SHORT $LN7@Calculate_

; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r9+rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmp	rcx, rax
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	rax, rcx

; 4724 :     }

	ret	0
$LN7@Calculate_:

; 4720 :             return _Max;

	mov	rax, r8

; 4724 :     }

	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
_TEXT	SEGMENT
this$ = 64
_Off$dead$ = 72
_Ptr$ = 80
_Count$ = 88
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 3487 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN82:
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r14, r8
	mov	r15, rcx

; 2260 :         if (_Mysize < _Off) {

	mov	r8, QWORD PTR [rcx+16]

; 3487 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	mov	rdi, r9

; 3488 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 3489 :         _Mypair._Myval2._Check_offset(_Off);
; 3490 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3491 : 
; 3492 :         // We can't check for overlapping ranges when constant evaluated since comparison of pointers into string
; 3493 :         // literals is unspecified, so always reallocate and copy to the new buffer if constant evaluated.
; 3494 : #if _HAS_CXX20
; 3495 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();

	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, rcx
	sub	rax, r8
	cmp	r9, rax
	ja	$LN2@insert
	mov	QWORD PTR [rsp+64], rbx

; 3496 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 3497 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
; 3498 : #endif // _HAS_CXX20
; 3499 : 
; 3500 :         if (_Check_overlap) {
; 3501 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3502 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [r8+r9]
	mov	QWORD PTR [r15+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rbx, r15

; 3488 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 3489 :         _Mypair._Myval2._Check_offset(_Off);
; 3490 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3491 : 
; 3492 :         // We can't check for overlapping ranges when constant evaluated since comparison of pointers into string
; 3493 :         // literals is unspecified, so always reallocate and copy to the new buffer if constant evaluated.
; 3494 : #if _HAS_CXX20
; 3495 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();

	mov	QWORD PTR [rsp+72], rsi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rcx, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN16@insert

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [r15]
$LN16@insert:

; 3503 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3504 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 3505 :             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
; 3506 :             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
; 3507 :             size_type _Ptr_shifted_after;
; 3508 :             if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {

	lea	rax, QWORD PTR [r14+r9]
	cmp	rax, rbx
	jbe	SHORT $LN5@insert
	lea	rax, QWORD PTR [rbx+r8]
	cmp	r14, rax
	ja	SHORT $LN5@insert

; 3511 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

	cmp	rbx, r14
	ja	SHORT $LN6@insert

; 3512 :                 _Ptr_shifted_after = 0;

	xor	esi, esi

; 3513 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

	jmp	SHORT $LN7@insert
$LN6@insert:

; 3514 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

	mov	rsi, rbx
	sub	rsi, r14
	jmp	SHORT $LN7@insert
$LN5@insert:

; 3509 :                 // inserted content is before the shifted region, or does not alias
; 3510 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts

	mov	rsi, rdi
$LN7@insert:

; 3515 :             }
; 3516 : 
; 3517 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	r8
	lea	rcx, QWORD PTR [rbx+r9]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memmove

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, rbx
	call	memcpy

; 3518 :             _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
; 3519 :             _Traits::copy(

	mov	r8, rdi
	lea	rdx, QWORD PTR [rsi+r14]
	sub	r8, rsi
	lea	rcx, QWORD PTR [rbx+rsi]
	add	rdx, rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 3520 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 3521 :             return *this;

	mov	rsi, QWORD PTR [rsp+72]
	mov	rax, r15
	mov	rbx, QWORD PTR [rsp+64]

; 3525 :             _Count,
; 3526 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3527 :                 const _Elem* const _Ptr, const size_type _Count) {
; 3528 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3529 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3530 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3531 :             },
; 3532 :             _Off, _Ptr, _Count);
; 3533 :     }

	mov	rdi, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r15
	ret	0
$LN2@insert:

; 3522 :         }
; 3523 : 
; 3524 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+40], rdi
	mov	rdx, rdi
	mov	rcx, r15
	mov	QWORD PTR [rsp+32], r14
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>

; 3525 :             _Count,
; 3526 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3527 :                 const _Elem* const _Ptr, const size_type _Count) {
; 3528 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3529 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3530 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3531 :             },
; 3532 :             _Off, _Ptr, _Count);
; 3533 :     }

	mov	rdi, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r15
	ret	0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Off$dead$ = 80
_Ptr$ = 88
_Count$ = 96
??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>::operator(), COMDAT

; 3527 :                 const _Elem* const _Ptr, const size_type _Count) {

$LN39:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rbx, QWORD PTR _Count$[rsp]

; 3527 :                 const _Elem* const _Ptr, const size_type _Count) {

	mov	rdi, rdx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, QWORD PTR _Ptr$[rsp]

; 3527 :                 const _Elem* const _Ptr, const size_type _Count) {

	mov	rbp, r8

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
	mov	rcx, rdi

; 3527 :                 const _Elem* const _Ptr, const size_type _Count) {

	mov	rsi, r9

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 3528 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3529 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3530 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbp

; 3528 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3529 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3530 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	rcx, QWORD PTR [rdi+rbx]

; 3531 :             },

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	jmp	memcpy
??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	xorps	xmm0, xmm0
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UEntry@SarcFile@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UEntry@SarcFile@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 329406144173384850			; 0492492492492492H

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UEntry@SarcFile@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UEntry@SarcFile@@@std@@QEAAPEAUEntry@SarcFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UEntry@SarcFile@@@std@@QEAAPEAUEntry@SarcFile@@_K@Z PROC ; std::allocator<SarcFile::Entry>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 329406144173384850			; 0492492492492492H
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	imul	rcx, rdx, 56				; 00000038H

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UEntry@SarcFile@@@std@@QEAAPEAUEntry@SarcFile@@_K@Z ENDP ; std::allocator<SarcFile::Entry>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	sar	rax, 3
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SA_KAEBV?$allocator@VNode@BymlFile@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SA_KAEBV?$allocator@VNode@BymlFile@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 209622091746699450			; 02e8ba2e8ba2e8baH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SA_KAEBV?$allocator@VNode@BymlFile@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z PROC ; std::allocator<BymlFile::Node>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 209622091746699450			; 02e8ba2e8ba2e8baH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	imul	rcx, rdx, 88				; 00000058H

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z ENDP ; std::allocator<BymlFile::Node>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]

; 1880 :     }

	ret	0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@E@std@@QEAAPEAE_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@E@std@@QEAAPEAE_K@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN28:
	sub	rsp, 40					; 00000028H

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN5@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN27@allocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN14@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN14@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@allocate:

; 244  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN6@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN6@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN27@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN25@allocate:
?allocate@?$allocator@E@std@@QEAAPEAE_K@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z
_TEXT	SEGMENT
_RNext$ = 8
_UVal$ = 16
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z PROC	; std::_UIntegral_to_buff<char,unsigned int>, COMDAT

; 442  : _NODISCARD _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) {

	mov	r8d, edx
	npad	13
$LL4@UIntegral_:

; 443  :     // format _UVal into buffer *ending at* _RNext
; 444  :     static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
; 445  : 
; 446  : #ifdef _WIN64
; 447  :     auto _UVal_trunc = _UVal;
; 448  : #else // ^^^ _WIN64 / !_WIN64 vvv
; 449  : 
; 450  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 451  :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 452  :         while (_UVal > 0xFFFFFFFFU) {
; 453  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 454  :             _UVal /= 1000000000;
; 455  : 
; 456  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 457  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 458  :                 _UVal_chunk /= 10;
; 459  :             }
; 460  :         }
; 461  :     }
; 462  : 
; 463  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 464  : #endif // _WIN64
; 465  : 
; 466  :     do {
; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	rcx
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	r9d, DWORD PTR [rax+rdx]
	add	r9b, r9b
	sub	r8b, r9b
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [rcx], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 469  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL4@UIntegral_

; 470  :     return _RNext;

	mov	rax, rcx

; 471  : }

	ret	0
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ENDP	; std::_UIntegral_to_buff<char,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Al$dead$ = 72
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>, COMDAT

; 2570 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN19:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2570 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rcx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2571 :         _Adl_verify_range(_First, _Last);
; 2572 :         auto _UFirst = _Get_unwrapped(_First);
; 2573 :         auto _ULast  = _Get_unwrapped(_Last);
; 2574 :         if (_UFirst == _ULast) {

	cmp	rdx, r8
	jne	SHORT $LN2@allocator

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al

; 2580 :                     _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2581 :             } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
; 2582 :                 const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
; 2583 :                 const auto _Count  = _Convert_size<size_type>(_Length);
; 2584 :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast), _Count);
; 2585 :             } else {
; 2586 :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));
; 2587 :             }
; 2588 :         }
; 2589 :     }

	mov	rax, rcx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@allocator:

; 2575 :             _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2576 :             _Tidy_init();
; 2577 :         } else {
; 2578 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2579 :                 _Construct<_Construct_strategy::_From_ptr>(

	sub	r8, rdx
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>

; 2580 :                     _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2581 :             } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
; 2582 :                 const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
; 2583 :                 const auto _Count  = _Convert_size<size_type>(_Length);
; 2584 :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast), _Count);
; 2585 :             } else {
; 2586 :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));
; 2587 :             }
; 2588 :         }
; 2589 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z
_TEXT	SEGMENT
_RNext$ = 8
_UVal$ = 16
??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z PROC	; std::_UIntegral_to_buff<char,unsigned __int64>, COMDAT

; 442  : _NODISCARD _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) {

	mov	r8, rdx

; 443  :     // format _UVal into buffer *ending at* _RNext
; 444  :     static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
; 445  : 
; 446  : #ifdef _WIN64
; 447  :     auto _UVal_trunc = _UVal;

	mov	r10, -3689348814741910323		; cccccccccccccccdH
	npad	3
$LL4@UIntegral_:

; 448  : #else // ^^^ _WIN64 / !_WIN64 vvv
; 449  : 
; 450  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 451  :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 452  :         while (_UVal > 0xFFFFFFFFU) {
; 453  :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 454  :             _UVal /= 1000000000;
; 455  : 
; 456  :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 457  :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 458  :                 _UVal_chunk /= 10;
; 459  :             }
; 460  :         }
; 461  :     }
; 462  : 
; 463  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 464  : #endif // _WIN64
; 465  : 
; 466  :     do {
; 467  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	rcx
	mov	rax, r10
	mul	r8
	shr	rdx, 3
	movzx	eax, dl
	shl	al, 2
	lea	r9d, DWORD PTR [rax+rdx]
	add	r9b, r9b
	sub	r8b, r9b
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [rcx], r8b

; 468  :         _UVal_trunc /= 10;

	mov	r8, rdx

; 469  :     } while (_UVal_trunc != 0);

	test	rdx, rdx
	jne	SHORT $LL4@UIntegral_

; 470  :     return _RNext;

	mov	rax, rcx

; 471  : }

	ret	0
??$_UIntegral_to_buff@D_K@std@@YAPEADPEAD_K@Z ENDP	; std::_UIntegral_to_buff<char,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>, COMDAT

; 491  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

$LN103:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r15, r8
	mov	r12, rdx
	mov	rsi, rcx

; 492  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 493  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 494  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR _State$[rsp], ebx

; 497  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	mov	rax, QWORD PTR [rcx]
	movsxd	r9, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase

; 290  :         return _Wide;

	mov	rdi, QWORD PTR [r9+rcx+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 497  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	test	rdi, rdi
	jle	SHORT $LN10@Insert_str
	cmp	rdi, r8
	jbe	SHORT $LN10@Insert_str

; 499  :     } else {
; 500  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

	sub	rdi, r8
	jmp	SHORT $LN9@Insert_str
$LN10@Insert_str:

; 498  :         _Pad = 0;

	xor	edi, edi
$LN9@Insert_str:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 76   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	r14, rsi
	mov	QWORD PTR _Ok$[rsp], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [r9+rcx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 78   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN68@Insert_str

; 79   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN68@Insert_str:

; 98   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN99@Insert_str

; 99   :                 _Ok = false;
; 100  :                 return;
; 101  :             }
; 102  : 
; 103  :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 69   :         return _Tiestr;

	mov	rcx, QWORD PTR [rcx+rsi+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 104  :             if (!_Tied || _Tied == &_Ostr) {

	test	rcx, rcx
	je	SHORT $LN64@Insert_str
	cmp	rcx, rsi
	je	SHORT $LN64@Insert_str

; 106  :                 return;
; 107  :             }
; 108  : 
; 109  :             _Tied->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 110  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	jmp	SHORT $LN99@Insert_str
$LN64@Insert_str:

; 105  :                 _Ok = true;

	mov	al, 1
$LN99@Insert_str:

; 111  :         }

	mov	BYTE PTR _Ok$[rsp+8], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 505  :     if (!_Ok) {

	test	al, al
	jne	SHORT $LN11@Insert_str

; 506  :         _State |= _Ostr_t::badbit;

	mov	ebx, 4

; 507  :     } else { // state okay, insert characters

	jmp	$LN23@Insert_str
$LN11@Insert_str:

; 509  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase

; 249  :         return _Fmtfl;

	mov	eax, DWORD PTR [rcx+rsi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 509  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN93@Insert_str
$LL4@Insert_str:

; 510  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	rdi, rdi
	je	SHORT $LN93@Insert_str

; 511  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	jne	SHORT $LN2@Insert_str

; 512  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	ebx, 4
	mov	DWORD PTR _State$[rsp], ebx

; 513  :                     break;

	jmp	SHORT $LL96@Insert_str
$LN2@Insert_str:

; 510  :             for (; 0 < _Pad; --_Pad) { // pad on left

	dec	rdi
	jmp	SHORT $LL4@Insert_str
$LN93@Insert_str:

; 514  :                 }
; 515  :             }
; 516  :         }
; 517  : 
; 518  :         if (_State == _Ostr_t::goodbit
; 519  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	r8, r15
	mov	rdx, r12
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
	cmp	rax, r15
	jne	SHORT $LN100@Insert_str
$LL96@Insert_str:

; 520  :             _State |= _Ostr_t::badbit;
; 521  :         } else {
; 522  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	rdi, rdi
	je	SHORT $LN6@Insert_str

; 523  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	je	SHORT $LN100@Insert_str

; 520  :             _State |= _Ostr_t::badbit;
; 521  :         } else {
; 522  :             for (; 0 < _Pad; --_Pad) { // pad on right

	dec	rdi
	jmp	SHORT $LL96@Insert_str
$LN100@Insert_str:

; 524  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 525  :                     break;
; 526  :                 }
; 527  :             }
; 528  :         }
; 529  : 
; 530  :         _Ostr.width(0);

	or	ebx, 4
	mov	DWORD PTR _State$[rsp], ebx
$LN6@Insert_str:
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase

; 296  :         _Wide                      = _Newwidth;

	mov	QWORD PTR [rcx+rsi+40], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
	jmp	SHORT $LN23@Insert_str
$LN24@Insert_str:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xiosbase
	mov	rsi, QWORD PTR _Ostr$[rsp]
	mov	ebx, DWORD PTR _State$[rsp]
	mov	r14, QWORD PTR _Ok$[rsp]
$LN23@Insert_str:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 534  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	mov	edx, ebx
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 120  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

	call	QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 121  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 122  : 
; 123  :             if (_Zero_uncaught_exceptions) {

	test	eax, eax
	jne	SHORT $LN26@Insert_str

; 124  :                 this->_Myostr._Osfx();

	mov	rcx, r14
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN26@Insert_str:

; 84   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [r14]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+r14+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ostream

; 85   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN97@Insert_str

; 86   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN97@Insert_str:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 536  : }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?dtor$11@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$11
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$11@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$17

; 531  :         _CATCH_IO_(_Ostr_t, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$17
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEAVNode@BymlFile@@@std@@YA$$QEAPEAVNode@BymlFile@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAVNode@BymlFile@@@std@@YA$$QEAPEAVNode@BymlFile@@AEAPEAV12@@Z PROC ; std::move<BymlFile::Node * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEAVNode@BymlFile@@@std@@YA$$QEAPEAVNode@BymlFile@@AEAPEAV12@@Z ENDP ; std::move<BymlFile::Node * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAVNode@BymlFile@@@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAVNode@BymlFile@@@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z PROC ; std::_Get_unwrapped<BymlFile::Node *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAVNode@BymlFile@@@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z ENDP ; std::_Get_unwrapped<BymlFile::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z PROC ; std::_Uninitialized_copy_n<BymlFile::Node *,std::allocator<BymlFile::Node> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN252:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN249@Uninitiali
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0Node@BymlFile@@QEAA@AEBV01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 88					; 00000058H
	mov	QWORD PTR _Backout$[rsp+8], rdi

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	add	rbx, 88					; 00000058H
	sub	rsi, 1
	jne	SHORT $LL4@Uninitiali
$LN249@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z ENDP ; std::_Uninitialized_copy_n<BymlFile::Node *,std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<BymlFile::Node *,std::allocator<BymlFile::Node> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::~_Uninitialized_backout_al<std::allocator<BymlFile::Node> >
?dtor$0@?0???$_Uninitialized_copy_n@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0AEAV?$allocator@VNode@BymlFile@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<BymlFile::Node *,std::allocator<BymlFile::Node> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAVNode@BymlFile@@_KPEAV12@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAVNode@BymlFile@@_KPEAV12@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0@Z PROC ; std::_Copy_n_unchecked4<BymlFile::Node *,unsigned __int64,BymlFile::Node *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN481:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rdx
	mov	rsi, rcx

; 4557 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4558 :     // note: has callers outside the copy family
; 4559 : #ifdef __cpp_lib_concepts
; 4560 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4561 : #endif // __cpp_lib_concepts
; 4562 : 
; 4563 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4564 : #if _HAS_CXX20
; 4565 :         if (!_STD is_constant_evaluated())
; 4566 : #endif // _HAS_CXX20
; 4567 :         {
; 4568 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4569 :         }
; 4570 :     }
; 4571 : 
; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	SHORT $LN477@Copy_n_unc
	sub	rsi, rbx
$LL4@Copy_n_unc:

; 4573 :         *_Dest = *_First;

	lea	rdx, QWORD PTR [rsi+rbx]
	mov	rcx, rbx
	call	??4Node@BymlFile@@QEAAAEAV01@AEBV01@@Z
	add	rbx, 88					; 00000058H
	sub	rdi, 1
	jne	SHORT $LL4@Copy_n_unc
$LN477@Copy_n_unc:

; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEAVNode@BymlFile@@_KPEAV12@@std@@YAPEAVNode@BymlFile@@PEAV12@_K0@Z ENDP ; std::_Copy_n_unchecked4<BymlFile::Node *,unsigned __int64,BymlFile::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBVNode@BymlFile@@@std@@YAAEBVNode@BymlFile@@AEBV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBVNode@BymlFile@@@std@@YAAEBVNode@BymlFile@@AEBV12@@Z PROC ; std::forward<BymlFile::Node const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBVNode@BymlFile@@@std@@YAAEBVNode@BymlFile@@AEBV12@@Z ENDP ; std::forward<BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
<_Val_0>$ = 56
??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_back_with_unused_capacity<BymlFile::Node const &>, COMDAT

; 789  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN14:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rbx, QWORD PTR [rcx+8]
	mov	QWORD PTR $T1[rsp], rbx
	mov	rcx, rbx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rdi+24]
	mov	BYTE PTR [rbx+24], al
	lea	rcx, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR [rdi+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+64]
	lea	rdx, QWORD PTR [rdi+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rsi+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+88]
	mov	QWORD PTR [rsi+8], rcx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_back_with_unused_capacity<BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
<_Val_0>$ = 56
?dtor$0@?0???$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_back_with_unused_capacity<BymlFile::Node const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_back_with_unused_capacity<BymlFile::Node const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
<_Val_0>$ = 56
?dtor$1@?0???$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_back_with_unused_capacity<BymlFile::Node const &>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$_Emplace_back_with_unused_capacity@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAAEAVNode@BymlFile@@AEBV23@@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_back_with_unused_capacity<BymlFile::Node const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z
_TEXT	SEGMENT
_Newvec$ = 32
$T1 = 40
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_reallocate<BymlFile::Node const &>, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN31:
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r15, r8
	mov	r13, rdx
	mov	r14, rcx

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, rdx
	sub	r9, r8
	mov	r10, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	mov	rax, r10
	imul	r9
	mov	rdi, rdx
	sar	rdi, 4
	mov	rax, rdi
	shr	rax, 63					; 0000003fH
	add	rdi, rax

; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r12, QWORD PTR [rcx+8]
	sub	r12, r8
	sar	r12, 3
	imul	r12, r10

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 209622091746699450			; 02e8ba2e8ba2e8baH
	cmp	r12, rbx
	je	$LN30@Emplace_re

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	inc	r12

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r10

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN27@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, r12
	cmovb	rbx, r12
$LN27@Emplace_re:

; 829  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 830  : 
; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	call	?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z ; std::allocator<BymlFile::Node>::allocate
	mov	rsi, rax
	mov	QWORD PTR _Newvec$[rsp], rax

; 832  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	imul	rdi, rdi, 88				; 00000058H
	add	rdi, rax
	lea	rax, QWORD PTR [rdi+88]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 833  :         pointer _Constructed_first      = _Constructed_last;

	mov	QWORD PTR _Constructed_first$[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdi
	mov	rdx, r15
	mov	rcx, rdi
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [r15+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [r15+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [r15+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 837  :         _Constructed_first = _Newvec + _Whereoff;

	mov	QWORD PTR _Constructed_first$[rsp], rdi

; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rdx, QWORD PTR [r14+8]
	mov	rcx, QWORD PTR [r14]
	mov	r8, rsi
	cmp	r13, rdx
	je	SHORT $LN28@Emplace_re

; 840  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 841  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             } else {
; 843  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 844  :             }
; 845  :         } else { // provide basic guarantee
; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	rdx, r13
	call	??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Uninitialized_move<BymlFile::Node *,std::allocator<BymlFile::Node> >

; 847  :             _Constructed_first = _Newvec;

	mov	QWORD PTR _Constructed_first$[rsp], rsi

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	lea	r8, QWORD PTR [rdi+88]
	mov	rdx, QWORD PTR [r14+8]
	mov	rcx, r13
$LN28@Emplace_re:
	call	??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Uninitialized_move<BymlFile::Node *,std::allocator<BymlFile::Node> >
	npad	1

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, r12
	mov	rdx, rsi
	mov	rcx, r14
	call	?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Change_array

; 857  :         return _Newvec + _Whereoff;

	mov	rax, rdi

; 858  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN30@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Xlength
	int	3
$LN26@Emplace_re:
??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_reallocate<BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
$T1 = 40
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?dtor$0@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_reallocate<BymlFile::Node const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_reallocate<BymlFile::Node const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
$T1 = 40
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?dtor$1@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_reallocate<BymlFile::Node const &>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_reallocate<BymlFile::Node const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
$T1 = 40
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?catch$3@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_reallocate<BymlFile::Node const &>'::`1'::catch$3

; 850  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z$0:

; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rdx, QWORD PTR _Constructed_last$[rbp]
	mov	rcx, QWORD PTR _Constructed_first$[rbp]
	call	??$_Destroy_range@V?$allocator@VNode@BymlFile@@@std@@@std@@YAXPEAVNode@BymlFile@@QEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z ; std::_Destroy_range<std::allocator<BymlFile::Node> >

; 852  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	call	?deallocate@?$allocator@VNode@BymlFile@@@std@@QEAAXQEAVNode@BymlFile@@_K@Z ; std::allocator<BymlFile::Node>::deallocate

; 853  :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$3@?0???$_Emplace_reallocate@AEBVNode@BymlFile@@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAPEAVNode@BymlFile@@QEAV23@AEBV23@@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Emplace_reallocate<BymlFile::Node const &>'::`1'::catch$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN99:
	push	rbx
	push	rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rsi, rdx
	mov	r14, rcx
	cmp	rdx, rbx
	ja	$LN96@Resize_rea
	mov	QWORD PTR [rsp+80], rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbp, QWORD PTR [rcx+8]
	sub	rbp, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [r14]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+88], rdi
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	jbe	SHORT $LN10@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow

	mov	rcx, -9223372036854775770		; 8000000000000026H
$LN29@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN28@Resize_rea

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN17@Resize_rea
$LN10@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rsi
	cmovb	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN82@Resize_rea

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN97@Resize_rea
	jmp	SHORT $LN29@Resize_rea
$LN28@Resize_rea:

; 142  :     }
; 143  : 
; 144  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN82@Resize_rea:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN20@Resize_rea

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN17@Resize_rea
$LN20@Resize_rea:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN17@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r8, rsi
	lea	rcx, QWORD PTR [rdi+rbp]
	sub	r8, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rsi
	mov	rdx, rdi
	mov	rcx, r14
	mov	rbp, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rsi
	pop	rbx

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
$LN96@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN97@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN94@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN27:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	xor	edx, edx

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	mov	rbx, rcx

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	memset

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rdi+rbx]

; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {
; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPEAEPEAE_KAEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z PROC		; std::move<unsigned char * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEAE@std@@YA$$QEAPEAEAEAPEAE@Z ENDP		; std::move<unsigned char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAE@std@@YA?A_T$$QEAPEAE@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAE@std@@YA?A_T$$QEAPEAE@Z PROC	; std::_Get_unwrapped<unsigned char *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAE@std@@YA?A_T$$QEAPEAE@Z ENDP	; std::_Get_unwrapped<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAEV?$allocator@E@std@@@std@@YAPEAEPEAE_K0AEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy_n@PEAEV?$allocator@E@std@@@std@@YAPEAEPEAE_K0AEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_copy_n<unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN25:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rdi+rbx]

; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {
; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAEV?$allocator@E@std@@@std@@YAPEAEPEAE_K0AEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_copy_n<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove_n@PEAEPEAE@std@@YAPEAEPEAE_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_memmove_n@PEAEPEAE@std@@YAPEAEPEAE_K0@Z PROC	; std::_Copy_memmove_n<unsigned char *,unsigned char *>, COMDAT

; 4543 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {

$LN6:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4544 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);
; 4545 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4546 :         return _Result;
; 4547 :     } else { // _Result is unused so the compiler can optimize it away
; 4548 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
; 4549 :     }
; 4550 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove_n@PEAEPEAE@std@@YAPEAEPEAE_K0@Z ENDP	; std::_Copy_memmove_n<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAE_KPEAE@std@@YAPEAEPEAE_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAE_KPEAE@std@@YAPEAEPEAE_K0@Z PROC ; std::_Copy_n_unchecked4<unsigned char *,unsigned __int64,unsigned char *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN16:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4557 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4558 :     // note: has callers outside the copy family
; 4559 : #ifdef __cpp_lib_concepts
; 4560 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4561 : #endif // __cpp_lib_concepts
; 4562 : 
; 4563 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4564 : #if _HAS_CXX20
; 4565 :         if (!_STD is_constant_evaluated())
; 4566 : #endif // _HAS_CXX20
; 4567 :         {
; 4568 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4569 :         }
; 4570 :     }
; 4571 : 
; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEAE_KPEAE@std@@YAPEAEPEAE_K0@Z ENDP ; std::_Copy_n_unchecked4<unsigned char *,unsigned __int64,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z PROC ; std::forward<std::allocator<unsigned char> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@E@std@@@std@@YA$$QEAV?$allocator@E@0@AEAV10@@Z ENDP ; std::forward<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z PROC		; std::forward<unsigned char *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAE@std@@YA$$QEAPEAEAEAPEAE@Z ENDP		; std::forward<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z PROC		; std::forward<unsigned char * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAE@std@@YAAEBQEAEAEBQEAE@Z ENDP		; std::forward<unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z PROC ; std::ranges::_Unwrap_iter<unsigned char *,unsigned char *>, COMDAT

; 2488 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2489 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2490 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2491 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2492 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2493 :         } else {
; 2494 :             return static_cast<_Iter&&>(_It);
; 2495 :         }
; 2496 :     }

	ret	0
??$_Unwrap_iter@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ENDP ; std::ranges::_Unwrap_iter<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z PROC ; std::ranges::_Unwrap_sent<unsigned char *,unsigned char *>, COMDAT

; 2501 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2502 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2503 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2504 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2505 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2506 :         } else {
; 2507 :             return static_cast<_Sent&&>(_Se);
; 2508 :         }
; 2509 :     }

	ret	0
??$_Unwrap_sent@PEAEPEAE@ranges@std@@YA?A_T$$QEAPEAE@Z ENDP ; std::ranges::_Unwrap_sent<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN23:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1850 :             return _Dest;

	sub	rsi, rbx
	lea	rax, QWORD PTR [rdi+rsi]

; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Uninitialized_copy@PEAEPEAEV?$allocator@E@std@@@std@@YAPEAEPEAE00AEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z PROC		; std::_To_address<unsigned char *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z ENDP		; std::_To_address<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UEntry@SarcFile@@@std@@YAPEAUEntry@SarcFile@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UEntry@SarcFile@@@std@@YAPEAUEntry@SarcFile@@PEAU12@@Z PROC ; std::_Unfancy<SarcFile::Entry>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UEntry@SarcFile@@@std@@YAPEAUEntry@SarcFile@@PEAU12@@Z ENDP ; std::_Unfancy<SarcFile::Entry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@UEntry@SarcFile@@@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@UEntry@SarcFile@@@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::destroy<SarcFile::Entry>, COMDAT

; 724  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	rcx, rdx
	jmp	??1Entry@SarcFile@@QEAA@XZ
??$destroy@UEntry@SarcFile@@@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::destroy<SarcFile::Entry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z PROC ; std::construct_at<char *,char * &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEADAEAPEAD$0A@@std@@YAPEAPEADQEAPEADAEAPEAD@Z ENDP ; std::construct_at<char *,char * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 137  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN17:
	sub	rsp, 40					; 00000028H

; 138  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN16@Allocate_m

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 142  :     }
; 143  : 
; 144  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN7@Allocate_m

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 148  : 
; 149  : #ifdef _DEBUG
; 150  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 151  : #endif // _DEBUG
; 152  :     return _Ptr;
; 153  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@Allocate_m:

; 142  :     }
; 143  : 
; 144  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN16@Allocate_m:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN14@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@E@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@E@std@@YAPEAEPEAE@Z PROC			; std::_Unfancy<unsigned char>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@E@std@@YAPEAEPEAE@Z ENDP			; std::_Unfancy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z PROC		; std::construct_at<char,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@D$$V$0A@@std@@YAPEADQEAD@Z ENDP		; std::construct_at<char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$dead$ = 120
<_Args_1>$ = 128
<_Args_2>$ = 136
??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>, COMDAT

; 4761 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN148:
	push	rbx
	push	rsi
	push	r12
	push	r13
	push	r14
	sub	rsp, 48					; 00000030H

; 4762 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4763 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4764 :         auto& _My_data            = _Mypair._Myval2;
; 4765 :         const size_type _Old_size = _My_data._Mysize;

	mov	r14, QWORD PTR [rcx+16]

; 4766 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	r12, QWORD PTR <_Args_2>$[rsp]
	mov	rax, rbx
	mov	r13, QWORD PTR <_Args_1>$[rsp]
	sub	rax, r14
	mov	rsi, rcx
	cmp	rax, rdx
	jb	$LN145@Reallocate

; 4768 :         }
; 4769 : 
; 4770 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4771 :         const size_type _Old_capacity = _My_data._Myres;

	mov	QWORD PTR [rsp+112], rbp
	mov	rbp, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+32], r15
	lea	r15, QWORD PTR [rdx+r14]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdx, r15
	or	rdx, 15
	cmp	rdx, rbx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rbp
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	rbp, rax
	ja	SHORT $LN8@Reallocate

; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax
$LN8@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4774 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], rdi
	add	rcx, 1
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN18@Reallocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN146@Reallocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN72@Reallocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN19@Reallocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN19@Reallocate:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4779 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], r15

; 4780 :         _My_data._Myres       = _New_capacity;

	lea	r15, QWORD PTR [r12+rdi]
	mov	QWORD PTR [rsi+24], rbx

; 4781 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4782 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	r8, r12
	mov	rdx, r13
	mov	rcx, rdi
	cmp	rbp, 16
	jb	SHORT $LN3@Reallocate

; 4783 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
	lea	r8, QWORD PTR [r14+1]
	mov	rdx, rbx
	mov	rcx, r15
	call	memcpy

; 4784 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4785 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN75@Reallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN72@Reallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rcx
$LN75@Reallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4787 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN72@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
	lea	r8, QWORD PTR [r14+1]
	mov	rdx, rsi
	mov	rcx, r15
	call	memcpy
$LN4@Reallocate:

; 4788 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4789 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4790 :         }
; 4791 : 
; 4792 :         _ASAN_STRING_CREATE(*this);
; 4793 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi
	mov	rdi, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+112]
	mov	r15, QWORD PTR [rsp+32]

; 4794 :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	pop	rbx
	ret	0
$LN146@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN145@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4767 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN143@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<88>, COMDAT

; 65   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 66   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 67   : 
; 68   :     if constexpr (_Overflow_is_possible) {
; 69   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 70   :         if (_Count > _Max_possible) {

	mov	rax, 209622091746699450			; 02e8ba2e8ba2e8baH
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	imul	rax, rcx, 88				; 00000058H

; 76   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 71   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$0FI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<88>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAPEAVNode@BymlFile@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::~_Uninitialized_backout_al<std::allocator<BymlFile::Node> >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN188:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+64]
	call	?_Tidy@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 88					; 00000058H
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::~_Uninitialized_backout_al<std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@PEAVNode@BymlFile@@AEAV?$allocator@VNode@BymlFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@PEAVNode@BymlFile@@AEAV?$allocator@VNode@BymlFile@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@PEAVNode@BymlFile@@AEAV?$allocator@VNode@BymlFile@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAPEAUEntry@SarcFile@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::~_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
	mov	rcx, rbx
	call	??1Entry@SarcFile@@QEAA@XZ
	add	rbx, 56					; 00000038H
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::~_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@PEAUEntry@SarcFile@@AEAV?$allocator@UEntry@SarcFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@PEAUEntry@SarcFile@@AEAV?$allocator@UEntry@SarcFile@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@PEAUEntry@SarcFile@@AEAV?$allocator@UEntry@SarcFile@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBAXPEAVNode@BymlFile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBAXPEAVNode@BymlFile@@0@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEBAXPEAVNode@BymlFile@@0@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN184:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r14, r9
	mov	r15, r8
	mov	rbp, rdx
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN157@Change_arr
	mov	QWORD PTR [rsp+72], rsi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+64]
	call	?_Tidy@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 88					; 00000058H
	cmp	rbx, rsi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 88				; 00000058H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN169@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN166@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN169@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN157@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	QWORD PTR [rdi], rbp
	imul	rax, r15, 88				; 00000058H
	add	rax, rbp
	mov	QWORD PTR [rdi+8], rax
	imul	rax, r14, 88				; 00000058H
	add	rax, rbp
	mov	rbp, QWORD PTR [rsp+88]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN166@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN181@Change_arr:
?_Change_array@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXQEAVNode@BymlFile@@_K1@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp]
	mov	QWORD PTR [rbx], rdi

; 2033 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi]
	mov	rsi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 80
_Arg$ = 88
_Count$ = 96
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>, COMDAT

; 2610 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN44:
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H

; 2611 :         auto& _My_data = _Mypair._Myval2;
; 2612 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2613 : 
; 2614 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2615 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2616 :         } else {
; 2617 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2618 :         }
; 2619 : 
; 2620 :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	mov	rdi, r8
	mov	r14, rdx
	mov	rsi, rcx
	cmp	r8, rbp
	ja	$LN42@Construct

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rcx+24], 15
	cmp	r8, 16
	jae	SHORT $LN3@Construct

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r8

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;
; 2631 : 
; 2632 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2633 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2635 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2636 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rdi+rsi], 0

; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@Construct:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rdi
	mov	QWORD PTR [rsp+32], rbx
	or	rax, 15
	cmp	rax, rbp

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN13@Construct
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
$LN13@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, -1
	mov	rdx, rbp
	add	rdx, 1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rax

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp
	mov	rbx, rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0
	mov	rbx, QWORD PTR [rsp+32]

; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN42@Construct:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN40@Construct:
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEAVNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEAVNode@BymlFile@@@Z
_TEXT	SEGMENT
this$ = 48
<_Vals_0>$ = 56
??$_Emplace_back@AEAVNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEAVNode@BymlFile@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Emplace_back<BymlFile::Node &>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN424:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
	call	??0Node@BymlFile@@QEAA@AEBV01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rbx+8], 88			; 00000058H

; 1804 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Emplace_back@AEAVNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAXAEAVNode@BymlFile@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Emplace_back<BymlFile::Node &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z
_TEXT	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node const &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN12:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdx
	mov	rdx, r8
	mov	rcx, rbx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rdi+24]
	mov	BYTE PTR [rbx+24], al
	lea	rcx, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR [rdi+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+64]
	lea	rdx, QWORD PTR [rdi+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
?dtor$0@?0???$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
?dtor$1@?0???$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node const &>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$construct@VNode@BymlFile@@AEBV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEBV34@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAVNode@BymlFile@@@std@@YA?A_TAEBQEAVNode@BymlFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAVNode@BymlFile@@@std@@YA?A_TAEBQEAVNode@BymlFile@@@Z PROC ; std::_Get_unwrapped<BymlFile::Node * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAVNode@BymlFile@@@std@@YA?A_TAEBQEAVNode@BymlFile@@@Z ENDP ; std::_Get_unwrapped<BymlFile::Node * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z PROC ; std::_Uninitialized_move<BymlFile::Node *,std::allocator<BymlFile::Node> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN111:
	push	rbx
	mov	r11, r8
	mov	rbx, rdx

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	$LN106@Uninitiali
	mov	r10, r11
	mov	QWORD PTR [rsp+24], rdi
	sub	r10, rcx
	lea	r8, QWORD PTR [rcx+80]
	xor	edi, edi
	npad	14
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8-64]
	xorps	xmm0, xmm0
	mov	rcx, QWORD PTR [r8-72]
	mov	rax, QWORD PTR [r8-80]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-64], rdi
	mov	QWORD PTR [r8-72], rdi
	mov	QWORD PTR [r8-80], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10-72], rcx
	mov	QWORD PTR [r11], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	r11, 88					; 00000058H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10-64], rdx
	movzx	eax, BYTE PTR [r8-56]
	mov	BYTE PTR [r8+r10-56], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8+r10-48], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r8+r10-32], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+r10-24], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8-48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [r8+r10-136], xmm0
	movups	xmm1, XMMWORD PTR [r8-120]
	movups	XMMWORD PTR [r8+r10-120], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8-120], rdi
	mov	QWORD PTR [r8-112], 15
	mov	BYTE PTR [r8-136], dil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-104]
	mov	r9, QWORD PTR [r8-88]
	mov	rdx, QWORD PTR [r8-96]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-88], rdi
	mov	QWORD PTR [r8-96], rdi
	mov	QWORD PTR [r8-104], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10-104], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10-96], rdx
	mov	QWORD PTR [r8+r10-88], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rbx
	jne	$LL4@Uninitiali
	mov	rdi, QWORD PTR [rsp+24]
$LN106@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, r11
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAVNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@QEAV12@0PEAV12@AEAV?$allocator@VNode@BymlFile@@@0@@Z ENDP ; std::_Uninitialized_move<BymlFile::Node *,std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z PROC	; std::_Get_unwrapped<unsigned char * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z ENDP	; std::_Get_unwrapped<unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN23:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1940 :             return _Dest + (_ULast - _UFirst);

	sub	rsi, rbx
	lea	rax, QWORD PTR [rdi+rsi]

; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 2017 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2018 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 2019 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	mov	rbx, rdx
	sub	r8, rcx
	xor	edx, edx
	call	memset

; 2021 :     return _Last;

	mov	rax, rbx

; 2022 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Zero_range@PEAE@std@@YAPEAEQEAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	BYTE PTR [rax], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char &>, COMDAT

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 1803 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1804 :     }

	ret	0
??$_Emplace_back@AEAE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEAE@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z PROC	; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z ENDP	; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@E@std@@YAPEAEQEAE@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@E@std@@YAPEAEQEAE@Z PROC			; std::to_address<unsigned char>, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@E@std@@YAPEAEQEAE@Z ENDP			; std::to_address<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z PROC ; std::construct_at<char *,char * const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEADAEBQEAD$0A@@std@@YAPEAPEADQEAPEADAEBQEAD@Z ENDP ; std::construct_at<char *,char * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@UEntry@SarcFile@@@std@@YAXQEAUEntry@SarcFile@@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@UEntry@SarcFile@@@std@@YAXQEAUEntry@SarcFile@@@Z PROC ; std::destroy_at<SarcFile::Entry>, COMDAT

; 314  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

	jmp	??1Entry@SarcFile@@QEAA@XZ
??$destroy_at@UEntry@SarcFile@@@std@@YAXQEAUEntry@SarcFile@@@Z ENDP ; std::destroy_at<SarcFile::Entry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1Entry@SarcFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Entry@SarcFile@@QEAA@XZ PROC				; SarcFile::Entry::~Entry, COMDAT
$LN39:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx+32]
	test	rcx, rcx
	je	SHORT $LN6@Entry

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+48]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@Entry

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@Entry

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@Entry:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+32], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+40], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+48], rax
$LN6@Entry:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN21@Entry:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN36@Entry:
??1Entry@SarcFile@@QEAA@XZ ENDP				; SarcFile::Entry::~Entry
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GEntry@SarcFile@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GEntry@SarcFile@@QEAAPEAXI@Z PROC			; SarcFile::Entry::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1Entry@SarcFile@@QEAA@XZ
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GEntry@SarcFile@@QEAAPEAXI@Z ENDP			; SarcFile::Entry::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAVNode@BymlFile@@@std@@YAAEAVNode@BymlFile@@AEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAVNode@BymlFile@@@std@@YAAEAVNode@BymlFile@@AEAV12@@Z PROC ; std::forward<BymlFile::Node &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAVNode@BymlFile@@@std@@YAAEAVNode@BymlFile@@AEAV12@@Z ENDP ; std::forward<BymlFile::Node &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@VNode@BymlFile@@AEAV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEAV34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VNode@BymlFile@@AEAV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEAV34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, r8
	jmp	??0Node@BymlFile@@QEAA@AEBV01@@Z
??$construct@VNode@BymlFile@@AEAV12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@AEAV34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z
_TEXT	SEGMENT
$T1 = 48
_Location$ = 48
<_Args_0>$ = 56
??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z PROC ; std::construct_at<BymlFile::Node,BymlFile::Node const &,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN10:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rcx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	rax, rdi

; 242  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z ENDP ; std::construct_at<BymlFile::Node,BymlFile::Node const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
_Location$ = 48
<_Args_0>$ = 56
?dtor$0@?0???$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z@4HA PROC ; `std::construct_at<BymlFile::Node,BymlFile::Node const &,0>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z@4HA ENDP ; `std::construct_at<BymlFile::Node,BymlFile::Node const &,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
_Location$ = 48
<_Args_0>$ = 56
?dtor$1@?0???$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z@4HA PROC ; `std::construct_at<BymlFile::Node,BymlFile::Node const &,0>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$construct_at@VNode@BymlFile@@AEBV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEBV12@@Z@4HA ENDP ; `std::construct_at<BymlFile::Node,BymlFile::Node const &,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAVNode@BymlFile@@@std@@YA$$QEAVNode@BymlFile@@AEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAVNode@BymlFile@@@std@@YA$$QEAVNode@BymlFile@@AEAV12@@Z PROC ; std::move<BymlFile::Node &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAVNode@BymlFile@@@std@@YA$$QEAVNode@BymlFile@@AEAV12@@Z ENDP ; std::move<BymlFile::Node &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@VNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX$$QEAVNode@BymlFile@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@VNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX$$QEAVNode@BymlFile@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Emplace_back<BymlFile::Node>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN72:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r10, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	edi, edi

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	r11, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]
	xorps	xmm0, xmm0

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], rdi
	mov	QWORD PTR [rdx+8], rdi
	mov	QWORD PTR [rdx], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], r9
	movzx	eax, BYTE PTR [rdx+24]
	mov	BYTE PTR [r10+24], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r10+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+48], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+56], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [r10+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [r10+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+48], rdi
	mov	QWORD PTR [rdx+56], 15
	mov	BYTE PTR [rdx+32], dil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [r11+72]
	mov	rax, QWORD PTR [r11+64]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r11+80], rdi
	mov	QWORD PTR [r11+72], rdi
	mov	QWORD PTR [r11+64], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1804 :     }

	mov	rdi, QWORD PTR [rsp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+64], rax
	mov	QWORD PTR [r10+72], rcx
	mov	QWORD PTR [r10+80], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rbx+8], 88			; 00000058H

; 1804 :     }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
??$_Emplace_back@VNode@BymlFile@@@?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAAX$$QEAVNode@BymlFile@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::_Emplace_back<BymlFile::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAE@std@@YA$$QEAEAEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAE@std@@YA$$QEAEAEAE@Z PROC			; std::move<unsigned char &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAE@std@@YA$$QEAEAEAE@Z ENDP			; std::move<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>, COMDAT

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 1803 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1804 :     }

	ret	0
??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@E$$V@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAE@std@@YAAEAEAEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAE@std@@YAAEAEAEAE@Z PROC			; std::forward<unsigned char &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAE@std@@YAAEAEAEAE@Z ENDP			; std::forward<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@EAEAE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0Node@BymlFile@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0Node@BymlFile@@QEAA@AEBV01@@Z PROC			; BymlFile::Node::Node, COMDAT
$LN8:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	movzx	eax, BYTE PTR [rbx+24]
	mov	BYTE PTR [rdi+24], al
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rbx+64]
	call	??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
	npad	1
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0Node@BymlFile@@QEAA@AEBV01@@Z ENDP			; BymlFile::Node::Node
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0Node@BymlFile@@QEAA@AEBV01@@Z@4HA PROC	; `BymlFile::Node::Node'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???0Node@BymlFile@@QEAA@AEBV01@@Z@4HA ENDP	; `BymlFile::Node::Node'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$1@?0???0Node@BymlFile@@QEAA@AEBV01@@Z@4HA PROC	; `BymlFile::Node::Node'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???0Node@BymlFile@@QEAA@AEBV01@@Z@4HA ENDP	; `BymlFile::Node::Node'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 112
_Right$ = 120
??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >, COMDAT

; 683  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN123:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, rdx
	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 684  :         const auto& _Right_data = _Right._Mypair._Myval2;
; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]
	sar	rbx, 3
	mov	rax, 3353953467947191203		; 2e8ba2e8ba2e8ba3H
	imul	rbx, rax

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	SHORT $LN108@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 209622091746699450			; 02e8ba2e8ba2e8baH
	cmp	rbx, rax
	ja	$LN121@vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z ; std::allocator<BymlFile::Node>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	imul	rax, rbx, 88				; 00000058H
	add	rax, rdi
	mov	QWORD PTR [rsi+16], rax

; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], rsi

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbp, QWORD PTR [r14+8]
	mov	rbx, QWORD PTR [r14]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$2[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$2[rsp], rdi
	mov	QWORD PTR _Backout$2[rsp+8], rdi
	mov	QWORD PTR _Backout$2[rsp+16], rsi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rbp
	je	SHORT $LN19@vector
	npad	6
$LL20@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0Node@BymlFile@@QEAA@AEBV01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 88					; 00000058H
	mov	QWORD PTR _Backout$2[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 88					; 00000058H
	cmp	rbx, rbp
	jne	SHORT $LL20@vector
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rdi
$LN108@vector:

; 686  :         _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
; 687  :     }

	mov	rax, rsi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN121@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Xlength
	int	3
$LN119@vector:
??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 112
_Right$ = 120
?dtor$0@?0???0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > >::~_Tidy_guard<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > >
?dtor$0@?0???0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 112
_Right$ = 120
?dtor$1@?0???0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::~_Uninitialized_backout_al<std::allocator<BymlFile::Node> >
?dtor$1@?0???0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SA?AV?$allocator@VNode@BymlFile@@@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SA?AV?$allocator@VNode@BymlFile@@@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::select_on_container_copy_construction, COMDAT

; 737  :         return _Al;

	mov	rax, rcx

; 738  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SA?AV?$allocator@VNode@BymlFile@@@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@VNode@BymlFile@@AEAV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEAV12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@VNode@BymlFile@@AEAV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEAV12@@Z PROC ; std::construct_at<BymlFile::Node,BymlFile::Node &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	jmp	??0Node@BymlFile@@QEAA@AEBV01@@Z
??$construct_at@VNode@BymlFile@@AEAV12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@AEAV12@@Z ENDP ; std::construct_at<BymlFile::Node,BymlFile::Node &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@VNode@BymlFile@@@std@@YA$$QEAVNode@BymlFile@@AEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@VNode@BymlFile@@@std@@YA$$QEAVNode@BymlFile@@AEAV12@@Z PROC ; std::forward<BymlFile::Node>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@VNode@BymlFile@@@std@@YA$$QEAVNode@BymlFile@@AEAV12@@Z ENDP ; std::forward<BymlFile::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@VNode@BymlFile@@V12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@$$QEAV34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VNode@BymlFile@@V12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@$$QEAV34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [r8+16]
	xorps	xmm0, xmm0

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+16], r11
	mov	QWORD PTR [r8+8], r11
	mov	QWORD PTR [r8], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx+16], r9
	movzx	eax, BYTE PTR [r8+24]
	mov	BYTE PTR [rdx+24], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+48], r11

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+56], r11

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rdx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8+48], r11
	mov	QWORD PTR [r8+56], 15
	mov	BYTE PTR [r8+32], r11b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+80]
	mov	rcx, QWORD PTR [r8+72]
	mov	rax, QWORD PTR [r8+64]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+80], r11
	mov	QWORD PTR [r8+72], r11
	mov	QWORD PTR [r8+64], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+64], rax
	mov	QWORD PTR [r10+72], rcx
	mov	QWORD PTR [r10+80], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@VNode@BymlFile@@V12@@?$_Default_allocator_traits@V?$allocator@VNode@BymlFile@@@std@@@std@@SAXAEAV?$allocator@VNode@BymlFile@@@1@QEAVNode@BymlFile@@$$QEAV34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BymlFile::Node> >::construct<BymlFile::Node,BymlFile::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@E@std@@YA$$QEAEAEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@E@std@@YA$$QEAEAEAE@Z PROC			; std::forward<unsigned char>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@E@std@@YA$$QEAEAEAE@Z ENDP			; std::forward<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z PROC		; std::construct_at<unsigned char,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@E$$V$0A@@std@@YAPEAEQEAE@Z ENDP		; std::construct_at<unsigned char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z PROC	; std::construct_at<unsigned char,unsigned char &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@EAEAE$0A@@std@@YAPEAEQEAEAEAE@Z ENDP	; std::construct_at<unsigned char,unsigned char &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@VNode@BymlFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VNode@BymlFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@VNode@BymlFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VNode@BymlFile@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1>::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1><std::allocator<BymlFile::Node> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@VNode@BymlFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VNode@BymlFile@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1>::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1><std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z
_TEXT	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 128
_Count$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Construct_n<BymlFile::Node * const &,BymlFile::Node * const &>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN112:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN108@Construct_
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rsi, r9
	mov	r15, r8
	mov	rbx, rdx
	mov	r14, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 209622091746699450			; 02e8ba2e8ba2e8baH
	cmp	rdx, rax
	ja	$LN110@Construct_

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z ; std::allocator<BymlFile::Node>::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [r14+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	imul	rcx, rbx, 88				; 00000058H
	add	rcx, rax
	mov	QWORD PTR [r14+16], rcx

; 2066 :             _Buy_nonzero(_Count);
; 2067 :             _Tidy_guard<vector> _Guard{this};

	mov	QWORD PTR _Guard$1[rsp], r14

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rsi, QWORD PTR [rsi]
	mov	rbx, QWORD PTR [r15]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$2[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$2[rsp], rax
	mov	QWORD PTR _Backout$2[rsp+8], rax
	mov	QWORD PTR _Backout$2[rsp+16], r14

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rsi
	je	SHORT $LN13@Construct_
$LL14@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0Node@BymlFile@@QEAA@AEBV01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 88					; 00000058H
	mov	QWORD PTR _Backout$2[rsp+8], rdi

; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 88					; 00000058H
	cmp	rbx, rsi
	jne	SHORT $LL14@Construct_
$LN13@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [r14+8], rdi

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
$LN108@Construct_:
	ret	0
$LN110@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Xlength
	int	3
$LN107@Construct_:
??$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Construct_n<BymlFile::Node * const &,BymlFile::Node * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 128
_Count$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
?dtor$0@?0???$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Construct_n<BymlFile::Node * const &,BymlFile::Node * const &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$1[rdx]
	jmp	??1?$_Tidy_guard@V?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > >::~_Tidy_guard<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > >
?dtor$0@?0???$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Construct_n<BymlFile::Node * const &,BymlFile::Node * const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$1 = 32
_Backout$2 = 40
__$ArrayPad$ = 64
this$ = 128
_Count$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
?dtor$1@?0???$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z@4HA PROC ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Construct_n<BymlFile::Node * const &,BymlFile::Node * const &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::~_Uninitialized_backout_al<std::allocator<BymlFile::Node> >
?dtor$1@?0???$_Construct_n@AEBQEAVNode@BymlFile@@AEBQEAV12@@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_KAEBQEAVNode@BymlFile@@1@Z@4HA ENDP ; `std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Construct_n<BymlFile::Node * const &,BymlFile::Node * const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0Entry@SarcFile@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0Entry@SarcFile@@QEAA@AEBU01@@Z PROC			; SarcFile::Entry::Entry, COMDAT
$LN7:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0Entry@SarcFile@@QEAA@AEBU01@@Z ENDP			; SarcFile::Entry::Entry
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0Entry@SarcFile@@QEAA@AEBU01@@Z@4HA PROC	; `SarcFile::Entry::Entry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0Entry@SarcFile@@QEAA@AEBU01@@Z@4HA ENDP	; `SarcFile::Entry::Entry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > >::~_Tidy_guard<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > >::~_Tidy_guard<std::vector<BymlFile::Node,std::allocator<BymlFile::Node> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 209622091746699450			; 02e8ba2e8ba2e8baH
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN9@Buy_nonzer

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@VNode@BymlFile@@@std@@QEAAPEAVNode@BymlFile@@_K@Z ; std::allocator<BymlFile::Node>::allocate

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	imul	rcx, rbx, 88				; 00000058H

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);
; 2011 :     }

	mov	rbx, QWORD PTR [rsp+48]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rcx, rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rcx

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);
; 2011 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@CAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Xlength
	int	3
$LN7@Buy_nonzer:
?_Buy_nonzero@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@VNode@BymlFile@@V12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@$$QEAV12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@VNode@BymlFile@@V12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@$$QEAV12@@Z PROC ; std::construct_at<BymlFile::Node,BymlFile::Node,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN68:
	mov	QWORD PTR [rsp+8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	ebx, ebx
	mov	r9, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r11, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], rbx
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	movzx	eax, BYTE PTR [rdx+24]
	mov	BYTE PTR [rcx+24], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+48], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+56], rbx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+48], rbx
	mov	QWORD PTR [rdx+56], 15
	mov	BYTE PTR [rdx+32], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r10+64]
	mov	rdx, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [r10+72]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+80], rbx
	mov	QWORD PTR [r10+72], rbx
	mov	QWORD PTR [r10+64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	mov	rbx, QWORD PTR [rsp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+64], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+72], rcx
	mov	QWORD PTR [r11+80], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@VNode@BymlFile@@V12@$0A@@std@@YAPEAVNode@BymlFile@@QEAV12@$$QEAV12@@Z ENDP ; std::construct_at<BymlFile::Node,BymlFile::Node,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z PROC	; std::construct_at<unsigned char,unsigned char,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@EE$0A@@std@@YAPEAEQEAE$$QEAE@Z ENDP	; std::construct_at<unsigned char,unsigned char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@VNode@BymlFile@@@std@@@std@@YA$$QEAV?$allocator@VNode@BymlFile@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@VNode@BymlFile@@@std@@@std@@YA$$QEAV?$allocator@VNode@BymlFile@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<BymlFile::Node> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@VNode@BymlFile@@@std@@@std@@YA$$QEAV?$allocator@VNode@BymlFile@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAVNode@BymlFile@@@std@@YAAEBQEAVNode@BymlFile@@AEBQEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAVNode@BymlFile@@@std@@YAAEBQEAVNode@BymlFile@@AEBQEAV12@@Z PROC ; std::forward<BymlFile::Node * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAVNode@BymlFile@@@std@@YAAEBQEAVNode@BymlFile@@AEBQEAV12@@Z ENDP ; std::forward<BymlFile::Node * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_iter@PEAVNode@BymlFile@@PEAV12@@ranges@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEAVNode@BymlFile@@PEAV12@@ranges@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z PROC ; std::ranges::_Unwrap_iter<BymlFile::Node *,BymlFile::Node *>, COMDAT

; 2488 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2489 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2490 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2491 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2492 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2493 :         } else {
; 2494 :             return static_cast<_Iter&&>(_It);
; 2495 :         }
; 2496 :     }

	ret	0
??$_Unwrap_iter@PEAVNode@BymlFile@@PEAV12@@ranges@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z ENDP ; std::ranges::_Unwrap_iter<BymlFile::Node *,BymlFile::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_sent@PEAVNode@BymlFile@@PEAV12@@ranges@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEAVNode@BymlFile@@PEAV12@@ranges@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z PROC ; std::ranges::_Unwrap_sent<BymlFile::Node *,BymlFile::Node *>, COMDAT

; 2501 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2502 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2503 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2504 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2505 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2506 :         } else {
; 2507 :             return static_cast<_Sent&&>(_Se);
; 2508 :         }
; 2509 :     }

	ret	0
??$_Unwrap_sent@PEAVNode@BymlFile@@PEAV12@@ranges@std@@YA?A_T$$QEAPEAVNode@BymlFile@@@Z ENDP ; std::ranges::_Unwrap_sent<BymlFile::Node *,BymlFile::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z PROC ; std::_Uninitialized_copy<BymlFile::Node *,BymlFile::Node *,std::allocator<BymlFile::Node> >, COMDAT

; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN252:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1820 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1821 :     // note: only called internally from elsewhere in the STL
; 1822 :     using _Ptrval = typename _Alloc::value_type*;
; 1823 : 
; 1824 : #ifdef __cpp_lib_concepts
; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;
; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN249@Uninitiali
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0Node@BymlFile@@QEAA@AEBV01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 88					; 00000058H
	mov	QWORD PTR _Backout$[rsp+8], rdi

; 1820 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1821 :     // note: only called internally from elsewhere in the STL
; 1822 :     using _Ptrval = typename _Alloc::value_type*;
; 1823 : 
; 1824 : #ifdef __cpp_lib_concepts
; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;
; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 88					; 00000058H
	cmp	rbx, rsi
	jne	SHORT $LL4@Uninitiali
$LN249@Uninitiali:

; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z ENDP ; std::_Uninitialized_copy<BymlFile::Node *,BymlFile::Node *,std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy<BymlFile::Node *,BymlFile::Node *,std::allocator<BymlFile::Node> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<BymlFile::Node> >::~_Uninitialized_backout_al<std::allocator<BymlFile::Node> >
?dtor$0@?0???$_Uninitialized_copy@PEAVNode@BymlFile@@PEAV12@V?$allocator@VNode@BymlFile@@@std@@@std@@YAPEAVNode@BymlFile@@PEAV12@00AEAV?$allocator@VNode@BymlFile@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy<BymlFile::Node *,BymlFile::Node *,std::allocator<BymlFile::Node> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0Node@BymlFile@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0Node@BymlFile@@QEAA@$$QEAV01@@Z PROC			; BymlFile::Node::Node, COMDAT
$LN65:
	mov	QWORD PTR [rsp+8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	ebx, ebx
	mov	r9, QWORD PTR [rdx+16]
	mov	r10, rdx

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]
	mov	r11, rcx

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], rbx
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	movzx	eax, BYTE PTR [rdx+24]
	mov	BYTE PTR [rcx+24], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+48], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+56], rbx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+48], rbx
	mov	QWORD PTR [rdx+56], 15
	mov	BYTE PTR [rdx+32], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r10+64]
	mov	rdx, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [r10+72]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+80], rbx
	mov	QWORD PTR [r10+72], rbx
	mov	QWORD PTR [r10+64], rbx
	mov	rbx, QWORD PTR [rsp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+64], rax
	mov	rax, r11
	mov	QWORD PTR [r11+72], rcx
	mov	QWORD PTR [r11+80], rdx
	ret	0
??0Node@BymlFile@@QEAA@$$QEAV01@@Z ENDP			; BymlFile::Node::Node
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::vector<BymlFile::Node,std::allocator<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@VNode@BymlFile@@@std@@@std@@YA$$QEAV?$allocator@VNode@BymlFile@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@VNode@BymlFile@@@std@@@std@@YA$$QEAV?$allocator@VNode@BymlFile@@@0@AEAV10@@Z PROC ; std::move<std::allocator<BymlFile::Node> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@VNode@BymlFile@@@std@@@std@@YA$$QEAV?$allocator@VNode@BymlFile@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<BymlFile::Node> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAVNode@BymlFile@@$$T@std@@YAPEAVNode@BymlFile@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVNode@BymlFile@@$$T@std@@YAPEAVNode@BymlFile@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<BymlFile::Node *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAVNode@BymlFile@@$$T@std@@YAPEAVNode@BymlFile@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<BymlFile::Node *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@VNode@BymlFile@@@std@@PEAVNode@BymlFile@@PEAV23@PEAV23@@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VNode@BymlFile@@@1@$$QEAPEAVNode@BymlFile@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@VNode@BymlFile@@@std@@PEAVNode@BymlFile@@PEAV23@PEAV23@@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VNode@BymlFile@@@1@$$QEAPEAVNode@BymlFile@@22@Z PROC ; std::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1>::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1><std::allocator<BymlFile::Node>,BymlFile::Node *,BymlFile::Node *,BymlFile::Node *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@VNode@BymlFile@@@std@@PEAVNode@BymlFile@@PEAV23@PEAV23@@?$_Compressed_pair@V?$allocator@VNode@BymlFile@@@std@@V?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VNode@BymlFile@@@1@$$QEAPEAVNode@BymlFile@@22@Z ENDP ; std::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1>::_Compressed_pair<std::allocator<BymlFile::Node>,std::_Vector_val<std::_Simple_types<BymlFile::Node> >,1><std::allocator<BymlFile::Node>,BymlFile::Node *,BymlFile::Node *,BymlFile::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@std@@QEAA@PEAVNode@BymlFile@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@std@@QEAA@PEAVNode@BymlFile@@00@Z PROC ; std::_Vector_val<std::_Simple_types<BymlFile::Node> >::_Vector_val<std::_Simple_types<BymlFile::Node> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@VNode@BymlFile@@@std@@@std@@QEAA@PEAVNode@BymlFile@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<BymlFile::Node> >::_Vector_val<std::_Simple_types<BymlFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAVNode@BymlFile@@@std@@YA$$QEAPEAVNode@BymlFile@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVNode@BymlFile@@@std@@YA$$QEAPEAVNode@BymlFile@@AEAPEAV12@@Z PROC ; std::forward<BymlFile::Node *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAVNode@BymlFile@@@std@@YA$$QEAPEAVNode@BymlFile@@AEAPEAV12@@Z ENDP ; std::forward<BymlFile::Node *>
_TEXT	ENDS
END
