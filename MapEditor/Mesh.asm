; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0M@DDLHAGJC@modelMatrix@			; `string'
PUBLIC	??_C@_09KNKDONHI@camMatrix@			; `string'
;	COMDAT ??_C@_09KNKDONHI@camMatrix@
CONST	SEGMENT
??_C@_09KNKDONHI@camMatrix@ DB 'camMatrix', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DDLHAGJC@modelMatrix@
CONST	SEGMENT
??_C@_0M@DDLHAGJC@modelMatrix@ DB 'modelMatrix', 00H	; `string'
PUBLIC	??$construct_at@U?$mat@$03$03M$0A@@glm@@AEAU12@$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@AEAU12@@Z ; std::construct_at<glm::mat<4,4,float,0>,glm::mat<4,4,float,0> &,0>
PUBLIC	??$construct@U?$mat@$03$03M$0A@@glm@@AEAU12@@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@AEAU34@@Z ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::construct<glm::mat<4,4,float,0>,glm::mat<4,4,float,0> &>
PUBLIC	??$forward@AEAU?$mat@$03$03M$0A@@glm@@@std@@YAAEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z ; std::forward<glm::mat<4,4,float,0> &>
PUBLIC	??$_Emplace_back@AEAU?$mat@$03$03M$0A@@glm@@@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAXAEAU?$mat@$03$03M$0A@@glm@@@Z ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Emplace_back<glm::mat<4,4,float,0> &>
PUBLIC	??$_Copy_memmove@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00@Z ; std::_Copy_memmove<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *>
PUBLIC	??$_Unfancy@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@@Z ; std::_Unfancy<glm::mat<4,4,float,0> >
PUBLIC	??$to_address@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@@Z ; std::to_address<glm::mat<4,4,float,0> >
PUBLIC	??$move@AEAPEAU?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAPEAU?$mat@$03$03M$0A@@glm@@AEAPEAU12@@Z ; std::move<glm::mat<4,4,float,0> * &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@PEAU?$mat@$03$03M$0A@@glm@@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::~_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@XZ ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::__autoclassinit2
PUBLIC	??$_To_address@PEAU?$mat@$03$03M$0A@@glm@@@std@@YA?A_PAEBQEAU?$mat@$03$03M$0A@@glm@@@Z ; std::_To_address<glm::mat<4,4,float,0> *>
PUBLIC	??$_Uninitialized_copy@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z ; std::_Uninitialized_copy<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *,std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	??$_Unwrap_sent@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@ranges@std@@YA?A_T$$QEAPEAU?$mat@$03$03M$0A@@glm@@@Z ; std::ranges::_Unwrap_sent<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *>
PUBLIC	??$_Unwrap_iter@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@ranges@std@@YA?A_T$$QEAPEAU?$mat@$03$03M$0A@@glm@@@Z ; std::ranges::_Unwrap_iter<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *>
PUBLIC	??$forward@AEBQEAU?$mat@$03$03M$0A@@glm@@@std@@YAAEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@Z ; std::forward<glm::mat<4,4,float,0> * const &>
PUBLIC	??$forward@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YA$$QEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@AEAV10@@Z ; std::forward<std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::allocator<glm::mat<4,4,float,0> >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SA_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@@Z ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::max_size
PUBLIC	?max_size@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::max_size
PUBLIC	?_Buy_raw@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Buy_raw
PUBLIC	?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Xlength
PUBLIC	?_Buy_nonzero@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Buy_nonzero
PUBLIC	??1?$_Tidy_guard@V?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > > >::~_Tidy_guard<std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > > >
PUBLIC	??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Construct_n<glm::mat<4,4,float,0> * const &,glm::mat<4,4,float,0> * const &>
PUBLIC	??$?0V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1><std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	??$_Unfancy_maybe_null@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@@Z ; std::_Unfancy_maybe_null<glm::mat<4,4,float,0> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Get_first
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SA?AV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::select_on_container_copy_construction
PUBLIC	?_Getal@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Getal
PUBLIC	?size@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEBA_KXZ ; std::vector<Texture *,std::allocator<Texture *> >::size
PUBLIC	??A?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAPEAVTexture@@_K@Z ; std::vector<Texture *,std::allocator<Texture *> >::operator[]
PUBLIC	??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	?data@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@XZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::data
PUBLIC	?size@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::size
PUBLIC	?UpdateInstanceMatrix@Mesh@@QEAAXAEAV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@@Z ; Mesh::UpdateInstanceMatrix
PUBLIC	?UpdateInstances@Mesh@@QEAAXI@Z			; Mesh::UpdateInstances
PUBLIC	?DrawPicking@Mesh@@QEAAXPEAVShader@@PEAVCamera@@U?$mat@$03$03M$0A@@glm@@@Z ; Mesh::DrawPicking
PUBLIC	?Draw@Mesh@@QEAAXPEAVShader@@H@Z		; Mesh::Draw
PUBLIC	?Delete@Mesh@@QEAAXXZ				; Mesh::Delete
PUBLIC	??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z ; Mesh::Mesh
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+52
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+108
	DD	imagerel $unwind$?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$?_Buy_raw@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z DD imagerel $LN10
	DD	imagerel $LN10+71
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z DD imagerel $LN45
	DD	imagerel $LN45+42
	DD	imagerel $unwind$??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z DD imagerel $LN45+42
	DD	imagerel $LN45+120
	DD	imagerel $chain$0$??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z DD imagerel $LN45+120
	DD	imagerel $LN45+127
	DD	imagerel $chain$1$??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN51
	DD	imagerel $LN51+62
	DD	imagerel $unwind$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN51+62
	DD	imagerel $LN51+131
	DD	imagerel $chain$0$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN51+131
	DD	imagerel $LN51+149
	DD	imagerel $chain$1$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UpdateInstanceMatrix@Mesh@@QEAAXAEAV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@@Z DD imagerel $LN9
	DD	imagerel $LN9+58
	DD	imagerel $unwind$?UpdateInstanceMatrix@Mesh@@QEAAXAEAV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UpdateInstances@Mesh@@QEAAXI@Z DD imagerel $LN32
	DD	imagerel $LN32+405
	DD	imagerel $unwind$?UpdateInstances@Mesh@@QEAAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawPicking@Mesh@@QEAAXPEAVShader@@PEAVCamera@@U?$mat@$03$03M$0A@@glm@@@Z DD imagerel $LN13
	DD	imagerel $LN13+164
	DD	imagerel $unwind$?DrawPicking@Mesh@@QEAAXPEAVShader@@PEAVCamera@@U?$mat@$03$03M$0A@@glm@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Draw@Mesh@@QEAAXPEAVShader@@H@Z DD imagerel $LN60
	DD	imagerel $LN60+161
	DD	imagerel $unwind$?Draw@Mesh@@QEAAXPEAVShader@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Delete@Mesh@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+75
	DD	imagerel $unwind$?Delete@Mesh@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z DD imagerel $LN231
	DD	imagerel $LN231+1038
	DD	imagerel $unwind$??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z DB 0cH
	DB	'%', 02H
	DB	0aH
	DB	'a', 03H
	DB	0cH
	DB	'x'
	DB	0aH
	DB	0a9H, 06H
	DB	02H
	DB	'i', 02H
	DB	00H
	DB	'N'
	DB	0aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z DB 0cH
	DB	0cH
	DD	imagerel ??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ
	DB	0e0H
	DB	034H
	DD	imagerel ??1?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@XZ
	DB	0d0H
	DB	034H
	DD	imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DB	0c0H
	DB	036H
	DD	imagerel ?dtor$3@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA
	DB	02cH
	DD	imagerel ??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ
	DB	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z
	DD	imagerel $ip2state$??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z DD 0a2719H
	DD	0110119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Delete@Mesh@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Draw@Mesh@@QEAAXPEAVShader@@H@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawPicking@Mesh@@QEAAXPEAVShader@@PEAVCamera@@U?$mat@$03$03M$0A@@glm@@@Z DD 060b01H
	DD	0e007320bH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UpdateInstances@Mesh@@QEAAXI@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UpdateInstanceMatrix@Mesh@@QEAAXAEAV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+62
	DD	imagerel $unwind$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z DD 020521H
	DD	0a7405H
	DD	imagerel $LN51
	DD	imagerel $LN51+62
	DD	imagerel $unwind$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z DD 040901H
	DD	0e0053209H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+42
	DD	imagerel $unwind$??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z DD 020521H
	DD	047405H
	DD	imagerel $LN45
	DD	imagerel $LN45+42
	DD	imagerel $unwind$??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z DD 050f01H
	DD	0f00b420fH
	DD	06007e009H
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
;	COMDAT ??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z
_TEXT	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 64
vertices$GSCopy$1$ = 88
this$GSCopy$ = 96
textures$GSCopy$ = 104
instanceMatrix$GSCopy$ = 112
__$ArrayPad$ = 120
this$ = 208
vertices$ = 216
indices$ = 224
textures$ = 232
instancing$dead$ = 240
instanceMatrix$ = 248
??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z PROC ; Mesh::Mesh, COMDAT

; 13   : {

$LN231:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-15]
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-121], rax
	mov	r15, r9
	mov	r13, r8
	mov	QWORD PTR vertices$GSCopy$1$[rbp-121], rdx
	mov	rsi, rcx

; 11   : 	std::vector<glm::mat4> instanceMatrix

	mov	QWORD PTR this$GSCopy$[rbp-121], rcx
	mov	QWORD PTR textures$GSCopy$[rbp-121], r9
	mov	r14, QWORD PTR instanceMatrix$[rbp-121]
	mov	QWORD PTR instanceMatrix$GSCopy$[rbp-121], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ecx, ecx
	mov	QWORD PTR [rsi], rcx
	mov	QWORD PTR [rsi+8], rcx
	mov	QWORD PTR [rsi+16], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 13   : {

	lea	rbx, QWORD PTR [rsi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx+16], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 13   : {

	lea	rdi, QWORD PTR [rsi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdi], rcx
	mov	QWORD PTR [rdi+8], rcx
	mov	QWORD PTR [rdi+16], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 13   : {

	lea	r12, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rsi, rdx
	je	SHORT $LN225@Mesh

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdx]
	mov	r8, QWORD PTR [r12]
	sub	r8, rdx
	sar	r8, 2
	mov	rcx, rsi
	call	??$_Assign_counted_range@PEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAXPEAM_K@Z ; std::vector<float,std::allocator<float> >::_Assign_counted_range<float *>
$LN225@Mesh:

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rbx, r13
	je	SHORT $LN31@Mesh

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r13]
	mov	r8, QWORD PTR [r13+8]
	sub	r8, rdx
	sar	r8, 2
	mov	rcx, rbx
	call	??$_Assign_counted_range@PEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAXPEAI_K@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Assign_counted_range<unsigned int *>
$LN31@Mesh:

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rdi, r15
	je	SHORT $LN34@Mesh

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r15]
	mov	r8, QWORD PTR [r15+8]
	sub	r8, rdx
	sar	r8, 3
	mov	rcx, rdi
	call	??$_Assign_counted_range@PEAPEAVTexture@@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAXPEAPEAVTexture@@_K@Z ; std::vector<Texture *,std::allocator<Texture *> >::_Assign_counted_range<Texture * *>
$LN34@Mesh:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 17   : 	Mesh::instancing = instancing;

	mov	DWORD PTR [rsi+88], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 6    : 	if (Initialize) glGenVertexArrays(1, &ID);

	lea	rdx, QWORD PTR $T6[rbp-121]
	mov	ecx, 1
	call	QWORD PTR glad_glGenVertexArrays
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 19   : 	Vao = VAO(true);

	mov	ecx, DWORD PTR $T6[rbp-121]
	mov	DWORD PTR [rsi+72], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 21   : 	glBindVertexArray(ID);

	call	QWORD PTR glad_glBindVertexArray
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T7[rbp-121], xmm0
	xor	edi, edi
	mov	QWORD PTR $T7[rbp-105], rdi

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [r14+8]
	sub	rbx, QWORD PTR [r14]
	sar	rbx, 6

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	SHORT $LN79@Mesh

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	rbx, rax
	ja	$LN229@Mesh

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::allocator<glm::mat<4,4,float,0> >::allocate
	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR $T7[rbp-121], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR $T7[rbp-113], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rbx, 6
	add	rbx, rax
	mov	QWORD PTR $T7[rbp-105], rbx

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [r14+8]
	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	and	rbx, -64				; ffffffffffffffc0H
	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR $T7[rbp-113], rax
	xor	edi, edi
$LN79@Mesh:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 22   : 	instanceVBO = VBO(instanceMatrix);

	lea	rax, QWORD PTR $T7[rbp-121]
	mov	QWORD PTR $T4[rbp-121], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 13   : 	glGenBuffers(1, &ID);

	lea	rdx, QWORD PTR $T3[rbp-121]
	mov	ecx, 1
	call	QWORD PTR glad_glGenBuffers

; 14   : 	glBindBuffer(GL_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR $T3[rbp-121]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR $T7[rbp-113]
	mov	r8, QWORD PTR $T7[rbp-121]
	sub	rdx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 15   : 	glBufferData(GL_ARRAY_BUFFER, mat4s.size() * sizeof(glm::mat4), mat4s.data(), GL_STATIC_DRAW);

	and	rdx, -64				; ffffffffffffffc0H
	mov	ecx, 34962				; 00008892H
	lea	r9d, QWORD PTR [rcx+82]
	call	QWORD PTR glad_glBufferData
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T7[rbp-121]
	test	rcx, rcx
	je	SHORT $LN91@Mesh

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T7[rbp-105]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN109@Mesh

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN109@Mesh
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN109@Mesh:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR $T7[rbp-121], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR $T7[rbp-105], rdi
$LN91@Mesh:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 22   : 	instanceVBO = VBO(instanceMatrix);

	mov	eax, DWORD PTR $T3[rbp-121]
	mov	DWORD PTR [rsi+76], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 6    : 	glGenBuffers(1, &ID);

	lea	rdx, QWORD PTR $T5[rbp-121]
	mov	ecx, 1
	call	QWORD PTR glad_glGenBuffers

; 7    : 	glBindBuffer(GL_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR $T5[rbp-121]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer

; 8    : 	glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(float), vertices.data(), GL_STATIC_DRAW);

	mov	rax, QWORD PTR vertices$GSCopy$1$[rbp-121]
	mov	r8, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [r12]
	sub	rdx, r8
	sar	rdx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 8    : 	glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(float), vertices.data(), GL_STATIC_DRAW);

	lea	rdx, QWORD PTR [rdx*4]
	mov	ecx, 34962				; 00008892H
	lea	r9d, QWORD PTR [rcx+82]
	call	QWORD PTR glad_glBufferData
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 23   : 	Vbo = VBO(vertices);

	mov	eax, DWORD PTR $T5[rbp-121]
	mov	DWORD PTR [rsi+80], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp

; 6    : 	glGenBuffers(1, &ID);

	lea	rdx, QWORD PTR $T2[rbp-121]
	mov	ecx, 1
	call	QWORD PTR glad_glGenBuffers

; 7    : 	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR $T2[rbp-121]
	mov	ecx, 34963				; 00008893H
	call	QWORD PTR glad_glBindBuffer

; 8    : 	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(int), indices.data(), GL_STATIC_DRAW);

	mov	r8, QWORD PTR [r13]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [r13+8]
	sub	rdx, r8
	sar	rdx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp

; 8    : 	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(int), indices.data(), GL_STATIC_DRAW);

	lea	rdx, QWORD PTR [rdx*4]
	mov	ecx, 34963				; 00008893H
	lea	r9d, QWORD PTR [rcx+81]
	call	QWORD PTR glad_glBufferData
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 25   : 	Ebo = EBO(indices);

	mov	eax, DWORD PTR $T2[rbp-121]
	mov	DWORD PTR [rsi+84], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 21   : 	glBindBuffer(GL_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR [rsi+80]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 13   : 	glVertexAttribPointer(layout, numComponents, type, GL_FALSE, stride, offset);

	mov	QWORD PTR [rsp+40], rdi
	mov	DWORD PTR [rsp+32], 20
	xor	r9d, r9d
	lea	edx, QWORD PTR [r9+3]
	xor	ecx, ecx
	mov	r8d, 5126				; 00001406H
	call	QWORD PTR glad_glVertexAttribPointer

; 14   : 	glEnableVertexAttribArray(layout);

	xor	ecx, ecx
	call	QWORD PTR glad_glEnableVertexAttribArray
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 27   : 	glBindBuffer(GL_ARRAY_BUFFER, 0);

	xor	edx, edx
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer

; 21   : 	glBindBuffer(GL_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR [rsi+80]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 13   : 	glVertexAttribPointer(layout, numComponents, type, GL_FALSE, stride, offset);

	mov	QWORD PTR [rsp+40], 12
	mov	DWORD PTR [rsp+32], 20
	xor	r9d, r9d
	lea	edx, QWORD PTR [r9+2]
	lea	ecx, QWORD PTR [rdx-1]
	mov	r8d, 5126				; 00001406H
	call	QWORD PTR glad_glVertexAttribPointer

; 14   : 	glEnableVertexAttribArray(layout);

	mov	ecx, 1
	call	QWORD PTR glad_glEnableVertexAttribArray
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 27   : 	glBindBuffer(GL_ARRAY_BUFFER, 0);

	xor	edx, edx
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 27   : 	glBindVertexArray(0);

	xor	ecx, ecx
	call	QWORD PTR glad_glBindVertexArray
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 27   : 	glBindBuffer(GL_ARRAY_BUFFER, 0);

	xor	edx, edx
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
	xor	edx, edx
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp

; 20   : 	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

	xor	edx, edx
	mov	ecx, 34963				; 00008893H
	call	QWORD PTR glad_glBindBuffer
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [r15]
	test	rcx, rcx
	je	SHORT $LN146@Mesh

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR [r15+16]
	sub	rax, rcx
	sar	rax, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN164@Mesh

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN161@Mesh

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN164@Mesh:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [r15], rdi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [r15+8], rdi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [r15+16], rdi
$LN146@Mesh:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [r14]
	test	rcx, rcx
	je	SHORT $LN172@Mesh

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [r14+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN190@Mesh

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN187@Mesh

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN190@Mesh:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [r14], rdi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [r14+8], rdi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [r14+16], rdi
$LN172@Mesh:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 48   : }

	mov	rax, rsi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-121]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN161@Mesh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN187@Mesh:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN229@Mesh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Xlength
	int	3
$LN227@Mesh:
??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z ENDP ; Mesh::Mesh
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 64
vertices$GSCopy$1$ = 88
this$GSCopy$ = 96
textures$GSCopy$ = 104
instanceMatrix$GSCopy$ = 112
__$ArrayPad$ = 120
this$ = 208
vertices$ = 216
indices$ = 224
textures$ = 232
instancing$dead$ = 240
instanceMatrix$ = 248
?dtor$0@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA PROC ; `Mesh::Mesh'::`1'::dtor$0
	mov	rcx, QWORD PTR instanceMatrix$GSCopy$[rdx]
	jmp	??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::~vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
?dtor$0@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA ENDP ; `Mesh::Mesh'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 64
vertices$GSCopy$1$ = 88
this$GSCopy$ = 96
textures$GSCopy$ = 104
instanceMatrix$GSCopy$ = 112
__$ArrayPad$ = 120
this$ = 208
vertices$ = 216
indices$ = 224
textures$ = 232
instancing$dead$ = 240
instanceMatrix$ = 248
?dtor$1@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA PROC ; `Mesh::Mesh'::`1'::dtor$1
	mov	rcx, QWORD PTR textures$GSCopy$[rdx]
	jmp	??1?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@XZ ; std::vector<Texture *,std::allocator<Texture *> >::~vector<Texture *,std::allocator<Texture *> >
?dtor$1@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA ENDP ; `Mesh::Mesh'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 64
vertices$GSCopy$1$ = 88
this$GSCopy$ = 96
textures$GSCopy$ = 104
instanceMatrix$GSCopy$ = 112
__$ArrayPad$ = 120
this$ = 208
vertices$ = 216
indices$ = 224
textures$ = 232
instancing$dead$ = 240
instanceMatrix$ = 248
?dtor$2@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA PROC ; `Mesh::Mesh'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$2@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA ENDP ; `Mesh::Mesh'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 64
vertices$GSCopy$1$ = 88
this$GSCopy$ = 96
textures$GSCopy$ = 104
instanceMatrix$GSCopy$ = 112
__$ArrayPad$ = 120
this$ = 208
vertices$ = 216
indices$ = 224
textures$ = 232
instancing$dead$ = 240
instanceMatrix$ = 248
?dtor$3@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA PROC ; `Mesh::Mesh'::`1'::dtor$3
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 24
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$3@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA ENDP ; `Mesh::Mesh'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 64
vertices$GSCopy$1$ = 88
this$GSCopy$ = 96
textures$GSCopy$ = 104
instanceMatrix$GSCopy$ = 112
__$ArrayPad$ = 120
this$ = 208
vertices$ = 216
indices$ = 224
textures$ = 232
instancing$dead$ = 240
instanceMatrix$ = 248
?dtor$4@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA PROC ; `Mesh::Mesh'::`1'::dtor$4
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@XZ ; std::vector<Texture *,std::allocator<Texture *> >::~vector<Texture *,std::allocator<Texture *> >
?dtor$4@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA ENDP ; `Mesh::Mesh'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 64
vertices$GSCopy$1$ = 88
this$GSCopy$ = 96
textures$GSCopy$ = 104
instanceMatrix$GSCopy$ = 112
__$ArrayPad$ = 120
this$ = 208
vertices$ = 216
indices$ = 224
textures$ = 232
instancing$dead$ = 240
instanceMatrix$ = 248
?dtor$7@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA PROC ; `Mesh::Mesh'::`1'::dtor$7
	mov	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::~vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
?dtor$7@?0???0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z@4HA ENDP ; `Mesh::Mesh'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
;	COMDAT ?Delete@Mesh@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Delete@Mesh@@QEAAXXZ PROC				; Mesh::Delete, COMDAT

; 124  : {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 33   : 	glDeleteVertexArrays(1, &ID);

	lea	rdx, QWORD PTR [rcx+72]
	mov	ecx, 1
	call	QWORD PTR glad_glDeleteVertexArrays
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 33   : 	glDeleteBuffers(1, &ID);

	lea	rdx, QWORD PTR [rbx+76]
	mov	ecx, 1
	call	QWORD PTR glad_glDeleteBuffers
	lea	rdx, QWORD PTR [rbx+80]
	mov	ecx, 1
	call	QWORD PTR glad_glDeleteBuffers
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp

; 26   : 	glDeleteBuffers(1, &ID);

	lea	rdx, QWORD PTR [rbx+84]
	mov	ecx, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 129  : }

	add	rsp, 32					; 00000020H
	pop	rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp

; 26   : 	glDeleteBuffers(1, &ID);

	rex_jmp	QWORD PTR glad_glDeleteBuffers
?Delete@Mesh@@QEAAXXZ ENDP				; Mesh::Delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Texture.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
;	COMDAT ?Draw@Mesh@@QEAAXPEAVShader@@H@Z
_TEXT	SEGMENT
this$ = 64
GameShader$dead$ = 72
AlbedoTexCount$dead$ = 80
?Draw@Mesh@@QEAAXPEAVShader@@H@Z PROC			; Mesh::Draw, COMDAT

; 51   : {

$LN60:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 21   : 	glBindVertexArray(ID);

	mov	ecx, DWORD PTR [rcx+72]
	call	QWORD PTR glad_glBindVertexArray
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 67   : 		for (unsigned int i = 0; i < textures.size(); i++)

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rbx+56]
	sub	rax, rdx
	sar	rax, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 67   : 		for (unsigned int i = 0; i < textures.size(); i++)

	test	rax, rax
	je	SHORT $LN6@Draw
	mov	ecx, edi
	npad	2
$LL7@Draw:

; 68   : 		{
; 69   : 			textures[i]->Bind();

	mov	rcx, QWORD PTR [rdx+rcx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Texture.cpp

; 130  : 	glBindTexture(type, ID);

	mov	edx, DWORD PTR [rcx]
	mov	ecx, DWORD PTR [rcx+4]
	call	QWORD PTR glad_glBindTexture
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 67   : 		for (unsigned int i = 0; i < textures.size(); i++)

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rbx+56]
	sub	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 67   : 		for (unsigned int i = 0; i < textures.size(); i++)

	mov	ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 67   : 		for (unsigned int i = 0; i < textures.size(); i++)

	cmp	rcx, rax
	jb	SHORT $LL7@Draw
$LN6@Draw:

; 70   : 		}
; 71   : 	}
; 72   : 
; 73   : 	// Check if instance drawing should be performed
; 74   : 	if (instancing == 1)

	mov	rdx, QWORD PTR [rbx+32]
	xor	r9d, r9d
	sub	rdx, QWORD PTR [rbx+24]
	mov	r8d, 5125				; 00001405H
	mov	eax, DWORD PTR [rbx+88]
	lea	ecx, QWORD PTR [r9+4]
	cmp	eax, 1
	jne	SHORT $LN10@Draw

; 75   : 	{
; 76   : 		// Draw the actual mesh
; 77   : 		glDrawElements(GL_TRIANGLES, sizeof(int) * indices.size(), GL_UNSIGNED_INT, 0);

	and	edx, -4

; 82   : 	}
; 83   : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi

; 75   : 	{
; 76   : 		// Draw the actual mesh
; 77   : 		glDrawElements(GL_TRIANGLES, sizeof(int) * indices.size(), GL_UNSIGNED_INT, 0);

	rex_jmp	QWORD PTR glad_glDrawElements
$LN10@Draw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rdx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 81   : 		glDrawElementsInstanced(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0, instancing);

	mov	DWORD PTR [rsp+32], eax
	call	QWORD PTR glad_glDrawElementsInstanced

; 82   : 	}
; 83   : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?Draw@Mesh@@QEAAXPEAVShader@@H@Z ENDP			; Mesh::Draw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
;	COMDAT ?DrawPicking@Mesh@@QEAAXPEAVShader@@PEAVCamera@@U?$mat@$03$03M$0A@@glm@@@Z
_TEXT	SEGMENT
this$ = 80
Shader$ = 88
Camera$ = 96
Matrix$ = 104
?DrawPicking@Mesh@@QEAAXPEAVShader@@PEAVCamera@@U?$mat@$03$03M$0A@@glm@@@Z PROC ; Mesh::DrawPicking, COMDAT

; 86   : {

$LN13:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	r14, rcx
	mov	rbp, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp

; 75   : 	glUseProgram(ID);

	mov	ecx, DWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 86   : {

	mov	rdi, r8
	mov	rsi, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp

; 75   : 	glUseProgram(ID);

	call	QWORD PTR glad_glUseProgram
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 21   : 	glBindVertexArray(ID);

	mov	ecx, DWORD PTR [r14+72]
	call	QWORD PTR glad_glBindVertexArray
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 33   : 	glUniformMatrix4fv(glGetUniformLocation(shader->ID, uniform), 1, GL_FALSE, glm::value_ptr(CameraMatrix));

	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_09KNKDONHI@camMatrix@
	mov	ecx, DWORD PTR [rsi]
	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	call	rax
	xor	r8d, r8d
	lea	r9, QWORD PTR [rdi+164]
	mov	ecx, eax
	lea	edx, QWORD PTR [r8+1]
	call	rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 93   : 	glUniformMatrix4fv(glGetUniformLocation(Shader->ID, "modelMatrix"), 1, GL_FALSE, glm::value_ptr(Matrix));

	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_0M@DDLHAGJC@modelMatrix@
	mov	ecx, DWORD PTR [rsi]
	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	call	rax
	xor	r8d, r8d
	mov	r9, rbp
	mov	ecx, eax
	lea	edx, QWORD PTR [r8+1]
	call	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [r14+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 96   : 	glDrawElements(GL_TRIANGLES, sizeof(int) * indices.size(), GL_UNSIGNED_INT, 0);

	xor	r9d, r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, QWORD PTR [r14+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 96   : 	glDrawElements(GL_TRIANGLES, sizeof(int) * indices.size(), GL_UNSIGNED_INT, 0);

	mov	r8d, 5125				; 00001405H
	and	edx, -4
	lea	ecx, QWORD PTR [r9+4]
	call	QWORD PTR glad_glDrawElements

; 97   : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?DrawPicking@Mesh@@QEAAXPEAVShader@@PEAVCamera@@U?$mat@$03$03M$0A@@glm@@@Z ENDP ; Mesh::DrawPicking
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
;	COMDAT ?UpdateInstances@Mesh@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 64
Instances$ = 72
?UpdateInstances@Mesh@@QEAAXI@Z PROC			; Mesh::UpdateInstances, COMDAT

; 100  : {

$LN32:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 101  : 	Mesh::instancing = Instances;

	mov	DWORD PTR [rcx+88], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 21   : 	glBindVertexArray(ID);

	mov	ecx, DWORD PTR [rcx+72]
	call	QWORD PTR glad_glBindVertexArray
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 21   : 	glBindBuffer(GL_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR [rbx+76]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
	mov	edx, DWORD PTR [rbx+76]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 13   : 	glVertexAttribPointer(layout, numComponents, type, GL_FALSE, stride, offset);

	xor	r9d, r9d
	mov	QWORD PTR [rsp+40], 0
	mov	r8d, 5126				; 00001406H
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	lea	edx, QWORD PTR [r9+4]
	lea	ecx, QWORD PTR [rdx-2]
	call	QWORD PTR glad_glVertexAttribPointer

; 14   : 	glEnableVertexAttribArray(layout);

	mov	ecx, 2
	call	QWORD PTR glad_glEnableVertexAttribArray
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 27   : 	glBindBuffer(GL_ARRAY_BUFFER, 0);

	xor	edx, edx
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer

; 21   : 	glBindBuffer(GL_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR [rbx+76]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 13   : 	glVertexAttribPointer(layout, numComponents, type, GL_FALSE, stride, offset);

	xor	r9d, r9d
	mov	QWORD PTR [rsp+40], 16
	mov	r8d, 5126				; 00001406H
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	lea	edx, QWORD PTR [r9+4]
	lea	ecx, QWORD PTR [rdx-1]
	call	QWORD PTR glad_glVertexAttribPointer

; 14   : 	glEnableVertexAttribArray(layout);

	mov	ecx, 3
	call	QWORD PTR glad_glEnableVertexAttribArray
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 27   : 	glBindBuffer(GL_ARRAY_BUFFER, 0);

	xor	edx, edx
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer

; 21   : 	glBindBuffer(GL_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR [rbx+76]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 13   : 	glVertexAttribPointer(layout, numComponents, type, GL_FALSE, stride, offset);

	mov	edx, 4
	mov	QWORD PTR [rsp+40], 32			; 00000020H
	mov	ecx, edx
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	xor	r9d, r9d
	mov	r8d, 5126				; 00001406H
	call	QWORD PTR glad_glVertexAttribPointer

; 14   : 	glEnableVertexAttribArray(layout);

	mov	ecx, 4
	call	QWORD PTR glad_glEnableVertexAttribArray
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 27   : 	glBindBuffer(GL_ARRAY_BUFFER, 0);

	xor	edx, edx
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer

; 21   : 	glBindBuffer(GL_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR [rbx+76]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 13   : 	glVertexAttribPointer(layout, numComponents, type, GL_FALSE, stride, offset);

	xor	r9d, r9d
	mov	QWORD PTR [rsp+40], 48			; 00000030H
	mov	r8d, 5126				; 00001406H
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	lea	edx, QWORD PTR [r9+4]
	lea	ecx, QWORD PTR [rdx+1]
	call	QWORD PTR glad_glVertexAttribPointer

; 14   : 	glEnableVertexAttribArray(layout);

	mov	ecx, 5
	call	QWORD PTR glad_glEnableVertexAttribArray
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 27   : 	glBindBuffer(GL_ARRAY_BUFFER, 0);

	xor	edx, edx
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 111  : 	glVertexAttribDivisor(2, 1);

	mov	edx, 1
	lea	ecx, QWORD PTR [rdx+1]
	call	QWORD PTR glad_glVertexAttribDivisor

; 112  : 	glVertexAttribDivisor(3, 1);

	mov	edx, 1
	lea	ecx, QWORD PTR [rdx+2]
	call	QWORD PTR glad_glVertexAttribDivisor

; 113  : 	glVertexAttribDivisor(4, 1);

	mov	edx, 1
	lea	ecx, QWORD PTR [rdx+3]
	call	QWORD PTR glad_glVertexAttribDivisor

; 114  : 	glVertexAttribDivisor(5, 1);

	mov	edx, 1
	lea	ecx, QWORD PTR [rdx+4]

; 115  : }

	add	rsp, 48					; 00000030H
	pop	rbx

; 114  : 	glVertexAttribDivisor(5, 1);

	rex_jmp	QWORD PTR glad_glVertexAttribDivisor
?UpdateInstances@Mesh@@QEAAXI@Z ENDP			; Mesh::UpdateInstances
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
;	COMDAT ?UpdateInstanceMatrix@Mesh@@QEAAXAEAV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@@Z
_TEXT	SEGMENT
this$ = 48
Matrix$ = 56
?UpdateInstanceMatrix@Mesh@@QEAAXAEAV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@@Z PROC ; Mesh::UpdateInstanceMatrix, COMDAT

; 118  : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 21   : 	glBindBuffer(GL_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR [rcx+76]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 120  : 	glBufferData(GL_ARRAY_BUFFER, Matrix.size() * sizeof(glm::mat4), Matrix.data(), GL_STATIC_DRAW);

	mov	r8, QWORD PTR [rbx]
	mov	ecx, 34962				; 00008892H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+8]
	sub	rdx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 120  : 	glBufferData(GL_ARRAY_BUFFER, Matrix.size() * sizeof(glm::mat4), Matrix.data(), GL_STATIC_DRAW);

	and	rdx, -64				; ffffffffffffffc0H
	lea	r9d, QWORD PTR [rcx+82]

; 121  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 120  : 	glBufferData(GL_ARRAY_BUFFER, Matrix.size() * sizeof(glm::mat4), Matrix.data(), GL_STATIC_DRAW);

	rex_jmp	QWORD PTR glad_glBufferData
?UpdateInstanceMatrix@Mesh@@QEAAXAEAV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@@Z ENDP ; Mesh::UpdateInstanceMatrix
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 6

; 1870 :     }

	ret	0
?size@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?data@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@XZ
_TEXT	SEGMENT
this$ = 8
?data@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@XZ PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::data, COMDAT

; 1787 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx]

; 1788 :     }

	ret	0
?data@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@XZ ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >, COMDAT

; 683  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN51:
	push	rbx
	push	rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 683  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	r14, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax

; 683  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 684  :         const auto& _Right_data = _Right._Mypair._Myval2;
; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]
	sar	rbx, 6

; 2065 :         if (_Count != 0) {

	test	rbx, rbx
	je	SHORT $LN38@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	rbx, rax
	ja	SHORT $LN49@vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	mov	QWORD PTR [rsp+80], rdi
	call	?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::allocator<glm::mat<4,4,float,0> >::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax
	mov	rdi, rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rbx, 6
	add	rbx, rax
	mov	QWORD PTR [rsi+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));

	mov	rdx, QWORD PTR [r14]

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	and	rbx, -64				; ffffffffffffffc0H
	lea	rcx, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+80]
	mov	QWORD PTR [rsi+8], rcx
$LN38@vector:

; 686  :         _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
; 687  :     }

	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rsi
	pop	rbx
	ret	0
$LN49@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Xlength
	int	3
$LN47@vector:
??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAPEAVTexture@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAPEAVTexture@@_K@Z PROC ; std::vector<Texture *,std::allocator<Texture *> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAPEAVTexture@@_K@Z ENDP ; std::vector<Texture *,std::allocator<Texture *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Texture *,std::allocator<Texture *> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1870 :     }

	ret	0
?size@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Texture *,std::allocator<Texture *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SA?AV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SA?AV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::select_on_container_copy_construction, COMDAT

; 737  :         return _Al;

	mov	rax, rcx

; 738  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SA?AV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Unfancy_maybe_null@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@@Z PROC ; std::_Unfancy_maybe_null<glm::mat<4,4,float,0> >, COMDAT

; 434  :     return _Ptr;

	mov	rax, rcx

; 435  : }

	ret	0
??$_Unfancy_maybe_null@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@@Z ENDP ; std::_Unfancy_maybe_null<glm::mat<4,4,float,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1><std::allocator<glm::mat<4,4,float,0> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1><std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Construct_n<glm::mat<4,4,float,0> * const &,glm::mat<4,4,float,0> * const &>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN45:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN41@Construct_
	push	rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r15, r9
	mov	r14, r8
	mov	rbx, rdx
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN43@Construct_
	mov	QWORD PTR [rsp+32], rdi

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::allocator<glm::mat<4,4,float,0> >::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax
	mov	rdi, rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rbx, 6
	add	rbx, rax
	mov	QWORD PTR [rsi+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));

	mov	rdx, QWORD PTR [r14]

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	and	rbx, -64				; ffffffffffffffc0H
	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+32]
	mov	QWORD PTR [rsi+8], rax

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
$LN41@Construct_:
	ret	0
$LN43@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Xlength
	int	3
$LN40@Construct_:
??$_Construct_n@AEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBQEAU?$mat@$03$03M$0A@@glm@@1@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Construct_n<glm::mat<4,4,float,0> * const &,glm::mat<4,4,float,0> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > > >::~_Tidy_guard<std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > > >::~_Tidy_guard<std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN9@Buy_nonzer

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::allocator<glm::mat<4,4,float,0> >::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rbx, 6
	add	rbx, rax
	mov	QWORD PTR [rdi], rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rbx

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);
; 2011 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Xlength
	int	3
$LN7@Buy_nonzer:
?_Buy_nonzero@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 1980 :         // allocate array with _Newcapacity elements
; 1981 :         auto& _My_data    = _Mypair._Myval2;
; 1982 :         pointer& _Myfirst = _My_data._Myfirst;
; 1983 :         pointer& _Mylast  = _My_data._Mylast;
; 1984 :         pointer& _Myend   = _My_data._Myend;
; 1985 : 
; 1986 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1987 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1988 : 
; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::allocator<glm::mat<4,4,float,0> >::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rbx], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rbx+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rdi, 6
	add	rdi, rax
	mov	QWORD PTR [rbx+16], rdi

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Buy_raw@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SA_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SA_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SA_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z PROC ; std::allocator<glm::mat<4,4,float,0> >::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	shl	rdx, 6

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN10@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z ENDP ; std::allocator<glm::mat<4,4,float,0> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YA$$QEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YA$$QEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<glm::mat<4,4,float,0> > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YA$$QEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$mat@$03$03M$0A@@glm@@@std@@YAAEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$mat@$03$03M$0A@@glm@@@std@@YAAEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@Z PROC ; std::forward<glm::mat<4,4,float,0> * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAU?$mat@$03$03M$0A@@glm@@@std@@YAAEBQEAU?$mat@$03$03M$0A@@glm@@AEBQEAU12@@Z ENDP ; std::forward<glm::mat<4,4,float,0> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_iter@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@ranges@std@@YA?A_T$$QEAPEAU?$mat@$03$03M$0A@@glm@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@ranges@std@@YA?A_T$$QEAPEAU?$mat@$03$03M$0A@@glm@@@Z PROC ; std::ranges::_Unwrap_iter<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *>, COMDAT

; 2488 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2489 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2490 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2491 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2492 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2493 :         } else {
; 2494 :             return static_cast<_Iter&&>(_It);
; 2495 :         }
; 2496 :     }

	ret	0
??$_Unwrap_iter@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@ranges@std@@YA?A_T$$QEAPEAU?$mat@$03$03M$0A@@glm@@@Z ENDP ; std::ranges::_Unwrap_iter<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_sent@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@ranges@std@@YA?A_T$$QEAPEAU?$mat@$03$03M$0A@@glm@@@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@ranges@std@@YA?A_T$$QEAPEAU?$mat@$03$03M$0A@@glm@@@Z PROC ; std::ranges::_Unwrap_sent<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *>, COMDAT

; 2501 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2502 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2503 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2504 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2505 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2506 :         } else {
; 2507 :             return static_cast<_Sent&&>(_Se);
; 2508 :         }
; 2509 :     }

	ret	0
??$_Unwrap_sent@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@ranges@std@@YA?A_T$$QEAPEAU?$mat@$03$03M$0A@@glm@@@Z ENDP ; std::ranges::_Unwrap_sent<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z PROC ; std::_Uninitialized_copy<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *,std::allocator<glm::mat<4,4,float,0> > >, COMDAT

; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN27:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	and	rbx, -64				; ffffffffffffffc0H
	lea	rax, QWORD PTR [rdi+rbx]

; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z ENDP ; std::_Uninitialized_copy<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *,std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEAU?$mat@$03$03M$0A@@glm@@@std@@YA?A_PAEBQEAU?$mat@$03$03M$0A@@glm@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAU?$mat@$03$03M$0A@@glm@@@std@@YA?A_PAEBQEAU?$mat@$03$03M$0A@@glm@@@Z PROC ; std::_To_address<glm::mat<4,4,float,0> *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEAU?$mat@$03$03M$0A@@glm@@@std@@YA?A_PAEBQEAU?$mat@$03$03M$0A@@glm@@@Z ENDP ; std::_To_address<glm::mat<4,4,float,0> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::~_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::~_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@PEAU?$mat@$03$03M$0A@@glm@@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@PEAU?$mat@$03$03M$0A@@glm@@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@PEAU?$mat@$03$03M$0A@@glm@@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEAU?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAPEAU?$mat@$03$03M$0A@@glm@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAU?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAPEAU?$mat@$03$03M$0A@@glm@@AEAPEAU12@@Z PROC ; std::move<glm::mat<4,4,float,0> * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEAU?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAPEAU?$mat@$03$03M$0A@@glm@@AEAPEAU12@@Z ENDP ; std::move<glm::mat<4,4,float,0> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@@Z PROC ; std::to_address<glm::mat<4,4,float,0> >, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@@Z ENDP ; std::to_address<glm::mat<4,4,float,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@@Z PROC ; std::_Unfancy<glm::mat<4,4,float,0> >, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@U?$mat@$03$03M$0A@@glm@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@@Z ENDP ; std::_Unfancy<glm::mat<4,4,float,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00@Z PROC ; std::_Copy_memmove<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAU?$mat@$03$03M$0A@@glm@@PEAU12@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@00@Z ENDP ; std::_Copy_memmove<glm::mat<4,4,float,0> *,glm::mat<4,4,float,0> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEAU?$mat@$03$03M$0A@@glm@@@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAXAEAU?$mat@$03$03M$0A@@glm@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEAU?$mat@$03$03M$0A@@glm@@@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAXAEAU?$mat@$03$03M$0A@@glm@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Emplace_back<glm::mat<4,4,float,0> &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rax+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rax+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rax+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 64			; 00000040H

; 1804 :     }

	ret	0
??$_Emplace_back@AEAU?$mat@$03$03M$0A@@glm@@@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAXAEAU?$mat@$03$03M$0A@@glm@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Emplace_back<glm::mat<4,4,float,0> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAU?$mat@$03$03M$0A@@glm@@@std@@YAAEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAU?$mat@$03$03M$0A@@glm@@@std@@YAAEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z PROC ; std::forward<glm::mat<4,4,float,0> &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAU?$mat@$03$03M$0A@@glm@@@std@@YAAEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z ENDP ; std::forward<glm::mat<4,4,float,0> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$mat@$03$03M$0A@@glm@@AEAU12@@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@AEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$mat@$03$03M$0A@@glm@@AEAU12@@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@AEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::construct<glm::mat<4,4,float,0>,glm::mat<4,4,float,0> &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rdx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@U?$mat@$03$03M$0A@@glm@@AEAU12@@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@AEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::construct<glm::mat<4,4,float,0>,glm::mat<4,4,float,0> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$mat@$03$03M$0A@@glm@@AEAU12@$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@AEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@U?$mat@$03$03M$0A@@glm@@AEAU12@$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@AEAU12@@Z PROC ; std::construct_at<glm::mat<4,4,float,0>,glm::mat<4,4,float,0> &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1

; 242  : }

	ret	0
??$construct_at@U?$mat@$03$03M$0A@@glm@@AEAU12@$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@AEAU12@@Z ENDP ; std::construct_at<glm::mat<4,4,float,0>,glm::mat<4,4,float,0> &,0>
_TEXT	ENDS
END
