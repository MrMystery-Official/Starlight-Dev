; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@ODMJHMKC@CopyPasteVec3f@		; `string'
PUBLIC	??_C@_01IHBHIGKO@?0@				; `string'
PUBLIC	??_C@_0BC@IDEAKKGM@Copy?5?$CIto?5degrees?$CJ@	; `string'
PUBLIC	??_C@_0BC@KCKIFGGJ@Copy?5?$CIto?5radians?$CJ@	; `string'
PUBLIC	??_C@_0DG@DJCIJAEA@Can?8t?5import?5vector?5data?5from?5c@ ; `string'
PUBLIC	??_C@_09CNJMKLLF@StarImGui@			; `string'
PUBLIC	?Window@StarImGui@@3PEAUGLFWwindow@@EA		; StarImGui::Window
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z:PROC
?Window@StarImGui@@3PEAUGLFWwindow@@EA DQ 01H DUP (?)	; StarImGui::Window
_BSS	ENDS
;	COMDAT ??_C@_09CNJMKLLF@StarImGui@
CONST	SEGMENT
??_C@_09CNJMKLLF@StarImGui@ DB 'StarImGui', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DJCIJAEA@Can?8t?5import?5vector?5data?5from?5c@
CONST	SEGMENT
??_C@_0DG@DJCIJAEA@Can?8t?5import?5vector?5data?5from?5c@ DB 'Can''t impo'
	DB	'rt vector data from clipboard, wrong length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KCKIFGGJ@Copy?5?$CIto?5radians?$CJ@
CONST	SEGMENT
??_C@_0BC@KCKIFGGJ@Copy?5?$CIto?5radians?$CJ@ DB 'Copy (to radians)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IDEAKKGM@Copy?5?$CIto?5degrees?$CJ@
CONST	SEGMENT
??_C@_0BC@IDEAKKGM@Copy?5?$CIto?5degrees?$CJ@ DB 'Copy (to degrees)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ODMJHMKC@CopyPasteVec3f@
CONST	SEGMENT
??_C@_0P@ODMJHMKC@CopyPasteVec3f@ DB 'CopyPasteVec3f', 00H ; `string'
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Release_to_buffer@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AU_Released_buffer@12@AEAV?$allocator@D@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Release_to_buffer
PUBLIC	?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init_string_inplace
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?RenderPerFrame@StarImGui@@YAXXZ		; StarImGui::RenderPerFrame
PUBLIC	?ButtonDelete@StarImGui@@YA_NPEBDAEBUImVec2@@@Z	; StarImGui::ButtonDelete
PUBLIC	?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z ; StarImGui::CheckVec3fInputRightClick
PUBLIC	?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z ; StarImGui::InputFloat3Colored
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN11
	DD	imagerel $LN11+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+36
	DD	imagerel $unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD imagerel $LN12
	DD	imagerel $LN12+63
	DD	imagerel $unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+36
	DD	imagerel $unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD imagerel $LN88
	DD	imagerel $LN88+394
	DD	imagerel $unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$9@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD imagerel ?catch$9@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	imagerel ?catch$9@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA+59
	DD	imagerel $unwind$?catch$9@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release_to_buffer@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AU_Released_buffer@12@AEAV?$allocator@D@2@@Z DD imagerel $LN52
	DD	imagerel $LN52+114
	DD	imagerel $unwind$?_Release_to_buffer@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AU_Released_buffer@12@AEAV?$allocator@D@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN71
	DD	imagerel $LN71+54
	DD	imagerel $unwind$?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN71+54
	DD	imagerel $LN71+184
	DD	imagerel $chain$1$?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN71+184
	DD	imagerel $LN71+252
	DD	imagerel $chain$2$?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD imagerel $LN78
	DD	imagerel $LN78+201
	DD	imagerel $unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD imagerel $LN86
	DD	imagerel $LN86+317
	DD	imagerel $unwind$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ButtonDelete@StarImGui@@YA_NPEBDAEBUImVec2@@@Z DD imagerel $LN49
	DD	imagerel $LN49+398
	DD	imagerel $unwind$?ButtonDelete@StarImGui@@YA_NPEBDAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z DD imagerel $LN1373
	DD	imagerel $LN1373+4437
	DD	imagerel $unwind$?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$40@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA DD imagerel ?dtor$40@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA
	DD	imagerel ?dtor$40@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA+55
	DD	imagerel $unwind$?dtor$40@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z DD imagerel $LN119
	DD	imagerel $LN119+95
	DD	imagerel $unwind$?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z DD imagerel $LN119+95
	DD	imagerel $LN119+544
	DD	imagerel $chain$3$?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z DD imagerel $LN119+544
	DD	imagerel $LN119+731
	DD	imagerel $chain$4$?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z DD 021H
	DD	imagerel $LN119
	DD	imagerel $LN119+95
	DD	imagerel $unwind$?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z DD 061521H
	DD	0ed415H
	DD	0f7410H
	DD	0105408H
	DD	imagerel $LN119
	DD	imagerel $LN119+95
	DD	imagerel $unwind$?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z DD 085f01H
	DD	018345fH
	DD	0110118H
	DD	0e00ff011H
	DD	0600bc00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$40@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z DB 'R'
	DB	'm', 02H
	DB	02H
	DB	09eH
	DB	04H
	DB	'<'
	DB	02H
	DB	011H, 02H
	DB	04H
	DB	09eH
	DB	02H
	DB	0faH
	DB	06H
	DB	'*'
	DB	08H
	DB	0b0H
	DB	0aH
	DB	'z'
	DB	0cH
	DB	'0'
	DB	0eH
	DB	'|'
	DB	010H
	DB	'0'
	DB	0eH
	DB	'e', 05H
	DB	02H
	DB	0d8H
	DB	012H
	DB	0aeH
	DB	014H
	DB	0d0H
	DB	016H
	DB	'-', 02H
	DB	018H
	DB	','
	DB	01aH
	DB	0ecH
	DB	01cH
	DB	'2'
	DB	01aH
	DB	0e9H, 08H
	DB	02H
	DB	0f2H
	DB	04H
	DB	0c6H
	DB	01eH
	DB	0c6H
	DB	' '
	DB	0f8H
	DB	'"'
	DB	'2'
	DB	'$'
	DB	'-', 02H
	DB	'&'
	DB	'4'
	DB	'$'
	DB	09dH, 06H
	DB	02H
	DB	0d2H
	DB	'('
	DB	'R'
	DB	'*'
	DB	'@'
	DB	','
	DB	098H
	DB	'.'
	DB	'b'
	DB	'0'
	DB	08dH, 02H
	DB	'6'
	DB	'}', 03H
	DB	'8'
	DB	'd'
	DB	'6'
	DB	0e0H
	DB	'4'
	DB	'l'
	DB	02H
	DB	'0'
	DB	00H
	DB	'T'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z DB 038H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	07H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	06aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	06H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	06H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
	DB	075H
	DB	03H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	05H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	07H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	0b5H
	DB	05H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	05H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0d0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	07H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	055H
	DB	08H
	DD	imagerel ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
	DB	061H
	DB	07H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	036H
	DD	imagerel ?dtor$40@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$41@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA
	DB	02cH
	DD	imagerel __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DB	0c0H
	DB	0b2H
	DD	imagerel ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
	DB	01H
	DB	0aH
	DB	055H
	DB	02H
	DD	imagerel ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
	DB	01H
	DB	0aH
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	07H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z DB 028H
	DD	imagerel $stateUnwindMap$?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z
	DD	imagerel $ip2state$?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z DD 0f3919H
	DD	0397828H
	DD	03a6824H
	DD	0803420H
	DD	0760120H
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z
	DD	0382H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ButtonDelete@StarImGui@@YA_NPEBDAEBUImVec2@@@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 08H
	DB	08cH
	DB	00H
	DB	'8'
	DB	02H
	DB	'f'
	DB	04H
	DB	'\'
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA
	DB	02cH
	DD	imagerel __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
	DD	imagerel $ip2state$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD 081c11H
	DD	0c541cH
	DD	0b341cH
	DD	0e018521cH
	DD	060157016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 04H
	DB	'>'
	DB	00H
	DB	'\'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 02H
	DB	0cH
	DD	imagerel __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
	DD	imagerel $ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD 081911H
	DD	096419H
	DD	085419H
	DD	073419H
	DD	070153219H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 021H
	DD	imagerel $LN71
	DD	imagerel $LN71+54
	DD	imagerel $unwind$?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 040a21H
	DD	07e40aH
	DD	065405H
	DD	imagerel $LN71
	DD	imagerel $LN71+54
	DD	imagerel $unwind$?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release_to_buffer@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AU_Released_buffer@12@AEAV?$allocator@D@2@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$9@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 010H
	DB	08cH
	DB	00H
	DB	012H
	DB	02H
	DB	'd'
	DB	06H
	DB	0a6H
	DB	04H
	DB	'Z'
	DB	06H
	DB	'N'
	DB	04H
	DB	'd'
	DB	0aH
	DB	'0'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$9@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DB	0a1H, 04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 0aH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	080H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	080H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DB 038H
	DD	imagerel $stateUnwindMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	imagerel $tryMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	imagerel $ip2state$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 081119H
	DD	0123411H
	DD	0f00d9211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 04H
	DB	'H'
	DB	00H
	DB	012H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 02H
	DB	0cH
	DD	imagerel ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
	DD	imagerel $ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
;	COMDAT ?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z
_TEXT	SEGMENT
value_changed$1$ = 64
backup$1 = 80
$T2 = 80
Label$ = 176
Values$ = 184
ColorA$ = 192
ColorB$ = 200
ColorC$ = 208
CopyPastePopUp$ = 216
?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z PROC ; StarImGui::InputFloat3Colored, COMDAT

; 15   : {

$LN119:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	r12
	push	r14
	push	r15
	sub	rsp, 136				; 00000088H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	r14, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 15   : {

	mov	r12, r9
	mov	r15, r8
	mov	rsi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r14+16408]
	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 17   :     if (window->SkipItems)

	mov	rax, QWORD PTR [r14+16408]
	cmp	BYTE PTR [rax+240], 0
	je	SHORT $LN7@InputFloat

; 18   :         return false;

	xor	al, al

; 77   : }

	add	rsp, 136				; 00000088H
	pop	r15
	pop	r14
	pop	r12
	pop	rsi
	ret	0
$LN7@InputFloat:
	mov	QWORD PTR [rsp+192], rbx
	mov	QWORD PTR [rsp+128], rbp

; 19   : 
; 20   :     void* Data = Values;

	mov	rbp, rdx
	mov	QWORD PTR [rsp+120], rdi
	mov	QWORD PTR [rsp+112], r13

; 21   : 
; 22   :     ImGuiContext& g = *GImGui;
; 23   :     bool value_changed = false;

	mov	BYTE PTR value_changed$1$[rsp], 0

; 24   :     ImGui::BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 25   :     ImGui::PushID(Label);

	mov	rcx, rsi
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 26   :     ImGui::PushMultiItemsWidths(3, ImGui::CalcItemWidth());

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movaps	xmm1, xmm0
	call	?PushMultiItemsWidths@ImGui@@YAXHM@Z	; ImGui::PushMultiItemsWidths

; 28   :     for (int i = 0; i < 3; i++)

	mov	r13, QWORD PTR ColorC$[rsp]
	lea	rsi, OFFSET FLAT:??_C@_04GFJLOHHD@?$CF?43f@
	xor	edi, edi
$LL4@InputFloat:

; 29   :     {
; 30   :         ImGui::PushID(i);

	mov	ecx, edi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 31   :         if (i > 0)

	test	edi, edi
	je	SHORT $LN8@InputFloat

; 32   :             ImGui::SameLine(0, g.Style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [r14+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
$LN8@InputFloat:

; 33   : 
; 34   :         switch (i)

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	ecx, edi
	mov	DWORD PTR backup$1[rsp], 7
	lea	rdx, QWORD PTR backup$1[rsp]
	movups	xmm0, XMMWORD PTR [rbx+14888]
	movups	XMMWORD PTR backup$1[rsp+4], xmm0
	test	edi, edi
	je	SHORT $LN9@InputFloat
	sub	ecx, 1
	je	SHORT $LN10@InputFloat
	cmp	ecx, 1
	lea	rcx, QWORD PTR [rbx+18824]
	jne	SHORT $LN115@InputFloat
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3137 :     g.ColorStack.push_back(backup);

	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	movups	xmm0, XMMWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 49   :             break;

	jmp	SHORT $LN116@InputFloat
$LN10@InputFloat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	movups	xmm0, XMMWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 44   :             break;

	jmp	SHORT $LN116@InputFloat
$LN9@InputFloat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
$LN115@InputFloat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 58   :         value_changed |= ImGui::InputScalar("", ImGuiDataType_Float, Data, NULL, NULL, "%.3f", 0);

	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back
	movups	xmm0, XMMWORD PTR [r15]
$LN116@InputFloat:
	xor	eax, eax
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	DWORD PTR [rsp+48], eax
	xor	r9d, r9d
	mov	QWORD PTR [rsp+40], rsi
	mov	r8, rbp
	movups	XMMWORD PTR [rbx+14888], xmm0
	lea	edx, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rax
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8415 :     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 58   :         value_changed |= ImGui::InputScalar("", ImGuiDataType_Float, Data, NULL, NULL, "%.3f", 0);

	movzx	ebx, BYTE PTR value_changed$1$[rsp]
	or	bl, al
	mov	BYTE PTR value_changed$1$[rsp], bl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [r9+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r9+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r8, QWORD PTR [r9+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r8+520]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	ecx, DWORD PTR [rax+rdx*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+512], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	DWORD PTR [r8+500], ecx

; 3144 :     if (g.ColorStack.Size < count)

	movsxd	rax, DWORD PTR [r9+18824]
	cmp	eax, 1
	jl	SHORT $LN31@InputFloat
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [r9+18832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3153 :         g.ColorStack.pop_back();

	lea	rdx, QWORD PTR [rax+rax*4]
	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	add	rax, rax
	movups	XMMWORD PTR [r9+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [r9+18824]
$LN31@InputFloat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 62   :         Data = (void*)((char*)Data + type_size);

	add	rbp, 4
	inc	edi
	cmp	edi, 3
	jl	$LL4@InputFloat
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rsi, QWORD PTR Label$[rsp]

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [r9+16408]

; 3327 :     const char* text_display_end = text;

	mov	rdx, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 28   :     for (int i = 0; i < 3; i++)

	mov	r13, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+120]
	mov	rbp, QWORD PTR [rsp+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rsi, -1
	jae	$LN14@InputFloat
$LL43@InputFloat:
	movzx	ecx, BYTE PTR [rdx]
	test	cl, cl
	je	SHORT $LN44@InputFloat
	lea	rax, QWORD PTR [rdx+1]
	cmp	cl, 35					; 00000023H
	jne	SHORT $LN99@InputFloat
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN44@InputFloat
$LN99@InputFloat:

; 3332 :         text_display_end++;

	mov	rdx, rax
	cmp	rax, -1
	jb	SHORT $LL43@InputFloat
$LN44@InputFloat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 67   :     if (Label != label_end)

	cmp	rsi, rdx
	je	SHORT $LN14@InputFloat

; 68   :     {
; 69   :         ImGui::SameLine(0.0f, g.Style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [r14+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 70   :         ImGui::TextEx(Label, label_end);

	mov	rcx, rsi
	xor	r8d, r8d
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx

; 71   :         if (CopyPastePopUp)

	cmp	BYTE PTR CopyPastePopUp$[rsp], 0
	je	SHORT $LN14@InputFloat
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rsp+16], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rsp+24], 0

; 400  :             return __builtin_strlen(_First);

	mov	r8, -1
	npad	7
$LL100@InputFloat:
	inc	r8
	cmp	BYTE PTR [rsi+r8], 0
	jne	SHORT $LL100@InputFloat

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 72   :             CheckVec3fInputRightClick(std::string(Label), Values);

	mov	rdx, QWORD PTR Values$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	xor	r8d, r8d
	call	?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z ; StarImGui::CheckVec3fInputRightClick
$LN14@InputFloat:

; 73   :     }
; 74   : 
; 75   :     ImGui::EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 76   :     return value_changed;

	movzx	eax, bl
	mov	rbx, QWORD PTR [rsp+192]

; 77   : }

	add	rsp, 136				; 00000088H
	pop	r15
	pop	r14
	pop	r12
	pop	rsi
	ret	0
?InputFloat3Colored@StarImGui@@YA_NPEBDQEAMUImVec4@@22_N@Z ENDP ; StarImGui::InputFloat3Colored
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
;	COMDAT ?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z
_TEXT	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z PROC ; StarImGui::CheckVec3fInputRightClick, COMDAT

; 80   : {

$LN1373:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-744]
	sub	rsp, 944				; 000003b0H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	movzx	r12d, r8b
	mov	r13, rdx
	mov	r15, rcx
	mov	QWORD PTR Id$GSCopy$[rbp-256], rcx
	mov	DWORD PTR $T15[rbp-256], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rcx, QWORD PTR [rcx+16]

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rbx
	sub	rax, rcx
	cmp	rax, 14
	jb	$LN1370@CheckVec3f

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN1363@CheckVec3f

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [r15]
$LN1363@CheckVec3f:

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 14
	lea	r9, OFFSET FLAT:??_C@_0P@ODMJHMKC@CopyPasteVec3f@
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdi, QWORD PTR $T5[rsp]

; 2236 :         if (_Large_string_engaged()) {

	mov	r9, QWORD PTR $T5[rsp+24]
	cmp	r9, 16
	cmovae	rdi, QWORD PTR $T5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11238:     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11239:     ImGuiWindow* window = g.CurrentWindow;

	mov	r14, QWORD PTR [rsi+16408]

; 11240:     int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
; 11241:     if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	mov	ecx, 1
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	test	al, al
	je	SHORT $LN83@CheckVec3f
	mov	ecx, 32					; 00000020H
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN1365@CheckVec3f

; 11242:     {
; 11243:         ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID;    // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!

	test	rdi, rdi
	je	SHORT $LN85@CheckVec3f
	mov	rdx, rdi
	mov	rcx, r14
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	jmp	SHORT $LN86@CheckVec3f
$LN85@CheckVec3f:
	mov	eax, DWORD PTR [rsi+18616]
$LN86@CheckVec3f:

; 11244:         IM_ASSERT(id != 0);                                             // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
; 11245:         OpenPopupEx(id, popup_flags);

	mov	edx, 1
	mov	ecx, eax
	call	?OpenPopupEx@ImGui@@YAXIH@Z		; ImGui::OpenPopupEx
$LN1365@CheckVec3f:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 81   :     ImGui::OpenPopupOnItemClick(("CopyPasteVec3f" + Id).c_str(), ImGuiPopupFlags_MouseButtonRight);

	mov	r9, QWORD PTR $T5[rsp+24]
$LN83@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN99@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [r9+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T5[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN111@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN111@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN111@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN99@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rcx, QWORD PTR [r15+16]

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	sub	rbx, rcx
	cmp	rbx, 14
	jb	$LN1371@CheckVec3f

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN126@CheckVec3f

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [r15]
$LN126@CheckVec3f:

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 14
	lea	r9, OFFSET FLAT:??_C@_0P@ODMJHMKC@CopyPasteVec3f@
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r14d, 3

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T4[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T4[rsp+24], 16
	cmovae	rdx, QWORD PTR $T4[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11170:     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11171:     if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance

	mov	eax, DWORD PTR [rcx+18936]
	cmp	DWORD PTR [rcx+18920], eax
	jg	SHORT $LN138@CheckVec3f

; 11172:     {
; 11173:         g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values

	xor	edi, edi
	mov	DWORD PTR [rcx+18680], edi

; 11174:         return false;

	xor	bl, bl
	jmp	SHORT $LN137@CheckVec3f
$LN138@CheckVec3f:

; 11175:     }
; 11176:     flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
; 11177:     ImGuiID id = g.CurrentWindow->GetID(str_id);

	mov	rcx, QWORD PTR [rcx+16408]
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID

; 11178:     return BeginPopupEx(id, flags);

	mov	edx, 321				; 00000141H
	mov	ecx, eax
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx
	movzx	ebx, al
	xor	edi, edi
$LN137@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T4[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN152@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T4[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN164@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN164@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN164@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN152@CheckVec3f:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 83   : 	if (ImGui::BeginPopup(("CopyPasteVec3f" + Id).c_str()))

	test	bl, bl
	je	$LN4@CheckVec3f

; 84   : 	{
; 85   :         if (!ConvertAngles)

	xor	r9d, r9d
	xor	r8d, r8d
	test	r12b, r12b
	jne	$LN5@CheckVec3f
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7476 :     return MenuItemEx(label, NULL, shortcut, selected, enabled);

	lea	rcx, OFFSET FLAT:??_C@_04OPMHGHMB@Copy@
	call	?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z	; ImGui::MenuItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 87   :             if (ImGui::MenuItem("Copy"))

	test	al, al
	je	$LN1073@CheckVec3f

; 88   :             {
; 89   :                 std::string Clipboard = std::to_string(Values[0]) + "," + std::to_string(Values[1]) + "," + std::to_string(Values[2]);

	movss	xmm1, DWORD PTR [r13+8]
	lea	rcx, QWORD PTR $T20[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@M@Z ; std::to_string
	mov	rsi, rax
	movss	xmm1, DWORD PTR [r13+4]
	lea	rcx, QWORD PTR $T26[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@M@Z ; std::to_string
	mov	rdi, rax
	movss	xmm6, DWORD PTR [r13]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 536  :     return _STD to_string(static_cast<double>(_Val));

	cvtps2pd xmm6, xmm6

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	movaps	xmm1, xmm6
	movq	rdx, xmm6
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	movsxd	rbx, eax

; 530  :     string _Str(_Len, '\0');

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T21[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T21[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T21[rbp-232], 16
	cmovae	rcx, QWORD PTR $T21[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rbx+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s

; 536  :     return _STD to_string(static_cast<double>(_Val));

	mov	r14d, 98307				; 00018003H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3292 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01IHBHIGKO@?0@
	lea	rcx, QWORD PTR $T21[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T14[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T14[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], 0
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], r12b
	bts	r14d, 25

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rdi
	lea	r8, QWORD PTR $T14[rbp-256]
	lea	rcx, QWORD PTR $T25[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	r14d, 26

; 3292 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01IHBHIGKO@?0@
	lea	rcx, QWORD PTR $T25[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T11[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T11[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	xor	edi, edi
	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], dil
	bts	r14d, 27

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rsi
	lea	r8, QWORD PTR $T11[rbp-256]
	lea	rcx, QWORD PTR Clipboard$35[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	r14d, 28

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T11[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1165@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T11[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1
$LN1165@CheckVec3f:

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T25[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1173@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T25[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1173@CheckVec3f:

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T25[rbp-240], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T25[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T14[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1181@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T14[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1
$LN1181@CheckVec3f:

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T21[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1189@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T21[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1189@CheckVec3f:

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T21[rbp-240], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T21[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T26[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1197@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T26[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1197@CheckVec3f:

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T26[rbp-240], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T26[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T20[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1259@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T20[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1259@CheckVec3f:

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T20[rbp-240], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T20[rbp-256], 0

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Clipboard$35[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Clipboard$35[rbp-232], 16
	cmovae	rdx, QWORD PTR Clipboard$35[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 90   :                 glfwSetClipboardString(Window, Clipboard.c_str());

	mov	rcx, QWORD PTR ?Window@StarImGui@@3PEAUGLFWwindow@@EA ; StarImGui::Window
	call	glfwSetClipboardString
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR Clipboard$35[rbp-232]
	cmp	rdx, 16
	jb	$LN1073@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR Clipboard$35[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN351@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN351@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN351@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 92   :         }

	jmp	$LN1073@CheckVec3f
$LN5@CheckVec3f:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7476 :     return MenuItemEx(label, NULL, shortcut, selected, enabled);

	lea	rcx, OFFSET FLAT:??_C@_0BC@IDEAKKGM@Copy?5?$CIto?5degrees?$CJ@
	call	?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z	; ImGui::MenuItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 95   :             if (ImGui::MenuItem("Copy (to degrees)"))

	test	al, al
	je	$LN736@CheckVec3f
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 28   : 		return radians * static_cast<genType>(57.295779513082320876798154814105);

	movss	xmm0, DWORD PTR [r13+8]
	movss	xmm7, DWORD PTR __real@42652ee1
	mulss	xmm0, xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 536  :     return _STD to_string(static_cast<double>(_Val));

	cvtps2pd xmm6, xmm0

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	movaps	xmm1, xmm6
	movq	rdx, xmm6
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	movsxd	rbx, eax

; 530  :     string _Str(_Len, '\0');

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T23[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T23[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T23[rbp-232], 16
	cmovae	rcx, QWORD PTR $T23[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rbx+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 28   : 		return radians * static_cast<genType>(57.295779513082320876798154814105);

	movss	xmm0, DWORD PTR [r13+4]
	mulss	xmm0, xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 536  :     return _STD to_string(static_cast<double>(_Val));

	cvtps2pd xmm6, xmm0

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	movaps	xmm1, xmm6
	movq	rdx, xmm6
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	movsxd	rbx, eax

; 530  :     string _Str(_Len, '\0');

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T22[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T22[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T22[rbp-232], 16
	cmovae	rcx, QWORD PTR $T22[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rbx+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 28   : 		return radians * static_cast<genType>(57.295779513082320876798154814105);

	movss	xmm0, DWORD PTR [r13]
	mulss	xmm0, xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 536  :     return _STD to_string(static_cast<double>(_Val));

	cvtps2pd xmm6, xmm0

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	movaps	xmm1, xmm6
	movq	rdx, xmm6
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	movsxd	rbx, eax

; 530  :     string _Str(_Len, '\0');

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T28[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T28[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T28[rbp-232], 16
	cmovae	rcx, QWORD PTR $T28[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rbx+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s

; 536  :     return _STD to_string(static_cast<double>(_Val));

	mov	r14d, 507				; 000001fbH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T28[rbp-240]
	mov	rdx, QWORD PTR $T28[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN422@CheckVec3f

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T28[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T28[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T28[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 44			; 0000002cH

; 3277 :             return *this;

	lea	rax, QWORD PTR $T28[rbp-256]
	jmp	SHORT $LN421@CheckVec3f
$LN422@CheckVec3f:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01IHBHIGKO@?0@
	mov	edx, 1
	lea	rcx, QWORD PTR $T28[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN421@CheckVec3f:

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T10[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T10[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	bts	r14d, 9

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	lea	r9, QWORD PTR $T22[rbp-256]
	lea	r8, QWORD PTR $T10[rbp-256]
	lea	rcx, QWORD PTR $T16[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	r14d, 10

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T16[rbp-240]
	mov	rdx, QWORD PTR $T16[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN487@CheckVec3f

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T16[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T16[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T16[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 44			; 0000002cH

; 3277 :             return *this;

	lea	rax, QWORD PTR $T16[rbp-256]
	jmp	SHORT $LN486@CheckVec3f
$LN487@CheckVec3f:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01IHBHIGKO@?0@
	mov	edx, 1
	lea	rcx, QWORD PTR $T16[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN486@CheckVec3f:

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T13[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T13[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	bts	r14d, 11

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	lea	r9, QWORD PTR $T23[rbp-256]
	lea	r8, QWORD PTR $T13[rbp-256]
	lea	rcx, QWORD PTR Clipboard$32[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	r14d, 12

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T13[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN555@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T13[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN567@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN567@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN567@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN555@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T16[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN584@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T16[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN596@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN596@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN596@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN584@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T16[rbp-240], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T16[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T10[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN613@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T10[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN625@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN625@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN625@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN613@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T28[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN642@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T28[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN654@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN654@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN654@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN642@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T28[rbp-240], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T28[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T22[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN671@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T22[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN683@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN683@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN683@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN671@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T22[rbp-240], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T22[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T23[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN700@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T23[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN712@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN712@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN712@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN700@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T23[rbp-240], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T23[rbp-256], 0

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Clipboard$32[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Clipboard$32[rbp-232], 16
	cmovae	rdx, QWORD PTR Clipboard$32[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 98   :                 glfwSetClipboardString(Window, Clipboard.c_str());

	mov	rcx, QWORD PTR ?Window@StarImGui@@3PEAUGLFWwindow@@EA ; StarImGui::Window
	call	glfwSetClipboardString
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR Clipboard$32[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN736@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR Clipboard$32[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN748@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN748@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN748@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN736@CheckVec3f:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7476 :     return MenuItemEx(label, NULL, shortcut, selected, enabled);

	xor	r9d, r9d
	xor	r8d, r8d
	lea	rcx, OFFSET FLAT:??_C@_0BC@KCKIFGGJ@Copy?5?$CIto?5radians?$CJ@
	call	?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z	; ImGui::MenuItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 100  :             if (ImGui::MenuItem("Copy (to radians)"))

	test	al, al
	je	$LN1073@CheckVec3f
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	movss	xmm0, DWORD PTR [r13+8]
	movss	xmm7, DWORD PTR __real@3c8efa35
	mulss	xmm0, xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 536  :     return _STD to_string(static_cast<double>(_Val));

	cvtps2pd xmm6, xmm0

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	movaps	xmm1, xmm6
	movq	rdx, xmm6
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	movsxd	rbx, eax

; 530  :     string _Str(_Len, '\0');

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 532  :     return _Str;

	bts	r14d, 14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T3[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T3[rsp+24], 16
	cmovae	rcx, QWORD PTR $T3[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rbx+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s

; 536  :     return _STD to_string(static_cast<double>(_Val));

	bts	r14d, 13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	movss	xmm0, DWORD PTR [r13+4]
	mulss	xmm0, xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 536  :     return _STD to_string(static_cast<double>(_Val));

	cvtps2pd xmm6, xmm0

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	movaps	xmm1, xmm6
	movq	rdx, xmm6
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	movsxd	rbx, eax

; 530  :     string _Str(_Len, '\0');

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T24[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 532  :     return _Str;

	bts	r14d, 18
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T24[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T24[rbp-232], 16
	cmovae	rcx, QWORD PTR $T24[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rbx+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s

; 536  :     return _STD to_string(static_cast<double>(_Val));

	bts	r14d, 17
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	movss	xmm0, DWORD PTR [r13]
	mulss	xmm0, xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 536  :     return _STD to_string(static_cast<double>(_Val));

	cvtps2pd xmm6, xmm0

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	movaps	xmm1, xmm6
	movq	rdx, xmm6
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	movsxd	rbx, eax

; 530  :     string _Str(_Len, '\0');

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 532  :     return _Str;

	bts	r14d, 20
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T8[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T8[rbp-232], 16
	cmovae	rcx, QWORD PTR $T8[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rbx+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s

; 536  :     return _STD to_string(static_cast<double>(_Val));

	bts	r14d, 19
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T8[rsp+16]
	mov	rdx, QWORD PTR $T8[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN830@CheckVec3f

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T8[rsp+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T8[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T8[rsp]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 44			; 0000002cH

; 3277 :             return *this;

	lea	rax, QWORD PTR $T8[rsp]
	jmp	SHORT $LN829@CheckVec3f
$LN830@CheckVec3f:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01IHBHIGKO@?0@
	mov	edx, 1
	lea	rcx, QWORD PTR $T8[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN829@CheckVec3f:

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T9[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T9[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	bts	r14d, 21

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	lea	r9, QWORD PTR $T24[rbp-256]
	lea	r8, QWORD PTR $T9[rbp-256]
	lea	rcx, QWORD PTR $T30[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	r14d, 22

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T30[rbp-240]
	mov	rdx, QWORD PTR $T30[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN895@CheckVec3f

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T30[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T30[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T30[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 44			; 0000002cH

; 3277 :             return *this;

	lea	rax, QWORD PTR $T30[rbp-256]
	jmp	SHORT $LN894@CheckVec3f
$LN895@CheckVec3f:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01IHBHIGKO@?0@
	mov	edx, 1
	lea	rcx, QWORD PTR $T30[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN894@CheckVec3f:

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T12[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T12[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	bts	r14d, 23

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	lea	r9, QWORD PTR $T3[rsp]
	lea	r8, QWORD PTR $T12[rbp-256]
	lea	rcx, QWORD PTR Clipboard$34[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	r14d, 24

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T12[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN963@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T12[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN975@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN975@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN975@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN963@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T30[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN992@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T30[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1004@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1004@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1004@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN992@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T30[rbp-240], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T30[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T9[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN1021@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T9[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1033@CheckVec3f

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1033@CheckVec3f
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1033@CheckVec3f:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN1021@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T8[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1042@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T8[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1042@CheckVec3f:

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T8[rsp+16], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T8[rsp], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T24[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1050@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T24[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1050@CheckVec3f:

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T24[rbp-240], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T24[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T3[rsp+24]
	cmp	r8, 16
	jb	SHORT $LN1058@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T3[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1058@CheckVec3f:

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T3[rsp+16], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T3[rsp], 0

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Clipboard$34[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Clipboard$34[rbp-232], 16
	cmovae	rdx, QWORD PTR Clipboard$34[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 103  :                 glfwSetClipboardString(Window, Clipboard.c_str());

	mov	rcx, QWORD PTR ?Window@StarImGui@@3PEAUGLFWwindow@@EA ; StarImGui::Window
	call	glfwSetClipboardString
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR Clipboard$34[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1073@CheckVec3f

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR Clipboard$34[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1073@CheckVec3f:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7476 :     return MenuItemEx(label, NULL, shortcut, selected, enabled);

	xor	r9d, r9d
	xor	r8d, r8d
	lea	rcx, OFFSET FLAT:??_C@_05NEBJFIEK@Paste@
	call	?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z	; ImGui::MenuItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 106  : 		if (ImGui::MenuItem("Paste"))

	test	al, al
	je	$EndPopUp$1374
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Result$27[rbp-256], xmm1
	mov	QWORD PTR Result$27[rbp-240], rdi
	xor	edx, edx
	mov	r8d, 248				; 000000f8H
	lea	rcx, QWORD PTR Data$36[rbp-256]
	call	memset
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 109  : 			std::stringstream Data(glfwGetClipboardString(Window));

	mov	rcx, QWORD PTR ?Window@StarImGui@@3PEAUGLFWwindow@@EA ; StarImGui::Window
	call	glfwGetClipboardString
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqu	XMMWORD PTR $T2[rsp+16], xmm1

; 400  :             return __builtin_strlen(_First);

	mov	r8, -1
$LL1364@CheckVec3f:
	inc	r8
	cmp	BYTE PTR [rax+r8], 0
	jne	SHORT $LL1364@CheckVec3f

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 817  :         : _Mybase(_STD addressof(_Stringbuffer)), _Stringbuffer(_STD move(_Str), _Mode) {}

	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
	mov	QWORD PTR Data$36[rbp-256], rax
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
	mov	QWORD PTR Data$36[rbp-240], rax
	lea	rcx, QWORD PTR Data$36[rbp-104]
	call	QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	or	r14d, 4
	mov	DWORD PTR $T15[rbp-256], r14d
	xor	r8d, r8d
	lea	rdx, QWORD PTR Data$36[rbp-232]
	lea	rcx, QWORD PTR Data$36[rbp-256]
	call	QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR Data$36[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR Data$36[rbp+rcx-256], rax
	mov	rax, QWORD PTR Data$36[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-152]
	mov	DWORD PTR Data$36[rbp+rcx-260], edx
	lea	rax, QWORD PTR Data$36[rbp-232]
	mov	QWORD PTR $T6[rsp], rax

; 51   :         : _Al(_STD move(_Str._Getal())) {

	lea	rcx, QWORD PTR Data$36[rbp-232]
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR Data$36[rbp-232], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2944 :         if (_My_data._Large_string_engaged()) {

	mov	rbx, QWORD PTR $T2[rsp+24]
	cmp	rbx, 16
	jb	SHORT $LN226@CheckVec3f

; 2945 :             _Result._Ptr = _My_data._Bx._Ptr;

	mov	r8, QWORD PTR $T2[rsp]

; 2946 :             _Result._Res = _My_data._Myres + 1;

	inc	rbx

; 2947 :         } else {

	jmp	SHORT $LN227@CheckVec3f
$LN226@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ebx, 17
	mov	ecx, ebx
	call	??2@YAPEAX_K@Z				; operator new
	mov	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR $T2[rsp]
	movups	XMMWORD PTR [rax], xmm0
$LN227@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 478  :         _Seekhigh                = _Pnew + _Size;

	mov	rdx, QWORD PTR $T2[rsp+16]
	add	rdx, r8
	mov	QWORD PTR Data$36[rbp-128], rdx

; 479  :         auto _Next               = (_State & (_Atend | _Append)) ? _Seekhigh : _Pnew;
; 480  :         auto _End_buffer         = _Pnew + _Res;

	lea	rdx, QWORD PTR [r8+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf

; 251  :         *_IPfirst = _First;

	mov	rcx, QWORD PTR Data$36[rbp-200]
	mov	QWORD PTR [rcx], r8

; 252  :         *_IPnext  = _Next;

	mov	rcx, QWORD PTR Data$36[rbp-168]
	mov	QWORD PTR [rcx], r8

; 253  :         *_IPcount = static_cast<int>(_Last - _Next);

	sub	edx, r8d
	mov	rax, QWORD PTR Data$36[rbp-144]
	mov	DWORD PTR [rax], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 486  :             _Mysb::setg(_Pnew, _Pnew, _Seekhigh);

	mov	rcx, QWORD PTR Data$36[rbp-128]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf

; 208  :         *_IGfirst = _First;

	mov	rax, QWORD PTR Data$36[rbp-208]
	mov	QWORD PTR [rax], r8

; 209  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR Data$36[rbp-176]
	mov	QWORD PTR [rax], r8

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	ecx, r8d
	mov	rax, QWORD PTR Data$36[rbp-152]
	mov	DWORD PTR [rax], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 109  : 			std::stringstream Data(glfwGetClipboardString(Window));

	mov	DWORD PTR Data$36[rbp-120], 33		; 00000021H
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Line$29[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	movdqa	xmm1, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR Line$29[rbp-240], xmm1

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Line$29[rbp-256], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 79   :     return _STD getline(_STD move(_Istr), _Str, _Delim);

	lea	rdx, QWORD PTR Line$29[rbp-256]
	lea	rcx, QWORD PTR Data$36[rbp-256]
	call	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 111  : 			while (std::getline(Data, Line, ','))

	mov	rcx, QWORD PTR [rax]
	movsxd	rcx, DWORD PTR [rcx+4]
	add	rcx, rax
	call	QWORD PTR __imp_??Bios_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN3@CheckVec3f
	npad	7
$LL2@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR Result$27[rbp-248]
	cmp	rax, QWORD PTR Result$27[rbp-240]
	je	SHORT $LN52@CheckVec3f
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR Line$29[rbp-256]
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR Result$27[rbp-248], 32	; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN51@CheckVec3f
$LN52@CheckVec3f:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Line$29[rbp-256]
	mov	rdx, rax
	lea	rcx, QWORD PTR Result$27[rbp-256]
	call	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
$LN51@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 79   :     return _STD getline(_STD move(_Istr), _Str, _Delim);

	lea	rdx, QWORD PTR Line$29[rbp-256]
	lea	rcx, QWORD PTR Data$36[rbp-256]
	call	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 111  : 			while (std::getline(Data, Line, ','))

	mov	rcx, QWORD PTR [rax]
	movsxd	rcx, DWORD PTR [rcx+4]
	add	rcx, rax
	call	QWORD PTR __imp_??Bios_base@std@@QEBA_NXZ
	test	al, al
	jne	SHORT $LL2@CheckVec3f
$LN3@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR Result$27[rbp-248]
	mov	rdx, QWORD PTR Result$27[rbp-256]
	sub	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 116  : 			if (Result.size() != 3)

	cmp	rax, 96					; 00000060H
	je	$LN11@CheckVec3f

; 118  : 				Logger::Error("StarImGui", "Can't import vector data from clipboard, wrong length");

	lea	rax, QWORD PTR $T33[rbp-256]
	mov	QWORD PTR $T7[rsp], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T33[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T33[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T33[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 53					; 00000035H
	lea	rdx, OFFSET FLAT:??_C@_0DG@DJCIJAEA@Can?8t?5import?5vector?5data?5from?5c@
	lea	rcx, QWORD PTR $T33[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T31[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T31[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T31[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 9
	lea	rdx, OFFSET FLAT:??_C@_09CNJMKLLF@StarImGui@
	lea	rcx, QWORD PTR $T31[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 118  : 				Logger::Error("StarImGui", "Can't import vector data from clipboard, wrong length");

	lea	rdx, QWORD PTR $T33[rbp-256]
	lea	rcx, QWORD PTR $T31[rbp-256]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	jmp	SHORT $LN1368@CheckVec3f
$LN11@CheckVec3f:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 122  : 			Values[0] = Util::StringToNumber<float>(Result[0]);

	lea	rcx, QWORD PTR $T19[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	??$StringToNumber@M@Util@@YAMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::StringToNumber<float>
	movss	DWORD PTR [r13], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR Result$27[rbp-256]
	add	rdx, 32					; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 123  : 			Values[1] = Util::StringToNumber<float>(Result[1]);

	lea	rcx, QWORD PTR $T18[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	??$StringToNumber@M@Util@@YAMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::StringToNumber<float>
	movss	DWORD PTR [r13+4], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR Result$27[rbp-256]
	add	rdx, 64					; 00000040H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 124  : 			Values[2] = Util::StringToNumber<float>(Result[2]);

	lea	rcx, QWORD PTR $T17[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	??$StringToNumber@M@Util@@YAMV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::StringToNumber<float>
	movss	DWORD PTR [r13+8], xmm0
$LN1368@CheckVec3f:

; 125  : 		}

	mov	r8, QWORD PTR Line$29[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1249@CheckVec3f
	inc	r8
	mov	rdx, QWORD PTR Line$29[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1
$LN1249@CheckVec3f:
	lea	rcx, QWORD PTR Data$36[rbp-256]
	call	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Result$27[rbp-256]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
$EndPopUp$1374:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 127  : 		ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	npad	1
$LN4@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, r15
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 129  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+944]
	mov	rbx, QWORD PTR [r11+80]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN1371@CheckVec3f:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4917 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1370@CheckVec3f:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1366@CheckVec3f:
?CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z ENDP ; StarImGui::CheckVec3fInputRightClick
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$0@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$0
	mov	rcx, QWORD PTR Id$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$1@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$1
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$2@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$3@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$3
	lea	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$4@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$4
	lea	rcx, QWORD PTR $T26[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$5@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$5
	lea	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$6@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$6
	lea	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$7@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$7
	lea	rcx, QWORD PTR $T25[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$8@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$8
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$10@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$10
	lea	rcx, QWORD PTR $T23[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$11@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$11
	lea	rcx, QWORD PTR $T22[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$12@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$12
	lea	rcx, QWORD PTR $T28[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$13@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$13
	lea	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$13@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$14@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$14
	lea	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$14@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$15@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$15
	lea	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$15@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$17@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$17
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$17@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$18@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$18
	lea	rcx, QWORD PTR $T24[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$18@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$19@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$19
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$19@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$20@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$20
	lea	rcx, QWORD PTR $T9[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$20@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$21@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$21
	lea	rcx, QWORD PTR $T30[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$21@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$22@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$22
	lea	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$22@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$24@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$24
	lea	rcx, QWORD PTR Result$27[rdx]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$24@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$24
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$25@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$25
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$25@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$40@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$40
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T15[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN206@dtor$40
	and	DWORD PTR $T15[rbp], -5
	lea	rcx, QWORD PTR Data$36[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN206@dtor$40:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$40@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$40
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$41@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$41
	lea	rcx, QWORD PTR Data$36[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$41@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$41
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$43@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$43
	mov	rcx, QWORD PTR $T6[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$43@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$43
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$26@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$26
	lea	rcx, QWORD PTR Data$36[rdx]
	jmp	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$26@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$27@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$27
	lea	rcx, QWORD PTR Line$29[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$27@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 96
$T7 = 96
$T8 = 104
$T9 = 136
$T10 = 136
$T11 = 136
$T12 = 168
$T13 = 168
$T14 = 168
$T15 = 200
$T16 = 208
$T17 = 240
$T18 = 240
$T19 = 240
$T20 = 240
$T21 = 272
$T22 = 304
$T23 = 336
$T24 = 368
$T25 = 400
$T26 = 432
Id$GSCopy$ = 464
Result$27 = 472
$T28 = 472
Line$29 = 504
$T30 = 504
$T31 = 536
Clipboard$32 = 536
$T33 = 568
Clipboard$34 = 568
Clipboard$35 = 600
Data$36 = 640
__$ArrayPad$ = 896
Id$ = 1008
Values$ = 1016
ConvertAngles$ = 1024
?dtor$28@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA PROC ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$28
	mov	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$28@?0??CheckVec3fInputRightClick@StarImGui@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAM_N@Z@4HA ENDP ; `StarImGui::CheckVec3fInputRightClick'::`1'::dtor$28
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
;	COMDAT ?ButtonDelete@StarImGui@@YA_NPEBDAEBUImVec2@@@Z
_TEXT	SEGMENT
backup$1 = 32
backup$2 = 32
backup$3 = 32
Label$ = 80
Size$ = 88
?ButtonDelete@StarImGui@@YA_NPEBDAEBUImVec2@@@Z PROC	; StarImGui::ButtonDelete, COMDAT

; 132  : {

$LN49:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3133 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 132  : {

	mov	rdi, rdx
	mov	rsi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3135 :     backup.Col = idx;

	mov	DWORD PTR backup$3[rsp], 21

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR backup$3[rsp]
	movups	xmm0, XMMWORD PTR [rbx+15112]
	lea	rcx, QWORD PTR [rbx+18824]
	movups	XMMWORD PTR backup$3[rsp+4], xmm0
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	mov	DWORD PTR [rbx+15112], 1056964608	; 3f000000H

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR backup$1[rsp]

; 3138 :     g.Style.Colors[idx] = col;

	mov	DWORD PTR [rbx+15116], 1041194025	; 3e0f5c29H
	mov	DWORD PTR [rbx+15120], 1041194025	; 3e0f5c29H
	mov	DWORD PTR [rbx+15124], 1065353216	; 3f800000H

; 3133 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3135 :     backup.Col = idx;

	mov	DWORD PTR backup$1[rsp], 22

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+15128]

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
	movups	XMMWORD PTR backup$1[rsp+4], xmm0
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	mov	DWORD PTR [rbx+15128], 1063843267	; 3f68f5c3H

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR backup$2[rsp]

; 3138 :     g.Style.Colors[idx] = col;

	mov	DWORD PTR [rbx+15132], 1039516303	; 3df5c28fH
	mov	DWORD PTR [rbx+15136], 1041865114	; 3e19999aH
	mov	DWORD PTR [rbx+15140], 1065353216	; 3f800000H

; 3133 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3135 :     backup.Col = idx;

	mov	DWORD PTR backup$2[rsp], 23

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+15144]

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
	movups	XMMWORD PTR backup$2[rsp+4], xmm0
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	mov	QWORD PTR [rbx+15144], 1065353216	; 3f800000H
	xor	eax, eax
	mov	DWORD PTR [rbx+15152], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	mov	rdx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3138 :     g.Style.Colors[idx] = col;

	mov	DWORD PTR [rbx+15156], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	mov	rcx, rsi
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 137  :     ImGui::PopStyleColor(3);

	mov	r9d, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	movzx	r10d, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3144 :     if (g.ColorStack.Size < count)

	mov	ecx, DWORD PTR [r8+18824]
	cmp	ecx, r9d
	jge	SHORT $LL30@ButtonDele

; 3145 :     {
; 3146 :         IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times: stack underflow.");
; 3147 :         count = g.ColorStack.Size;

	mov	r9d, ecx

; 3149 :     while (count > 0)

	test	ecx, ecx
	jle	SHORT $LN31@ButtonDele
	npad	8
$LL30@ButtonDele:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3154 :         count--;

	dec	r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [r8+18832]
	lea	rdx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3152 :         g.Style.Colors[backup.Col] = backup.BackupValue;

	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	add	rax, rax
	movups	XMMWORD PTR [r8+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [r8+18824]
	mov	ecx, DWORD PTR [r8+18824]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3149 :     while (count > 0)

	test	r9d, r9d
	jg	SHORT $LL30@ButtonDele
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp

; 138  :     return Changed;

	movzx	eax, r10b
$LN31@ButtonDele:

; 139  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?ButtonDelete@StarImGui@@YA_NPEBDAEBUImVec2@@@Z ENDP	; StarImGui::ButtonDelete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\StarImGui.cpp
;	COMDAT ?RenderPerFrame@StarImGui@@YAXXZ
_TEXT	SEGMENT
?RenderPerFrame@StarImGui@@YAXXZ PROC			; StarImGui::RenderPerFrame, COMDAT

; 143  : }

	ret	0
?RenderPerFrame@StarImGui@@YAXXZ ENDP			; StarImGui::RenderPerFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
;	COMDAT ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
_TEXT	SEGMENT
$T2 = 32
this$ = 80
_Str$ = 88
_Mode$dead$ = 96
$initVBases$dead$ = 104
$T3 = 104
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 817  :         : _Mybase(_STD addressof(_Stringbuffer)), _Stringbuffer(_STD move(_Str), _Mode) {}

$LN86:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rdi, rdx
	mov	r14, rcx
	mov	DWORD PTR $T3[rsp], 0
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
	mov	QWORD PTR [rcx], rax
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
	mov	QWORD PTR [rcx+16], rax
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	mov	DWORD PTR $T3[rsp], 1
	lea	rbx, QWORD PTR [r14+24]
	xor	r8d, r8d
	mov	rdx, rbx
	mov	rcx, r14
	call	QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
	npad	1
	mov	rax, QWORD PTR [r14]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rcx+r14], rax
	mov	rax, QWORD PTR [r14]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-152]
	mov	DWORD PTR [rcx+r14-4], edx
	mov	QWORD PTR $T2[rsp], rbx

; 51   :         : _Al(_STD move(_Str._Getal())) {

	mov	rcx, rbx
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rbx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2942 :         _Result._Size  = _My_data._Mysize;

	mov	rbp, QWORD PTR [rdi+16]

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rsi, QWORD PTR [rdi+24]

; 2944 :         if (_My_data._Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN25@basic_stri

; 2945 :             _Result._Ptr = _My_data._Bx._Ptr;

	mov	rdx, QWORD PTR [rdi]

; 2946 :             _Result._Res = _My_data._Myres + 1;

	inc	rsi

; 2947 :         } else {

	jmp	SHORT $LN26@basic_stri
$LN25@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	esi, 17
	mov	ecx, esi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rax], xmm0
$LN26@basic_stri:

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 478  :         _Seekhigh                = _Pnew + _Size;

	lea	rcx, QWORD PTR [rdx+rbp]
	mov	QWORD PTR [rbx+104], rcx

; 479  :         auto _Next               = (_State & (_Atend | _Append)) ? _Seekhigh : _Pnew;
; 480  :         auto _End_buffer         = _Pnew + _Res;

	lea	rcx, QWORD PTR [rsi+rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf

; 251  :         *_IPfirst = _First;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rax], rdx

; 252  :         *_IPnext  = _Next;

	mov	rax, QWORD PTR [rbx+64]
	mov	QWORD PTR [rax], rdx

; 253  :         *_IPcount = static_cast<int>(_Last - _Next);

	sub	ecx, edx
	mov	rax, QWORD PTR [rbx+88]
	mov	DWORD PTR [rax], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 486  :             _Mysb::setg(_Pnew, _Pnew, _Seekhigh);

	mov	rcx, QWORD PTR [rbx+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf

; 208  :         *_IGfirst = _First;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR [rax], rdx

; 209  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rdx

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	ecx, edx
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 817  :         : _Mybase(_STD addressof(_Stringbuffer)), _Stringbuffer(_STD move(_Str), _Mode) {}

	mov	DWORD PTR [rbx+112], 33			; 00000021H
	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
this$ = 80
_Str$ = 88
_Mode$dead$ = 96
$initVBases$dead$ = 104
$T3 = 104
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T3[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T3[rbp], -2
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
this$ = 80
_Str$ = 88
_Mode$dead$ = 96
$initVBases$dead$ = 104
$T3 = 104
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
this$ = 80
_Str$ = 88
_Mode$dead$ = 96
$initVBases$dead$ = 104
$T3 = 104
?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T2[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
_TEXT	SEGMENT
this$ = 48
_Str$ = 56
_Mode$dead$ = 64
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 50   :     explicit basic_stringbuf(_Mystr&& _Str, ios_base::openmode _Mode = ios_base::in | ios_base::out)

$LN78:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 51   :         : _Al(_STD move(_Str._Getal())) {

	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	QWORD PTR [rbx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2942 :         _Result._Size  = _My_data._Mysize;

	mov	rbp, QWORD PTR [rdi+16]

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rsi, QWORD PTR [rdi+24]

; 2944 :         if (_My_data._Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN18@basic_stri

; 2945 :             _Result._Ptr = _My_data._Bx._Ptr;

	mov	rdx, QWORD PTR [rdi]

; 2946 :             _Result._Res = _My_data._Myres + 1;

	inc	rsi

; 2947 :         } else {

	jmp	SHORT $LN19@basic_stri
$LN18@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	esi, 17
	mov	ecx, esi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rax], xmm0
$LN19@basic_stri:

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 478  :         _Seekhigh                = _Pnew + _Size;

	lea	rcx, QWORD PTR [rdx+rbp]
	mov	QWORD PTR [rbx+104], rcx

; 479  :         auto _Next               = (_State & (_Atend | _Append)) ? _Seekhigh : _Pnew;
; 480  :         auto _End_buffer         = _Pnew + _Res;

	lea	rcx, QWORD PTR [rsi+rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf

; 251  :         *_IPfirst = _First;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rax], rdx

; 252  :         *_IPnext  = _Next;

	mov	rax, QWORD PTR [rbx+64]
	mov	QWORD PTR [rax], rdx

; 253  :         *_IPcount = static_cast<int>(_Last - _Next);

	sub	ecx, edx
	mov	rax, QWORD PTR [rbx+88]
	mov	DWORD PTR [rax], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 486  :             _Mysb::setg(_Pnew, _Pnew, _Seekhigh);

	mov	rcx, QWORD PTR [rbx+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf

; 208  :         *_IGfirst = _First;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR [rax], rdx

; 209  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rdx

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	ecx, edx
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 53   :     }

	mov	DWORD PTR [rbx+112], 33			; 00000021H
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Str$ = 56
_Mode$dead$ = 64
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream
;	COMDAT ?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
this$ = 48
_Str$ = 56
_State$ = 64
?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init_string_inplace, COMDAT

; 468  :     void _Init_string_inplace(_Mystr&& _Str, int _State) {

$LN71:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	eax, r8d
	mov	esi, r8d
	and	eax, 6
	mov	rdi, rdx
	mov	rbx, rcx
	cmp	al, 6

; 469  :         if ((_State & _Noread) && (_State & _Constant)) { // Cannot read / write buffer, do nothing

	jne	SHORT $LN2@Init_strin

; 470  :             _Seekhigh = nullptr;

	xor	r9d, r9d
	mov	QWORD PTR [rcx+104], r9

; 471  :             _Mystate  = _State | _From_rvalue;

	lea	eax, QWORD PTR [r9+32]

; 472  :             return;

	jmp	$LN1@Init_strin
$LN2@Init_strin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rax, QWORD PTR [rdx+24]
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], r14

; 2942 :         _Result._Size  = _My_data._Mysize;

	mov	r14, QWORD PTR [rdx+16]

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rax, 16

; 2944 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN9@Init_strin

; 2945 :             _Result._Ptr = _My_data._Bx._Ptr;

	mov	r8, QWORD PTR [rdx]

; 2946 :             _Result._Res = _My_data._Myres + 1;

	lea	ebp, DWORD PTR [rax+1]

; 2947 :         } else {

	jmp	SHORT $LN10@Init_strin
$LN9@Init_strin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ebp, 17
	mov	ecx, ebp
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	XMMWORD PTR [rax], xmm0
$LN10@Init_strin:

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 478  :         _Seekhigh                = _Pnew + _Size;

	lea	rdx, QWORD PTR [r8+r14]

; 483  :         if (_State & _Noread) { // maintain "_Allocated == eback() points to buffer base" invariant

	mov	r14, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4821 :         _My_data._Mysize = 0;

	xor	r9d, r9d
	mov	QWORD PTR [rdi+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 479  :         auto _Next               = (_State & (_Atend | _Append)) ? _Seekhigh : _Pnew;

	test	sil, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], r9b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf

; 253  :         *_IPcount = static_cast<int>(_Last - _Next);

	mov	ecx, r8d
	mov	rax, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 478  :         _Seekhigh                = _Pnew + _Size;

	mov	QWORD PTR [rbx+104], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf

; 251  :         *_IPfirst = _First;

	cmove	rdx, r8

; 253  :         *_IPcount = static_cast<int>(_Last - _Next);

	sub	ecx, edx
	add	ecx, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 483  :         if (_State & _Noread) { // maintain "_Allocated == eback() points to buffer base" invariant

	mov	rbp, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf

; 251  :         *_IPfirst = _First;

	mov	QWORD PTR [rax], r8

; 252  :         *_IPnext  = _Next;

	mov	rax, QWORD PTR [rbx+64]
	mov	QWORD PTR [rax], rdx

; 253  :         *_IPcount = static_cast<int>(_Last - _Next);

	mov	rax, QWORD PTR [rbx+88]
	mov	DWORD PTR [rax], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 483  :         if (_State & _Noread) { // maintain "_Allocated == eback() points to buffer base" invariant

	mov	rax, QWORD PTR [rbx+24]
	test	sil, 4
	je	SHORT $LN3@Init_strin
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf

; 208  :         *_IGfirst = _First;

	mov	QWORD PTR [rax], r8

; 209  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], r8

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 485  :         } else {

	jmp	SHORT $LN55@Init_strin
$LN3@Init_strin:

; 486  :             _Mysb::setg(_Pnew, _Pnew, _Seekhigh);

	mov	rcx, QWORD PTR [rbx+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\streambuf

; 208  :         *_IGfirst = _First;

	mov	QWORD PTR [rax], r8

; 210  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	ecx, r8d
	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], r8
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], ecx
$LN55@Init_strin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\sstream

; 489  :         _Mystate = _State | _Allocated | _From_rvalue;

	mov	eax, 33					; 00000021H
$LN1@Init_strin:

; 490  :     }

	or	eax, esi
	mov	DWORD PTR [rbx+112], eax
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Init_string_inplace@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init_string_inplace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Release_to_buffer@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AU_Released_buffer@12@AEAV?$allocator@D@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Al$dead$ = 64
?_Release_to_buffer@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AU_Released_buffer@12@AEAV?$allocator@D@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Release_to_buffer, COMDAT

; 2938 :     _NODISCARD _Released_buffer _Release_to_buffer(_Alloc& _Al) {

$LN52:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2939 :         // Release to a buffer, or allocate a new one if in small string mode; used exclusively by basic_stringbuf
; 2940 :         _Released_buffer _Result;
; 2941 :         auto& _My_data = _Mypair._Myval2;
; 2942 :         _Result._Size  = _My_data._Mysize;

	mov	rax, QWORD PTR [rcx+16]
	mov	rdi, rdx
	mov	QWORD PTR [rdx+8], rax
	mov	rbx, rcx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2943 :         _ASAN_STRING_REMOVE(*this);
; 2944 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN2@Release_to

; 2945 :             _Result._Ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 2946 :             _Result._Res = _My_data._Myres + 1;

	mov	rsi, QWORD PTR [rcx+24]
	inc	rsi

; 2947 :         } else {

	jmp	SHORT $LN3@Release_to
$LN2@Release_to:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	esi, 17
	mov	ecx, esi
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2949 :             _Result._Ptr = _Al.allocate(_BUF_SIZE + 1);

	mov	QWORD PTR [rdi], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR [rax], xmm0
$LN3@Release_to:

; 4820 :         auto& _My_data   = _Mypair._Myval2;

	mov	QWORD PTR [rdi+16], rsi

; 2950 :             _Traits::copy(_Unfancy(_Result._Ptr), _My_data._Bx._Buf, _BUF_SIZE);
; 2951 :             _Result._Res = _BUF_SIZE + 1;
; 2952 :         }
; 2953 :         _My_data._Orphan_all();
; 2954 :         _Tidy_init();
; 2955 :         return _Result;

	mov	rax, rdi

; 2956 :     }

	mov	rsi, QWORD PTR [rsp+56]

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 2956 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Release_to_buffer@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AU_Released_buffer@12@AEAV?$allocator@D@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Release_to_buffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
_Istr$ = 8
_Str$ = 16
_Delim$dead$ = 24
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 78   :     // get characters into string, discard delimiter
; 79   :     return _STD getline(_STD move(_Istr), _Str, _Delim);

	jmp	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 48
_Ok$ = 64
_Istr$ = 128
_Str$ = 136
_Delim$dead$ = 144
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 27   :     basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str, const _Elem _Delim) {

$LN88:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rdi, rdx
	mov	rsi, rcx
	mov	QWORD PTR _Istr$GSCopy$[rsp], rcx

; 28   :     // get characters into string, discard delimiter
; 29   :     using _Myis = basic_istream<_Elem, _Traits>;
; 30   : 
; 31   :     typename _Myis::iostate _State = _Myis::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR _State$[rsp], ebx

; 32   :     bool _Changed                  = false;

	xor	r14b, r14b
	mov	BYTE PTR _Changed$[rsp], r14b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream

; 79   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

	mov	r15, rcx
	mov	QWORD PTR _Ok$[rsp], rcx

; 80   :             const auto _Rdbuf = _Myistr.rdbuf();

	mov	rax, QWORD PTR [rcx]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+r15+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream

; 81   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN41@getline

; 82   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN41@getline:

; 101  :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

	mov	dl, 1
	mov	rcx, rsi
	call	QWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
	mov	BYTE PTR _Ok$[rsp+8], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 33   :     const typename _Myis::sentry _Ok(_Istr, true);

	test	al, al

; 34   : 
; 35   :     if (_Ok) { // state okay, extract characters

	je	$LN82@getline
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN83@getline

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN83@getline:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [rdi+16], rbx
	mov	BYTE PTR [rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 39   :         typename _Traits::int_type _Meta            = _Istr.rdbuf()->sgetc();

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	mov	r9d, eax
	mov	r12, 9223372036854775807		; 7fffffffffffffffH
$LL4@getline:

; 42   :             if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

	cmp	r9d, -1
	jne	SHORT $LN7@getline

; 43   :                 _State |= _Myis::eofbit;

	lea	ebx, QWORD PTR [r9+2]

; 44   :                 break;

	jmp	SHORT $LN85@getline
$LN7@getline:

; 45   :             } else if (_Traits::eq_int_type(_Meta, _Metadelim)) { // got a delimiter, discard it and quit

	cmp	r9d, 44					; 0000002cH
	jne	SHORT $LN9@getline

; 46   :                 _Changed = true;

	mov	r14b, 1
	mov	BYTE PTR _Changed$[rsp], r14b

; 47   :                 _Istr.rdbuf()->sbumpc();

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ

; 48   :                 break;

	jmp	SHORT $LN3@getline
$LN9@getline:

; 49   :             } else if (_Str.max_size() <= _Str.size()) { // string too large, quit

	mov	rcx, QWORD PTR [rdi+16]
	cmp	rcx, r12
	jb	SHORT $LN11@getline

; 50   :                 _State |= _Myis::failbit;

	mov	ebx, 2
$LN85@getline:

; 55   :             }
; 56   :         }

	mov	DWORD PTR _State$[rsp], ebx
$LN3@getline:
	jmp	SHORT $LN18@getline
$LN11@getline:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN52@getline

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN55@getline

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN55@getline:

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 4053 :             return;

	jmp	SHORT $LN51@getline
$LN52@getline:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN51@getline:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 54   :                 _Changed = true;

	mov	r14b, 1
	mov	BYTE PTR _Changed$[rsp], r14b

; 40   : 
; 41   :         for (;; _Meta = _Istr.rdbuf()->snextc()) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	mov	r9d, eax
	jmp	$LL4@getline
$LN19@getline:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
	mov	ebx, DWORD PTR _State$[rsp]
	movzx	r14d, BYTE PTR _Changed$[rsp]
	mov	r15, QWORD PTR _Ok$[rsp]
	mov	rsi, QWORD PTR _Istr$GSCopy$[rsp]
$LN18@getline:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 57   :         _CATCH_IO_(_Myis, _Istr)
; 58   :     }
; 59   : 
; 60   :     if (!_Changed) {

	test	r14b, r14b
	jne	SHORT $LN13@getline
$LN82@getline:

; 61   :         _State |= _Myis::failbit;

	or	ebx, 2
$LN13@getline:

; 62   :     }
; 63   : 
; 64   :     _Istr.setstate(_State);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	mov	edx, ebx
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream

; 87   :             const auto _Rdbuf = _Myistr.rdbuf();

	mov	rcx, QWORD PTR [r15]
	movsxd	rdx, DWORD PTR [rcx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rdx+r15+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream

; 88   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN84@getline

; 89   :                 _Rdbuf->_Unlock();

	mov	rdx, QWORD PTR [rcx]
	call	QWORD PTR [rdx+16]
	npad	1
$LN84@getline:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 66   : }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 48
_Ok$ = 64
_Istr$ = 128
_Str$ = 136
_Delim$dead$ = 144
?dtor$5@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$5
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$5@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 48
_Ok$ = 64
_Istr$ = 128
_Str$ = 136
_Delim$dead$ = 144
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 48
_Ok$ = 64
_Istr$ = 128
_Str$ = 136
_Delim$dead$ = 144
?catch$9@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$9

; 57   :         _CATCH_IO_(_Myis, _Istr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:
	mov	rdx, QWORD PTR _Istr$GSCopy$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$9@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$9
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
$LN13:
	sub	rsp, 40					; 00000028H

; 87   :             const auto _Rdbuf = _Myistr.rdbuf();

	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rdx+rcx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream

; 88   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN10@sentry

; 89   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN10@sentry:
	add	rsp, 40					; 00000028H
	ret	0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 104  :             return _Ok;

	movzx	eax, BYTE PTR [rcx+8]

; 105  :         }

	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
_TEXT	SEGMENT
this$ = 48
_Istr$ = 56
_Noskip$dead$ = 64
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 101  :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 79   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

	mov	QWORD PTR [rcx], rdx

; 80   :             const auto _Rdbuf = _Myistr.rdbuf();

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [r8+rdx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream

; 81   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN5@sentry

; 82   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN5@sentry:

; 101  :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

	mov	dl, 1
	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
	mov	BYTE PTR [rbx+8], al
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Istr$ = 56
_Noskip$dead$ = 64
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 86   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept {

$LN9:
	sub	rsp, 40					; 00000028H

; 87   :             const auto _Rdbuf = _Myistr.rdbuf();

	mov	rdx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream

; 88   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN2@Sentry_bas

; 89   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 90   :             }
; 91   :         }

	add	rsp, 40					; 00000028H
	ret	0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@erase

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN10@erase:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [rcx+16], 0
	mov	BYTE PTR [rax], 0

; 3627 :         _Mypair._Myval2._Check_offset(_Off);
; 3628 :         _Eos(_Off);
; 3629 :         return *this;

	mov	rax, rcx

; 3630 :     }

	ret	0
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Istr$ = 56
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 79   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rcx], rdx
	mov	rbx, rcx

; 80   :             const auto _Rdbuf = _Myistr.rdbuf();

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [r8+rdx+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\istream

; 81   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN7@Sentry_bas

; 82   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
$LN7@Sentry_bas:

; 83   :             }
; 84   :         }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
END
