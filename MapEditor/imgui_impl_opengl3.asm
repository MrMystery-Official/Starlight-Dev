; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CF@PMPPENEO@Failed?5to?5initialize?5OpenGL?5loa@ ; `string'
PUBLIC	??_C@_0N@DOKAJOHF@opengl32?4dll@		; `string'
PUBLIC	??_C@_0N@NPMABONB@?$CDversion?5130@		; `string'
PUBLIC	??_C@_0BD@BIIFHGKK@imgui_impl_opengl3@		; `string'
PUBLIC	??_C@_0FD@CCPHEBOI@ERROR?3?5ImGui_ImplOpenGL3_Create@ ; `string'
PUBLIC	??_C@_0BE@NFGEKHNE@GL_ARB_clip_control@		; `string'
PUBLIC	??_C@_0EP@EPOJCDAM@ERROR?3?5ImGui_ImplOpenGL3_Create@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0PF@HLCKEEPJ@uniform?5mat4?5ProjMtx?$DL?6attribute@ ; `string'
PUBLIC	??_C@_0M@GIPNOCDP@?$CDversion?5?$CFd@		; `string'
PUBLIC	??_C@_0BDB@OGMOMKDH@precision?5highp?5float?$DL?6layout?5?$CI@ ; `string'
PUBLIC	??_C@_0NI@FNJCCLKC@uniform?5mat4?5ProjMtx?$DL?6in?5vec2?5P@ ; `string'
PUBLIC	??_C@_0MM@DPJDGIBF@?$CDifdef?5GL_ES?6?5?5?5?5precision?5medi@ ; `string'
PUBLIC	??_C@_0BBK@IIAKMGPG@layout?5?$CIlocation?5?$DN?50?$CJ?5in?5vec2?5P@ ; `string'
PUBLIC	??_C@_0MP@NIPCIBOH@precision?5mediump?5float?$DL?6unifor@ ; `string'
PUBLIC	??_C@_0KA@HKFHPDID@uniform?5sampler2D?5Texture?$DL?6in?5v@ ; `string'
PUBLIC	??_C@_0O@FGFIIOKE@vertex?5shader@		; `string'
PUBLIC	??_C@_0LG@KGGNFOLP@in?5vec2?5Frag_UV?$DL?6in?5vec4?5Frag_C@ ; `string'
PUBLIC	??_C@_0P@HEBBPOKI@shader?5program@		; `string'
PUBLIC	??_C@_0BA@MDFBHBOK@fragment?5shader@		; `string'
PUBLIC	??_C@_07EDEMHDKD@ProjMtx@			; `string'
PUBLIC	??_C@_07GKACAEDJ@Texture@			; `string'
PUBLIC	??_C@_02IGCIDAGE@UV@				; `string'
PUBLIC	??_C@_08GCJNLIKG@Position@			; `string'
PUBLIC	imgl3wProcs
EXTRN	__imp_LoadLibraryA:PROC
imgl3wProcs DB	01d8H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_08GCJNLIKG@Position@
CONST	SEGMENT
??_C@_08GCJNLIKG@Position@ DB 'Position', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02IGCIDAGE@UV@
CONST	SEGMENT
??_C@_02IGCIDAGE@UV@ DB 'UV', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07GKACAEDJ@Texture@
CONST	SEGMENT
??_C@_07GKACAEDJ@Texture@ DB 'Texture', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EDEMHDKD@ProjMtx@
CONST	SEGMENT
??_C@_07EDEMHDKD@ProjMtx@ DB 'ProjMtx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDFBHBOK@fragment?5shader@
CONST	SEGMENT
??_C@_0BA@MDFBHBOK@fragment?5shader@ DB 'fragment shader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HEBBPOKI@shader?5program@
CONST	SEGMENT
??_C@_0P@HEBBPOKI@shader?5program@ DB 'shader program', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LG@KGGNFOLP@in?5vec2?5Frag_UV?$DL?6in?5vec4?5Frag_C@
CONST	SEGMENT
??_C@_0LG@KGGNFOLP@in?5vec2?5Frag_UV?$DL?6in?5vec4?5Frag_C@ DB 'in vec2 F'
	DB	'rag_UV;', 0aH, 'in vec4 Frag_Color;', 0aH, 'uniform sampler2D'
	DB	' Texture;', 0aH, 'layout (location = 0) out vec4 Out_Color;', 0aH
	DB	'void main()', 0aH, '{', 0aH, '    Out_Color = Frag_Color * te'
	DB	'xture(Texture, Frag_UV.st);', 0aH, '}', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FGFIIOKE@vertex?5shader@
CONST	SEGMENT
??_C@_0O@FGFIIOKE@vertex?5shader@ DB 'vertex shader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0KA@HKFHPDID@uniform?5sampler2D?5Texture?$DL?6in?5v@
CONST	SEGMENT
??_C@_0KA@HKFHPDID@uniform?5sampler2D?5Texture?$DL?6in?5v@ DB 'uniform sa'
	DB	'mpler2D Texture;', 0aH, 'in vec2 Frag_UV;', 0aH, 'in vec4 Fra'
	DB	'g_Color;', 0aH, 'out vec4 Out_Color;', 0aH, 'void main()', 0aH
	DB	'{', 0aH, '    Out_Color = Frag_Color * texture(Texture, Frag_'
	DB	'UV.st);', 0aH, '}', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0MP@NIPCIBOH@precision?5mediump?5float?$DL?6unifor@
CONST	SEGMENT
??_C@_0MP@NIPCIBOH@precision?5mediump?5float?$DL?6unifor@ DB 'precision m'
	DB	'ediump float;', 0aH, 'uniform sampler2D Texture;', 0aH, 'in v'
	DB	'ec2 Frag_UV;', 0aH, 'in vec4 Frag_Color;', 0aH, 'layout (loca'
	DB	'tion = 0) out vec4 Out_Color;', 0aH, 'void main()', 0aH, '{', 0aH
	DB	'    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);', 0aH
	DB	'}', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBK@IIAKMGPG@layout?5?$CIlocation?5?$DN?50?$CJ?5in?5vec2?5P@
CONST	SEGMENT
??_C@_0BBK@IIAKMGPG@layout?5?$CIlocation?5?$DN?50?$CJ?5in?5vec2?5P@ DB 'l'
	DB	'ayout (location = 0) in vec2 Position;', 0aH, 'layout (locati'
	DB	'on = 1) in vec2 UV;', 0aH, 'layout (location = 2) in vec4 Col'
	DB	'or;', 0aH, 'uniform mat4 ProjMtx;', 0aH, 'out vec2 Frag_UV;', 0aH
	DB	'out vec4 Frag_Color;', 0aH, 'void main()', 0aH, '{', 0aH, '  '
	DB	'  Frag_UV = UV;', 0aH, '    Frag_Color = Color;', 0aH, '    g'
	DB	'l_Position = ProjMtx * vec4(Position.xy,0,1);', 0aH, '}', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0MM@DPJDGIBF@?$CDifdef?5GL_ES?6?5?5?5?5precision?5medi@
CONST	SEGMENT
??_C@_0MM@DPJDGIBF@?$CDifdef?5GL_ES?6?5?5?5?5precision?5medi@ DB '#ifdef '
	DB	'GL_ES', 0aH, '    precision mediump float;', 0aH, '#endif', 0aH
	DB	'uniform sampler2D Texture;', 0aH, 'varying vec2 Frag_UV;', 0aH
	DB	'varying vec4 Frag_Color;', 0aH, 'void main()', 0aH, '{', 0aH, ' '
	DB	'   gl_FragColor = Frag_Color * texture2D(Texture, Frag_UV.st)'
	DB	';', 0aH, '}', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0NI@FNJCCLKC@uniform?5mat4?5ProjMtx?$DL?6in?5vec2?5P@
CONST	SEGMENT
??_C@_0NI@FNJCCLKC@uniform?5mat4?5ProjMtx?$DL?6in?5vec2?5P@ DB 'uniform m'
	DB	'at4 ProjMtx;', 0aH, 'in vec2 Position;', 0aH, 'in vec2 UV;', 0aH
	DB	'in vec4 Color;', 0aH, 'out vec2 Frag_UV;', 0aH, 'out vec4 Fra'
	DB	'g_Color;', 0aH, 'void main()', 0aH, '{', 0aH, '    Frag_UV = '
	DB	'UV;', 0aH, '    Frag_Color = Color;', 0aH, '    gl_Position ='
	DB	' ProjMtx * vec4(Position.xy,0,1);', 0aH, '}', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDB@OGMOMKDH@precision?5highp?5float?$DL?6layout?5?$CI@
CONST	SEGMENT
??_C@_0BDB@OGMOMKDH@precision?5highp?5float?$DL?6layout?5?$CI@ DB 'precis'
	DB	'ion highp float;', 0aH, 'layout (location = 0) in vec2 Positi'
	DB	'on;', 0aH, 'layout (location = 1) in vec2 UV;', 0aH, 'layout '
	DB	'(location = 2) in vec4 Color;', 0aH, 'uniform mat4 ProjMtx;', 0aH
	DB	'out vec2 Frag_UV;', 0aH, 'out vec4 Frag_Color;', 0aH, 'void m'
	DB	'ain()', 0aH, '{', 0aH, '    Frag_UV = UV;', 0aH, '    Frag_Co'
	DB	'lor = Color;', 0aH, '    gl_Position = ProjMtx * vec4(Positio'
	DB	'n.xy,0,1);', 0aH, '}', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GIPNOCDP@?$CDversion?5?$CFd@
CONST	SEGMENT
??_C@_0M@GIPNOCDP@?$CDversion?5?$CFd@ DB '#version %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0PF@HLCKEEPJ@uniform?5mat4?5ProjMtx?$DL?6attribute@
CONST	SEGMENT
??_C@_0PF@HLCKEEPJ@uniform?5mat4?5ProjMtx?$DL?6attribute@ DB 'uniform mat'
	DB	'4 ProjMtx;', 0aH, 'attribute vec2 Position;', 0aH, 'attribute'
	DB	' vec2 UV;', 0aH, 'attribute vec4 Color;', 0aH, 'varying vec2 '
	DB	'Frag_UV;', 0aH, 'varying vec4 Frag_Color;', 0aH, 'void main()'
	DB	0aH, '{', 0aH, '    Frag_UV = UV;', 0aH, '    Frag_Color = Col'
	DB	'or;', 0aH, '    gl_Position = ProjMtx * vec4(Position.xy,0,1)'
	DB	';', 0aH, '}', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@EPOJCDAM@ERROR?3?5ImGui_ImplOpenGL3_Create@
CONST	SEGMENT
??_C@_0EP@EPOJCDAM@ERROR?3?5ImGui_ImplOpenGL3_Create@ DB 'ERROR: ImGui_Im'
	DB	'plOpenGL3_CreateDeviceObjects: failed to link %s! With GLSL %'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NFGEKHNE@GL_ARB_clip_control@
CONST	SEGMENT
??_C@_0BE@NFGEKHNE@GL_ARB_clip_control@ DB 'GL_ARB_clip_control', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@CCPHEBOI@ERROR?3?5ImGui_ImplOpenGL3_Create@
CONST	SEGMENT
??_C@_0FD@CCPHEBOI@ERROR?3?5ImGui_ImplOpenGL3_Create@ DB 'ERROR: ImGui_Im'
	DB	'plOpenGL3_CreateDeviceObjects: failed to compile %s! With GLS'
	DB	'L: %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BIIFHGKK@imgui_impl_opengl3@
CONST	SEGMENT
??_C@_0BD@BIIFHGKK@imgui_impl_opengl3@ DB 'imgui_impl_opengl3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NPMABONB@?$CDversion?5130@
CONST	SEGMENT
??_C@_0N@NPMABONB@?$CDversion?5130@ DB '#version 130', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DOKAJOHF@opengl32?4dll@
CONST	SEGMENT
??_C@_0N@DOKAJOHF@opengl32?4dll@ DB 'opengl32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PMPPENEO@Failed?5to?5initialize?5OpenGL?5loa@
CONST	SEGMENT
??_C@_0CF@PMPPENEO@Failed?5to?5initialize?5OpenGL?5loa@ DB 'Failed to ini'
	DB	'tialize OpenGL loader!', 0aH, 00H		; `string'
	ORG $+1
proc_names DQ	FLAT:??_C@_0BA@KOBBIKOF@glActiveTexture@
	DQ	FLAT:??_C@_0P@LDMLEABL@glAttachShader@
	DQ	FLAT:??_C@_0N@BONEPPLO@glBindBuffer@
	DQ	FLAT:??_C@_0O@PDEILAPG@glBindSampler@
	DQ	FLAT:??_C@_0O@JKKCIBGC@glBindTexture@
	DQ	FLAT:??_C@_0BC@LHBAHFAN@glBindVertexArray@
	DQ	FLAT:??_C@_0BA@PFHILPAN@glBlendEquation@
	DQ	FLAT:??_C@_0BI@JNHDNJAG@glBlendEquationSeparate@
	DQ	FLAT:??_C@_0BE@LLLCIIOO@glBlendFuncSeparate@
	DQ	FLAT:??_C@_0N@JHHJMABP@glBufferData@
	DQ	FLAT:??_C@_0BA@GAJMDBBN@glBufferSubData@
	DQ	FLAT:??_C@_07IBAPPAHJ@glClear@
	DQ	FLAT:??_C@_0N@OGLMDNKC@glClearColor@
	DQ	FLAT:??_C@_0BA@DGIEGONF@glCompileShader@
	DQ	FLAT:??_C@_0BA@FLKLHNKP@glCreateProgram@
	DQ	FLAT:??_C@_0P@HGHBNC@glCreateShader@
	DQ	FLAT:??_C@_0BA@DMNLADIO@glDeleteBuffers@
	DQ	FLAT:??_C@_0BA@NKGCDOPO@glDeleteProgram@
	DQ	FLAT:??_C@_0P@HHCDONAG@glDeleteShader@
	DQ	FLAT:??_C@_0BB@KMPLFJIC@glDeleteTextures@
	DQ	FLAT:??_C@_0BF@BMPCJLEF@glDeleteVertexArrays@
	DQ	FLAT:??_C@_0P@DJFJFCJL@glDetachShader@
	DQ	FLAT:??_C@_09MHGMIMKN@glDisable@
	DQ	FLAT:??_C@_0BL@NKHLOFFF@glDisableVertexAttribArray@
	DQ	FLAT:??_C@_0P@MENFIFGE@glDrawElements@
	DQ	FLAT:??_C@_0BJ@LFMMIAHA@glDrawElementsBaseVertex@
	DQ	FLAT:??_C@_08OOEHEKOP@glEnable@
	DQ	FLAT:??_C@_0BK@EHBAHNHE@glEnableVertexAttribArray@
	DQ	FLAT:??_C@_07COFELLJA@glFlush@
	DQ	FLAT:??_C@_0N@LAOHBIBA@glGenBuffers@
	DQ	FLAT:??_C@_0O@LLMANLNK@glGenTextures@
	DQ	FLAT:??_C@_0BC@EPJLBJBJ@glGenVertexArrays@
	DQ	FLAT:??_C@_0BE@BEPGJDMM@glGetAttribLocation@
	DQ	FLAT:??_C@_0L@FPKAMKHB@glGetError@
	DQ	FLAT:??_C@_0O@DHHDCCLF@glGetIntegerv@
	DQ	FLAT:??_C@_0BE@DHGHAJFL@glGetProgramInfoLog@
	DQ	FLAT:??_C@_0P@FMMDFLCO@glGetProgramiv@
	DQ	FLAT:??_C@_0BD@GIABBCMO@glGetShaderInfoLog@
	DQ	FLAT:??_C@_0O@JBDFPDMG@glGetShaderiv@
	DQ	FLAT:??_C@_0M@OPOBFDCB@glGetString@
	DQ	FLAT:??_C@_0N@PILJCBOD@glGetStringi@
	DQ	FLAT:??_C@_0BF@KIOPGICP@glGetUniformLocation@
	DQ	FLAT:??_C@_0BK@DOJMENLD@glGetVertexAttribPointerv@
	DQ	FLAT:??_C@_0BE@HLCEAPNO@glGetVertexAttribiv@
	DQ	FLAT:??_C@_0M@INHMIHKC@glIsEnabled@
	DQ	FLAT:??_C@_0M@INLOJDGO@glIsProgram@
	DQ	FLAT:??_C@_0O@PIOEEBPO@glLinkProgram@
	DQ	FLAT:??_C@_0O@JCCIGLOF@glPixelStorei@
	DQ	FLAT:??_C@_0O@DKMNBFMB@glPolygonMode@
	DQ	FLAT:??_C@_0N@CKFNNHOO@glReadPixels@
	DQ	FLAT:??_C@_09ECGPAEPL@glScissor@
	DQ	FLAT:??_C@_0P@DFHCPFMO@glShaderSource@
	DQ	FLAT:??_C@_0N@JBIKHLCC@glTexImage2D@
	DQ	FLAT:??_C@_0BA@KDNJAKA@glTexParameteri@
	DQ	FLAT:??_C@_0M@EMBKBDCK@glUniform1i@
	DQ	FLAT:??_C@_0BD@LNHCBEKP@glUniformMatrix4fv@
	DQ	FLAT:??_C@_0N@ICBDHBI@glUseProgram@
	DQ	FLAT:??_C@_0BG@JPNNNPKG@glVertexAttribPointer@
	DQ	FLAT:??_C@_0L@KBLIPDFH@glViewport@
PUBLIC	??$IM_DELETE@UImGui_ImplOpenGL3_Data@@@@YAXPEAUImGui_ImplOpenGL3_Data@@@Z ; IM_DELETE<ImGui_ImplOpenGL3_Data>
PUBLIC	??A?$ImVector@UImDrawCmd@@@@QEBAAEBUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
PUBLIC	?ImGui_ImplOpenGL3_DestroyDeviceObjects@@YAXXZ	; ImGui_ImplOpenGL3_DestroyDeviceObjects
PUBLIC	?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ	; ImGui_ImplOpenGL3_CreateDeviceObjects
PUBLIC	?ImGui_ImplOpenGL3_DestroyFontsTexture@@YAXXZ	; ImGui_ImplOpenGL3_DestroyFontsTexture
PUBLIC	?ImGui_ImplOpenGL3_CreateFontsTexture@@YA_NXZ	; ImGui_ImplOpenGL3_CreateFontsTexture
PUBLIC	?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z ; ImGui_ImplOpenGL3_RenderDrawData
PUBLIC	?ImGui_ImplOpenGL3_NewFrame@@YAXXZ		; ImGui_ImplOpenGL3_NewFrame
PUBLIC	?ImGui_ImplOpenGL3_Shutdown@@YAXXZ		; ImGui_ImplOpenGL3_Shutdown
PUBLIC	?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z		; ImGui_ImplOpenGL3_Init
PUBLIC	??0ImGui_ImplOpenGL3_Data@@QEAA@XZ		; ImGui_ImplOpenGL3_Data::ImGui_ImplOpenGL3_Data
PUBLIC	imgl3wInit2
PUBLIC	imgl3wInit
PUBLIC	fprintf
PUBLIC	?SetTexID@ImFontAtlas@@QEAAXPEAX@Z		; ImFontAtlas::SetTexID
PUBLIC	?GetTexID@ImDrawCmd@@QEBAPEAXXZ			; ImDrawCmd::GetTexID
libgl	DQ	01H DUP (?)
version	DQ	01H DUP (?)
wgl_get_proc_address DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplOpenGL3_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z DD imagerel ?ImGui_ImplOpenGL3_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z
	DD	imagerel ?ImGui_ImplOpenGL3_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z+66
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplOpenGL3_DestroyDeviceObjects@@YAXXZ DD imagerel $LN24
	DD	imagerel $LN24+200
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_DestroyDeviceObjects@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ DD imagerel $LN70
	DD	imagerel $LN70+1202
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckProgram@@YA_NIPEBD@Z DD imagerel ?CheckProgram@@YA_NIPEBD@Z
	DD	imagerel ?CheckProgram@@YA_NIPEBD@Z+361
	DD	imagerel $unwind$?CheckProgram@@YA_NIPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckShader@@YA_NIPEBD@Z DD imagerel ?CheckShader@@YA_NIPEBD@Z
	DD	imagerel ?CheckShader@@YA_NIPEBD@Z+344
	DD	imagerel $unwind$?CheckShader@@YA_NIPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplOpenGL3_DestroyFontsTexture@@YAXXZ DD imagerel $LN11
	DD	imagerel $LN11+86
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_DestroyFontsTexture@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplOpenGL3_CreateFontsTexture@@YA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+295
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_CreateFontsTexture@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD imagerel $LN102
	DD	imagerel $LN102+93
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD imagerel $LN102+93
	DD	imagerel $LN102+97
	DD	imagerel $chain$0$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD imagerel $LN102+97
	DD	imagerel $LN102+109
	DD	imagerel $chain$3$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD imagerel $LN102+109
	DD	imagerel $LN102+1203
	DD	imagerel $chain$7$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD imagerel $LN102+1203
	DD	imagerel $LN102+1374
	DD	imagerel $chain$8$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD imagerel $LN102+1374
	DD	imagerel $LN102+1406
	DD	imagerel $chain$9$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD imagerel $LN102+1406
	DD	imagerel $LN102+1438
	DD	imagerel $chain$10$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD imagerel $LN102+1438
	DD	imagerel $LN102+1615
	DD	imagerel $chain$11$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD imagerel $LN102+1615
	DD	imagerel $LN102+1641
	DD	imagerel $chain$12$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplOpenGL3_SetupRenderState@@YAXPEAUImDrawData@@HHI@Z DD imagerel ?ImGui_ImplOpenGL3_SetupRenderState@@YAXPEAUImDrawData@@HHI@Z
	DD	imagerel ?ImGui_ImplOpenGL3_SetupRenderState@@YAXPEAUImDrawData@@HHI@Z+720
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_SetupRenderState@@YAXPEAUImDrawData@@HHI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplOpenGL3_Shutdown@@YAXXZ DD imagerel $LN46
	DD	imagerel $LN46+298
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_Shutdown@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z DD imagerel $LN94
	DD	imagerel $LN94+78
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z DD imagerel $LN94+78
	DD	imagerel $LN94+208
	DD	imagerel $chain$0$?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z DD imagerel $LN94+208
	DD	imagerel $LN94+852
	DD	imagerel $chain$1$?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_procs DD imagerel load_procs
	DD	imagerel load_procs+64
	DD	imagerel $unwind$load_procs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$imgl3wInit2 DD imagerel $LN26
	DD	imagerel $LN26+217
	DD	imagerel $unwind$imgl3wInit2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$imgl3wInit DD imagerel $LN40
	DD	imagerel $LN40+39
	DD	imagerel $unwind$imgl3wInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$imgl3wInit DD imagerel $LN40+39
	DD	imagerel $LN40+198
	DD	imagerel $chain$3$imgl3wInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$imgl3wInit DD imagerel $LN40+198
	DD	imagerel $LN40+215
	DD	imagerel $chain$4$imgl3wInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$imgl3wInit DD imagerel $LN40+215
	DD	imagerel $LN40+337
	DD	imagerel $chain$6$imgl3wInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_version DD imagerel parse_version
	DD	imagerel parse_version+156
	DD	imagerel $unwind$parse_version
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_proc DD imagerel get_proc
	DD	imagerel get_proc+48
	DD	imagerel $unwind$get_proc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$open_libgl DD imagerel open_libgl
	DD	imagerel open_libgl+69
	DD	imagerel $unwind$open_libgl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN6
	DD	imagerel $LN6+69
	DD	imagerel $unwind$fprintf
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$open_libgl DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_proc DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_version DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$imgl3wInit DD 020021H
	DD	086400H
	DD	imagerel $LN40
	DD	imagerel $LN40+39
	DD	imagerel $unwind$imgl3wInit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$imgl3wInit DD 020021H
	DD	086400H
	DD	imagerel $LN40
	DD	imagerel $LN40+39
	DD	imagerel $unwind$imgl3wInit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$imgl3wInit DD 081e21H
	DD	04741eH
	DD	086419H
	DD	075411H
	DD	063405H
	DD	imagerel $LN40
	DD	imagerel $LN40+39
	DD	imagerel $unwind$imgl3wInit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$imgl3wInit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$imgl3wInit2 DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_procs DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z DD 021H
	DD	imagerel $LN94
	DD	imagerel $LN94+78
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z DD 020521H
	DD	0ae405H
	DD	imagerel $LN94
	DD	imagerel $LN94+78
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z DD 082319H
	DD	0d6414H
	DD	0c5414H
	DD	0b3414H
	DD	070107214H
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplOpenGL3_Shutdown@@YAXXZ DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplOpenGL3_SetupRenderState@@YAXPEAUImDrawData@@HHI@Z DD 0b2c19H
	DD	09681aH
	DD	0140112H
	DD	0e009f00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD 021H
	DD	imagerel $LN102
	DD	imagerel $LN102+93
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD 020021H
	DD	01ef400H
	DD	imagerel $LN102
	DD	imagerel $LN102+93
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD 040021H
	DD	01ef400H
	DD	027e400H
	DD	imagerel $LN102
	DD	imagerel $LN102+93
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD 040021H
	DD	01ef400H
	DD	027e400H
	DD	imagerel $LN102+93
	DD	imagerel $LN102+97
	DD	imagerel $chain$0$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD 021H
	DD	imagerel $LN102+97
	DD	imagerel $LN102+109
	DD	imagerel $chain$3$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD 081421H
	DD	0b9814H
	DD	0c880fH
	DD	0d780aH
	DD	0e6805H
	DD	imagerel $LN102+97
	DD	imagerel $LN102+109
	DD	imagerel $chain$3$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD 060c21H
	DD	01ef40cH
	DD	027e408H
	DD	0267404H
	DD	imagerel $LN102+93
	DD	imagerel $LN102+97
	DD	imagerel $chain$0$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD 020421H
	DD	0256404H
	DD	imagerel $LN102
	DD	imagerel $LN102+93
	DD	imagerel $unwind$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z DD 062219H
	DD	01f0114H
	DD	0c007d009H
	DD	050043005H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplOpenGL3_CreateFontsTexture@@YA_NXZ DD 041919H
	DD	010340aH
	DD	07006d20aH
	DD	imagerel __GSHandlerCheck
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplOpenGL3_DestroyFontsTexture@@YAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?CheckShader@@YA_NIPEBD@Z DB 08H
	DB	098H
	DB	00H
	DB	0aeH
	DB	02H
	DB	0e4H
	DB	04H
	DB	'b'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?CheckShader@@YA_NIPEBD@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$ImVector@D@@QEAA@XZ
	DB	040H
	DB	03eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?CheckShader@@YA_NIPEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$?CheckShader@@YA_NIPEBD@Z
	DD	imagerel $ip2state$?CheckShader@@YA_NIPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckShader@@YA_NIPEBD@Z DD 061b19H
	DD	0e340cH
	DD	07008720cH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?CheckShader@@YA_NIPEBD@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?CheckProgram@@YA_NIPEBD@Z DB 08H
	DB	0a2H
	DB	00H
	DB	0b6H
	DB	02H
	DB	0e4H
	DB	04H
	DB	'b'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?CheckProgram@@YA_NIPEBD@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$ImVector@D@@QEAA@XZ
	DB	040H
	DB	03eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?CheckProgram@@YA_NIPEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$?CheckProgram@@YA_NIPEBD@Z
	DD	imagerel $ip2state$?CheckProgram@@YA_NIPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckProgram@@YA_NIPEBD@Z DD 082319H
	DD	0d6414H
	DD	0c5414H
	DD	0b3414H
	DD	070107214H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?CheckProgram@@YA_NIPEBD@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ DB 08H
	DB	0acH
	DB	00H
	DB	'M', 07H
	DB	02H
	DB	0e8H
	DB	04H
	DB	'T'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ DB 04H
	DB	0aH
	DD	imagerel ??1?$ImVector@D@@QEAA@XZ
	DB	0a0H
	DB	03eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ DB 028H
	DD	imagerel $stateUnwindMap$?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ
	DD	imagerel $ip2state$?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ DD 0d3219H
	DD	01e7424H
	DD	01d6424H
	DD	01c3424H
	DD	0160124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ
	DD	0a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplOpenGL3_DestroyDeviceObjects@@YAXXZ DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImGui_ImplOpenGL3_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?GetTexID@ImDrawCmd@@QEBAPEAXXZ
_TEXT	SEGMENT
this$ = 8
?GetTexID@ImDrawCmd@@QEBAPEAXXZ PROC			; ImDrawCmd::GetTexID, COMDAT

; 2643 :     inline ImTextureID GetTexID() const { return TextureId; }

	mov	rax, QWORD PTR [rcx+16]
	ret	0
?GetTexID@ImDrawCmd@@QEBAPEAXXZ ENDP			; ImDrawCmd::GetTexID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?SetTexID@ImFontAtlas@@QEAAXPEAX@Z
_TEXT	SEGMENT
this$ = 8
id$ = 16
?SetTexID@ImFontAtlas@@QEAAXPEAX@Z PROC			; ImFontAtlas::SetTexID, COMDAT

; 3004 :     void                        SetTexID(ImTextureID id)    { TexID = id; }

	mov	QWORD PTR [rcx+8], rdx
	ret	0
?SetTexID@ImFontAtlas@@QEAAXPEAX@Z ENDP			; ImFontAtlas::SetTexID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Stream$ = 80
_Format$ = 88
fprintf	PROC						; COMDAT

; 837  :     {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rdx

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rbx, rcx

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 842  :         __crt_va_end(_ArgList);
; 843  :         return _Result;
; 844  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3_loader.h
;	COMDAT open_libgl
_TEXT	SEGMENT
open_libgl PROC						; COMDAT

; 624  : {

	sub	rsp, 40					; 00000028H

; 625  :     libgl = LoadLibraryA("opengl32.dll");

	lea	rcx, OFFSET FLAT:??_C@_0N@DOKAJOHF@opengl32?4dll@
	call	QWORD PTR __imp_LoadLibraryA
	mov	QWORD PTR libgl, rax
	test	rax, rax

; 626  :     if (!libgl)

	jne	SHORT $LN2@open_libgl

; 627  :         return GL3W_ERROR_LIBRARY_OPEN;

	mov	eax, -2

; 630  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@open_libgl:

; 628  :     wgl_get_proc_address = (GL3WglGetProcAddr)GetProcAddress(libgl, "wglGetProcAddress");

	lea	rdx, OFFSET FLAT:??_C@_0BC@FFKMKEGM@wglGetProcAddress@
	mov	rcx, rax
	call	QWORD PTR __imp_GetProcAddress
	mov	QWORD PTR wgl_get_proc_address, rax

; 629  :     return GL3W_OK;

	xor	eax, eax

; 630  : }

	add	rsp, 40					; 00000028H
	ret	0
open_libgl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3_loader.h
;	COMDAT close_libgl
_TEXT	SEGMENT
close_libgl PROC					; COMDAT

; 632  : static void close_libgl(void) { FreeLibrary(libgl); }

	mov	rcx, QWORD PTR libgl
	rex_jmp	QWORD PTR __imp_FreeLibrary
close_libgl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3_loader.h
;	COMDAT get_proc
_TEXT	SEGMENT
proc$ = 48
get_proc PROC						; COMDAT

; 634  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 635  :     GL3WglProc res;
; 636  :     res = (GL3WglProc)wgl_get_proc_address(proc);

	call	QWORD PTR wgl_get_proc_address

; 637  :     if (!res)

	test	rax, rax
	jne	SHORT $LN4@get_proc

; 638  :         res = (GL3WglProc)GetProcAddress(libgl, proc);

	mov	rcx, QWORD PTR libgl
	mov	rdx, rbx

; 639  :     return res;
; 640  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 638  :         res = (GL3WglProc)GetProcAddress(libgl, proc);

	rex_jmp	QWORD PTR __imp_GetProcAddress
$LN4@get_proc:

; 639  :     return res;
; 640  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
get_proc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3_loader.h
;	COMDAT parse_version
_TEXT	SEGMENT
parse_version PROC					; COMDAT

; 691  : {

	sub	rsp, 40					; 00000028H

; 692  :     if (!glGetIntegerv)

	mov	rax, QWORD PTR imgl3wProcs+272
	test	rax, rax
	jne	SHORT $LN2@parse_vers

; 693  :         return GL3W_ERROR_INIT;

	mov	eax, -1

; 704  :     return GL3W_OK;
; 705  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@parse_vers:

; 694  :     glGetIntegerv(GL_MAJOR_VERSION, &version.major);

	lea	rdx, OFFSET FLAT:version
	mov	ecx, 33307				; 0000821bH
	call	rax

; 695  :     glGetIntegerv(GL_MINOR_VERSION, &version.minor);

	lea	rdx, OFFSET FLAT:version+4
	mov	ecx, 33308				; 0000821cH
	call	QWORD PTR imgl3wProcs+272

; 696  :     if (version.major == 0 && version.minor == 0)

	cmp	DWORD PTR version, 0
	jne	SHORT $LN4@parse_vers
	cmp	DWORD PTR version+4, 0
	jne	SHORT $LN7@parse_vers

; 697  :     {
; 698  :         // Query GL_VERSION in desktop GL 2.x, the string will start with "<major>.<minor>"
; 699  :         if (const char* gl_version = (const char*)glGetString(GL_VERSION))

	mov	rax, QWORD PTR imgl3wProcs+312
	mov	ecx, 7938				; 00001f02H
	call	rax
	test	rax, rax
	je	SHORT $LN4@parse_vers

; 700  :             sscanf(gl_version, "%d.%d", &version.major, &version.minor);

	lea	r9, OFFSET FLAT:version+4
	mov	rcx, rax
	lea	r8, OFFSET FLAT:version
	lea	rdx, OFFSET FLAT:??_C@_05KBEOJPB@?$CFd?4?$CFd@
	call	sscanf
$LN4@parse_vers:

; 701  :     }
; 702  :     if (version.major < 2)

	xor	eax, eax
	mov	ecx, -3
	cmp	DWORD PTR version, 2
	cmovl	eax, ecx

; 704  :     return GL3W_OK;
; 705  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@parse_vers:

; 703  :         return GL3W_ERROR_OPENGL_VERSION;

	mov	eax, -3

; 704  :     return GL3W_OK;
; 705  : }

	add	rsp, 40					; 00000028H
	ret	0
parse_version ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3_loader.h
;	COMDAT imgl3wInit
_TEXT	SEGMENT
imgl3wInit PROC						; COMDAT

; 710  : {

$LN40:
	sub	rsp, 40					; 00000028H

; 625  :     libgl = LoadLibraryA("opengl32.dll");

	lea	rcx, OFFSET FLAT:??_C@_0N@DOKAJOHF@opengl32?4dll@
	call	QWORD PTR __imp_LoadLibraryA
	mov	QWORD PTR libgl, rax
	test	rax, rax

; 626  :     if (!libgl)

	jne	SHORT $LN5@imgl3wInit

; 711  :     int res = open_libgl();
; 712  :     if (res)
; 713  :         return res;

	mov	eax, -2

; 716  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@imgl3wInit:
	mov	QWORD PTR [rsp+48], rbx

; 628  :     wgl_get_proc_address = (GL3WglGetProcAddr)GetProcAddress(libgl, "wglGetProcAddress");

	lea	rdx, OFFSET FLAT:??_C@_0BC@FFKMKEGM@wglGetProcAddress@
	mov	QWORD PTR [rsp+56], rbp
	mov	rcx, rax
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+32], rdi
	call	QWORD PTR __imp_GetProcAddress

; 714  :     atexit(close_libgl);

	lea	rcx, OFFSET FLAT:close_libgl

; 628  :     wgl_get_proc_address = (GL3WglGetProcAddr)GetProcAddress(libgl, "wglGetProcAddress");

	mov	QWORD PTR wgl_get_proc_address, rax

; 714  :     atexit(close_libgl);

	call	atexit
	xor	esi, esi
	lea	rbp, OFFSET FLAT:__ImageBase
	mov	ebx, esi
	npad	7
$LL12@imgl3wInit:

; 803  :         imgl3wProcs.ptr[i] = proc(proc_names[i]);

	mov	rdi, QWORD PTR proc_names[rbx+rbp]

; 636  :     res = (GL3WglProc)wgl_get_proc_address(proc);

	mov	rcx, rdi
	call	QWORD PTR wgl_get_proc_address

; 637  :     if (!res)

	test	rax, rax
	jne	SHORT $LN17@imgl3wInit

; 638  :         res = (GL3WglProc)GetProcAddress(libgl, proc);

	mov	rcx, QWORD PTR libgl
	mov	rdx, rdi
	call	QWORD PTR __imp_GetProcAddress
$LN17@imgl3wInit:

; 803  :         imgl3wProcs.ptr[i] = proc(proc_names[i]);

	mov	QWORD PTR imgl3wProcs[rbx+rbp], rax
	add	rbx, 8
	cmp	rbx, 472				; 000001d8H
	jb	SHORT $LL12@imgl3wInit

; 692  :     if (!glGetIntegerv)

	mov	rax, QWORD PTR imgl3wProcs+272

; 802  :     for (i = 0; i < ARRAY_SIZE(proc_names); i++)

	mov	rdi, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 692  :     if (!glGetIntegerv)

	test	rax, rax
	jne	SHORT $LN20@imgl3wInit

; 693  :         return GL3W_ERROR_INIT;

	mov	esi, -1

; 715  :     return imgl3wInit2(get_proc);

	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+64]

; 716  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN20@imgl3wInit:

; 694  :     glGetIntegerv(GL_MAJOR_VERSION, &version.major);

	lea	rdx, OFFSET FLAT:version
	mov	ecx, 33307				; 0000821bH
	call	rax

; 695  :     glGetIntegerv(GL_MINOR_VERSION, &version.minor);

	lea	rdx, OFFSET FLAT:version+4
	mov	ecx, 33308				; 0000821cH
	call	QWORD PTR imgl3wProcs+272

; 696  :     if (version.major == 0 && version.minor == 0)

	cmp	DWORD PTR version, esi
	jne	SHORT $LN31@imgl3wInit
	cmp	DWORD PTR version+4, esi
	jne	SHORT $LN30@imgl3wInit

; 697  :     {
; 698  :         // Query GL_VERSION in desktop GL 2.x, the string will start with "<major>.<minor>"
; 699  :         if (const char* gl_version = (const char*)glGetString(GL_VERSION))

	mov	rax, QWORD PTR imgl3wProcs+312
	mov	ecx, 7938				; 00001f02H
	call	rax
	test	rax, rax
	je	SHORT $LN31@imgl3wInit

; 700  :             sscanf(gl_version, "%d.%d", &version.major, &version.minor);

	lea	r9, OFFSET FLAT:version+4
	mov	rcx, rax
	lea	r8, OFFSET FLAT:version
	lea	rdx, OFFSET FLAT:??_C@_05KBEOJPB@?$CFd?4?$CFd@
	call	sscanf
$LN31@imgl3wInit:

; 701  :     }
; 702  :     if (version.major < 2)

	cmp	DWORD PTR version, 2
	jge	SHORT $LN23@imgl3wInit
$LN30@imgl3wInit:

; 703  :         return GL3W_ERROR_OPENGL_VERSION;

	mov	esi, -3
$LN23@imgl3wInit:

; 715  :     return imgl3wInit2(get_proc);

	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+64]

; 716  : }

	add	rsp, 40					; 00000028H
	ret	0
imgl3wInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3_loader.h
;	COMDAT imgl3wInit2
_TEXT	SEGMENT
proc$dead$ = 48
imgl3wInit2 PROC					; COMDAT

; 719  : {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 802  :     for (i = 0; i < ARRAY_SIZE(proc_names); i++)

	xor	ebx, ebx
	lea	rdi, OFFSET FLAT:__ImageBase
$LL6@imgl3wInit:

; 803  :         imgl3wProcs.ptr[i] = proc(proc_names[i]);

	mov	rcx, QWORD PTR proc_names[rbx+rdi]
	call	get_proc
	mov	QWORD PTR imgl3wProcs[rbx+rdi], rax
	add	rbx, 8
	cmp	rbx, 472				; 000001d8H
	jb	SHORT $LL6@imgl3wInit

; 692  :     if (!glGetIntegerv)

	mov	rax, QWORD PTR imgl3wProcs+272
	test	rax, rax
	jne	SHORT $LN9@imgl3wInit

; 720  :     load_procs(proc);
; 721  :     return parse_version();

	mov	eax, -1

; 722  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@imgl3wInit:

; 694  :     glGetIntegerv(GL_MAJOR_VERSION, &version.major);

	lea	rdx, OFFSET FLAT:version
	mov	ecx, 33307				; 0000821bH
	call	rax

; 695  :     glGetIntegerv(GL_MINOR_VERSION, &version.minor);

	lea	rdx, OFFSET FLAT:version+4
	mov	ecx, 33308				; 0000821cH
	call	QWORD PTR imgl3wProcs+272

; 696  :     if (version.major == 0 && version.minor == 0)

	cmp	DWORD PTR version, 0
	jne	SHORT $LN19@imgl3wInit
	cmp	DWORD PTR version+4, 0
	jne	SHORT $LN18@imgl3wInit

; 697  :     {
; 698  :         // Query GL_VERSION in desktop GL 2.x, the string will start with "<major>.<minor>"
; 699  :         if (const char* gl_version = (const char*)glGetString(GL_VERSION))

	mov	rax, QWORD PTR imgl3wProcs+312
	mov	ecx, 7938				; 00001f02H
	call	rax
	test	rax, rax
	je	SHORT $LN19@imgl3wInit

; 700  :             sscanf(gl_version, "%d.%d", &version.major, &version.minor);

	lea	r9, OFFSET FLAT:version+4
	mov	rcx, rax
	lea	r8, OFFSET FLAT:version
	lea	rdx, OFFSET FLAT:??_C@_05KBEOJPB@?$CFd?4?$CFd@
	call	sscanf
$LN19@imgl3wInit:

; 701  :     }
; 702  :     if (version.major < 2)

	cmp	DWORD PTR version, 2
	jge	SHORT $LN12@imgl3wInit
$LN18@imgl3wInit:

; 720  :     load_procs(proc);
; 721  :     return parse_version();

	mov	eax, -3

; 722  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN12@imgl3wInit:
	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
imgl3wInit2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3_loader.h
;	COMDAT load_procs
_TEXT	SEGMENT
proc$dead$ = 48
load_procs PROC						; COMDAT

; 800  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 801  :     size_t i;
; 802  :     for (i = 0; i < ARRAY_SIZE(proc_names); i++)

	xor	ebx, ebx
	lea	rdi, OFFSET FLAT:__ImageBase
$LL4@load_procs:

; 803  :         imgl3wProcs.ptr[i] = proc(proc_names[i]);

	mov	rcx, QWORD PTR proc_names[rbx+rdi]
	call	get_proc
	mov	QWORD PTR imgl3wProcs[rbx+rdi], rax
	add	rbx, 8
	cmp	rbx, 472				; 000001d8H
	jb	SHORT $LL4@load_procs

; 804  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
load_procs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ??0ImGui_ImplOpenGL3_Data@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImGui_ImplOpenGL3_Data@@QEAA@XZ PROC			; ImGui_ImplOpenGL3_Data::ImGui_ImplOpenGL3_Data, COMDAT

; 231  :     ImGui_ImplOpenGL3_Data() { memset((void*)this, 0, sizeof(*this)); }

	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	mov	QWORD PTR [rcx+96], rax
	mov	rax, rcx
	ret	0
??0ImGui_ImplOpenGL3_Data@@QEAA@XZ ENDP			; ImGui_ImplOpenGL3_Data::ImGui_ImplOpenGL3_Data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_GetBackendData@@YAPEAUImGui_ImplOpenGL3_Data@@XZ
_TEXT	SEGMENT
?ImGui_ImplOpenGL3_GetBackendData@@YAPEAUImGui_ImplOpenGL3_Data@@XZ PROC ; ImGui_ImplOpenGL3_GetBackendData, COMDAT

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN3@ImGui_Impl
	mov	rax, QWORD PTR [rax+160]

; 239  : }

	ret	0
$LN3@ImGui_Impl:
	ret	0
?ImGui_ImplOpenGL3_GetBackendData@@YAPEAUImGui_ImplOpenGL3_Data@@XZ ENDP ; ImGui_ImplOpenGL3_GetBackendData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3_loader.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z
_TEXT	SEGMENT
major$ = 36
minor$ = 40
num_extensions$ = 48
current_texture$ = 52
__$ArrayPad$ = 56
glsl_version$dead$ = 80
?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z PROC		; ImGui_ImplOpenGL3_Init, COMDAT

; 271  : {

$LN94:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 272  :     ImGuiIO& io = ImGui::GetIO();

	mov	rbp, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3_loader.h

; 625  :     libgl = LoadLibraryA("opengl32.dll");

	lea	rcx, OFFSET FLAT:??_C@_0N@DOKAJOHF@opengl32?4dll@
	call	QWORD PTR __imp_LoadLibraryA
	mov	QWORD PTR libgl, rax
	test	rax, rax

; 626  :     if (!libgl)

	je	$LN65@ImGui_Impl

; 627  :         return GL3W_ERROR_LIBRARY_OPEN;
; 628  :     wgl_get_proc_address = (GL3WglGetProcAddr)GetProcAddress(libgl, "wglGetProcAddress");

	lea	rdx, OFFSET FLAT:??_C@_0BC@FFKMKEGM@wglGetProcAddress@
	mov	QWORD PTR [rsp+80], r14
	mov	rcx, rax
	call	QWORD PTR __imp_GetProcAddress

; 714  :     atexit(close_libgl);

	lea	rcx, OFFSET FLAT:close_libgl

; 628  :     wgl_get_proc_address = (GL3WglGetProcAddr)GetProcAddress(libgl, "wglGetProcAddress");

	mov	QWORD PTR wgl_get_proc_address, rax

; 714  :     atexit(close_libgl);

	call	atexit
	xor	edi, edi
	lea	r14, OFFSET FLAT:__ImageBase
	mov	ebx, edi
	npad	6
$LL28@ImGui_Impl:

; 803  :         imgl3wProcs.ptr[i] = proc(proc_names[i]);

	mov	rsi, QWORD PTR proc_names[rbx+r14]

; 636  :     res = (GL3WglProc)wgl_get_proc_address(proc);

	mov	rcx, rsi
	call	QWORD PTR wgl_get_proc_address

; 637  :     if (!res)

	test	rax, rax
	jne	SHORT $LN33@ImGui_Impl

; 638  :         res = (GL3WglProc)GetProcAddress(libgl, proc);

	mov	rcx, QWORD PTR libgl
	mov	rdx, rsi
	call	QWORD PTR __imp_GetProcAddress
$LN33@ImGui_Impl:

; 803  :         imgl3wProcs.ptr[i] = proc(proc_names[i]);

	mov	QWORD PTR imgl3wProcs[rbx+r14], rax
	add	rbx, 8
	cmp	rbx, 472				; 000001d8H
	jb	SHORT $LL28@ImGui_Impl

; 692  :     if (!glGetIntegerv)

	mov	rax, QWORD PTR imgl3wProcs+272

; 802  :     for (i = 0; i < ARRAY_SIZE(proc_names); i++)

	mov	r14, QWORD PTR [rsp+80]

; 692  :     if (!glGetIntegerv)

	test	rax, rax
	je	$LN65@ImGui_Impl

; 693  :         return GL3W_ERROR_INIT;
; 694  :     glGetIntegerv(GL_MAJOR_VERSION, &version.major);

	lea	rdx, OFFSET FLAT:version
	mov	ecx, 33307				; 0000821bH
	call	rax

; 695  :     glGetIntegerv(GL_MINOR_VERSION, &version.minor);

	lea	rdx, OFFSET FLAT:version+4
	mov	ecx, 33308				; 0000821cH
	call	QWORD PTR imgl3wProcs+272

; 696  :     if (version.major == 0 && version.minor == 0)

	cmp	DWORD PTR version, edi
	jne	SHORT $LN70@ImGui_Impl
	cmp	DWORD PTR version+4, edi
	jne	$LN65@ImGui_Impl

; 697  :     {
; 698  :         // Query GL_VERSION in desktop GL 2.x, the string will start with "<major>.<minor>"
; 699  :         if (const char* gl_version = (const char*)glGetString(GL_VERSION))

	mov	rax, QWORD PTR imgl3wProcs+312
	mov	ecx, 7938				; 00001f02H
	call	rax
	test	rax, rax
	je	SHORT $LN70@ImGui_Impl

; 700  :             sscanf(gl_version, "%d.%d", &version.major, &version.minor);

	lea	r9, OFFSET FLAT:version+4
	mov	rcx, rax
	lea	r8, OFFSET FLAT:version
	lea	rdx, OFFSET FLAT:??_C@_05KBEOJPB@?$CFd?4?$CFd@
	call	sscanf
$LN70@ImGui_Impl:

; 701  :     }
; 702  :     if (version.major < 2)

	cmp	DWORD PTR version, 2
	jl	$LN65@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN42@ImGui_Impl

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN42@ImGui_Impl:

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	ecx, 104				; 00000068H
	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 285  :     ImGui_ImplOpenGL3_Data* bd = IM_NEW(ImGui_ImplOpenGL3_Data)();

	test	rax, rax
	je	SHORT $LN13@ImGui_Impl
	xorps	xmm0, xmm0

; 231  :     ImGui_ImplOpenGL3_Data() { memset((void*)this, 0, sizeof(*this)); }

	xor	eax, eax
	movups	XMMWORD PTR [rbx], xmm0
	movups	XMMWORD PTR [rbx+16], xmm0
	movups	XMMWORD PTR [rbx+32], xmm0
	movups	XMMWORD PTR [rbx+48], xmm0
	movups	XMMWORD PTR [rbx+64], xmm0
	movups	XMMWORD PTR [rbx+80], xmm0
	mov	QWORD PTR [rbx+96], rax

; 285  :     ImGui_ImplOpenGL3_Data* bd = IM_NEW(ImGui_ImplOpenGL3_Data)();

	jmp	SHORT $LN14@ImGui_Impl
$LN13@ImGui_Impl:
	mov	rbx, rdi
$LN14@ImGui_Impl:

; 286  :     io.BackendRendererUserData = (void*)bd;
; 287  :     io.BackendRendererName = "imgui_impl_opengl3";

	lea	rax, OFFSET FLAT:??_C@_0BD@BIIFHGKK@imgui_impl_opengl3@
	mov	QWORD PTR [rbp+160], rbx

; 288  : 
; 289  :     // Query for GL version (e.g. 320 for GL 3.2)
; 290  : #if defined(IMGUI_IMPL_OPENGL_ES2)
; 291  :     // GLES 2
; 292  :     bd->GlVersion = 200;
; 293  :     bd->GlProfileIsES2 = true;
; 294  : #else
; 295  :     // Desktop or GLES 3
; 296  :     GLint major = 0;
; 297  :     GLint minor = 0;
; 298  :     glGetIntegerv(GL_MAJOR_VERSION, &major);

	lea	rdx, QWORD PTR major$[rsp]
	mov	QWORD PTR [rbp+144], rax
	mov	ecx, 33307				; 0000821bH
	mov	DWORD PTR major$[rsp], edi
	mov	DWORD PTR minor$[rsp], edi
	call	QWORD PTR imgl3wProcs+272

; 299  :     glGetIntegerv(GL_MINOR_VERSION, &minor);

	lea	rdx, QWORD PTR minor$[rsp]
	mov	ecx, 33308				; 0000821cH
	call	QWORD PTR imgl3wProcs+272

; 300  :     if (major == 0 && minor == 0)

	mov	eax, DWORD PTR major$[rsp]
	test	eax, eax
	jne	SHORT $LN71@ImGui_Impl
	cmp	DWORD PTR minor$[rsp], edi
	jne	SHORT $LN71@ImGui_Impl

; 301  :     {
; 302  :         // Query GL_VERSION in desktop GL 2.x, the string will start with "<major>.<minor>"
; 303  :         const char* gl_version = (const char*)glGetString(GL_VERSION);

	mov	rax, QWORD PTR imgl3wProcs+312
	mov	ecx, 7938				; 00001f02H
	call	rax

; 304  :         sscanf(gl_version, "%d.%d", &major, &minor);

	lea	r9, QWORD PTR minor$[rsp]
	mov	rcx, rax
	lea	r8, QWORD PTR major$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_05KBEOJPB@?$CFd?4?$CFd@
	call	sscanf
	mov	eax, DWORD PTR major$[rsp]
$LN71@ImGui_Impl:

; 305  :     }
; 306  :     bd->GlVersion = (GLuint)(major * 100 + minor * 10);

	lea	ecx, DWORD PTR [rax+rax*4]
	mov	eax, DWORD PTR minor$[rsp]

; 307  : #if defined(GL_CONTEXT_PROFILE_MASK)
; 308  :     if (bd->GlVersion >= 320)

	lea	rsi, QWORD PTR [rbx+40]
	lea	ecx, DWORD PTR [rax+rcx*2]
	lea	eax, DWORD PTR [rcx+rcx*4]
	add	eax, eax
	mov	DWORD PTR [rbx], eax
	cmp	eax, 320				; 00000140H
	jb	SHORT $LN7@ImGui_Impl

; 309  :         glGetIntegerv(GL_CONTEXT_PROFILE_MASK, &bd->GlProfileMask);

	mov	rdx, rsi
	mov	ecx, 37158				; 00009126H
	call	QWORD PTR imgl3wProcs+272
$LN7@ImGui_Impl:

; 310  :     bd->GlProfileIsCompat = (bd->GlProfileMask & GL_CONTEXT_COMPATIBILITY_PROFILE_BIT) != 0;

	mov	eax, DWORD PTR [rsi]
	shr	eax, 1
	and	al, 1

; 311  : #endif
; 312  : 
; 313  : #if defined(IMGUI_IMPL_OPENGL_ES3)
; 314  :     bd->GlProfileIsES3 = true;
; 315  : #endif
; 316  : 
; 317  :     bd->UseBufferSubData = false;

	mov	BYTE PTR [rbx+97], dil

; 318  :     /*
; 319  :     // Query vendor to enable glBufferSubData kludge
; 320  : #ifdef _WIN32
; 321  :     if (const char* vendor = (const char*)glGetString(GL_VENDOR))
; 322  :         if (strncmp(vendor, "Intel", 5) == 0)
; 323  :             bd->UseBufferSubData = true;
; 324  : #endif
; 325  :     */
; 326  : #endif
; 327  : 
; 328  : #ifdef IMGUI_IMPL_OPENGL_DEBUG
; 329  :     printf("GlVersion = %d\nGlProfileIsCompat = %d\nGlProfileMask = 0x%X\nGlProfileIsES2 = %d, GlProfileIsES3 = %d\nGL_VENDOR = '%s'\nGL_RENDERER = '%s'\n", bd->GlVersion, bd->GlProfileIsCompat, bd->GlProfileMask, bd->GlProfileIsES2, bd->GlProfileIsES3, (const char*)glGetString(GL_VENDOR), (const char*)glGetString(GL_RENDERER)); // [DEBUG]
; 330  : #endif
; 331  : 
; 332  : #ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_VTX_OFFSET
; 333  :     if (bd->GlVersion >= 320)

	cmp	DWORD PTR [rbx], 320			; 00000140H
	mov	BYTE PTR [rbx+38], al
	jb	SHORT $LN68@ImGui_Impl

; 334  :         io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.

	or	DWORD PTR [rbp+12], 8
$LN68@ImGui_Impl:

; 335  : #endif
; 336  :     io.BackendFlags |= ImGuiBackendFlags_RendererHasViewports;  // We can create multi-viewports on the Renderer side (optional)

	or	DWORD PTR [rbp+12], 4096		; 00001000H

; 337  : 
; 338  :     // Store GLSL version string so we can refer to it later in case we recreate shaders.
; 339  :     // Note: GLSL version is NOT the same as GL version. Leave this to nullptr if unsure.
; 340  :     if (glsl_version == nullptr)
; 341  :     {
; 342  : #if defined(IMGUI_IMPL_OPENGL_ES2)
; 343  :         glsl_version = "#version 100";
; 344  : #elif defined(IMGUI_IMPL_OPENGL_ES3)
; 345  :         glsl_version = "#version 300 es";
; 346  : #elif defined(__APPLE__)
; 347  :         glsl_version = "#version 150";
; 348  : #else
; 349  :         glsl_version = "#version 130";
; 350  : #endif
; 351  :     }
; 352  :     IM_ASSERT((int)strlen(glsl_version) + 2 < IM_ARRAYSIZE(bd->GlslVersionString));
; 353  :     strcpy(bd->GlslVersionString, glsl_version);

	lea	rdx, QWORD PTR [rbx+4]
	mov	r8, rdx
	lea	rcx, OFFSET FLAT:??_C@_0N@NPMABONB@?$CDversion?5130@
	sub	r8, rcx
	npad	4
$LL15@ImGui_Impl:
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [r8+rcx], al
	lea	rcx, QWORD PTR [rcx+1]
	test	al, al
	jne	SHORT $LL15@ImGui_Impl

; 354  :     strcat(bd->GlslVersionString, "\n");

	dec	rdx
$LL69@ImGui_Impl:
	cmp	BYTE PTR [rdx+1], dil
	lea	rdx, QWORD PTR [rdx+1]
	jne	SHORT $LL69@ImGui_Impl
	movzx	eax, WORD PTR ??_C@_01EEMJAFIK@?6@

; 355  : 
; 356  :     // Make an arbitrary GL call (we don't actually need the result)
; 357  :     // IF YOU GET A CRASH HERE: it probably means the OpenGL function loader didn't do its job. Let us know!
; 358  :     GLint current_texture;
; 359  :     glGetIntegerv(GL_TEXTURE_BINDING_2D, &current_texture);

	mov	ecx, 32873				; 00008069H
	mov	WORD PTR [rdx], ax
	lea	rdx, QWORD PTR current_texture$[rsp]
	call	QWORD PTR imgl3wProcs+272

; 360  : 
; 361  :     // Detect extensions we support
; 362  :     bd->HasClipOrigin = (bd->GlVersion >= 450);

	cmp	DWORD PTR [rbx], 450			; 000001c2H

; 363  : #ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_EXTENSIONS
; 364  :     GLint num_extensions = 0;
; 365  :     glGetIntegerv(GL_NUM_EXTENSIONS, &num_extensions);

	lea	rdx, QWORD PTR num_extensions$[rsp]
	mov	ecx, 33309				; 0000821dH
	setae	al
	mov	BYTE PTR [rbx+96], al
	mov	DWORD PTR num_extensions$[rsp], edi
	call	QWORD PTR imgl3wProcs+272

; 366  :     for (GLint i = 0; i < num_extensions; i++)

	cmp	DWORD PTR num_extensions$[rsp], edi
	jle	SHORT $LN3@ImGui_Impl
	npad	4
$LL4@ImGui_Impl:

; 367  :     {
; 368  :         const char* extension = (const char*)glGetStringi(GL_EXTENSIONS, i);

	mov	rax, QWORD PTR imgl3wProcs+320
	mov	edx, edi
	mov	ecx, 7939				; 00001f03H
	call	rax

; 369  :         if (extension != nullptr && strcmp(extension, "GL_ARB_clip_control") == 0)

	test	rax, rax
	je	SHORT $LN2@ImGui_Impl
	lea	rdx, OFFSET FLAT:??_C@_0BE@NFGEKHNE@GL_ARB_clip_control@
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN2@ImGui_Impl

; 370  :             bd->HasClipOrigin = true;

	mov	BYTE PTR [rbx+96], 1
$LN2@ImGui_Impl:

; 366  :     for (GLint i = 0; i < num_extensions; i++)

	inc	edi
	cmp	edi, DWORD PTR num_extensions$[rsp]
	jl	SHORT $LL4@ImGui_Impl
$LN3@ImGui_Impl:

; 371  :     }
; 372  : #endif
; 373  : 
; 374  :     if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)

	test	DWORD PTR [rbp+8], 1024			; 00000400H
	je	SHORT $LN11@ImGui_Impl

; 964  :     platform_io.Renderer_RenderWindow = ImGui_ImplOpenGL3_RenderWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	lea	rcx, OFFSET FLAT:?ImGui_ImplOpenGL3_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z ; ImGui_ImplOpenGL3_RenderWindow
	mov	QWORD PTR [rax+14504], rcx
$LN11@ImGui_Impl:

; 375  :         ImGui_ImplOpenGL3_InitPlatformInterface();
; 376  : 
; 377  :     return true;

	mov	al, 1
	jmp	SHORT $LN1@ImGui_Impl
$LN65@ImGui_Impl:

; 273  :     IM_ASSERT(io.BackendRendererUserData == nullptr && "Already initialized a renderer backend!");
; 274  : 
; 275  :     // Initialize our loader
; 276  : #if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3) && !defined(IMGUI_IMPL_OPENGL_LOADER_CUSTOM)
; 277  :     if (imgl3wInit() != 0)
; 278  :     {
; 279  :         fprintf(stderr, "Failed to initialize OpenGL loader!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_0CF@PMPPENEO@Failed?5to?5initialize?5OpenGL?5loa@
	call	fprintf

; 280  :         return false;

	xor	al, al
$LN1@ImGui_Impl:

; 378  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z ENDP		; ImGui_ImplOpenGL3_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_Shutdown@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplOpenGL3_Shutdown@@YAXXZ PROC			; ImGui_ImplOpenGL3_Shutdown, COMDAT

; 381  : {

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	r15d, r15d
	test	rdi, rdi
	je	SHORT $LN5@ImGui_Impl
	mov	rbp, QWORD PTR [rdi+160]
	jmp	SHORT $LN6@ImGui_Impl
$LN5@ImGui_Impl:
	mov	rbp, r15
$LN6@ImGui_Impl:

; 969  :     ImGui::DestroyPlatformWindows();

	call	?DestroyPlatformWindows@ImGui@@YAXXZ	; ImGui::DestroyPlatformWindows

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rbx, rbx
	je	SHORT $LN16@ImGui_Impl
	mov	rsi, QWORD PTR [rbx+160]
	jmp	SHORT $LN17@ImGui_Impl
$LN16@ImGui_Impl:
	mov	rsi, r15
$LN17@ImGui_Impl:

; 938  :     if (bd->VboHandle)      { glDeleteBuffers(1, &bd->VboHandle); bd->VboHandle = 0; }

	cmp	DWORD PTR [rsi+72], r15d
	je	SHORT $LN10@ImGui_Impl
	lea	rdx, QWORD PTR [rsi+72]
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+128
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	DWORD PTR [rsi+72], r15d
$LN10@ImGui_Impl:

; 939  :     if (bd->ElementsHandle) { glDeleteBuffers(1, &bd->ElementsHandle); bd->ElementsHandle = 0; }

	cmp	DWORD PTR [rsi+76], r15d
	je	SHORT $LN11@ImGui_Impl
	lea	rdx, QWORD PTR [rsi+76]
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+128
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	DWORD PTR [rsi+76], r15d
$LN11@ImGui_Impl:

; 940  :     if (bd->ShaderHandle)   { glDeleteProgram(bd->ShaderHandle); bd->ShaderHandle = 0; }

	mov	ecx, DWORD PTR [rsi+48]
	test	ecx, ecx
	je	SHORT $LN12@ImGui_Impl
	call	QWORD PTR imgl3wProcs+136
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	DWORD PTR [rsi+48], r15d
$LN12@ImGui_Impl:

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	test	rbx, rbx
	je	SHORT $LN23@ImGui_Impl
	mov	rax, QWORD PTR [rbx+160]
	jmp	SHORT $LN24@ImGui_Impl
$LN23@ImGui_Impl:
	mov	rax, r15
$LN24@ImGui_Impl:

; 701  :     if (bd->FontTexture)

	cmp	DWORD PTR [rax+44], r15d
	lea	rsi, QWORD PTR [rax+44]
	je	SHORT $LN19@ImGui_Impl

; 702  :     {
; 703  :         glDeleteTextures(1, &bd->FontTexture);

	mov	rdx, rsi
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+152

; 704  :         io.Fonts->SetTexID(0);

	mov	rax, QWORD PTR [rbx+56]

; 705  :         bd->FontTexture = 0;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR [rax+8], r15
	mov	DWORD PTR [rsi], r15d
$LN19@ImGui_Impl:

; 382  :     ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
; 383  :     IM_ASSERT(bd != nullptr && "No renderer backend to shutdown, or already shutdown?");
; 384  :     ImGuiIO& io = ImGui::GetIO();
; 385  : 
; 386  :     ImGui_ImplOpenGL3_ShutdownPlatformInterface();
; 387  :     ImGui_ImplOpenGL3_DestroyDeviceObjects();
; 388  :     io.BackendRendererName = nullptr;
; 389  :     io.BackendRendererUserData = nullptr;
; 390  :     io.BackendFlags &= ~(ImGuiBackendFlags_RendererHasVtxOffset | ImGuiBackendFlags_RendererHasViewports);

	and	DWORD PTR [rdi+12], -4105		; ffffffffffffeff7H
	mov	QWORD PTR [rdi+144], r15
	mov	QWORD PTR [rdi+160], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	test	rbp, rbp
	je	SHORT $LN32@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rbx, rbx
	je	SHORT $LN30@ImGui_Impl

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rbx+244]
$LN30@ImGui_Impl:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rbp
	call	QWORD PTR __imp_free
$LN32@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 392  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?ImGui_ImplOpenGL3_Shutdown@@YAXXZ ENDP			; ImGui_ImplOpenGL3_Shutdown
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_NewFrame@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplOpenGL3_NewFrame@@YAXXZ PROC			; ImGui_ImplOpenGL3_NewFrame, COMDAT

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN6@ImGui_Impl
	mov	rcx, QWORD PTR [rax+160]
	jmp	SHORT $LN7@ImGui_Impl
$LN6@ImGui_Impl:
	xor	ecx, ecx
$LN7@ImGui_Impl:

; 396  :     ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
; 397  :     IM_ASSERT(bd != nullptr && "Did you call ImGui_ImplOpenGL3_Init()?");
; 398  : 
; 399  :     if (!bd->ShaderHandle)

	cmp	DWORD PTR [rcx+48], 0
	je	?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ ; ImGui_ImplOpenGL3_CreateDeviceObjects
$LN2@ImGui_Impl:

; 400  :         ImGui_ImplOpenGL3_CreateDeviceObjects();
; 401  : }

	ret	0
?ImGui_ImplOpenGL3_NewFrame@@YAXXZ ENDP			; ImGui_ImplOpenGL3_NewFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_SetupRenderState@@YAXPEAUImDrawData@@HHI@Z
_TEXT	SEGMENT
current_clip_origin$1 = 48
ortho_projection$ = 64
__$ArrayPad$ = 128
draw_data$ = 224
fb_width$ = 232
fb_height$ = 240
vertex_array_object$ = 248
?ImGui_ImplOpenGL3_SetupRenderState@@YAXPEAUImDrawData@@HHI@Z PROC ; ImGui_ImplOpenGL3_SetupRenderState, COMDAT

; 404  : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 160				; 000000a0H
	movaps	XMMWORD PTR [rsp+144], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	r12d, r12d

; 404  : {

	mov	r15d, r9d
	mov	r14d, r8d
	mov	ebp, edx
	mov	rsi, rcx

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	test	rbx, rbx
	je	SHORT $LN11@ImGui_Impl
	mov	rbx, QWORD PTR [rbx+160]
	jmp	SHORT $LN12@ImGui_Impl
$LN11@ImGui_Impl:
	mov	rbx, r12
$LN12@ImGui_Impl:

; 405  :     ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
; 406  : 
; 407  :     // Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled, polygon fill
; 408  :     glEnable(GL_BLEND);

	mov	ecx, 3042				; 00000be2H
	call	QWORD PTR imgl3wProcs+208

; 409  :     glBlendEquation(GL_FUNC_ADD);

	mov	ecx, 32774				; 00008006H
	call	QWORD PTR imgl3wProcs+48

; 410  :     glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);

	mov	edx, 771				; 00000303H
	mov	r8d, 1
	mov	r9d, edx
	lea	ecx, QWORD PTR [rdx-1]
	call	QWORD PTR imgl3wProcs+64

; 411  :     glDisable(GL_CULL_FACE);

	mov	ecx, 2884				; 00000b44H
	call	QWORD PTR imgl3wProcs+176

; 412  :     glDisable(GL_DEPTH_TEST);

	mov	ecx, 2929				; 00000b71H
	call	QWORD PTR imgl3wProcs+176

; 413  :     glDisable(GL_STENCIL_TEST);

	mov	ecx, 2960				; 00000b90H
	call	QWORD PTR imgl3wProcs+176

; 414  :     glEnable(GL_SCISSOR_TEST);

	mov	ecx, 3089				; 00000c11H
	call	QWORD PTR imgl3wProcs+208

; 415  : #ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
; 416  :     if (bd->GlVersion >= 310)

	cmp	DWORD PTR [rbx], 310			; 00000136H
	jb	SHORT $LN2@ImGui_Impl

; 417  :         glDisable(GL_PRIMITIVE_RESTART);

	mov	ecx, 36765				; 00008f9dH
	call	QWORD PTR imgl3wProcs+176
$LN2@ImGui_Impl:

; 418  : #endif
; 419  : #ifdef IMGUI_IMPL_HAS_POLYGON_MODE
; 420  :     glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	mov	edx, 6914				; 00001b02H
	mov	ecx, 1032				; 00000408H
	call	QWORD PTR imgl3wProcs+384

; 421  : #endif
; 422  : 
; 423  :     // Support for GL 4.5 rarely used glClipControl(GL_UPPER_LEFT)
; 424  : #if defined(GL_CLIP_ORIGIN)
; 425  :     bool clip_origin_lower_left = true;

	mov	dil, 1

; 426  :     if (bd->HasClipOrigin)

	cmp	BYTE PTR [rbx+96], r12b
	je	SHORT $LN4@ImGui_Impl

; 427  :     {
; 428  :         GLenum current_clip_origin = 0; glGetIntegerv(GL_CLIP_ORIGIN, (GLint*)&current_clip_origin);

	lea	rdx, QWORD PTR current_clip_origin$1[rsp]
	mov	DWORD PTR current_clip_origin$1[rsp], r12d
	mov	ecx, 37724				; 0000935cH
	call	QWORD PTR imgl3wProcs+272

; 429  :         if (current_clip_origin == GL_UPPER_LEFT)

	cmp	DWORD PTR current_clip_origin$1[rsp], 36002 ; 00008ca2H
	movzx	edi, dil
	cmove	edi, r12d
$LN4@ImGui_Impl:

; 430  :             clip_origin_lower_left = false;
; 431  :     }
; 432  : #endif
; 433  : 
; 434  :     // Setup viewport, orthographic projection matrix
; 435  :     // Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayPos is (0,0) for single viewport apps.
; 436  :     GL_CALL(glViewport(0, 0, (GLsizei)fb_width, (GLsizei)fb_height));

	mov	r9d, r14d
	mov	r8d, ebp
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR imgl3wProcs+464

; 437  :     float L = draw_data->DisplayPos.x;
; 438  :     float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;
; 439  :     float T = draw_data->DisplayPos.y;

	movss	xmm4, DWORD PTR [rsi+36]
	movss	xmm6, DWORD PTR [rsi+32]

; 440  :     float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;

	movaps	xmm3, xmm4
	movaps	xmm5, xmm6
	addss	xmm3, DWORD PTR [rsi+44]
	addss	xmm5, DWORD PTR [rsi+40]

; 441  : #if defined(GL_CLIP_ORIGIN)
; 442  :     if (!clip_origin_lower_left) { float tmp = T; T = B; B = tmp; } // Swap top and bottom if origin is upper left

	test	dil, dil
	jne	SHORT $LN5@ImGui_Impl
	movaps	xmm0, xmm4
	movaps	xmm4, xmm3
	movaps	xmm3, xmm0
$LN5@ImGui_Impl:

; 443  : #endif
; 444  :     const float ortho_projection[4][4] =
; 445  :     {
; 446  :         { 2.0f/(R-L),   0.0f,         0.0f,   0.0f },

	movss	xmm2, DWORD PTR __real@40000000
	movaps	xmm1, xmm5
	subss	xmm1, xmm6
	mov	QWORD PTR ortho_projection$[rsp+4], r12
	movaps	xmm0, xmm2
	mov	QWORD PTR ortho_projection$[rsp+12], r12

; 447  :         { 0.0f,         2.0f/(T-B),   0.0f,   0.0f },

	mov	QWORD PTR ortho_projection$[rsp+24], r12

; 448  :         { 0.0f,         0.0f,        -1.0f,   0.0f },
; 449  :         { (R+L)/(L-R),  (T+B)/(B-T),  0.0f,   1.0f },

	mov	DWORD PTR ortho_projection$[rsp+56], r12d
	mov	DWORD PTR ortho_projection$[rsp+60], 1065353216 ; 3f800000H
	divss	xmm0, xmm1
	movaps	xmm1, xmm5
	movss	DWORD PTR ortho_projection$[rsp], xmm0
	addss	xmm1, xmm6
	movaps	xmm0, xmm4
	subss	xmm6, xmm5
	subss	xmm0, xmm3
	divss	xmm1, xmm6
	divss	xmm2, xmm0
	movaps	xmm0, XMMWORD PTR __xmm@00000000bf8000000000000000000000
	movaps	XMMWORD PTR ortho_projection$[rsp+32], xmm0
	movaps	xmm0, xmm3
	addss	xmm0, xmm4
	movss	DWORD PTR ortho_projection$[rsp+20], xmm2
	subss	xmm3, xmm4
	movss	DWORD PTR ortho_projection$[rsp+48], xmm1
	divss	xmm0, xmm3
	movss	DWORD PTR ortho_projection$[rsp+52], xmm0

; 450  :     };
; 451  :     glUseProgram(bd->ShaderHandle);

	mov	ecx, DWORD PTR [rbx+48]
	call	QWORD PTR imgl3wProcs+448

; 452  :     glUniform1i(bd->AttribLocationTex, 0);

	mov	ecx, DWORD PTR [rbx+52]
	xor	edx, edx
	call	QWORD PTR imgl3wProcs+432

; 453  :     glUniformMatrix4fv(bd->AttribLocationProjMtx, 1, GL_FALSE, &ortho_projection[0][0]);

	mov	ecx, DWORD PTR [rbx+56]
	lea	r9, QWORD PTR ortho_projection$[rsp]
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	call	QWORD PTR imgl3wProcs+440

; 454  : 
; 455  : #ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
; 456  :     if (bd->GlVersion >= 330 || bd->GlProfileIsES3)

	cmp	DWORD PTR [rbx], 330			; 0000014aH
	jae	SHORT $LN7@ImGui_Impl
	cmp	BYTE PTR [rbx+37], r12b
	je	SHORT $LN6@ImGui_Impl
$LN7@ImGui_Impl:

; 457  :         glBindSampler(0, 0); // We use combined texture/sampler state. Applications using GL 3.3 and GL ES 3.0 may set that otherwise.

	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR imgl3wProcs+24
$LN6@ImGui_Impl:

; 458  : #endif
; 459  : 
; 460  :     (void)vertex_array_object;
; 461  : #ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
; 462  :     glBindVertexArray(vertex_array_object);

	mov	ecx, r15d
	call	QWORD PTR imgl3wProcs+40

; 463  : #endif
; 464  : 
; 465  :     // Bind vertex/index buffers and setup attributes for ImDrawVert
; 466  :     GL_CALL(glBindBuffer(GL_ARRAY_BUFFER, bd->VboHandle));

	mov	edx, DWORD PTR [rbx+72]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR imgl3wProcs+16

; 467  :     GL_CALL(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bd->ElementsHandle));

	mov	edx, DWORD PTR [rbx+76]
	mov	ecx, 34963				; 00008893H
	call	QWORD PTR imgl3wProcs+16

; 468  :     GL_CALL(glEnableVertexAttribArray(bd->AttribLocationVtxPos));

	mov	ecx, DWORD PTR [rbx+60]
	call	QWORD PTR imgl3wProcs+216

; 469  :     GL_CALL(glEnableVertexAttribArray(bd->AttribLocationVtxUV));

	mov	ecx, DWORD PTR [rbx+64]
	call	QWORD PTR imgl3wProcs+216

; 470  :     GL_CALL(glEnableVertexAttribArray(bd->AttribLocationVtxColor));

	mov	ecx, DWORD PTR [rbx+68]
	call	QWORD PTR imgl3wProcs+216

; 471  :     GL_CALL(glVertexAttribPointer(bd->AttribLocationVtxPos,   2, GL_FLOAT,         GL_FALSE, sizeof(ImDrawVert), (GLvoid*)IM_OFFSETOF(ImDrawVert, pos)));

	mov	ecx, DWORD PTR [rbx+60]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+40], r12
	mov	r8d, 5126				; 00001406H
	mov	DWORD PTR [rsp+32], 20
	lea	edx, QWORD PTR [r9+2]
	call	QWORD PTR imgl3wProcs+456

; 472  :     GL_CALL(glVertexAttribPointer(bd->AttribLocationVtxUV,    2, GL_FLOAT,         GL_FALSE, sizeof(ImDrawVert), (GLvoid*)IM_OFFSETOF(ImDrawVert, uv)));

	mov	ecx, DWORD PTR [rbx+64]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+40], 8
	mov	r8d, 5126				; 00001406H
	mov	DWORD PTR [rsp+32], 20
	lea	edx, QWORD PTR [r9+2]
	call	QWORD PTR imgl3wProcs+456

; 473  :     GL_CALL(glVertexAttribPointer(bd->AttribLocationVtxColor, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(ImDrawVert), (GLvoid*)IM_OFFSETOF(ImDrawVert, col)));

	mov	ecx, DWORD PTR [rbx+68]
	mov	r9b, 1
	mov	edx, 4
	mov	QWORD PTR [rsp+40], 16
	mov	r8d, 5121				; 00001401H
	mov	DWORD PTR [rsp+32], 20
	call	QWORD PTR imgl3wProcs+456

; 474  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm6, XMMWORD PTR [rsp+144]
	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?ImGui_ImplOpenGL3_SetupRenderState@@YAXPEAUImDrawData@@HHI@Z ENDP ; ImGui_ImplOpenGL3_SetupRenderState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z
_TEXT	SEGMENT
last_enable_primitive_restart$1$ = 48
last_enable_cull_face$1$ = 49
last_enable_depth_test$1$ = 50
last_enable_stencil_test$1$ = 51
last_enable_blend$1$ = 52
last_enable_scissor_test$1$ = 53
n$1$ = 56
fb_width$1$ = 60
tv958 = 64
vertex_array_object$ = 72
last_program$ = 76
last_sampler$ = 80
last_texture$ = 84
last_active_texture$ = 88
last_vertex_array_object$ = 92
last_array_buffer$ = 96
last_blend_equation_alpha$ = 100
last_blend_equation_rgb$ = 104
last_blend_dst_alpha$ = 108
last_blend_src_alpha$ = 112
last_blend_dst_rgb$ = 116
last_blend_src_rgb$ = 120
last_polygon_mode$ = 128
last_viewport$ = 136
last_scissor_box$ = 152
__$ArrayPad$ = 168
draw_data$ = 288
?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z PROC ; ImGui_ImplOpenGL3_RenderDrawData, COMDAT

; 480  : {

$LN102:
	mov	r11, rsp
	push	rbp
	push	rbx
	push	r12
	push	r13
	lea	rbp, QWORD PTR [r11-95]
	sub	rsp, 248				; 000000f8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-185], rax

; 481  :     // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
; 482  :     int fb_width = (int)(draw_data->DisplaySize.x * draw_data->FramebufferScale.x);

	movss	xmm0, DWORD PTR [rcx+40]
	mov	r13, rcx
	mulss	xmm0, DWORD PTR [rcx+48]

; 483  :     int fb_height = (int)(draw_data->DisplaySize.y * draw_data->FramebufferScale.y);

	movss	xmm1, DWORD PTR [rcx+52]
	mulss	xmm1, DWORD PTR [rcx+44]
	cvttss2si ebx, xmm0
	cvttss2si r12d, xmm1
	mov	DWORD PTR fb_width$1$[rbp-185], ebx

; 484  :     if (fb_width <= 0 || fb_height <= 0)

	test	ebx, ebx
	jle	$LN9@ImGui_Impl
	test	r12d, r12d
	jle	$LN9@ImGui_Impl

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 484  :     if (fb_width <= 0 || fb_height <= 0)

	mov	QWORD PTR [r11+16], rsi
	mov	QWORD PTR [r11+24], rdi
	mov	QWORD PTR [r11+32], r14
	mov	QWORD PTR [r11-40], r15
	movaps	XMMWORD PTR [r11-56], xmm6
	movaps	XMMWORD PTR [r11-72], xmm7
	movaps	XMMWORD PTR [r11-88], xmm8
	movaps	XMMWORD PTR [r11-104], xmm9

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	test	rax, rax
	je	SHORT $LN58@ImGui_Impl
	mov	r15, QWORD PTR [rax+160]
	jmp	SHORT $LN59@ImGui_Impl
$LN58@ImGui_Impl:
	xor	r15d, r15d
$LN59@ImGui_Impl:

; 485  :         return;
; 486  : 
; 487  :     ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
; 488  : 
; 489  :     // Backup GL state
; 490  :     GLenum last_active_texture; glGetIntegerv(GL_ACTIVE_TEXTURE, (GLint*)&last_active_texture);

	lea	rdx, QWORD PTR last_active_texture$[rbp-185]
	mov	ecx, 34016				; 000084e0H
	call	QWORD PTR imgl3wProcs+272

; 491  :     glActiveTexture(GL_TEXTURE0);

	mov	ecx, 33984				; 000084c0H
	call	QWORD PTR imgl3wProcs

; 492  :     GLuint last_program; glGetIntegerv(GL_CURRENT_PROGRAM, (GLint*)&last_program);

	lea	rdx, QWORD PTR last_program$[rbp-185]
	mov	ecx, 35725				; 00008b8dH
	call	QWORD PTR imgl3wProcs+272

; 493  :     GLuint last_texture; glGetIntegerv(GL_TEXTURE_BINDING_2D, (GLint*)&last_texture);

	lea	rdx, QWORD PTR last_texture$[rbp-185]
	mov	ecx, 32873				; 00008069H
	call	QWORD PTR imgl3wProcs+272

; 494  : #ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
; 495  :     GLuint last_sampler; if (bd->GlVersion >= 330 || bd->GlProfileIsES3) { glGetIntegerv(GL_SAMPLER_BINDING, (GLint*)&last_sampler); } else { last_sampler = 0; }

	cmp	DWORD PTR [r15], 330			; 0000014aH
	jae	SHORT $LN69@ImGui_Impl
	cmp	BYTE PTR [r15+37], 0
	jne	SHORT $LN69@ImGui_Impl
	mov	DWORD PTR last_sampler$[rbp-185], 0
	jmp	SHORT $LN11@ImGui_Impl
$LN69@ImGui_Impl:
	lea	rdx, QWORD PTR last_sampler$[rbp-185]
	mov	ecx, 35097				; 00008919H
	call	QWORD PTR imgl3wProcs+272
$LN11@ImGui_Impl:

; 496  : #endif
; 497  :     GLuint last_array_buffer; glGetIntegerv(GL_ARRAY_BUFFER_BINDING, (GLint*)&last_array_buffer);

	lea	rdx, QWORD PTR last_array_buffer$[rbp-185]
	mov	ecx, 34964				; 00008894H
	call	QWORD PTR imgl3wProcs+272

; 498  : #ifndef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
; 499  :     // This is part of VAO on OpenGL 3.0+ and OpenGL ES 3.0+.
; 500  :     GLint last_element_array_buffer; glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &last_element_array_buffer);
; 501  :     ImGui_ImplOpenGL3_VtxAttribState last_vtx_attrib_state_pos; last_vtx_attrib_state_pos.GetState(bd->AttribLocationVtxPos);
; 502  :     ImGui_ImplOpenGL3_VtxAttribState last_vtx_attrib_state_uv; last_vtx_attrib_state_uv.GetState(bd->AttribLocationVtxUV);
; 503  :     ImGui_ImplOpenGL3_VtxAttribState last_vtx_attrib_state_color; last_vtx_attrib_state_color.GetState(bd->AttribLocationVtxColor);
; 504  : #endif
; 505  : #ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
; 506  :     GLuint last_vertex_array_object; glGetIntegerv(GL_VERTEX_ARRAY_BINDING, (GLint*)&last_vertex_array_object);

	lea	rdx, QWORD PTR last_vertex_array_object$[rbp-185]
	mov	ecx, 34229				; 000085b5H
	call	QWORD PTR imgl3wProcs+272

; 507  : #endif
; 508  : #ifdef IMGUI_IMPL_HAS_POLYGON_MODE
; 509  :     GLint last_polygon_mode[2]; glGetIntegerv(GL_POLYGON_MODE, last_polygon_mode);

	lea	rdx, QWORD PTR last_polygon_mode$[rbp-185]
	mov	ecx, 2880				; 00000b40H
	call	QWORD PTR imgl3wProcs+272

; 510  : #endif
; 511  :     GLint last_viewport[4]; glGetIntegerv(GL_VIEWPORT, last_viewport);

	lea	rdx, QWORD PTR last_viewport$[rbp-185]
	mov	ecx, 2978				; 00000ba2H
	call	QWORD PTR imgl3wProcs+272

; 512  :     GLint last_scissor_box[4]; glGetIntegerv(GL_SCISSOR_BOX, last_scissor_box);

	lea	rdx, QWORD PTR last_scissor_box$[rbp-185]
	mov	ecx, 3088				; 00000c10H
	call	QWORD PTR imgl3wProcs+272

; 513  :     GLenum last_blend_src_rgb; glGetIntegerv(GL_BLEND_SRC_RGB, (GLint*)&last_blend_src_rgb);

	lea	rdx, QWORD PTR last_blend_src_rgb$[rbp-185]
	mov	ecx, 32969				; 000080c9H
	call	QWORD PTR imgl3wProcs+272

; 514  :     GLenum last_blend_dst_rgb; glGetIntegerv(GL_BLEND_DST_RGB, (GLint*)&last_blend_dst_rgb);

	lea	rdx, QWORD PTR last_blend_dst_rgb$[rbp-185]
	mov	ecx, 32968				; 000080c8H
	call	QWORD PTR imgl3wProcs+272

; 515  :     GLenum last_blend_src_alpha; glGetIntegerv(GL_BLEND_SRC_ALPHA, (GLint*)&last_blend_src_alpha);

	lea	rdx, QWORD PTR last_blend_src_alpha$[rbp-185]
	mov	ecx, 32971				; 000080cbH
	call	QWORD PTR imgl3wProcs+272

; 516  :     GLenum last_blend_dst_alpha; glGetIntegerv(GL_BLEND_DST_ALPHA, (GLint*)&last_blend_dst_alpha);

	lea	rdx, QWORD PTR last_blend_dst_alpha$[rbp-185]
	mov	ecx, 32970				; 000080caH
	call	QWORD PTR imgl3wProcs+272

; 517  :     GLenum last_blend_equation_rgb; glGetIntegerv(GL_BLEND_EQUATION_RGB, (GLint*)&last_blend_equation_rgb);

	lea	rdx, QWORD PTR last_blend_equation_rgb$[rbp-185]
	mov	ecx, 32777				; 00008009H
	call	QWORD PTR imgl3wProcs+272

; 518  :     GLenum last_blend_equation_alpha; glGetIntegerv(GL_BLEND_EQUATION_ALPHA, (GLint*)&last_blend_equation_alpha);

	lea	rdx, QWORD PTR last_blend_equation_alpha$[rbp-185]
	mov	ecx, 34877				; 0000883dH
	call	QWORD PTR imgl3wProcs+272

; 519  :     GLboolean last_enable_blend = glIsEnabled(GL_BLEND);

	mov	rax, QWORD PTR imgl3wProcs+352
	mov	ecx, 3042				; 00000be2H
	call	rax

; 520  :     GLboolean last_enable_cull_face = glIsEnabled(GL_CULL_FACE);

	mov	rdx, QWORD PTR imgl3wProcs+352
	mov	ecx, 2884				; 00000b44H
	mov	BYTE PTR last_enable_blend$1$[rsp], al
	call	rdx

; 521  :     GLboolean last_enable_depth_test = glIsEnabled(GL_DEPTH_TEST);

	mov	rdx, QWORD PTR imgl3wProcs+352
	mov	ecx, 2929				; 00000b71H
	movzx	edi, al
	mov	BYTE PTR last_enable_cull_face$1$[rsp], al
	call	rdx

; 522  :     GLboolean last_enable_stencil_test = glIsEnabled(GL_STENCIL_TEST);

	mov	rdx, QWORD PTR imgl3wProcs+352
	mov	ecx, 2960				; 00000b90H
	movzx	esi, al
	mov	BYTE PTR last_enable_depth_test$1$[rsp], al
	call	rdx

; 523  :     GLboolean last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);

	mov	rdx, QWORD PTR imgl3wProcs+352
	mov	ecx, 3089				; 00000c11H
	movzx	r14d, al
	mov	BYTE PTR last_enable_stencil_test$1$[rsp], al
	call	rdx

; 524  : #ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
; 525  :     GLboolean last_enable_primitive_restart = (bd->GlVersion >= 310) ? glIsEnabled(GL_PRIMITIVE_RESTART) : GL_FALSE;

	cmp	DWORD PTR [r15], 310			; 00000136H
	mov	BYTE PTR last_enable_scissor_test$1$[rsp], al
	jb	SHORT $LN46@ImGui_Impl
	mov	rdx, QWORD PTR imgl3wProcs+352
	mov	ecx, 36765				; 00008f9dH
	call	rdx
	mov	BYTE PTR last_enable_primitive_restart$1$[rsp], al
	jmp	SHORT $LN47@ImGui_Impl
$LN46@ImGui_Impl:
	mov	BYTE PTR last_enable_primitive_restart$1$[rsp], 0
$LN47@ImGui_Impl:

; 526  : #endif
; 527  : 
; 528  :     // Setup desired GL state
; 529  :     // Recreate the VAO every time (this is to easily allow multiple GL contexts to be rendered to. VAO are not shared among GL contexts)
; 530  :     // The renderer would actually work without any VAO bound, but then our VertexAttrib calls would overwrite the default one currently bound.
; 531  :     GLuint vertex_array_object = 0;
; 532  : #ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
; 533  :     GL_CALL(glGenVertexArrays(1, &vertex_array_object));

	lea	rdx, QWORD PTR vertex_array_object$[rbp-185]
	mov	DWORD PTR vertex_array_object$[rbp-185], 0
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+248

; 534  : #endif
; 535  :     ImGui_ImplOpenGL3_SetupRenderState(draw_data, fb_width, fb_height, vertex_array_object);

	mov	r9d, DWORD PTR vertex_array_object$[rbp-185]
	mov	r8d, r12d
	mov	edx, ebx
	mov	rcx, r13
	call	?ImGui_ImplOpenGL3_SetupRenderState@@YAXPEAUImDrawData@@HHI@Z ; ImGui_ImplOpenGL3_SetupRenderState

; 536  : 
; 537  :     // Will project scissor/clipping rectangles into framebuffer space
; 538  :     ImVec2 clip_off = draw_data->DisplayPos;         // (0,0) unless using multi-viewports
; 539  :     ImVec2 clip_scale = draw_data->FramebufferScale; // (1,1) unless using retina display which are often (2,2)
; 540  : 
; 541  :     // Render command lists
; 542  :     for (int n = 0; n < draw_data->CmdListsCount; n++)

	cmp	DWORD PTR [r13+4], 0
	movss	xmm6, DWORD PTR [r13+32]
	movss	xmm7, DWORD PTR [r13+36]
	movss	xmm8, DWORD PTR [r13+48]
	movss	xmm9, DWORD PTR [r13+52]
	mov	DWORD PTR n$1$[rsp], 0
	jle	$LN3@ImGui_Impl
	xor	edx, edx
	mov	QWORD PTR tv958[rbp-185], rdx
	npad	11
$LL4@ImGui_Impl:

; 543  :     {
; 544  :         const ImDrawList* cmd_list = draw_data->CmdLists[n];

	mov	rax, QWORD PTR [r13+24]
	mov	rdi, QWORD PTR [rdx+rax]

; 545  : 
; 546  :         // Upload vertex/index buffers
; 547  :         // - OpenGL drivers are in a very sorry state nowadays....
; 548  :         //   During 2021 we attempted to switch from glBufferData() to orphaning+glBufferSubData() following reports
; 549  :         //   of leaks on Intel GPU when using multi-viewports on Windows.
; 550  :         // - After this we kept hearing of various display corruptions issues. We started disabling on non-Intel GPU, but issues still got reported on Intel.
; 551  :         // - We are now back to using exclusively glBufferData(). So bd->UseBufferSubData IS ALWAYS FALSE in this code.
; 552  :         //   We are keeping the old code path for a while in case people finding new issues may want to test the bd->UseBufferSubData path.
; 553  :         // - See https://github.com/ocornut/imgui/issues/4468 and please report any corruption issues.
; 554  :         const GLsizeiptr vtx_buffer_size = (GLsizeiptr)cmd_list->VtxBuffer.Size * (int)sizeof(ImDrawVert);

	movsxd	rax, DWORD PTR [rdi+32]

; 555  :         const GLsizeiptr idx_buffer_size = (GLsizeiptr)cmd_list->IdxBuffer.Size * (int)sizeof(ImDrawIdx);

	movsxd	rsi, DWORD PTR [rdi+16]
	add	rsi, rsi
	lea	rbx, QWORD PTR [rax+rax*4]
	shl	rbx, 2

; 556  :         if (bd->UseBufferSubData)

	cmp	BYTE PTR [r15+97], 0
	je	SHORT $LN13@ImGui_Impl

; 557  :         {
; 558  :             if (bd->VertexBufferSize < vtx_buffer_size)

	cmp	QWORD PTR [r15+80], rbx
	jge	SHORT $LN15@ImGui_Impl

; 559  :             {
; 560  :                 bd->VertexBufferSize = vtx_buffer_size;
; 561  :                 GL_CALL(glBufferData(GL_ARRAY_BUFFER, bd->VertexBufferSize, nullptr, GL_STREAM_DRAW));

	mov	r9d, 35040				; 000088e0H
	mov	QWORD PTR [r15+80], rbx
	xor	r8d, r8d
	mov	rdx, rbx
	lea	ecx, QWORD PTR [r9-78]
	call	QWORD PTR imgl3wProcs+72
$LN15@ImGui_Impl:

; 562  :             }
; 563  :             if (bd->IndexBufferSize < idx_buffer_size)

	cmp	QWORD PTR [r15+88], rsi
	jge	SHORT $LN16@ImGui_Impl

; 564  :             {
; 565  :                 bd->IndexBufferSize = idx_buffer_size;
; 566  :                 GL_CALL(glBufferData(GL_ELEMENT_ARRAY_BUFFER, bd->IndexBufferSize, nullptr, GL_STREAM_DRAW));

	mov	r9d, 35040				; 000088e0H
	mov	QWORD PTR [r15+88], rsi
	xor	r8d, r8d
	mov	rdx, rsi
	lea	ecx, QWORD PTR [r9-77]
	call	QWORD PTR imgl3wProcs+72
$LN16@ImGui_Impl:

; 567  :             }
; 568  :             GL_CALL(glBufferSubData(GL_ARRAY_BUFFER, 0, vtx_buffer_size, (const GLvoid*)cmd_list->VtxBuffer.Data));

	mov	r9, QWORD PTR [rdi+40]
	mov	r8, rbx
	xor	edx, edx
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR imgl3wProcs+80

; 569  :             GL_CALL(glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, idx_buffer_size, (const GLvoid*)cmd_list->IdxBuffer.Data));

	mov	r9, QWORD PTR [rdi+24]
	mov	r8, rsi
	xor	edx, edx
	mov	ecx, 34963				; 00008893H
	call	QWORD PTR imgl3wProcs+80

; 570  :         }

	jmp	SHORT $LN14@ImGui_Impl
$LN13@ImGui_Impl:

; 571  :         else
; 572  :         {
; 573  :             GL_CALL(glBufferData(GL_ARRAY_BUFFER, vtx_buffer_size, (const GLvoid*)cmd_list->VtxBuffer.Data, GL_STREAM_DRAW));

	mov	r8, QWORD PTR [rdi+40]
	mov	r9d, 35040				; 000088e0H
	mov	rdx, rbx
	lea	ecx, QWORD PTR [r9-78]
	call	QWORD PTR imgl3wProcs+72

; 574  :             GL_CALL(glBufferData(GL_ELEMENT_ARRAY_BUFFER, idx_buffer_size, (const GLvoid*)cmd_list->IdxBuffer.Data, GL_STREAM_DRAW));

	mov	r8, QWORD PTR [rdi+24]
	mov	r9d, 35040				; 000088e0H
	mov	rdx, rsi
	lea	ecx, QWORD PTR [r9-77]
	call	QWORD PTR imgl3wProcs+72
$LN14@ImGui_Impl:

; 575  :         }
; 576  : 
; 577  :         for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	xor	r14d, r14d
	cmp	DWORD PTR [rdi], r14d
	jle	$LN2@ImGui_Impl
	xor	esi, esi
	npad	8
$LL7@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rbx, QWORD PTR [rdi+8]
	add	rbx, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 580  :             if (pcmd->UserCallback != nullptr)

	mov	rax, QWORD PTR [rbx+40]
	test	rax, rax
	je	SHORT $LN17@ImGui_Impl

; 581  :             {
; 582  :                 // User callback, registered via ImDrawList::AddCallback()
; 583  :                 // (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to reset render state.)
; 584  :                 if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)

	cmp	rax, -1
	jne	SHORT $LN19@ImGui_Impl

; 585  :                     ImGui_ImplOpenGL3_SetupRenderState(draw_data, fb_width, fb_height, vertex_array_object);

	mov	r9d, DWORD PTR vertex_array_object$[rbp-185]
	mov	r8d, r12d
	mov	edx, DWORD PTR fb_width$1$[rbp-185]
	mov	rcx, r13
	call	?ImGui_ImplOpenGL3_SetupRenderState@@YAXPEAUImDrawData@@HHI@Z ; ImGui_ImplOpenGL3_SetupRenderState
	jmp	$LN5@ImGui_Impl
$LN19@ImGui_Impl:

; 586  :                 else
; 587  :                     pcmd->UserCallback(cmd_list, pcmd);

	mov	rdx, rbx
	mov	rcx, rdi
	call	rax

; 588  :             }

	jmp	$LN5@ImGui_Impl
$LN17@ImGui_Impl:

; 589  :             else
; 590  :             {
; 591  :                 // Project scissor/clipping rectangles into framebuffer space
; 592  :                 ImVec2 clip_min((pcmd->ClipRect.x - clip_off.x) * clip_scale.x, (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);

	movss	xmm4, DWORD PTR [rbx]

; 593  :                 ImVec2 clip_max((pcmd->ClipRect.z - clip_off.x) * clip_scale.x, (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);

	movss	xmm3, DWORD PTR [rbx+8]
	subss	xmm4, xmm6
	movss	xmm2, DWORD PTR [rbx+4]
	subss	xmm3, xmm6
	movss	xmm1, DWORD PTR [rbx+12]
	subss	xmm2, xmm7
	subss	xmm1, xmm7
	mulss	xmm4, xmm8
	mulss	xmm3, xmm8
	mulss	xmm2, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	comiss	xmm4, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 593  :                 ImVec2 clip_max((pcmd->ClipRect.z - clip_off.x) * clip_scale.x, (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);

	mulss	xmm1, xmm9

; 594  :                 if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)

	jae	SHORT $LN5@ImGui_Impl
	comiss	xmm2, xmm1
	jae	SHORT $LN5@ImGui_Impl

; 595  :                     continue;
; 596  : 
; 597  :                 // Apply scissor/clipping rectangle (Y is inverted in OpenGL)
; 598  :                 GL_CALL(glScissor((int)clip_min.x, (int)((float)fb_height - clip_max.y), (int)(clip_max.x - clip_min.x), (int)(clip_max.y - clip_min.y)));

	movaps	xmm0, xmm1
	subss	xmm3, xmm4
	subss	xmm0, xmm2
	cvttss2si ecx, xmm4
	cvttss2si r9d, xmm0
	movd	xmm0, r12d
	cvtdq2ps xmm0, xmm0
	cvttss2si r8d, xmm3
	subss	xmm0, xmm1
	cvttss2si edx, xmm0
	call	QWORD PTR imgl3wProcs+400

; 599  : 
; 600  :                 // Bind texture, Draw
; 601  :                 GL_CALL(glBindTexture(GL_TEXTURE_2D, (GLuint)(intptr_t)pcmd->GetTexID()));

	mov	edx, DWORD PTR [rbx+16]
	mov	ecx, 3553				; 00000de1H
	call	QWORD PTR imgl3wProcs+32

; 602  : #ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_VTX_OFFSET
; 603  :                 if (bd->GlVersion >= 320)

	mov	r9d, DWORD PTR [rbx+28]
	mov	r8d, 5123				; 00001403H
	mov	edx, DWORD PTR [rbx+32]
	add	r9, r9
	cmp	DWORD PTR [r15], 320			; 00000140H
	mov	ecx, 4
	jb	SHORT $LN23@ImGui_Impl

; 604  :                     GL_CALL(glDrawElementsBaseVertex(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, (void*)(intptr_t)(pcmd->IdxOffset * sizeof(ImDrawIdx)), (GLint)pcmd->VtxOffset));

	mov	eax, DWORD PTR [rbx+24]
	mov	DWORD PTR [rsp+32], eax
	call	QWORD PTR imgl3wProcs+200
	jmp	SHORT $LN5@ImGui_Impl
$LN23@ImGui_Impl:

; 605  :                 else
; 606  : #endif
; 607  :                 GL_CALL(glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, (void*)(intptr_t)(pcmd->IdxOffset * sizeof(ImDrawIdx))));

	call	QWORD PTR imgl3wProcs+192
$LN5@ImGui_Impl:

; 575  :         }
; 576  : 
; 577  :         for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	inc	r14d
	add	rsi, 56					; 00000038H
	cmp	r14d, DWORD PTR [rdi]
	jl	$LL7@ImGui_Impl
$LN2@ImGui_Impl:

; 536  : 
; 537  :     // Will project scissor/clipping rectangles into framebuffer space
; 538  :     ImVec2 clip_off = draw_data->DisplayPos;         // (0,0) unless using multi-viewports
; 539  :     ImVec2 clip_scale = draw_data->FramebufferScale; // (1,1) unless using retina display which are often (2,2)
; 540  : 
; 541  :     // Render command lists
; 542  :     for (int n = 0; n < draw_data->CmdListsCount; n++)

	mov	ecx, DWORD PTR n$1$[rsp]
	mov	rdx, QWORD PTR tv958[rbp-185]
	inc	ecx
	add	rdx, 8
	mov	DWORD PTR n$1$[rsp], ecx
	mov	QWORD PTR tv958[rbp-185], rdx
	cmp	ecx, DWORD PTR [r13+4]
	jl	$LL4@ImGui_Impl
	movzx	edi, BYTE PTR last_enable_cull_face$1$[rsp]
	movzx	esi, BYTE PTR last_enable_depth_test$1$[rsp]
	movzx	r14d, BYTE PTR last_enable_stencil_test$1$[rsp]
$LN3@ImGui_Impl:

; 608  :             }
; 609  :         }
; 610  :     }
; 611  : 
; 612  :     // Destroy the temporary VAO
; 613  : #ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
; 614  :     GL_CALL(glDeleteVertexArrays(1, &vertex_array_object));

	lea	rdx, QWORD PTR vertex_array_object$[rbp-185]
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+160

; 615  : #endif
; 616  : 
; 617  :     // Restore modified GL state
; 618  :     // This "glIsProgram()" check is required because if the program is "pending deletion" at the time of binding backup, it will have been deleted by now and will cause an OpenGL error. See #6220.
; 619  :     if (last_program == 0 || glIsProgram(last_program)) glUseProgram(last_program);

	mov	ecx, DWORD PTR last_program$[rbp-185]
	movaps	xmm9, XMMWORD PTR [rsp+176]
	movaps	xmm8, XMMWORD PTR [rsp+192]
	movaps	xmm7, XMMWORD PTR [rsp+208]
	movaps	xmm6, XMMWORD PTR [rsp+224]
	test	ecx, ecx
	je	SHORT $LN26@ImGui_Impl
	mov	rax, QWORD PTR imgl3wProcs+360
	call	rax
	test	al, al
	je	SHORT $LN25@ImGui_Impl
	mov	ecx, DWORD PTR last_program$[rbp-185]
$LN26@ImGui_Impl:
	call	QWORD PTR imgl3wProcs+448
$LN25@ImGui_Impl:

; 620  :     glBindTexture(GL_TEXTURE_2D, last_texture);

	mov	edx, DWORD PTR last_texture$[rbp-185]
	mov	ecx, 3553				; 00000de1H
	call	QWORD PTR imgl3wProcs+32

; 621  : #ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
; 622  :     if (bd->GlVersion >= 330 || bd->GlProfileIsES3)

	cmp	DWORD PTR [r15], 330			; 0000014aH
	jae	SHORT $LN28@ImGui_Impl
	cmp	BYTE PTR [r15+37], 0
	je	SHORT $LN27@ImGui_Impl
$LN28@ImGui_Impl:

; 623  :         glBindSampler(0, last_sampler);

	mov	edx, DWORD PTR last_sampler$[rbp-185]
	xor	ecx, ecx
	call	QWORD PTR imgl3wProcs+24
$LN27@ImGui_Impl:

; 624  : #endif
; 625  :     glActiveTexture(last_active_texture);

	mov	ecx, DWORD PTR last_active_texture$[rbp-185]
	call	QWORD PTR imgl3wProcs

; 626  : #ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
; 627  :     glBindVertexArray(last_vertex_array_object);

	mov	ecx, DWORD PTR last_vertex_array_object$[rbp-185]
	call	QWORD PTR imgl3wProcs+40

; 628  : #endif
; 629  :     glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);

	mov	edx, DWORD PTR last_array_buffer$[rbp-185]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR imgl3wProcs+16

; 630  : #ifndef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
; 631  :     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, last_element_array_buffer);
; 632  :     last_vtx_attrib_state_pos.SetState(bd->AttribLocationVtxPos);
; 633  :     last_vtx_attrib_state_uv.SetState(bd->AttribLocationVtxUV);
; 634  :     last_vtx_attrib_state_color.SetState(bd->AttribLocationVtxColor);
; 635  : #endif
; 636  :     glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);

	mov	edx, DWORD PTR last_blend_equation_alpha$[rbp-185]
	mov	ecx, DWORD PTR last_blend_equation_rgb$[rbp-185]
	call	QWORD PTR imgl3wProcs+56

; 637  :     glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);

	mov	r9d, DWORD PTR last_blend_dst_alpha$[rbp-185]
	mov	r8d, DWORD PTR last_blend_src_alpha$[rbp-185]
	mov	edx, DWORD PTR last_blend_dst_rgb$[rbp-185]
	mov	ecx, DWORD PTR last_blend_src_rgb$[rbp-185]
	call	QWORD PTR imgl3wProcs+64

; 638  :     if (last_enable_blend) glEnable(GL_BLEND); else glDisable(GL_BLEND);

	cmp	BYTE PTR last_enable_blend$1$[rsp], 0
	mov	ecx, 3042				; 00000be2H
	je	SHORT $LN29@ImGui_Impl
	call	QWORD PTR imgl3wProcs+208
	jmp	SHORT $LN30@ImGui_Impl
$LN29@ImGui_Impl:
	call	QWORD PTR imgl3wProcs+176
$LN30@ImGui_Impl:

; 639  :     if (last_enable_cull_face) glEnable(GL_CULL_FACE); else glDisable(GL_CULL_FACE);

	test	dil, dil
	mov	ecx, 2884				; 00000b44H
	mov	rdi, QWORD PTR [rsp+304]
	je	SHORT $LN31@ImGui_Impl
	call	QWORD PTR imgl3wProcs+208
	jmp	SHORT $LN32@ImGui_Impl
$LN31@ImGui_Impl:
	call	QWORD PTR imgl3wProcs+176
$LN32@ImGui_Impl:

; 640  :     if (last_enable_depth_test) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);

	test	sil, sil
	mov	ecx, 2929				; 00000b71H
	mov	rsi, QWORD PTR [rsp+296]
	je	SHORT $LN33@ImGui_Impl
	call	QWORD PTR imgl3wProcs+208
	jmp	SHORT $LN34@ImGui_Impl
$LN33@ImGui_Impl:
	call	QWORD PTR imgl3wProcs+176
$LN34@ImGui_Impl:

; 641  :     if (last_enable_stencil_test) glEnable(GL_STENCIL_TEST); else glDisable(GL_STENCIL_TEST);

	test	r14b, r14b
	mov	ecx, 2960				; 00000b90H
	mov	r14, QWORD PTR [rsp+312]
	je	SHORT $LN35@ImGui_Impl
	call	QWORD PTR imgl3wProcs+208
	jmp	SHORT $LN36@ImGui_Impl
$LN35@ImGui_Impl:
	call	QWORD PTR imgl3wProcs+176
$LN36@ImGui_Impl:

; 642  :     if (last_enable_scissor_test) glEnable(GL_SCISSOR_TEST); else glDisable(GL_SCISSOR_TEST);

	cmp	BYTE PTR last_enable_scissor_test$1$[rsp], 0
	mov	ecx, 3089				; 00000c11H
	je	SHORT $LN37@ImGui_Impl
	call	QWORD PTR imgl3wProcs+208
	jmp	SHORT $LN38@ImGui_Impl
$LN37@ImGui_Impl:
	call	QWORD PTR imgl3wProcs+176
$LN38@ImGui_Impl:

; 643  : #ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
; 644  :     if (bd->GlVersion >= 310) { if (last_enable_primitive_restart) glEnable(GL_PRIMITIVE_RESTART); else glDisable(GL_PRIMITIVE_RESTART); }

	cmp	DWORD PTR [r15], 310			; 00000136H
	jb	SHORT $LN44@ImGui_Impl
	cmp	BYTE PTR last_enable_primitive_restart$1$[rsp], 0
	mov	ecx, 36765				; 00008f9dH
	je	SHORT $LN40@ImGui_Impl
	call	QWORD PTR imgl3wProcs+208
	jmp	SHORT $LN41@ImGui_Impl
$LN40@ImGui_Impl:
	call	QWORD PTR imgl3wProcs+176
$LN41@ImGui_Impl:

; 645  : #endif
; 646  : 
; 647  : #ifdef IMGUI_IMPL_HAS_POLYGON_MODE
; 648  :     // Desktop OpenGL 3.0 and OpenGL 3.1 had separate polygon draw modes for front-facing and back-facing faces of polygons
; 649  :     if (bd->GlVersion <= 310 || bd->GlProfileIsCompat)

	cmp	DWORD PTR [r15], 310			; 00000136H
	jbe	SHORT $LN44@ImGui_Impl
	cmp	BYTE PTR [r15+38], 0
	jne	SHORT $LN44@ImGui_Impl

; 653  :     }
; 654  :     else
; 655  :     {
; 656  :         glPolygonMode(GL_FRONT_AND_BACK, (GLenum)last_polygon_mode[0]);

	mov	edx, DWORD PTR last_polygon_mode$[rbp-185]
	mov	ecx, 1032				; 00000408H
	jmp	SHORT $LN100@ImGui_Impl
$LN44@ImGui_Impl:

; 650  :     {
; 651  :         glPolygonMode(GL_FRONT, (GLenum)last_polygon_mode[0]);

	mov	edx, DWORD PTR last_polygon_mode$[rbp-185]
	mov	ecx, 1028				; 00000404H
	call	QWORD PTR imgl3wProcs+384

; 652  :         glPolygonMode(GL_BACK, (GLenum)last_polygon_mode[1]);

	mov	edx, DWORD PTR last_polygon_mode$[rbp-181]
	mov	ecx, 1029				; 00000405H
$LN100@ImGui_Impl:

; 657  :     }
; 658  : #endif // IMGUI_IMPL_HAS_POLYGON_MODE
; 659  : 
; 660  :     glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);

	call	QWORD PTR imgl3wProcs+384
	mov	r9d, DWORD PTR last_viewport$[rbp-173]
	mov	r8d, DWORD PTR last_viewport$[rbp-177]
	mov	edx, DWORD PTR last_viewport$[rbp-181]
	mov	ecx, DWORD PTR last_viewport$[rbp-185]
	call	QWORD PTR imgl3wProcs+464

; 661  :     glScissor(last_scissor_box[0], last_scissor_box[1], (GLsizei)last_scissor_box[2], (GLsizei)last_scissor_box[3]);

	mov	r9d, DWORD PTR last_scissor_box$[rbp-173]
	mov	r8d, DWORD PTR last_scissor_box$[rbp-177]
	mov	edx, DWORD PTR last_scissor_box$[rbp-181]
	mov	ecx, DWORD PTR last_scissor_box$[rbp-185]
	call	QWORD PTR imgl3wProcs+400
	mov	r15, QWORD PTR [rsp+240]
$LN9@ImGui_Impl:

; 662  :     (void)bd; // Not all compilation paths use this
; 663  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-185]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 248				; 000000f8H
	pop	r13
	pop	r12
	pop	rbx
	pop	rbp
	ret	0
?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z ENDP ; ImGui_ImplOpenGL3_RenderDrawData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_CreateFontsTexture@@YA_NXZ
_TEXT	SEGMENT
height$ = 80
width$ = 84
pixels$ = 88
last_texture$ = 96
__$ArrayPad$ = 104
?ImGui_ImplOpenGL3_CreateFontsTexture@@YA_NXZ PROC	; ImGui_ImplOpenGL3_CreateFontsTexture, COMDAT

; 666  : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 667  :     ImGuiIO& io = ImGui::GetIO();

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	test	rdi, rdi
	je	SHORT $LN5@ImGui_Impl
	mov	rbx, QWORD PTR [rdi+160]
	jmp	SHORT $LN6@ImGui_Impl
$LN5@ImGui_Impl:
	xor	ebx, ebx
$LN6@ImGui_Impl:

; 668  :     ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
; 669  : 
; 670  :     // Build texture atlas
; 671  :     unsigned char* pixels;
; 672  :     int width, height;
; 673  :     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   // Load as RGBA 32-bit (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.

	mov	rcx, QWORD PTR [rdi+56]
	lea	r9, QWORD PTR height$[rsp]
	lea	r8, QWORD PTR width$[rsp]
	lea	rdx, QWORD PTR pixels$[rsp]
	call	?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32

; 674  : 
; 675  :     // Upload texture to graphics system
; 676  :     // (Bilinear sampling is required by default. Set 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines' or 'style.AntiAliasedLinesUseTex = false' to allow point/nearest sampling)
; 677  :     GLint last_texture;
; 678  :     GL_CALL(glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture));

	lea	rdx, QWORD PTR last_texture$[rsp]
	mov	ecx, 32873				; 00008069H
	call	QWORD PTR imgl3wProcs+272

; 679  :     GL_CALL(glGenTextures(1, &bd->FontTexture));

	lea	rdx, QWORD PTR [rbx+44]
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+240

; 680  :     GL_CALL(glBindTexture(GL_TEXTURE_2D, bd->FontTexture));

	mov	edx, DWORD PTR [rbx+44]
	mov	ecx, 3553				; 00000de1H
	call	QWORD PTR imgl3wProcs+32

; 681  :     GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));

	mov	edx, 10241				; 00002801H
	mov	ecx, 3553				; 00000de1H
	mov	r8d, 9729				; 00002601H
	call	QWORD PTR imgl3wProcs+424

; 682  :     GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));

	mov	edx, 10240				; 00002800H
	mov	ecx, 3553				; 00000de1H
	mov	r8d, 9729				; 00002601H
	call	QWORD PTR imgl3wProcs+424

; 683  : #ifdef GL_UNPACK_ROW_LENGTH // Not on WebGL/ES
; 684  :     GL_CALL(glPixelStorei(GL_UNPACK_ROW_LENGTH, 0));

	xor	edx, edx
	mov	ecx, 3314				; 00000cf2H
	call	QWORD PTR imgl3wProcs+376

; 685  : #endif
; 686  :     GL_CALL(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels));

	mov	rax, QWORD PTR pixels$[rsp]
	xor	edx, edx
	mov	r9d, DWORD PTR width$[rsp]
	mov	ecx, 3553				; 00000de1H
	mov	QWORD PTR [rsp+64], rax
	mov	r8d, 6408				; 00001908H
	mov	eax, DWORD PTR height$[rsp]
	mov	DWORD PTR [rsp+56], 5121		; 00001401H
	mov	DWORD PTR [rsp+48], 6408		; 00001908H
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], eax
	call	QWORD PTR imgl3wProcs+416

; 687  : 
; 688  :     // Store our identifier
; 689  :     io.Fonts->SetTexID((ImTextureID)(intptr_t)bd->FontTexture);

	mov	edx, DWORD PTR [rbx+44]

; 690  : 
; 691  :     // Restore state
; 692  :     GL_CALL(glBindTexture(GL_TEXTURE_2D, last_texture));

	mov	ecx, 3553				; 00000de1H
	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rax+8], rdx
	mov	edx, DWORD PTR last_texture$[rsp]
	call	QWORD PTR imgl3wProcs+32

; 693  : 
; 694  :     return true;

	mov	al, 1

; 695  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
?ImGui_ImplOpenGL3_CreateFontsTexture@@YA_NXZ ENDP	; ImGui_ImplOpenGL3_CreateFontsTexture
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_DestroyFontsTexture@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplOpenGL3_DestroyFontsTexture@@YAXXZ PROC	; ImGui_ImplOpenGL3_DestroyFontsTexture, COMDAT

; 698  : {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 699  :     ImGuiIO& io = ImGui::GetIO();

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	test	rbx, rbx
	je	SHORT $LN6@ImGui_Impl
	mov	rax, QWORD PTR [rbx+160]
	jmp	SHORT $LN7@ImGui_Impl
$LN6@ImGui_Impl:
	xor	eax, eax
$LN7@ImGui_Impl:

; 700  :     ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
; 701  :     if (bd->FontTexture)

	cmp	DWORD PTR [rax+44], 0
	lea	rdi, QWORD PTR [rax+44]
	je	SHORT $LN2@ImGui_Impl

; 702  :     {
; 703  :         glDeleteTextures(1, &bd->FontTexture);

	mov	rdx, rdi
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+152

; 704  :         io.Fonts->SetTexID(0);

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax+8], 0

; 705  :         bd->FontTexture = 0;

	mov	DWORD PTR [rdi], 0
$LN2@ImGui_Impl:

; 706  :     }
; 707  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?ImGui_ImplOpenGL3_DestroyFontsTexture@@YAXXZ ENDP	; ImGui_ImplOpenGL3_DestroyFontsTexture
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?CheckShader@@YA_NIPEBD@Z
_TEXT	SEGMENT
buf$1 = 32
log_length$ = 48
status$ = 52
__$ArrayPad$ = 56
handle$ = 96
desc$ = 104
?CheckShader@@YA_NIPEBD@Z PROC				; CheckShader, COMDAT

; 711  : {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rdx
	mov	ebp, ecx

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	xor	edi, edi
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN8@CheckShade
	mov	rbx, QWORD PTR [rax+160]
	jmp	SHORT $LN9@CheckShade
$LN8@CheckShade:
	mov	rbx, rdi
$LN9@CheckShade:

; 712  :     ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
; 713  :     GLint status = 0, log_length = 0;

	mov	DWORD PTR status$[rsp], edi
	mov	DWORD PTR log_length$[rsp], edi

; 714  :     glGetShaderiv(handle, GL_COMPILE_STATUS, &status);

	lea	r8, QWORD PTR status$[rsp]
	mov	edx, 35713				; 00008b81H
	call	QWORD PTR imgl3wProcs+304

; 715  :     glGetShaderiv(handle, GL_INFO_LOG_LENGTH, &log_length);

	lea	r8, QWORD PTR log_length$[rsp]
	mov	edx, 35716				; 00008b84H
	mov	ecx, ebp
	call	QWORD PTR imgl3wProcs+304

; 716  :     if ((GLboolean)status == GL_FALSE)

	cmp	BYTE PTR status$[rsp], dil
	jne	SHORT $LN2@CheckShade

; 717  :         fprintf(stderr, "ERROR: ImGui_ImplOpenGL3_CreateDeviceObjects: failed to compile %s! With GLSL: %s\n", desc, bd->GlslVersionString);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	r9, QWORD PTR [rbx+4]
	mov	r8, rsi
	lea	rdx, OFFSET FLAT:??_C@_0FD@CCPHEBOI@ERROR?3?5ImGui_ImplOpenGL3_Create@
	call	fprintf
$LN2@CheckShade:

; 718  :     if (log_length > 1)

	mov	edx, DWORD PTR log_length$[rsp]
	cmp	edx, 1
	jle	$LN40@CheckShade
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR buf$1[rsp], rdi
	mov	QWORD PTR buf$1[rsp+8], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 721  :         buf.resize((int)(log_length + 1));

	lea	esi, DWORD PTR [rdx+1]
	test	esi, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	jle	SHORT $LN19@CheckShade

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	ebx, esi
	mov	eax, 8
	cmp	esi, eax
	cmovl	ebx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	test	ebx, ebx

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	jle	SHORT $LN19@CheckShade
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN24@CheckShade

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN24@CheckShade:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rcx, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
	mov	QWORD PTR buf$1[rsp+8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR buf$1[rsp+4], ebx
	mov	edx, DWORD PTR log_length$[rsp]
$LN19@CheckShade:

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR buf$1[rsp], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 722  :         glGetShaderInfoLog(handle, log_length, nullptr, (GLchar*)buf.begin());

	mov	r9, rdi
	xor	r8d, r8d
	mov	ecx, ebp
	call	QWORD PTR imgl3wProcs+296

; 723  :         fprintf(stderr, "%s\n", buf.begin());

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6@
	mov	rcx, rax
	call	fprintf
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	test	rdi, rdi
	je	SHORT $LN46@CheckShade
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN44@CheckShade

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN44@CheckShade:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
	npad	1
$LN46@CheckShade:
$LN40@CheckShade:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 725  :     return (GLboolean)status == GL_TRUE;

	cmp	BYTE PTR status$[rsp], 1
	sete	al

; 726  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?CheckShader@@YA_NIPEBD@Z ENDP				; CheckShader
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
buf$1 = 32
log_length$ = 48
status$ = 52
__$ArrayPad$ = 56
handle$ = 96
desc$ = 104
?dtor$0@?0??CheckShader@@YA_NIPEBD@Z@4HA PROC		; `CheckShader'::`1'::dtor$0
	lea	rcx, QWORD PTR buf$1[rdx]
	jmp	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
?dtor$0@?0??CheckShader@@YA_NIPEBD@Z@4HA ENDP		; `CheckShader'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?CheckProgram@@YA_NIPEBD@Z
_TEXT	SEGMENT
buf$1 = 32
log_length$ = 48
status$ = 52
__$ArrayPad$ = 56
handle$ = 80
desc$dead$ = 88
?CheckProgram@@YA_NIPEBD@Z PROC				; CheckProgram, COMDAT

; 730  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	ebp, ecx

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	xor	edi, edi
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN8@CheckProgr
	mov	rbx, QWORD PTR [rax+160]
	jmp	SHORT $LN9@CheckProgr
$LN8@CheckProgr:
	mov	rbx, rdi
$LN9@CheckProgr:

; 731  :     ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
; 732  :     GLint status = 0, log_length = 0;

	mov	DWORD PTR status$[rsp], edi
	mov	DWORD PTR log_length$[rsp], edi

; 733  :     glGetProgramiv(handle, GL_LINK_STATUS, &status);

	lea	r8, QWORD PTR status$[rsp]
	mov	edx, 35714				; 00008b82H
	call	QWORD PTR imgl3wProcs+288

; 734  :     glGetProgramiv(handle, GL_INFO_LOG_LENGTH, &log_length);

	lea	r8, QWORD PTR log_length$[rsp]
	mov	edx, 35716				; 00008b84H
	mov	ecx, ebp
	call	QWORD PTR imgl3wProcs+288

; 735  :     if ((GLboolean)status == GL_FALSE)

	cmp	BYTE PTR status$[rsp], dil
	jne	SHORT $LN2@CheckProgr

; 736  :         fprintf(stderr, "ERROR: ImGui_ImplOpenGL3_CreateDeviceObjects: failed to link %s! With GLSL %s\n", desc, bd->GlslVersionString);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	r9, QWORD PTR [rbx+4]
	lea	r8, OFFSET FLAT:??_C@_0P@HEBBPOKI@shader?5program@
	lea	rdx, OFFSET FLAT:??_C@_0EP@EPOJCDAM@ERROR?3?5ImGui_ImplOpenGL3_Create@
	call	fprintf
$LN2@CheckProgr:

; 737  :     if (log_length > 1)

	mov	edx, DWORD PTR log_length$[rsp]
	cmp	edx, 1
	jle	$LN40@CheckProgr
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR buf$1[rsp], rdi
	mov	QWORD PTR buf$1[rsp+8], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 740  :         buf.resize((int)(log_length + 1));

	lea	esi, DWORD PTR [rdx+1]
	test	esi, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	jle	SHORT $LN19@CheckProgr

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	ebx, esi
	mov	eax, 8
	cmp	esi, eax
	cmovl	ebx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	test	ebx, ebx

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	jle	SHORT $LN19@CheckProgr
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN24@CheckProgr

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN24@CheckProgr:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rcx, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
	mov	QWORD PTR buf$1[rsp+8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR buf$1[rsp+4], ebx
	mov	edx, DWORD PTR log_length$[rsp]
$LN19@CheckProgr:

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR buf$1[rsp], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 741  :         glGetProgramInfoLog(handle, log_length, nullptr, (GLchar*)buf.begin());

	mov	r9, rdi
	xor	r8d, r8d
	mov	ecx, ebp
	call	QWORD PTR imgl3wProcs+280

; 742  :         fprintf(stderr, "%s\n", buf.begin());

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6@
	mov	rcx, rax
	call	fprintf
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	test	rdi, rdi
	je	SHORT $LN46@CheckProgr
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN44@CheckProgr

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN44@CheckProgr:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
	npad	1
$LN46@CheckProgr:
$LN40@CheckProgr:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 744  :     return (GLboolean)status == GL_TRUE;

	cmp	BYTE PTR status$[rsp], 1
	sete	al

; 745  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?CheckProgram@@YA_NIPEBD@Z ENDP				; CheckProgram
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
buf$1 = 32
log_length$ = 48
status$ = 52
__$ArrayPad$ = 56
handle$ = 80
desc$dead$ = 88
?dtor$0@?0??CheckProgram@@YA_NIPEBD@Z@4HA PROC		; `CheckProgram'::`1'::dtor$0
	lea	rcx, QWORD PTR buf$1[rdx]
	jmp	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
?dtor$0@?0??CheckProgram@@YA_NIPEBD@Z@4HA ENDP		; `CheckProgram'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ
_TEXT	SEGMENT
pixels$1 = 80
buf$2 = 80
width$3 = 96
log_length$4 = 96
height$5 = 100
status$6 = 100
glsl_version$ = 104
last_texture$7 = 108
last_texture$ = 112
last_array_buffer$ = 116
last_vertex_array$ = 120
vertex_shader_with_version$ = 128
fragment_shader_with_version$ = 144
__$ArrayPad$ = 160
?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ PROC	; ImGui_ImplOpenGL3_CreateDeviceObjects, COMDAT

; 748  : {

$LN70:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 176				; 000000b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-121], rax

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	xor	r14d, r14d
	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rsi, rsi
	je	SHORT $LN11@ImGui_Impl
	mov	rsi, QWORD PTR [rsi+160]
	jmp	SHORT $LN12@ImGui_Impl
$LN11@ImGui_Impl:
	mov	rsi, r14
$LN12@ImGui_Impl:

; 749  :     ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
; 750  : 
; 751  :     // Backup GL state
; 752  :     GLint last_texture, last_array_buffer;
; 753  :     glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);

	lea	rdx, QWORD PTR last_texture$[rbp-121]
	mov	ecx, 32873				; 00008069H
	call	QWORD PTR imgl3wProcs+272

; 754  :     glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);

	lea	rdx, QWORD PTR last_array_buffer$[rbp-121]
	mov	ecx, 34964				; 00008894H
	call	QWORD PTR imgl3wProcs+272

; 755  : #ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
; 756  :     GLint last_vertex_array;
; 757  :     glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);

	lea	rdx, QWORD PTR last_vertex_array$[rbp-121]
	mov	ecx, 34229				; 000085b5H
	call	QWORD PTR imgl3wProcs+272

; 758  : #endif
; 759  : 
; 760  :     // Parse GLSL version string
; 761  :     int glsl_version = 130;

	mov	DWORD PTR glsl_version$[rbp-121], 130	; 00000082H

; 762  :     sscanf(bd->GlslVersionString, "#version %d", &glsl_version);

	lea	rdi, QWORD PTR [rsi+4]
	lea	r8, QWORD PTR glsl_version$[rbp-121]
	lea	rdx, OFFSET FLAT:??_C@_0M@GIPNOCDP@?$CDversion?5?$CFd@
	mov	rcx, rdi
	call	sscanf

; 763  : 
; 764  :     const GLchar* vertex_shader_glsl_120 =
; 765  :         "uniform mat4 ProjMtx;\n"
; 766  :         "attribute vec2 Position;\n"
; 767  :         "attribute vec2 UV;\n"
; 768  :         "attribute vec4 Color;\n"
; 769  :         "varying vec2 Frag_UV;\n"
; 770  :         "varying vec4 Frag_Color;\n"
; 771  :         "void main()\n"
; 772  :         "{\n"
; 773  :         "    Frag_UV = UV;\n"
; 774  :         "    Frag_Color = Color;\n"
; 775  :         "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
; 776  :         "}\n";
; 777  : 
; 778  :     const GLchar* vertex_shader_glsl_130 =
; 779  :         "uniform mat4 ProjMtx;\n"
; 780  :         "in vec2 Position;\n"
; 781  :         "in vec2 UV;\n"
; 782  :         "in vec4 Color;\n"
; 783  :         "out vec2 Frag_UV;\n"
; 784  :         "out vec4 Frag_Color;\n"
; 785  :         "void main()\n"
; 786  :         "{\n"
; 787  :         "    Frag_UV = UV;\n"
; 788  :         "    Frag_Color = Color;\n"
; 789  :         "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
; 790  :         "}\n";
; 791  : 
; 792  :     const GLchar* vertex_shader_glsl_300_es =
; 793  :         "precision highp float;\n"
; 794  :         "layout (location = 0) in vec2 Position;\n"
; 795  :         "layout (location = 1) in vec2 UV;\n"
; 796  :         "layout (location = 2) in vec4 Color;\n"
; 797  :         "uniform mat4 ProjMtx;\n"
; 798  :         "out vec2 Frag_UV;\n"
; 799  :         "out vec4 Frag_Color;\n"
; 800  :         "void main()\n"
; 801  :         "{\n"
; 802  :         "    Frag_UV = UV;\n"
; 803  :         "    Frag_Color = Color;\n"
; 804  :         "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
; 805  :         "}\n";
; 806  : 
; 807  :     const GLchar* vertex_shader_glsl_410_core =
; 808  :         "layout (location = 0) in vec2 Position;\n"
; 809  :         "layout (location = 1) in vec2 UV;\n"
; 810  :         "layout (location = 2) in vec4 Color;\n"
; 811  :         "uniform mat4 ProjMtx;\n"
; 812  :         "out vec2 Frag_UV;\n"
; 813  :         "out vec4 Frag_Color;\n"
; 814  :         "void main()\n"
; 815  :         "{\n"
; 816  :         "    Frag_UV = UV;\n"
; 817  :         "    Frag_Color = Color;\n"
; 818  :         "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
; 819  :         "}\n";
; 820  : 
; 821  :     const GLchar* fragment_shader_glsl_120 =
; 822  :         "#ifdef GL_ES\n"
; 823  :         "    precision mediump float;\n"
; 824  :         "#endif\n"
; 825  :         "uniform sampler2D Texture;\n"
; 826  :         "varying vec2 Frag_UV;\n"
; 827  :         "varying vec4 Frag_Color;\n"
; 828  :         "void main()\n"
; 829  :         "{\n"
; 830  :         "    gl_FragColor = Frag_Color * texture2D(Texture, Frag_UV.st);\n"
; 831  :         "}\n";
; 832  : 
; 833  :     const GLchar* fragment_shader_glsl_130 =
; 834  :         "uniform sampler2D Texture;\n"
; 835  :         "in vec2 Frag_UV;\n"
; 836  :         "in vec4 Frag_Color;\n"
; 837  :         "out vec4 Out_Color;\n"
; 838  :         "void main()\n"
; 839  :         "{\n"
; 840  :         "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
; 841  :         "}\n";
; 842  : 
; 843  :     const GLchar* fragment_shader_glsl_300_es =
; 844  :         "precision mediump float;\n"
; 845  :         "uniform sampler2D Texture;\n"
; 846  :         "in vec2 Frag_UV;\n"
; 847  :         "in vec4 Frag_Color;\n"
; 848  :         "layout (location = 0) out vec4 Out_Color;\n"
; 849  :         "void main()\n"
; 850  :         "{\n"
; 851  :         "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
; 852  :         "}\n";
; 853  : 
; 854  :     const GLchar* fragment_shader_glsl_410_core =
; 855  :         "in vec2 Frag_UV;\n"
; 856  :         "in vec4 Frag_Color;\n"
; 857  :         "uniform sampler2D Texture;\n"
; 858  :         "layout (location = 0) out vec4 Out_Color;\n"
; 859  :         "void main()\n"
; 860  :         "{\n"
; 861  :         "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
; 862  :         "}\n";
; 863  : 
; 864  :     // Select shaders matching our GLSL versions
; 865  :     const GLchar* vertex_shader = nullptr;
; 866  :     const GLchar* fragment_shader = nullptr;
; 867  :     if (glsl_version < 130)

	mov	eax, DWORD PTR glsl_version$[rbp-121]
	cmp	eax, 130				; 00000082H
	jge	SHORT $LN2@ImGui_Impl

; 868  :     {
; 869  :         vertex_shader = vertex_shader_glsl_120;

	lea	rax, OFFSET FLAT:??_C@_0PF@HLCKEEPJ@uniform?5mat4?5ProjMtx?$DL?6attribute@

; 870  :         fragment_shader = fragment_shader_glsl_120;

	lea	rbx, OFFSET FLAT:??_C@_0MM@DPJDGIBF@?$CDifdef?5GL_ES?6?5?5?5?5precision?5medi@

; 871  :     }

	jmp	SHORT $LN7@ImGui_Impl
$LN2@ImGui_Impl:

; 872  :     else if (glsl_version >= 410)

	cmp	eax, 410				; 0000019aH
	jl	SHORT $LN4@ImGui_Impl

; 873  :     {
; 874  :         vertex_shader = vertex_shader_glsl_410_core;

	lea	rax, OFFSET FLAT:??_C@_0BBK@IIAKMGPG@layout?5?$CIlocation?5?$DN?50?$CJ?5in?5vec2?5P@

; 875  :         fragment_shader = fragment_shader_glsl_410_core;

	lea	rbx, OFFSET FLAT:??_C@_0LG@KGGNFOLP@in?5vec2?5Frag_UV?$DL?6in?5vec4?5Frag_C@

; 876  :     }

	jmp	SHORT $LN7@ImGui_Impl
$LN4@ImGui_Impl:

; 877  :     else if (glsl_version == 300)

	cmp	eax, 300				; 0000012cH
	jne	SHORT $LN6@ImGui_Impl

; 878  :     {
; 879  :         vertex_shader = vertex_shader_glsl_300_es;

	lea	rax, OFFSET FLAT:??_C@_0BDB@OGMOMKDH@precision?5highp?5float?$DL?6layout?5?$CI@

; 880  :         fragment_shader = fragment_shader_glsl_300_es;

	lea	rbx, OFFSET FLAT:??_C@_0MP@NIPCIBOH@precision?5mediump?5float?$DL?6unifor@

; 881  :     }

	jmp	SHORT $LN7@ImGui_Impl
$LN6@ImGui_Impl:

; 882  :     else
; 883  :     {
; 884  :         vertex_shader = vertex_shader_glsl_130;

	lea	rax, OFFSET FLAT:??_C@_0NI@FNJCCLKC@uniform?5mat4?5ProjMtx?$DL?6in?5vec2?5P@

; 885  :         fragment_shader = fragment_shader_glsl_130;

	lea	rbx, OFFSET FLAT:??_C@_0KA@HKFHPDID@uniform?5sampler2D?5Texture?$DL?6in?5v@
$LN7@ImGui_Impl:

; 886  :     }
; 887  : 
; 888  :     // Create shaders
; 889  :     const GLchar* vertex_shader_with_version[2] = { bd->GlslVersionString, vertex_shader };

	mov	QWORD PTR vertex_shader_with_version$[rbp-121], rdi
	mov	QWORD PTR vertex_shader_with_version$[rbp-113], rax

; 890  :     GLuint vert_handle = glCreateShader(GL_VERTEX_SHADER);

	mov	rax, QWORD PTR imgl3wProcs+120
	mov	ecx, 35633				; 00008b31H
	call	rax
	mov	r12d, eax

; 891  :     glShaderSource(vert_handle, 2, vertex_shader_with_version, nullptr);

	xor	r9d, r9d
	lea	r8, QWORD PTR vertex_shader_with_version$[rbp-121]
	lea	edx, QWORD PTR [r9+2]
	mov	ecx, eax
	call	QWORD PTR imgl3wProcs+408

; 892  :     glCompileShader(vert_handle);

	mov	ecx, r12d
	call	QWORD PTR imgl3wProcs+104

; 893  :     CheckShader(vert_handle, "vertex shader");

	lea	rdx, OFFSET FLAT:??_C@_0O@FGFIIOKE@vertex?5shader@
	mov	ecx, r12d
	call	?CheckShader@@YA_NIPEBD@Z		; CheckShader

; 894  : 
; 895  :     const GLchar* fragment_shader_with_version[2] = { bd->GlslVersionString, fragment_shader };

	mov	QWORD PTR fragment_shader_with_version$[rbp-121], rdi
	mov	QWORD PTR fragment_shader_with_version$[rbp-113], rbx

; 896  :     GLuint frag_handle = glCreateShader(GL_FRAGMENT_SHADER);

	mov	rdx, QWORD PTR imgl3wProcs+120
	mov	ecx, 35632				; 00008b30H
	call	rdx
	mov	r13d, eax

; 897  :     glShaderSource(frag_handle, 2, fragment_shader_with_version, nullptr);

	xor	r9d, r9d
	lea	r8, QWORD PTR fragment_shader_with_version$[rbp-121]
	lea	edx, QWORD PTR [r9+2]
	mov	ecx, eax
	call	QWORD PTR imgl3wProcs+408

; 898  :     glCompileShader(frag_handle);

	mov	ecx, r13d
	call	QWORD PTR imgl3wProcs+104

; 899  :     CheckShader(frag_handle, "fragment shader");

	lea	rdx, OFFSET FLAT:??_C@_0BA@MDFBHBOK@fragment?5shader@
	mov	ecx, r13d
	call	?CheckShader@@YA_NIPEBD@Z		; CheckShader

; 900  : 
; 901  :     // Link
; 902  :     bd->ShaderHandle = glCreateProgram();

	call	QWORD PTR imgl3wProcs+112
	mov	DWORD PTR [rsi+48], eax

; 903  :     glAttachShader(bd->ShaderHandle, vert_handle);

	mov	edx, r12d
	mov	ecx, eax
	call	QWORD PTR imgl3wProcs+8

; 904  :     glAttachShader(bd->ShaderHandle, frag_handle);

	mov	edx, r13d
	mov	ecx, DWORD PTR [rsi+48]
	call	QWORD PTR imgl3wProcs+8

; 905  :     glLinkProgram(bd->ShaderHandle);

	mov	ecx, DWORD PTR [rsi+48]
	call	QWORD PTR imgl3wProcs+368

; 906  :     CheckProgram(bd->ShaderHandle, "shader program");

	mov	r15d, DWORD PTR [rsi+48]

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rbx, rbx
	je	SHORT $LN20@ImGui_Impl
	mov	rbx, QWORD PTR [rbx+160]
	jmp	SHORT $LN21@ImGui_Impl
$LN20@ImGui_Impl:
	mov	rbx, r14
$LN21@ImGui_Impl:

; 732  :     GLint status = 0, log_length = 0;

	mov	DWORD PTR status$6[rbp-121], r14d
	mov	DWORD PTR log_length$4[rbp-121], r14d

; 733  :     glGetProgramiv(handle, GL_LINK_STATUS, &status);

	lea	r8, QWORD PTR status$6[rbp-121]
	mov	edx, 35714				; 00008b82H
	mov	ecx, r15d
	call	QWORD PTR imgl3wProcs+288

; 734  :     glGetProgramiv(handle, GL_INFO_LOG_LENGTH, &log_length);

	lea	r8, QWORD PTR log_length$4[rbp-121]
	mov	edx, 35716				; 00008b84H
	mov	ecx, r15d
	call	QWORD PTR imgl3wProcs+288

; 735  :     if ((GLboolean)status == GL_FALSE)

	cmp	BYTE PTR status$6[rbp-121], r14b
	jne	SHORT $LN14@ImGui_Impl

; 736  :         fprintf(stderr, "ERROR: ImGui_ImplOpenGL3_CreateDeviceObjects: failed to link %s! With GLSL %s\n", desc, bd->GlslVersionString);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	r9, QWORD PTR [rbx+4]
	lea	r8, OFFSET FLAT:??_C@_0P@HEBBPOKI@shader?5program@
	lea	rdx, OFFSET FLAT:??_C@_0EP@EPOJCDAM@ERROR?3?5ImGui_ImplOpenGL3_Create@
	call	fprintf
$LN14@ImGui_Impl:

; 737  :     if (log_length > 1)

	mov	edx, DWORD PTR log_length$4[rbp-121]
	cmp	edx, 1
	jle	$LN52@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	mov	QWORD PTR buf$2[rbp-121], r14
	mov	rbx, r14
	mov	QWORD PTR buf$2[rbp-113], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 740  :         buf.resize((int)(log_length + 1));

	lea	r14d, DWORD PTR [rdx+1]
	test	r14d, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	jle	SHORT $LN31@ImGui_Impl

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	edi, r14d
	mov	eax, 8
	cmp	r14d, eax
	cmovl	edi, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	test	edi, edi

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	jle	SHORT $LN31@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN36@ImGui_Impl

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN36@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rcx, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
	mov	QWORD PTR buf$2[rbp-113], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR buf$2[rbp-117], edi
	mov	edx, DWORD PTR log_length$4[rbp-121]
$LN31@ImGui_Impl:

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR buf$2[rbp-121], r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 741  :         glGetProgramInfoLog(handle, log_length, nullptr, (GLchar*)buf.begin());

	mov	r9, rbx
	xor	r8d, r8d
	mov	ecx, r15d
	call	QWORD PTR imgl3wProcs+280

; 742  :         fprintf(stderr, "%s\n", buf.begin());

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8, rbx
	lea	rdx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6@
	mov	rcx, rax
	call	fprintf
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	test	rbx, rbx
	je	SHORT $LN58@ImGui_Impl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN56@ImGui_Impl

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN56@ImGui_Impl:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rbx
	call	QWORD PTR __imp_free
	npad	1
$LN58@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	xor	r14d, r14d
$LN52@ImGui_Impl:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp

; 908  :     glDetachShader(bd->ShaderHandle, vert_handle);

	mov	edx, r12d
	mov	ecx, DWORD PTR [rsi+48]
	call	QWORD PTR imgl3wProcs+168

; 909  :     glDetachShader(bd->ShaderHandle, frag_handle);

	mov	edx, r13d
	mov	ecx, DWORD PTR [rsi+48]
	call	QWORD PTR imgl3wProcs+168

; 910  :     glDeleteShader(vert_handle);

	mov	ecx, r12d
	call	QWORD PTR imgl3wProcs+144

; 911  :     glDeleteShader(frag_handle);

	mov	ecx, r13d
	call	QWORD PTR imgl3wProcs+144

; 912  : 
; 913  :     bd->AttribLocationTex = glGetUniformLocation(bd->ShaderHandle, "Texture");

	mov	rax, QWORD PTR imgl3wProcs+328
	lea	rdx, OFFSET FLAT:??_C@_07GKACAEDJ@Texture@
	mov	ecx, DWORD PTR [rsi+48]
	call	rax
	mov	DWORD PTR [rsi+52], eax

; 914  :     bd->AttribLocationProjMtx = glGetUniformLocation(bd->ShaderHandle, "ProjMtx");

	mov	rax, QWORD PTR imgl3wProcs+328
	lea	rdx, OFFSET FLAT:??_C@_07EDEMHDKD@ProjMtx@
	mov	ecx, DWORD PTR [rsi+48]
	call	rax
	mov	DWORD PTR [rsi+56], eax

; 915  :     bd->AttribLocationVtxPos = (GLuint)glGetAttribLocation(bd->ShaderHandle, "Position");

	mov	rax, QWORD PTR imgl3wProcs+256
	lea	rdx, OFFSET FLAT:??_C@_08GCJNLIKG@Position@
	mov	ecx, DWORD PTR [rsi+48]
	call	rax
	mov	DWORD PTR [rsi+60], eax

; 916  :     bd->AttribLocationVtxUV = (GLuint)glGetAttribLocation(bd->ShaderHandle, "UV");

	mov	rax, QWORD PTR imgl3wProcs+256
	lea	rdx, OFFSET FLAT:??_C@_02IGCIDAGE@UV@
	mov	ecx, DWORD PTR [rsi+48]
	call	rax
	mov	DWORD PTR [rsi+64], eax

; 917  :     bd->AttribLocationVtxColor = (GLuint)glGetAttribLocation(bd->ShaderHandle, "Color");

	mov	rax, QWORD PTR imgl3wProcs+256
	lea	rdx, OFFSET FLAT:??_C@_05PDOBBJNA@Color@
	mov	ecx, DWORD PTR [rsi+48]
	call	rax
	mov	DWORD PTR [rsi+68], eax

; 918  : 
; 919  :     // Create buffers
; 920  :     glGenBuffers(1, &bd->VboHandle);

	lea	rdx, QWORD PTR [rsi+72]
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+232

; 921  :     glGenBuffers(1, &bd->ElementsHandle);

	lea	rdx, QWORD PTR [rsi+76]
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+232

; 667  :     ImGuiIO& io = ImGui::GetIO();

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	test	rdi, rdi
	je	SHORT $LN66@ImGui_Impl
	mov	rbx, QWORD PTR [rdi+160]
	jmp	SHORT $LN67@ImGui_Impl
$LN66@ImGui_Impl:
	mov	rbx, r14
$LN67@ImGui_Impl:

; 673  :     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   // Load as RGBA 32-bit (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.

	lea	r9, QWORD PTR height$5[rbp-121]
	lea	r8, QWORD PTR width$3[rbp-121]
	lea	rdx, QWORD PTR pixels$1[rbp-121]
	mov	rcx, QWORD PTR [rdi+56]
	call	?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32

; 674  : 
; 675  :     // Upload texture to graphics system
; 676  :     // (Bilinear sampling is required by default. Set 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines' or 'style.AntiAliasedLinesUseTex = false' to allow point/nearest sampling)
; 677  :     GLint last_texture;
; 678  :     GL_CALL(glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture));

	lea	rdx, QWORD PTR last_texture$7[rbp-121]
	mov	ecx, 32873				; 00008069H
	call	QWORD PTR imgl3wProcs+272

; 679  :     GL_CALL(glGenTextures(1, &bd->FontTexture));

	lea	rdx, QWORD PTR [rbx+44]
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+240

; 680  :     GL_CALL(glBindTexture(GL_TEXTURE_2D, bd->FontTexture));

	mov	edx, DWORD PTR [rbx+44]
	mov	ecx, 3553				; 00000de1H
	call	QWORD PTR imgl3wProcs+32

; 681  :     GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));

	mov	edx, 10241				; 00002801H
	mov	ecx, 3553				; 00000de1H
	mov	r8d, 9729				; 00002601H
	call	QWORD PTR imgl3wProcs+424

; 682  :     GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));

	mov	edx, 10240				; 00002800H
	mov	ecx, 3553				; 00000de1H
	mov	r8d, 9729				; 00002601H
	call	QWORD PTR imgl3wProcs+424

; 683  : #ifdef GL_UNPACK_ROW_LENGTH // Not on WebGL/ES
; 684  :     GL_CALL(glPixelStorei(GL_UNPACK_ROW_LENGTH, 0));

	xor	edx, edx
	mov	ecx, 3314				; 00000cf2H
	call	QWORD PTR imgl3wProcs+376

; 685  : #endif
; 686  :     GL_CALL(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels));

	mov	rax, QWORD PTR pixels$1[rbp-121]
	mov	QWORD PTR [rsp+64], rax
	mov	DWORD PTR [rsp+56], 5121		; 00001401H
	mov	DWORD PTR [rsp+48], 6408		; 00001908H
	mov	DWORD PTR [rsp+40], r14d
	mov	eax, DWORD PTR height$5[rbp-121]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR width$3[rbp-121]
	xor	edx, edx
	mov	ecx, 3553				; 00000de1H
	mov	r8d, 6408				; 00001908H
	call	QWORD PTR imgl3wProcs+416

; 687  : 
; 688  :     // Store our identifier
; 689  :     io.Fonts->SetTexID((ImTextureID)(intptr_t)bd->FontTexture);

	mov	edx, DWORD PTR [rbx+44]
	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rax+8], rdx

; 690  : 
; 691  :     // Restore state
; 692  :     GL_CALL(glBindTexture(GL_TEXTURE_2D, last_texture));

	mov	edx, DWORD PTR last_texture$7[rbp-121]
	mov	ecx, 3553				; 00000de1H
	call	QWORD PTR imgl3wProcs+32

; 922  : 
; 923  :     ImGui_ImplOpenGL3_CreateFontsTexture();
; 924  : 
; 925  :     // Restore modified GL state
; 926  :     glBindTexture(GL_TEXTURE_2D, last_texture);

	mov	edx, DWORD PTR last_texture$[rbp-121]
	mov	ecx, 3553				; 00000de1H
	call	QWORD PTR imgl3wProcs+32

; 927  :     glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);

	mov	edx, DWORD PTR last_array_buffer$[rbp-121]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR imgl3wProcs+16

; 928  : #ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
; 929  :     glBindVertexArray(last_vertex_array);

	mov	ecx, DWORD PTR last_vertex_array$[rbp-121]
	call	QWORD PTR imgl3wProcs+40

; 930  : #endif
; 931  : 
; 932  :     return true;

	mov	al, 1

; 933  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-121]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ ENDP	; ImGui_ImplOpenGL3_CreateDeviceObjects
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
pixels$1 = 80
buf$2 = 80
width$3 = 96
log_length$4 = 96
height$5 = 100
status$6 = 100
glsl_version$ = 104
last_texture$7 = 108
last_texture$ = 112
last_array_buffer$ = 116
last_vertex_array$ = 120
vertex_shader_with_version$ = 128
fragment_shader_with_version$ = 144
__$ArrayPad$ = 160
?dtor$0@?0??ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ@4HA PROC ; `ImGui_ImplOpenGL3_CreateDeviceObjects'::`1'::dtor$0
	lea	rcx, QWORD PTR buf$2[rdx]
	jmp	??1?$ImVector@D@@QEAA@XZ		; ImVector<char>::~ImVector<char>
?dtor$0@?0??ImGui_ImplOpenGL3_CreateDeviceObjects@@YA_NXZ@4HA ENDP ; `ImGui_ImplOpenGL3_CreateDeviceObjects'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_DestroyDeviceObjects@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplOpenGL3_DestroyDeviceObjects@@YAXXZ PROC	; ImGui_ImplOpenGL3_DestroyDeviceObjects, COMDAT

; 936  : {

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xor	ebp, ebp
	test	rbx, rbx
	je	SHORT $LN8@ImGui_Impl
	mov	rdi, QWORD PTR [rbx+160]
	jmp	SHORT $LN9@ImGui_Impl
$LN8@ImGui_Impl:
	mov	rdi, rbp
$LN9@ImGui_Impl:

; 937  :     ImGui_ImplOpenGL3_Data* bd = ImGui_ImplOpenGL3_GetBackendData();
; 938  :     if (bd->VboHandle)      { glDeleteBuffers(1, &bd->VboHandle); bd->VboHandle = 0; }

	cmp	DWORD PTR [rdi+72], ebp
	je	SHORT $LN2@ImGui_Impl
	lea	rdx, QWORD PTR [rdi+72]
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+128
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	DWORD PTR [rdi+72], ebp
$LN2@ImGui_Impl:

; 939  :     if (bd->ElementsHandle) { glDeleteBuffers(1, &bd->ElementsHandle); bd->ElementsHandle = 0; }

	cmp	DWORD PTR [rdi+76], ebp
	je	SHORT $LN3@ImGui_Impl
	lea	rdx, QWORD PTR [rdi+76]
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+128
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	DWORD PTR [rdi+76], ebp
$LN3@ImGui_Impl:

; 940  :     if (bd->ShaderHandle)   { glDeleteProgram(bd->ShaderHandle); bd->ShaderHandle = 0; }

	mov	ecx, DWORD PTR [rdi+48]
	test	ecx, ecx
	je	SHORT $LN4@ImGui_Impl
	call	QWORD PTR imgl3wProcs+136
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	DWORD PTR [rdi+48], ebp
$LN4@ImGui_Impl:

; 238  :     return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;

	test	rbx, rbx
	je	SHORT $LN15@ImGui_Impl
	mov	rax, QWORD PTR [rbx+160]
	jmp	SHORT $LN16@ImGui_Impl
$LN15@ImGui_Impl:
	mov	rax, rbp
$LN16@ImGui_Impl:

; 701  :     if (bd->FontTexture)

	cmp	DWORD PTR [rax+44], ebp
	lea	rdi, QWORD PTR [rax+44]
	je	SHORT $LN11@ImGui_Impl

; 702  :     {
; 703  :         glDeleteTextures(1, &bd->FontTexture);

	mov	rdx, rdi
	mov	ecx, 1
	call	QWORD PTR imgl3wProcs+152

; 704  :         io.Fonts->SetTexID(0);

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax+8], rbp

; 705  :         bd->FontTexture = 0;

	mov	DWORD PTR [rdi], ebp
$LN11@ImGui_Impl:

; 941  :     ImGui_ImplOpenGL3_DestroyFontsTexture();
; 942  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?ImGui_ImplOpenGL3_DestroyDeviceObjects@@YAXXZ ENDP	; ImGui_ImplOpenGL3_DestroyDeviceObjects
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z
_TEXT	SEGMENT
viewport$ = 48
__formal$ = 56
?ImGui_ImplOpenGL3_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z PROC ; ImGui_ImplOpenGL3_RenderWindow, COMDAT

; 951  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 952  :     if (!(viewport->Flags & ImGuiViewportFlags_NoRendererClear))

	test	DWORD PTR [rcx+4], 256			; 00000100H
	mov	rbx, rcx
	jne	SHORT $LN2@ImGui_Impl

; 953  :     {
; 954  :         ImVec4 clear_color = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);
; 955  :         glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w);

	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	xorps	xmm0, xmm0
	call	QWORD PTR imgl3wProcs+96

; 956  :         glClear(GL_COLOR_BUFFER_BIT);

	mov	ecx, 16384				; 00004000H
	call	QWORD PTR imgl3wProcs+88
$LN2@ImGui_Impl:

; 957  :     }
; 958  :     ImGui_ImplOpenGL3_RenderDrawData(viewport->DrawData);

	mov	rcx, QWORD PTR [rbx+48]

; 959  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 957  :     }
; 958  :     ImGui_ImplOpenGL3_RenderDrawData(viewport->DrawData);

	jmp	?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z ; ImGui_ImplOpenGL3_RenderDrawData
?ImGui_ImplOpenGL3_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z ENDP ; ImGui_ImplOpenGL3_RenderWindow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_InitPlatformInterface@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplOpenGL3_InitPlatformInterface@@YAXXZ PROC	; ImGui_ImplOpenGL3_InitPlatformInterface, COMDAT

; 963  :     ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
; 964  :     platform_io.Renderer_RenderWindow = ImGui_ImplOpenGL3_RenderWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	lea	rcx, OFFSET FLAT:?ImGui_ImplOpenGL3_RenderWindow@@YAXPEAUImGuiViewport@@PEAX@Z ; ImGui_ImplOpenGL3_RenderWindow
	mov	QWORD PTR [rax+14504], rcx

; 965  : }

	ret	0
?ImGui_ImplOpenGL3_InitPlatformInterface@@YAXXZ ENDP	; ImGui_ImplOpenGL3_InitPlatformInterface
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_impl_opengl3.cpp
;	COMDAT ?ImGui_ImplOpenGL3_ShutdownPlatformInterface@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplOpenGL3_ShutdownPlatformInterface@@YAXXZ PROC ; ImGui_ImplOpenGL3_ShutdownPlatformInterface, COMDAT

; 969  :     ImGui::DestroyPlatformWindows();

	jmp	?DestroyPlatformWindows@ImGui@@YAXXZ	; ImGui::DestroyPlatformWindows
?ImGui_ImplOpenGL3_ShutdownPlatformInterface@@YAXXZ ENDP ; ImGui_ImplOpenGL3_ShutdownPlatformInterface
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawCmd@@@@QEBAAEBUImDrawCmd@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImDrawCmd@@@@QEBAAEBUImDrawCmd@@H@Z PROC	; ImVector<ImDrawCmd>::operator[], COMDAT

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	imul	rax, rax, 56				; 00000038H
	add	rax, QWORD PTR [rcx+8]
	ret	0
??A?$ImVector@UImDrawCmd@@@@QEBAAEBUImDrawCmd@@H@Z ENDP	; ImVector<ImDrawCmd>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??$IM_DELETE@UImGui_ImplOpenGL3_Data@@@@YAXPEAUImGui_ImplOpenGL3_Data@@@Z
_TEXT	SEGMENT
p$ = 8
??$IM_DELETE@UImGui_ImplOpenGL3_Data@@@@YAXPEAUImGui_ImplOpenGL3_Data@@@Z PROC ; IM_DELETE<ImGui_ImplOpenGL3_Data>, COMDAT

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	test	rcx, rcx
	je	SHORT $LN8@IM_DELETE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN6@IM_DELETE

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@IM_DELETE:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	rex_jmp	QWORD PTR __imp_free
$LN8@IM_DELETE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1876 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

	ret	0
??$IM_DELETE@UImGui_ImplOpenGL3_Data@@@@YAXPEAUImGui_ImplOpenGL3_Data@@@Z ENDP ; IM_DELETE<ImGui_ImplOpenGL3_Data>
_TEXT	ENDS
END
