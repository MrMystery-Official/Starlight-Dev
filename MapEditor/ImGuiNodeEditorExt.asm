; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z	; ImVector<ImVec2>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z		; ImVector<ImVec2>::reserve
PUBLIC	?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ; ImVector<ImVec2>::push_back
PUBLIC	?Icon@Widgets@ax@@YAXAEBUImVec2@@W4IconType@Drawing@2@_NAEBUImVec4@@3@Z ; ax::Widgets::Icon
PUBLIC	?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z ; ax::Drawing::DrawIcon
PUBLIC	??0ImRect@@QEAA@MMMM@Z				; ImRect::ImRect
PUBLIC	??0ImRect@@QEAA@AEBUImVec2@@0@Z			; ImRect::ImRect
PUBLIC	?PathStroke@ImDrawList@@QEAAXIHM@Z		; ImDrawList::PathStroke
PUBLIC	?PathFillConvex@ImDrawList@@QEAAXI@Z		; ImDrawList::PathFillConvex
PUBLIC	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z	; ImDrawList::PathLineTo
PUBLIC	??BImColor@@QEBAIXZ				; ImColor::operator unsigned int
PUBLIC	??0ImColor@@QEAA@AEBUImVec4@@@Z			; ImColor::ImColor
PUBLIC	??0ImVec2@@QEAA@MM@Z				; ImVec2::ImVec2
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+129
	DD	imagerel $chain$0$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD imagerel $LN26+129
	DD	imagerel $LN26+140
	DD	imagerel $chain$1$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z DD imagerel $LN11
	DD	imagerel $LN11+95
	DD	imagerel $unwind$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Icon@Widgets@ax@@YAXAEBUImVec2@@W4IconType@Drawing@2@_NAEBUImVec4@@3@Z DD imagerel $LN40
	DD	imagerel $LN40+327
	DD	imagerel $unwind$?Icon@Widgets@ax@@YAXAEBUImVec2@@W4IconType@Drawing@2@_NAEBUImVec4@@3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z DD imagerel $LN533
	DD	imagerel $LN533+1289
	DD	imagerel $unwind$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z DD imagerel $LN533+1289
	DD	imagerel $LN533+2496
	DD	imagerel $chain$1$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z DD imagerel $LN533+2496
	DD	imagerel $LN533+2662
	DD	imagerel $chain$3$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z DD imagerel $LN533+2662
	DD	imagerel $LN533+5056
	DD	imagerel $chain$4$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathStroke@ImDrawList@@QEAAXIHM@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$?PathStroke@ImDrawList@@QEAAXIHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathFillConvex@ImDrawList@@QEAAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$?PathFillConvex@ImDrawList@@QEAAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z DD imagerel $LN13
	DD	imagerel $LN13+97
	DD	imagerel $unwind$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathFillConvex@ImDrawList@@QEAAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PathStroke@ImDrawList@@QEAAXIHM@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z DD 021H
	DD	imagerel $LN533
	DD	imagerel $LN533+1289
	DD	imagerel $unwind$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z DD 020021H
	DD	031c400H
	DD	imagerel $LN533
	DD	imagerel $LN533+1289
	DD	imagerel $unwind$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z DD 045221H
	DD	032d452H
	DD	031c408H
	DD	imagerel $LN533
	DD	imagerel $LN533+1289
	DD	imagerel $unwind$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z DD 01d9c01H
	DD	0bf89cH
	DD	0ce878H
	DD	0dd870H
	DD	0ec865H
	DD	0fb85dH
	DD	010a847H
	DD	011983eH
	DD	0128835H
	DD	013782dH
	DD	0146829H
	DD	0333419H
	DD	02a0119H
	DD	0e00cf00eH
	DD	06009700aH
	DD	05008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Icon@Widgets@ax@@YAXAEBUImVec2@@W4IconType@Drawing@2@_NAEBUImVec4@@3@Z DD 041c19H
	DD	012340dH
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0ImVec2@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
??0ImVec2@@QEAA@MM@Z PROC				; ImVec2::ImVec2, COMDAT

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm1
	mov	rax, rcx
	movss	DWORD PTR [rcx+4], xmm2
	ret	0
??0ImVec2@@QEAA@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??D@YA?AUImVec2@@AEBU0@M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??D@YA?AUImVec2@@AEBU0@M@Z PROC				; operator*, COMDAT

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm2
	mov	rax, rcx
	mulss	xmm0, DWORD PTR [rdx]
	mulss	xmm2, DWORD PTR [rdx+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm2

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	ret	0
??D@YA?AUImVec2@@AEBU0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??H@YA?AUImVec2@@AEBU0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??H@YA?AUImVec2@@AEBU0@0@Z PROC				; operator+, COMDAT

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	addss	xmm0, DWORD PTR [r8]
	addss	xmm1, DWORD PTR [r8+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	ret	0
??H@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??G@YA?AUImVec2@@AEBU0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??G@YA?AUImVec2@@AEBU0@0@Z PROC				; operator-, COMDAT

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	subss	xmm0, DWORD PTR [r8]
	subss	xmm1, DWORD PTR [r8+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	ret	0
??G@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0ImColor@@QEAA@AEBUImVec4@@@Z
_TEXT	SEGMENT
this$ = 8
col$ = 16
??0ImColor@@QEAA@AEBUImVec4@@@Z PROC			; ImColor::ImColor, COMDAT

; 2587 :     constexpr ImColor(const ImVec4& col)                            : Value(col) {}

	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
??0ImColor@@QEAA@AEBUImVec4@@@Z ENDP			; ImColor::ImColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??BImColor@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
??BImColor@@QEBAIXZ PROC				; ImColor::operator unsigned int, COMDAT

; 2590 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	jmp	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
??BImColor@@QEBAIXZ ENDP				; ImColor::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
this$ = 48
pos$ = 56
?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z PROC	; ImDrawList::PathLineTo, COMDAT

; 2805 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rcx+120]

; 2805 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	lea	rbx, QWORD PTR [rcx+120]

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rcx+124]

; 2805 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	mov	rdi, rdx

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r8d, ecx
	jne	SHORT $LN4@PathLineTo
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN8@PathLineTo
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN9@PathLineTo
$LN8@PathLineTo:
	mov	eax, 8
$LN9@PathLineTo:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN4@PathLineTo:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbx]

; 2805 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ENDP	; ImDrawList::PathLineTo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?PathFillConvex@ImDrawList@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 48
col$ = 56
?PathFillConvex@ImDrawList@@QEAAXI@Z PROC		; ImDrawList::PathFillConvex, COMDAT

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8d, DWORD PTR [rcx+120]
	mov	r9d, edx
	mov	rdx, QWORD PTR [rcx+128]
	mov	rbx, rcx
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rbx+120], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?PathFillConvex@ImDrawList@@QEAAXI@Z ENDP		; ImDrawList::PathFillConvex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?PathStroke@ImDrawList@@QEAAXIHM@Z
_TEXT	SEGMENT
this$ = 64
col$ = 72
flags$ = 80
thickness$ = 88
?PathStroke@ImDrawList@@QEAAXIHM@Z PROC			; ImDrawList::PathStroke, COMDAT

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H
	movss	DWORD PTR [rsp+40], xmm3
	mov	r9d, edx
	mov	rdx, QWORD PTR [rcx+128]
	mov	rbx, rcx
	mov	DWORD PTR [rsp+32], r8d
	mov	r8d, DWORD PTR [rcx+120]
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	mov	DWORD PTR [rbx+120], 0
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?PathStroke@ImDrawList@@QEAAXIHM@Z ENDP			; ImDrawList::PathStroke
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@AEBUImVec2@@0@Z
_TEXT	SEGMENT
this$ = 8
min$ = 16
max$ = 24
??0ImRect@@QEAA@AEBUImVec2@@0@Z PROC			; ImRect::ImRect, COMDAT

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movsd	xmm0, QWORD PTR [rdx]
	mov	rax, rcx
	movsd	QWORD PTR [rcx], xmm0
	movsd	xmm1, QWORD PTR [r8]
	movsd	QWORD PTR [rcx+8], xmm1
	ret	0
??0ImRect@@QEAA@AEBUImVec2@@0@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
x1$ = 16
y1$ = 24
x2$ = 32
y2$ = 40
??0ImRect@@QEAA@MMMM@Z PROC				; ImRect::ImRect, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR y2$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 525  :     constexpr ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)          {}

	mov	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx+12], xmm0
	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm2
	movss	DWORD PTR [rcx+8], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 525  :     constexpr ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)          {}

	ret	0
??0ImRect@@QEAA@MMMM@Z ENDP				; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
;	COMDAT ?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z
_TEXT	SEGMENT
$T9 = 96
$T10 = 96
$T11 = 96
$T12 = 96
$T13 = 96
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 96
p1$18 = 96
p1$19 = 96
br$20 = 96
p1$21 = 96
p1$22 = 96
c$23 = 96
$T24 = 96
$T25 = 96
$T26 = 96
tip_top$27 = 96
rect_center$ = 96
$T28 = 104
p0$29 = 104
p0$30 = 104
tl$31 = 104
p0$32 = 104
p0$33 = 104
$T34 = 104
$T35 = 104
$T36 = 104
tip_right$1$sroa$2749$1$ = 112
col_trans$1$ = 112
w$1$ = 112
vtx_inner_idx$1$ = 116
tv5469 = 116
tv5378 = 116
rect_h$1$ = 120
$T37 = 120
$T38 = 120
$T39 = 120
vtx_count$1$ = 128
tv5379 = 128
r$1$ = 136
tip_bottom$40 = 136
rect_center$2$ = 144
$T41 = 144
rect$ = 152
drawList$ = 384
a$ = 392
b$ = 400
type$ = 408
filled$ = 416
color$ = 424
innerColor$ = 432
?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z PROC ; ax::Drawing::DrawIcon, COMDAT

; 6    : {

$LN533:
	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-120]
	sub	rsp, 336				; 00000150H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movsd	xmm2, QWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 6    : {

	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movsd	xmm3, QWORD PTR [rdx]
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 10   :     auto rect_w = rect.Max.x - rect.Min.x;

	movaps	xmm7, xmm2
	movaps	XMMWORD PTR [rax-88], xmm8
	subss	xmm7, xmm3
	movaps	XMMWORD PTR [rax-104], xmm9

; 12   :     auto rect_center_x = (rect.Min.x + rect.Max.x) * 0.5f;

	movaps	xmm8, xmm2
	movaps	XMMWORD PTR [rax-120], xmm10
	addss	xmm8, xmm3
	movss	xmm10, DWORD PTR __real@3f000000
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12

; 13   :     auto rect_center_y = (rect.Min.y + rect.Max.y) * 0.5f;
; 14   :     auto rect_center = ImVec2(rect_center_x, rect_center_y);
; 15   :     const auto outline_scale = rect_w / 24.0f;

	movaps	xmm1, xmm7
	movaps	XMMWORD PTR [rax-168], xmm13
	movaps	XMMWORD PTR [rax-184], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movsd	QWORD PTR rect$[rbp-248], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 10   :     auto rect_w = rect.Max.x - rect.Min.x;

	movss	xmm4, DWORD PTR rect$[rbp-244]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movsd	QWORD PTR rect$[rbp-256], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 12   :     auto rect_center_x = (rect.Min.x + rect.Max.x) * 0.5f;

	movaps	xmm9, xmm4
	movss	xmm5, DWORD PTR rect$[rbp-252]
	movaps	xmm14, xmm4
	movaps	XMMWORD PTR [rax-200], xmm15
	addss	xmm9, xmm5
	mulss	xmm8, xmm10
	subss	xmm14, xmm5
	movss	DWORD PTR r$1$[rbp-256], xmm7

; 13   :     auto rect_center_y = (rect.Min.y + rect.Max.y) * 0.5f;
; 14   :     auto rect_center = ImVec2(rect_center_x, rect_center_y);
; 15   :     const auto outline_scale = rect_w / 24.0f;

	divss	xmm1, DWORD PTR __real@41c00000
	mulss	xmm9, xmm10
	movss	DWORD PTR rect_h$1$[rsp], xmm14

; 16   :     const auto extra_segments = static_cast<int>(2 * outline_scale); // for full circle

	movaps	xmm11, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR rect_center$[rsp], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 16   :     const auto extra_segments = static_cast<int>(2 * outline_scale); // for full circle

	addss	xmm11, xmm1
	movss	DWORD PTR rect_center$2$[rbp-256], xmm9
	cvttss2si esi, xmm11

; 17   : 
; 18   :     if (type == IconType::Flow) {

	test	r9d, r9d
	jne	$LN5@DrawIcon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rcx+124]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 27   :         const auto canvas = ImRect(

	subss	xmm4, xmm11
	movaps	xmm0, xmm1
	subss	xmm2, xmm11
	movaps	xmm7, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2805 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	lea	r14, QWORD PTR [rcx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 24   :         const auto rounding = 0.1f * origin_scale;

	mulss	xmm7, DWORD PTR __real@3dcccccd
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	esi, QWORD PTR [r9+8]
	mov	ecx, DWORD PTR [r14]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm8, xmm11
	xorps	xmm6, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 22   :         const auto offset_y = 0.0f * origin_scale;

	mulss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm8, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 24   :         const auto rounding = 0.1f * origin_scale;

	movss	DWORD PTR tv5469[rsp], xmm7

; 27   :         const auto canvas = ImRect(

	addss	xmm2, xmm1
	movaps	xmm15, xmm11
	addss	xmm4, xmm0
	addss	xmm8, xmm0
	addss	xmm15, xmm3

; 28   :             rect.Min.x + margin + offset_x,
; 29   :             rect.Min.y + margin + offset_y,
; 30   :             rect.Max.x - margin + offset_x,
; 31   :             rect.Max.y - margin + offset_y);
; 32   :         const auto canvas_x = canvas.Min.x;
; 33   :         const auto canvas_y = canvas.Min.y;
; 34   :         const auto canvas_w = canvas.Max.x - canvas.Min.x;

	subss	xmm4, xmm8
	addss	xmm15, xmm1

; 39   :         const auto top = canvas_y + canvas_h * 0.5f * 0.2f;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm10
	subss	xmm2, xmm15
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movaps	xmm14, xmm2
	mulss	xmm14, xmm10
	movaps	xmm12, xmm0
	addss	xmm12, xmm8

; 40   :         const auto bottom = canvas_y + canvas_h - canvas_h * 0.5f * 0.2f;

	addss	xmm8, xmm4
	movaps	xmm1, xmm14
	mulss	xmm1, DWORD PTR __real@3e99999a

; 42   :         // const auto angle = AX_PI * 0.5f * 0.5f * 0.5f;
; 43   : 
; 44   :         const auto tip_top = ImVec2(canvas_x + canvas_w * 0.5f, top);

	addss	xmm14, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR tip_top$27[rsp+4], xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 40   :         const auto bottom = canvas_y + canvas_h - canvas_h * 0.5f * 0.2f;

	subss	xmm8, xmm0
	movaps	xmm9, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR tip_top$27[rsp], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 37   :         const auto left = canvas_x + canvas_w * 0.5f * 0.3f;

	addss	xmm9, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR tip_bottom$40[rbp-256], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 38   :         const auto right = canvas_x + canvas_w - canvas_w * 0.5f * 0.3f;

	addss	xmm15, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR tip_bottom$40[rbp-252], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 41   :         const auto center_y = (top + bottom) * 0.5f;

	movaps	xmm0, xmm8
	addss	xmm0, xmm12
	subss	xmm15, xmm1
	mulss	xmm0, xmm10
	movss	DWORD PTR tip_right$1$sroa$2749$1$[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm0, xmm9
	addss	xmm0, xmm6

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T36[rsp], xmm0

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm0, xmm7
	addss	xmm0, xmm12

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T36[rsp+4], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN51@DrawIcon
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN55@DrawIcon
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN56@DrawIcon
$LN55@DrawIcon:
	mov	eax, esi
$LN56@DrawIcon:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, r14
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN51@DrawIcon:
	movsxd	rdx, DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 49   :         drawList->PathBezierCubicCurveTo(

	lea	r9, QWORD PTR $T35[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rax, QWORD PTR $T36[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 49   :         drawList->PathBezierCubicCurveTo(

	lea	r8, QWORD PTR $T39[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [r14+8]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm13, xmm7
	movaps	xmm0, xmm12

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T39[rsp], xmm9

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm13, xmm9

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T39[rsp+4], xmm12

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, xmm6

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T41[rbp-256], xmm9

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 49   :         drawList->PathBezierCubicCurveTo(

	lea	rdx, QWORD PTR $T41[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	inc	DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 49   :         drawList->PathBezierCubicCurveTo(

	mov	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T41[rbp-252], xmm12
	movss	DWORD PTR $T35[rsp], xmm13
	movss	DWORD PTR $T35[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 49   :         drawList->PathBezierCubicCurveTo(

	call	?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z ; ImDrawList::PathBezierCubicCurveTo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [r14+4]
	mov	ecx, DWORD PTR [r14]
	cmp	ecx, r8d
	jne	SHORT $LN72@DrawIcon
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN76@DrawIcon
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN77@DrawIcon
$LN76@DrawIcon:
	mov	eax, esi
$LN77@DrawIcon:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, r14
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN72@DrawIcon:
	mov	rax, QWORD PTR tip_top$27[rsp]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movaps	xmm7, xmm15

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rdx, DWORD PTR [r14]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm7, xmm14

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [r14+8]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm14, DWORD PTR __real@3f333333

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR tip_right$1$sroa$2749$1$[rsp]
	movaps	xmm0, xmm2

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm0, xmm12

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [r14]
	inc	ecx

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm7, xmm14

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	DWORD PTR [r14], ecx
	mov	r8d, DWORD PTR [r14+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm0, xmm14
	addss	xmm7, DWORD PTR tip_top$27[rsp]
	addss	xmm0, xmm12
	movss	DWORD PTR $T26[rsp], xmm7
	movss	DWORD PTR $T26[rsp+4], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN93@DrawIcon
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN97@DrawIcon
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN98@DrawIcon
$LN97@DrawIcon:
	mov	eax, esi
$LN98@DrawIcon:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, r14
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
	movss	xmm2, DWORD PTR tip_right$1$sroa$2749$1$[rsp]
$LN93@DrawIcon:
	movsxd	rdx, DWORD PTR [r14]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movaps	xmm1, xmm2

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [r14+8]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm1, xmm8

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rax, QWORD PTR $T26[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1295 :         PathBezierCubicCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0); // Auto-tessellated

	xor	r15d, r15d
	mov	DWORD PTR [rsp+80], r15d
	movaps	xmm3, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	movsxd	rcx, DWORD PTR [r14]

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rdx, rcx

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm1, xmm14

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [r14], eax

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1295 :         PathBezierCubicCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0); // Auto-tessellated

	mov	rcx, QWORD PTR [rbx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rax, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1295 :         PathBezierCubicCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0); // Auto-tessellated

	movss	xmm0, DWORD PTR [rcx+20]
	mov	rcx, r14
	movss	DWORD PTR [rsp+72], xmm0
	movss	DWORD PTR [rsp+64], xmm1
	movss	xmm1, DWORD PTR [rax+rdx*8]
	movss	DWORD PTR [rsp+56], xmm7
	movss	DWORD PTR [rsp+48], xmm2
	movss	DWORD PTR [rsp+40], xmm15
	movss	DWORD PTR [rsp+32], xmm2
	movss	xmm2, DWORD PTR [rax+rdx*8+4]
	call	?PathBezierCubicCurveToCasteljau@@YAXPEAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ; PathBezierCubicCurveToCasteljau
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [r14+4]
	mov	ecx, DWORD PTR [r14]
	cmp	ecx, r8d
	jne	SHORT $LN134@DrawIcon
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN138@DrawIcon
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN139@DrawIcon
$LN138@DrawIcon:
	mov	eax, esi
$LN139@DrawIcon:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, r14
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN134@DrawIcon:
	movsxd	rdx, DWORD PTR [r14]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm0, xmm8

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [r14+8]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, xmm6

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rax, QWORD PTR tip_bottom$40[rbp-256]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T25[rsp], xmm13

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [r14]
	inc	ecx

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T25[rsp+4], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	DWORD PTR [r14], ecx
	mov	r8d, DWORD PTR [r14+4]
	cmp	ecx, r8d
	jne	SHORT $LN151@DrawIcon
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN155@DrawIcon
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	esi, DWORD PTR [r8+rax]
$LN155@DrawIcon:
	cmp	esi, ecx
	cmovg	ecx, esi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, r14
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN151@DrawIcon:
	mov	rax, QWORD PTR $T25[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 61   :         drawList->PathBezierCubicCurveTo(

	lea	r9, QWORD PTR $T24[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rdx, DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 61   :         drawList->PathBezierCubicCurveTo(

	lea	r8, QWORD PTR $T34[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [r14+8]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movaps	xmm0, xmm9
	subss	xmm0, xmm6

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T34[rsp], xmm9
	movss	DWORD PTR $T34[rsp+4], xmm8
	movss	DWORD PTR $T38[rsp], xmm9

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 61   :         drawList->PathBezierCubicCurveTo(

	lea	rdx, QWORD PTR $T38[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	inc	DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 61   :         drawList->PathBezierCubicCurveTo(

	mov	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T24[rsp], xmm0

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movaps	xmm0, xmm8
	subss	xmm0, DWORD PTR tv5469[rsp]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T38[rsp+4], xmm8
	movss	DWORD PTR $T24[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 61   :         drawList->PathBezierCubicCurveTo(

	call	?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z ; ImDrawList::PathBezierCubicCurveTo

; 62   :             ImVec2(left, bottom),
; 63   :             ImVec2(left, bottom),
; 64   :             ImVec2(left, bottom) - ImVec2(0, rounding));
; 65   : 
; 66   :         if (!filled) {

	cmp	BYTE PTR filled$[rbp-256], r15b
	jne	SHORT $LN7@DrawIcon

; 67   :             if (innerColor & 0xFF000000)

	mov	r9d, DWORD PTR innerColor$[rbp-256]
	test	r9d, -16777216				; ff000000H
	je	SHORT $LN9@DrawIcon

; 68   :                 drawList->AddConvexPolyFilled(drawList->_Path.Data, drawList->_Path.Size, innerColor);

	mov	r8d, DWORD PTR [r14]
	mov	rcx, rbx
	mov	rdx, QWORD PTR [rbx+128]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
$LN9@DrawIcon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r9d, DWORD PTR color$[rbp-256]
	mov	rcx, rbx
	mov	r8d, DWORD PTR [r14]
	mov	rdx, QWORD PTR [rbx+128]
	movss	DWORD PTR [rsp+40], xmm11
	mov	DWORD PTR [rsp+32], 1
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 74   :     }

	mov	DWORD PTR [r14], r15d
	jmp	$LN27@DrawIcon
$LN7@DrawIcon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	esi, DWORD PTR [r14]
	mov	rdi, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 975  :     if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)

	cmp	esi, 3
	jl	$LN230@DrawIcon
	mov	QWORD PTR [rsp+392], r12
	mov	r12d, DWORD PTR color$[rbp-256]
	test	r12d, -16777216				; ff000000H
	je	$LN531@DrawIcon

; 976  :         return;
; 977  : 
; 978  :     const ImVec2 uv = _Data->TexUvWhitePixel;
; 979  : 
; 980  :     if (Flags & ImDrawListFlags_AntiAliasedFill)

	test	BYTE PTR [rbx+48], 4
	mov	rcx, rbx
	mov	rax, QWORD PTR [rbx+56]
	movss	xmm7, DWORD PTR [rax]
	movss	xmm8, DWORD PTR [rax+4]
	je	$LN231@DrawIcon

; 981  :     {
; 982  :         // Anti-aliased Fill
; 983  :         const float AA_SIZE = _FringeScale;

	movss	xmm9, DWORD PTR [rbx+192]

; 984  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;
; 985  :         const int idx_count = (points_count - 2)*3 + points_count * 6;

	lea	edx, DWORD PTR [rsi*8-6]
	mov	eax, r12d
	mov	QWORD PTR [rsp+400], r13
	and	eax, 16777215				; 00ffffffH
	add	edx, esi
	mov	DWORD PTR col_trans$1$[rsp], eax

; 986  :         const int vtx_count = (points_count * 2);

	lea	eax, DWORD PTR [rsi+rsi]

; 987  :         PrimReserve(idx_count, vtx_count);

	mov	r8d, eax
	mov	DWORD PTR vtx_count$1$[rbp-256], eax
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 988  : 
; 989  :         // Add indexes for fill
; 990  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

	mov	r14d, DWORD PTR [rbx+52]
	mov	r8d, 2
	mov	DWORD PTR vtx_inner_idx$1$[rsp], r14d
	npad	13
$LL216@DrawIcon:

; 991  :         unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
; 992  :         for (int i = 2; i < points_count; i++)
; 993  :         {
; 994  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));

	mov	rax, QWORD PTR [rbx+80]
	movzx	edx, r8w
	add	dx, dx
	inc	r8d
	add	dx, r14w
	mov	WORD PTR [rax], r14w
	mov	rax, QWORD PTR [rbx+80]
	lea	ecx, DWORD PTR [rdx-2]
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+4], dx

; 995  :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	r8d, esi
	jl	SHORT $LL216@DrawIcon

; 996  :         }
; 997  : 
; 998  :         // Compute normals
; 999  :         _Data->TempBuffer.reserve_discard(points_count);

	mov	r14, QWORD PTR [rbx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	cmp	esi, DWORD PTR [r14+52]
	jle	SHORT $LN440@DrawIcon
	mov	rcx, QWORD PTR [r14+56]
	test	rcx, rcx
	je	SHORT $LN245@DrawIcon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN243@DrawIcon

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN243@DrawIcon:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN245@DrawIcon:

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN250@DrawIcon

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN250@DrawIcon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	movsxd	r13, esi
	lea	rcx, QWORD PTR [r13*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	QWORD PTR [r14+56], rax
	mov	DWORD PTR [r14+52], esi
	jmp	SHORT $LN237@DrawIcon
$LN440@DrawIcon:
	movsxd	r13, esi
$LN237@DrawIcon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1000 :         ImVec2* temp_normals = _Data->TempBuffer.Data;

	mov	rax, QWORD PTR [rbx+56]

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	lea	r10d, DWORD PTR [rsi-1]
	movss	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
	mov	rcx, r15
	mov	r11, QWORD PTR [rax+56]
	cmp	r13, 4
	jl	$LC429@DrawIcon
	movsxd	rax, r10d
	lea	r12, QWORD PTR [r13-3]
	mov	rdx, r11
	mov	r14d, 12
	sub	rdx, rdi
	sub	r14, rdi
	lea	r8, QWORD PTR [rax*8]
	lea	rax, QWORD PTR [rdi+12]
	npad	15
$LL434@DrawIcon:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rax-12]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rax-8]
	subss	xmm2, DWORD PTR [rdi+r8]
	subss	xmm3, DWORD PTR [rdi+r8+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm6
	jbe	SHORT $LN430@DrawIcon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN430@DrawIcon:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [r11+r8], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm4
	movss	DWORD PTR [r11+r8+4], xmm2
	movss	xmm2, DWORD PTR [rax-4]
	movss	xmm3, DWORD PTR [rax]
	subss	xmm2, DWORD PTR [rax-12]
	subss	xmm3, DWORD PTR [rax-8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm6
	jbe	SHORT $LN431@DrawIcon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN431@DrawIcon:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rax-12], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm4
	movss	DWORD PTR [rdx+rax-8], xmm2
	movss	xmm2, DWORD PTR [rax+4]
	movss	xmm3, DWORD PTR [rax+8]
	subss	xmm2, DWORD PTR [rax-4]
	subss	xmm3, DWORD PTR [rax]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm6
	jbe	SHORT $LN432@DrawIcon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN432@DrawIcon:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rax-4], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm4
	movss	DWORD PTR [rdx+rax], xmm2
	movss	xmm2, DWORD PTR [rax+12]
	movss	xmm3, DWORD PTR [rax+16]
	subss	xmm2, DWORD PTR [rax+4]
	subss	xmm3, DWORD PTR [rax+8]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm6
	jbe	SHORT $LN433@DrawIcon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN433@DrawIcon:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rdx+rax+4], xmm3
	lea	r9, QWORD PTR [rcx+3]

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm4
	lea	r8, QWORD PTR [r14+rax]
	movss	DWORD PTR [rdx+rax+8], xmm2
	add	rcx, 4
	add	rax, 32					; 00000020H
	cmp	rcx, r12
	jl	$LL434@DrawIcon

; 1001 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	cmp	rcx, r13
	jl	SHORT $LN455@DrawIcon
	jmp	SHORT $LN428@DrawIcon
$LC429@DrawIcon:
	test	r13, r13
	jle	SHORT $LN428@DrawIcon
	movsxd	r9, r10d
$LN455@DrawIcon:
	lea	rax, QWORD PTR [r9*8]
	lea	rdx, QWORD PTR [rdi+rcx*8]
$LC450@DrawIcon:

; 1002 :         {
; 1003 :             const ImVec2& p0 = points[i0];
; 1004 :             const ImVec2& p1 = points[i1];
; 1005 :             float dx = p1.x - p0.x;

	movss	xmm2, DWORD PTR [rdx]

; 1006 :             float dy = p1.y - p0.y;

	movss	xmm3, DWORD PTR [rdx+4]
	subss	xmm2, DWORD PTR [rax+rdi]
	subss	xmm3, DWORD PTR [rax+rdi+4]

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm6
	jbe	SHORT $LN233@DrawIcon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 446  : static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

	movaps	xmm0, xmm1
	rsqrtss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1007 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN233@DrawIcon:

; 1008 :             temp_normals[i0].x = dy;

	movss	DWORD PTR [rax+r11], xmm3

; 1009 :             temp_normals[i0].y = -dx;

	xorps	xmm2, xmm4
	movss	DWORD PTR [rax+r11+4], xmm2
	inc	rcx
	mov	rax, rdx
	add	rdx, 8
	sub	rax, rdi
	cmp	rcx, r13
	jl	SHORT $LC450@DrawIcon
$LN428@DrawIcon:

; 1010 :         }
; 1011 : 
; 1012 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

	movss	xmm6, DWORD PTR __real@358637bd
	lea	r9, QWORD PTR [rdi+4]
	movss	xmm4, DWORD PTR __real@3f800000
	lea	r14, QWORD PTR [rbx+120]
	movss	xmm5, DWORD PTR __real@42c80000
	mov	r13, r11
	sub	r13, rdi
	mulss	xmm9, xmm10
	mov	edi, DWORD PTR vtx_inner_idx$1$[rsp]
	mov	r12d, r15d
	mov	r15d, DWORD PTR color$[rbp-256]
	npad	2
$LL222@DrawIcon:

; 1013 :         {
; 1014 :             // Average normals
; 1015 :             const ImVec2& n0 = temp_normals[i0];
; 1016 :             const ImVec2& n1 = temp_normals[i1];
; 1017 :             float dm_x = (n0.x + n1.x) * 0.5f;

	movss	xmm2, DWORD PTR [r9+r13-4]

; 1018 :             float dm_y = (n0.y + n1.y) * 0.5f;

	movss	xmm3, DWORD PTR [r9+r13]
	movsxd	rax, r10d
	addss	xmm2, DWORD PTR [r11+rax*8]
	addss	xmm3, DWORD PTR [r11+rax*8+4]
	mulss	xmm2, xmm10
	mulss	xmm3, xmm10

; 1019 :             IM_FIXNORMAL2F(dm_x, dm_y);

	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	comiss	xmm1, xmm6
	jbe	SHORT $LN234@DrawIcon
	movaps	xmm0, xmm4
	divss	xmm0, xmm1
	movaps	xmm1, xmm5
	minss	xmm1, xmm0
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
$LN234@DrawIcon:

; 1020 :             dm_x *= AA_SIZE * 0.5f;
; 1021 :             dm_y *= AA_SIZE * 0.5f;
; 1022 : 
; 1023 :             // Add vertices
; 1024 :             _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	movss	xmm0, DWORD PTR [r9-4]

; 1025 :             _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
; 1026 :             _VtxWritePtr += 2;
; 1027 : 
; 1028 :             // Add indexes for fringes
; 1029 :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));

	add	r10w, r10w
	mov	rax, QWORD PTR [rbx+72]
	movzx	r8d, r12w
	mov	ecx, DWORD PTR col_trans$1$[rsp]
	add	r8w, r8w
	mulss	xmm2, xmm9
	mulss	xmm3, xmm9
	lea	edx, DWORD PTR [r8+rdi]
	subss	xmm0, xmm2
	movss	DWORD PTR [rax], xmm0
	movss	xmm1, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	subss	xmm1, xmm3
	movss	DWORD PTR [rax+4], xmm1
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm7
	movss	DWORD PTR [rax+12], xmm8
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r15d
	addss	xmm2, DWORD PTR [r9-4]
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+20], xmm2
	addss	xmm3, DWORD PTR [r9]
	mov	rax, QWORD PTR [rbx+72]
	add	r9, 8
	movss	DWORD PTR [rax+24], xmm3
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+28], xmm7
	movss	DWORD PTR [rax+32], xmm8
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+36], ecx
	lea	ecx, DWORD PTR [r10+rdi]
	mov	rax, QWORD PTR [rbx+80]
	add	QWORD PTR [rbx+72], 40			; 00000028H
	mov	WORD PTR [rax], dx
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	lea	ecx, DWORD PTR [rdi+1]
	mov	rax, QWORD PTR [rbx+80]
	add	r10w, cx

; 1030 :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));

	add	r8w, cx
	mov	WORD PTR [rax+4], r10w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+6], r10w
	mov	r10d, r12d
	mov	rax, QWORD PTR [rbx+80]
	inc	r12d
	mov	WORD PTR [rax+8], r8w
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+10], dx

; 1031 :             _IdxWritePtr += 6;

	add	QWORD PTR [rbx+80], 12
	cmp	r12d, esi
	jl	$LL222@DrawIcon

; 1032 :         }
; 1033 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, WORD PTR vtx_count$1$[rbp-256]
	add	DWORD PTR [rbx+52], eax
	mov	r13, QWORD PTR [rsp+400]

; 1034 :     }

	xor	r15d, r15d
	mov	r12, QWORD PTR [rsp+392]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 74   :     }

	mov	DWORD PTR [r14], r15d
	jmp	$LN27@DrawIcon
$LN231@DrawIcon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1038 :         const int idx_count = (points_count - 2)*3;

	lea	eax, DWORD PTR [rsi-2]

; 1039 :         const int vtx_count = points_count;
; 1040 :         PrimReserve(idx_count, vtx_count);

	mov	r8d, esi
	lea	edx, DWORD PTR [rax+rax*2]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	rcx, rsi
	npad	15
$LL225@DrawIcon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1043 :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	rax, QWORD PTR [rbx+72]
	movsd	xmm0, QWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+8]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rbx+72]
	movss	DWORD PTR [rax+8], xmm7
	movss	DWORD PTR [rax+12], xmm8
	mov	rax, QWORD PTR [rbx+72]
	mov	DWORD PTR [rax+16], r12d

; 1044 :             _VtxWritePtr++;

	add	QWORD PTR [rbx+72], 20
	sub	rcx, 1
	jne	SHORT $LL225@DrawIcon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 217  :                     drawList->AddConvexPolyFilled(drawList->_Path.Data, drawList->_Path.Size, innerColor);

	mov	r8d, 2
	npad	8
$LL228@DrawIcon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1048 :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);

	mov	rcx, QWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+52]
	mov	WORD PTR [rcx], ax
	lea	ecx, DWORD PTR [r8-1]
	add	cx, WORD PTR [rbx+52]
	mov	rax, QWORD PTR [rbx+80]
	mov	WORD PTR [rax+2], cx
	movzx	ecx, r8w
	mov	rax, QWORD PTR [rbx+80]
	inc	r8d
	add	cx, WORD PTR [rbx+52]
	mov	WORD PTR [rax+4], cx

; 1049 :             _IdxWritePtr += 3;

	add	QWORD PTR [rbx+80], 6
	cmp	r8d, esi
	jl	SHORT $LL228@DrawIcon

; 1050 :         }
; 1051 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, si
	add	DWORD PTR [rbx+52], eax
$LN531@DrawIcon:
	mov	r12, QWORD PTR [rsp+392]
$LN230@DrawIcon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 74   :     }

	mov	DWORD PTR [r14], r15d
	jmp	$LN27@DrawIcon
$LN5@DrawIcon:

; 75   :     else {
; 76   :         auto triangleStart = rect_center_x + 0.32f * rect_w;
; 77   : 
; 78   :         auto rect_offset = -static_cast<int>(rect_w * 0.25f * 0.25f);
; 79   : 
; 80   :         rect.Min.x += rect_offset;
; 81   :         rect.Max.x += rect_offset;
; 82   :         rect_x += rect_offset;
; 83   :         rect_center_x += rect_offset * 0.5f;
; 84   :         rect_center.x += rect_offset * 0.5f;
; 85   : 
; 86   :         if (type == IconType::Circle) {

	mov	edi, DWORD PTR color$[rbp-256]
	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR __real@3e800000
	movaps	xmm6, xmm7
	mulss	xmm6, DWORD PTR __real@3ea3d70a
	mulss	xmm1, DWORD PTR __real@3e800000
	addss	xmm6, xmm8
	cvttss2si eax, xmm1
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm10
	subss	xmm8, xmm1
	cmp	r9d, 1
	jne	$LN12@DrawIcon

; 87   :             const auto c = rect_center;

	movaps	xmm0, xmm8
	add	esi, 12

; 88   : 
; 89   :             if (!filled) {

	cmp	BYTE PTR filled$[rbp-256], 0
	movaps	xmm8, xmm7
	mulss	xmm8, xmm10
	unpcklps xmm0, xmm9
	movsd	QWORD PTR c$23[rsp], xmm0
	mulss	xmm8, xmm10
	jne	$LN11@DrawIcon

; 90   :                 const auto r = 0.5f * rect_w / 2.0f - 0.5f;
; 91   : 
; 92   :                 if (innerColor & 0xFF000000)

	mov	r9d, DWORD PTR innerColor$[rbp-256]
	subss	xmm8, xmm10
	test	r9d, -16777216				; ff000000H
	je	SHORT $LN441@DrawIcon

; 93   :                     drawList->AddCircleFilled(c, r, innerColor, 12 + extra_segments);

	movaps	xmm2, xmm8
	mov	DWORD PTR [rsp+32], esi
	lea	rdx, QWORD PTR c$23[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
$LN441@DrawIcon:

; 94   :                 drawList->AddCircle(c, r, color, 12 + extra_segments, 2.0f * outline_scale);

	movss	DWORD PTR [rsp+40], xmm11
	lea	rdx, QWORD PTR c$23[rsp]
	mov	r9d, edi
	mov	DWORD PTR [rsp+32], esi
	movaps	xmm2, xmm8
	mov	rcx, rbx
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
$LN26@DrawIcon:

; 222  :         else {
; 223  :             const auto triangleTip = triangleStart + rect_w * (0.45f - 0.32f);

	mulss	xmm7, DWORD PTR __real@3e051eb8

; 225  :             drawList->AddTriangleFilled(

	movaps	xmm2, xmm14
	mulss	xmm2, DWORD PTR __real@3e19999a
	movaps	xmm1, xmm9
	addss	xmm7, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rsp], xmm6
	movss	DWORD PTR $T28[rsp], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 225  :             drawList->AddTriangleFilled(

	subss	xmm1, xmm2
	addss	xmm2, xmm9
	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rsp+4], xmm1
	movss	DWORD PTR $T28[rsp+4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 225  :             drawList->AddTriangleFilled(

	call	ceilf
	mulss	xmm14, xmm10
	lea	r9, QWORD PTR $T9[rsp]
	lea	r8, QWORD PTR $T28[rsp]
	mov	rcx, rbx
	lea	rdx, QWORD PTR $T37[rsp]
	movss	DWORD PTR $T37[rsp], xmm0
	mov	DWORD PTR [rsp+32], edi
	addss	xmm14, DWORD PTR rect$[rbp-252]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T37[rsp+4], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 225  :             drawList->AddTriangleFilled(

	call	?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
$LN27@DrawIcon:

; 226  :                 ImVec2(ceilf(triangleTip), rect_y + rect_h * 0.5f),
; 227  :                 ImVec2(triangleStart, rect_center_y + 0.15f * rect_h),
; 228  :                 ImVec2(triangleStart, rect_center_y - 0.15f * rect_h),
; 229  :                 color);
; 230  :         }
; 231  :     }
; 232  : }

	lea	r11, QWORD PTR [rsp+336]
	mov	rbx, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [r11-144]
	movaps	xmm15, XMMWORD PTR [r11-160]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN11@DrawIcon:

; 95   :             }
; 96   :             else {
; 97   :                 drawList->AddCircleFilled(c, 0.5f * rect_w / 2.0f, color, 12 + extra_segments);

	mov	r9d, edi
	mov	DWORD PTR [rsp+32], esi
	movaps	xmm2, xmm8
	lea	rdx, QWORD PTR c$23[rsp]
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled

; 98   :             }
; 99   :         }
; 100  : 
; 101  :         if (type == IconType::Square) {

	jmp	$LN26@DrawIcon
$LN12@DrawIcon:
	cmp	r9d, 2
	jne	$LN16@DrawIcon

; 102  :             if (filled) {

	cmp	BYTE PTR filled$[rbp-256], 0
	movaps	xmm2, xmm7
	mulss	xmm2, xmm10
	movaps	xmm0, xmm8
	movaps	xmm1, xmm9
	mulss	xmm2, xmm10
	je	SHORT $LN15@DrawIcon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 108  :                 drawList->AddRectFilled(p0, p1, color, 0, ImDrawFlags_RoundCornersAll);

	mov	DWORD PTR [rsp+40], 240			; 000000f0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 108  :                 drawList->AddRectFilled(p0, p1, color, 0, ImDrawFlags_RoundCornersAll);

	mov	r9d, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm8, xmm2

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 108  :                 drawList->AddRectFilled(p0, p1, color, 0, ImDrawFlags_RoundCornersAll);

	lea	r8, QWORD PTR p1$22[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR p0$33[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 108  :                 drawList->AddRectFilled(p0, p1, color, 0, ImDrawFlags_RoundCornersAll);

	lea	rdx, QWORD PTR p0$33[rsp]
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR p0$33[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 108  :                 drawList->AddRectFilled(p0, p1, color, 0, ImDrawFlags_RoundCornersAll);

	movss	DWORD PTR [rsp+32], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR p1$22[rsp], xmm8
	movss	DWORD PTR p1$22[rsp+4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 108  :                 drawList->AddRectFilled(p0, p1, color, 0, ImDrawFlags_RoundCornersAll);

	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 109  : #else
; 110  :                 drawList->AddRectFilled(p0, p1, color, 0, 15);
; 111  : #endif
; 112  :             }

	jmp	$LN26@DrawIcon
$LN15@DrawIcon:

; 118  :                 if (innerColor & 0xFF000000) {

	mov	r9d, DWORD PTR innerColor$[rbp-256]
	subss	xmm2, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm8, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 114  :                 const auto r = 0.5f * rect_w / 2.0f - 0.5f;

	subss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm1, xmm2

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, xmm9

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR p1$21[rsp], xmm8
	xorps	xmm8, xmm8
	movss	DWORD PTR p0$32[rsp], xmm0
	movss	DWORD PTR p0$32[rsp+4], xmm1
	movss	DWORD PTR p1$21[rsp+4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 118  :                 if (innerColor & 0xFF000000) {

	test	r9d, -16777216				; ff000000H
	je	SHORT $LN17@DrawIcon

; 119  : #if IMGUI_VERSION_NUM > 18101
; 120  :                     drawList->AddRectFilled(p0, p1, innerColor, 0, ImDrawFlags_RoundCornersAll);

	mov	DWORD PTR [rsp+40], 240			; 000000f0H
	lea	r8, QWORD PTR p1$21[rsp]
	lea	rdx, QWORD PTR p0$32[rsp]
	movss	DWORD PTR [rsp+32], xmm8
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN17@DrawIcon:

; 121  : #else
; 122  :                     drawList->AddRectFilled(p0, p1, innerColor, 0, 15);
; 123  : #endif
; 124  :                 }
; 125  : 
; 126  : #if IMGUI_VERSION_NUM > 18101
; 127  :                 drawList->AddRect(p0, p1, color, 0, ImDrawFlags_RoundCornersAll, 2.0f * outline_scale);

	movss	DWORD PTR [rsp+48], xmm11
	lea	r8, QWORD PTR p1$21[rsp]
	mov	DWORD PTR [rsp+40], 240			; 000000f0H
	lea	rdx, QWORD PTR p0$32[rsp]
	mov	r9d, edi
	movss	DWORD PTR [rsp+32], xmm8
	mov	rcx, rbx
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect

; 128  : #else
; 129  :                 drawList->AddRect(p0, p1, color, 0, 15, 2.0f * outline_scale);
; 130  : #endif
; 131  :             }
; 132  :         }
; 133  : 
; 134  :         if (type == IconType::Grid) {

	jmp	$LN26@DrawIcon
$LN16@DrawIcon:
	cmp	r9d, 3
	jne	$LN442@DrawIcon

; 135  :             const auto r = 0.5f * rect_w / 2.0f;

	movaps	xmm0, xmm7
	mulss	xmm0, xmm10
	mulss	xmm0, xmm10

; 136  :             const auto w = ceilf(r / 3.0f);

	divss	xmm0, DWORD PTR __real@40400000
	call	ceilf

; 137  : 
; 138  :             const auto baseTl = ImVec2(floorf(rect_center_x - w * 2.5f), floorf(rect_center_y - w * 2.5f));

	movaps	xmm6, xmm0
	movaps	xmm10, xmm0
	mulss	xmm6, DWORD PTR __real@40200000
	movss	DWORD PTR w$1$[rsp], xmm10
	subss	xmm8, xmm6
	movaps	xmm0, xmm8
	call	floorf
	movaps	xmm14, xmm0
	movaps	xmm0, xmm9
	subss	xmm0, xmm6
	call	floorf
	movaps	xmm8, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm14
	addss	xmm0, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 139  :             const auto baseBr = ImVec2(floorf(baseTl.x + w), floorf(baseTl.y + w));

	call	floorf
	movaps	xmm7, xmm0
	movss	DWORD PTR tl$31[rsp+4], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 135  :             const auto r = 0.5f * rect_w / 2.0f;

	xor	r15d, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 135  :             const auto r = 0.5f * rect_w / 2.0f;

	mov	esi, r15d

; 139  :             const auto baseBr = ImVec2(floorf(baseTl.x + w), floorf(baseTl.y + w));

	call	floorf
	movzx	r14d, BYTE PTR filled$[rbp-256]
	movaps	xmm13, xmm10
	addss	xmm13, xmm10
	movss	DWORD PTR br$20[rsp+4], xmm0
	movaps	xmm12, xmm0
	xorps	xmm11, xmm11
	movaps	xmm0, xmm13
	movaps	xmm15, xmm13
	addss	xmm0, xmm7
	addss	xmm15, xmm14
	movaps	xmm6, xmm0
	movaps	xmm10, xmm0
	movaps	xmm9, xmm15
	addss	xmm6, xmm13
	addss	xmm9, xmm13
	npad	12
$LL4@DrawIcon:

; 140  : 
; 141  :             auto tl = baseTl;
; 142  :             auto br = baseBr;
; 143  :             for (int i = 0; i < 3; ++i) {
; 144  :                 tl.x = baseTl.x;
; 145  :                 br.x = baseBr.x;
; 146  :                 drawList->AddRectFilled(tl, br, color);

	mov	DWORD PTR [rsp+40], r15d
	lea	r8, QWORD PTR br$20[rsp]
	mov	r9d, edi
	movss	DWORD PTR [rsp+32], xmm11
	lea	rdx, QWORD PTR tl$31[rsp]
	movss	DWORD PTR tl$31[rsp], xmm14
	mov	rcx, rbx
	movss	DWORD PTR br$20[rsp], xmm7
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 147  :                 tl.x += w * 2;

	movss	DWORD PTR tl$31[rsp], xmm15

; 148  :                 br.x += w * 2;

	movss	DWORD PTR br$20[rsp], xmm10

; 149  :                 if (i != 1 || filled)

	cmp	esi, 1
	jne	SHORT $LN20@DrawIcon
	test	r14b, r14b
	je	SHORT $LN19@DrawIcon
$LN20@DrawIcon:

; 150  :                     drawList->AddRectFilled(tl, br, color);

	mov	DWORD PTR [rsp+40], r15d
	lea	r8, QWORD PTR br$20[rsp]
	mov	r9d, edi
	movss	DWORD PTR [rsp+32], xmm11
	lea	rdx, QWORD PTR tl$31[rsp]
	mov	rcx, rbx
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN19@DrawIcon:

; 151  :                 tl.x += w * 2;
; 152  :                 br.x += w * 2;
; 153  :                 drawList->AddRectFilled(tl, br, color);

	mov	DWORD PTR [rsp+40], r15d
	lea	r8, QWORD PTR br$20[rsp]
	mov	r9d, edi
	movss	DWORD PTR [rsp+32], xmm11
	lea	rdx, QWORD PTR tl$31[rsp]
	movss	DWORD PTR tl$31[rsp], xmm9
	mov	rcx, rbx
	movss	DWORD PTR br$20[rsp], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 154  : 
; 155  :                 tl.y += w * 2;

	addss	xmm8, xmm13
	inc	esi

; 156  :                 br.y += w * 2;

	addss	xmm12, xmm13
	movss	DWORD PTR tl$31[rsp+4], xmm8
	movss	DWORD PTR br$20[rsp+4], xmm12
	cmp	esi, 3
	jl	$LL4@DrawIcon

; 157  :             }
; 158  : 
; 159  :             triangleStart = br.x + w + 1.0f / 24.0f * rect_w;

	movss	xmm7, DWORD PTR r$1$[rbp-256]
	addss	xmm6, DWORD PTR w$1$[rsp]
	movss	xmm9, DWORD PTR rect_center$2$[rbp-256]
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR __real@3d2aaaab
	movss	xmm10, DWORD PTR __real@3f000000
	movss	xmm14, DWORD PTR rect_h$1$[rsp]
	addss	xmm6, xmm0
	jmp	$LN26@DrawIcon
$LN442@DrawIcon:
	movaps	xmm2, xmm7
	mulss	xmm2, xmm10

; 160  :         }
; 161  : 
; 162  :         if (type == IconType::RoundSquare) {

	cmp	r9d, 4
	jne	$LN21@DrawIcon

; 163  :             if (filled) {

	cmp	BYTE PTR filled$[rbp-256], 0
	movaps	xmm0, xmm8
	mulss	xmm2, xmm10
	movaps	xmm1, xmm9
	je	SHORT $LN23@DrawIcon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 170  :                 drawList->AddRectFilled(p0, p1, color, cr, ImDrawFlags_RoundCornersAll);

	mov	DWORD PTR [rsp+40], 240			; 000000f0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 170  :                 drawList->AddRectFilled(p0, p1, color, cr, ImDrawFlags_RoundCornersAll);

	mov	r9d, edi
	lea	r8, QWORD PTR p1$19[rsp]
	lea	rdx, QWORD PTR p0$30[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR p0$30[rsp], xmm0

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm0, xmm2

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR p0$30[rsp+4], xmm1

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, xmm8
	movaps	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 165  :                 const auto cr = r * 0.5f;

	mulss	xmm2, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm1, xmm9

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR p1$19[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 170  :                 drawList->AddRectFilled(p0, p1, color, cr, ImDrawFlags_RoundCornersAll);

	movss	DWORD PTR [rsp+32], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR p1$19[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 170  :                 drawList->AddRectFilled(p0, p1, color, cr, ImDrawFlags_RoundCornersAll);

	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 171  : #else
; 172  :                 drawList->AddRectFilled(p0, p1, color, cr, 15);
; 173  : #endif
; 174  :             }

	jmp	$LN27@DrawIcon
$LN23@DrawIcon:

; 181  :                 if (innerColor & 0xFF000000) {

	mov	r9d, DWORD PTR innerColor$[rbp-256]
	subss	xmm2, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 177  :                 const auto cr = r * 0.5f;

	movaps	xmm6, xmm2
	mulss	xmm6, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm1, xmm2

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR p0$29[rsp], xmm0

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm0, xmm2

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR p0$29[rsp+4], xmm1

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, xmm8
	addss	xmm2, xmm9

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR p1$18[rsp], xmm0
	movss	DWORD PTR p1$18[rsp+4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 181  :                 if (innerColor & 0xFF000000) {

	test	r9d, -16777216				; ff000000H
	je	SHORT $LN25@DrawIcon

; 182  : #if IMGUI_VERSION_NUM > 18101
; 183  :                     drawList->AddRectFilled(p0, p1, innerColor, cr, ImDrawFlags_RoundCornersAll);

	mov	DWORD PTR [rsp+40], 240			; 000000f0H
	lea	r8, QWORD PTR p1$18[rsp]
	lea	rdx, QWORD PTR p0$29[rsp]
	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN25@DrawIcon:

; 184  : #else
; 185  :                     drawList->AddRectFilled(p0, p1, innerColor, cr, 15);
; 186  : #endif
; 187  :                 }
; 188  : 
; 189  : #if IMGUI_VERSION_NUM > 18101
; 190  :                 drawList->AddRect(p0, p1, color, cr, ImDrawFlags_RoundCornersAll, 2.0f * outline_scale);

	movss	DWORD PTR [rsp+48], xmm11
	lea	r8, QWORD PTR p1$18[rsp]
	mov	DWORD PTR [rsp+40], 240			; 000000f0H
	lea	rdx, QWORD PTR p0$29[rsp]
	mov	r9d, edi
	movss	DWORD PTR [rsp+32], xmm6
	mov	rcx, rbx
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect

; 191  : #else
; 192  :                 drawList->AddRect(p0, p1, color, cr, 15, 2.0f * outline_scale);
; 193  : #endif
; 194  :             }
; 195  :         }

	jmp	$LN27@DrawIcon
$LN21@DrawIcon:

; 196  :         else if (type == IconType::Diamond) {

	cmp	r9d, 5
	jne	$LN26@DrawIcon

; 197  :             if (filled) {

	cmp	BYTE PTR filled$[rbp-256], 0
	lea	esi, QWORD PTR [r9+3]
	mulss	xmm7, DWORD PTR __real@3f1b645a
	mov	eax, DWORD PTR [rcx+120]
	mov	ecx, DWORD PTR [rcx+124]
	mulss	xmm7, xmm10
	je	$LN28@DrawIcon

; 201  :                 drawList->PathLineTo(c + ImVec2(0, -r));

	movaps	xmm6, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm10, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 201  :                 drawList->PathLineTo(c + ImVec2(0, -r));

	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm12, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm10, xmm12
	movaps	xmm0, xmm6
	addss	xmm0, xmm9
	movss	DWORD PTR $T17[rsp], xmm10
	movss	DWORD PTR $T17[rsp+4], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	eax, ecx
	jne	SHORT $LN320@DrawIcon
	lea	r8d, DWORD PTR [rax+1]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN324@DrawIcon
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN325@DrawIcon
$LN324@DrawIcon:
	mov	eax, esi
$LN325@DrawIcon:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rbx+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN320@DrawIcon:
	mov	rax, QWORD PTR $T17[rsp]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm7

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rdx, DWORD PTR [rbx+120]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm8

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [rbx+128]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm11, xmm9
	addss	xmm11, xmm12

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rbx+120]
	inc	ecx

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T16[rsp], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	DWORD PTR [rbx+120], ecx
	mov	r8d, DWORD PTR [rbx+124]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T16[rsp+4], xmm11

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN335@DrawIcon
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN339@DrawIcon
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN340@DrawIcon
$LN339@DrawIcon:
	mov	eax, esi
$LN340@DrawIcon:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rbx+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN335@DrawIcon:
	mov	rax, QWORD PTR $T16[rsp]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm7, xmm9

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rdx, DWORD PTR [rbx+120]
	mov	rcx, QWORD PTR [rbx+128]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T15[rsp], xmm10
	movss	DWORD PTR $T15[rsp+4], xmm7

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rbx+120]
	inc	ecx
	mov	DWORD PTR [rbx+120], ecx
	mov	r8d, DWORD PTR [rbx+124]
	cmp	ecx, r8d
	jne	SHORT $LN350@DrawIcon
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN354@DrawIcon
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN355@DrawIcon
$LN354@DrawIcon:
	mov	eax, esi
$LN355@DrawIcon:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rbx+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN350@DrawIcon:
	mov	rax, QWORD PTR $T15[rsp]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm6, xmm8

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rdx, DWORD PTR [rbx+120]
	mov	rcx, QWORD PTR [rbx+128]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T14[rsp+4], xmm11
	movss	DWORD PTR $T14[rsp], xmm6

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rbx+120]
	inc	ecx
	mov	DWORD PTR [rbx+120], ecx
	mov	r8d, DWORD PTR [rbx+124]
	cmp	ecx, r8d
	jne	SHORT $LN372@DrawIcon
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN376@DrawIcon
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	esi, DWORD PTR [r8+rax]
$LN376@DrawIcon:
	cmp	esi, ecx
	cmovg	ecx, esi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rbx+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN372@DrawIcon:
	movsxd	rdx, DWORD PTR [rbx+120]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, edi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR $T14[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rcx, rbx

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	inc	DWORD PTR [rbx+120]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rbx+120]
	mov	rdx, QWORD PTR [rbx+128]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 221  :         }

	xor	r15d, r15d
	mov	DWORD PTR [rbx+120], r15d
	jmp	$LN27@DrawIcon
$LN28@DrawIcon:

; 202  :                 drawList->PathLineTo(c + ImVec2(r, 0));
; 203  :                 drawList->PathLineTo(c + ImVec2(0, r));
; 204  :                 drawList->PathLineTo(c + ImVec2(-r, 0));
; 205  :                 drawList->PathFillConvex(color);
; 206  :             }
; 207  :             else {
; 208  :                 const auto r = 0.607f * rect_w / 2.0f - 0.5f;

	subss	xmm7, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm10, xmm8
	xorps	xmm13, xmm13
	addss	xmm10, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 211  :                 drawList->PathLineTo(c + ImVec2(0, -r));

	movaps	xmm6, xmm7
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rsp], xmm10
	movaps	xmm0, xmm6
	addss	xmm0, xmm9
	movss	DWORD PTR $T13[rsp+4], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	eax, ecx
	jne	SHORT $LN265@DrawIcon
	lea	r8d, DWORD PTR [rax+1]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN269@DrawIcon
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN270@DrawIcon
$LN269@DrawIcon:
	mov	eax, esi
$LN270@DrawIcon:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rbx+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN265@DrawIcon:
	mov	rax, QWORD PTR $T13[rsp]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm7

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rdx, DWORD PTR [rbx+120]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm8

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [rbx+128]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm12, xmm9
	addss	xmm12, xmm13

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rbx+120]
	inc	ecx

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T12[rsp], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	DWORD PTR [rbx+120], ecx
	mov	r8d, DWORD PTR [rbx+124]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T12[rsp+4], xmm12

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN359@DrawIcon
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN363@DrawIcon
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN364@DrawIcon
$LN363@DrawIcon:
	mov	eax, esi
$LN364@DrawIcon:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rbx+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN359@DrawIcon:
	mov	rax, QWORD PTR $T12[rsp]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm7, xmm9

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rdx, DWORD PTR [rbx+120]
	mov	rcx, QWORD PTR [rbx+128]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T11[rsp], xmm10
	movss	DWORD PTR $T11[rsp+4], xmm7

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rbx+120]
	inc	ecx
	mov	DWORD PTR [rbx+120], ecx
	mov	r8d, DWORD PTR [rbx+124]
	cmp	ecx, r8d
	jne	SHORT $LN290@DrawIcon
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN294@DrawIcon
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN295@DrawIcon
$LN294@DrawIcon:
	mov	eax, esi
$LN295@DrawIcon:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rbx+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN290@DrawIcon:
	mov	rax, QWORD PTR $T11[rsp]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm6, xmm8

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rdx, DWORD PTR [rbx+120]
	mov	rcx, QWORD PTR [rbx+128]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T10[rsp+4], xmm12
	movss	DWORD PTR $T10[rsp], xmm6

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rbx+120]
	inc	ecx
	mov	DWORD PTR [rbx+120], ecx
	mov	r8d, DWORD PTR [rbx+124]
	cmp	ecx, r8d
	jne	SHORT $LN305@DrawIcon
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN309@DrawIcon
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	esi, DWORD PTR [r8+rax]
$LN309@DrawIcon:
	cmp	esi, ecx
	cmovg	ecx, esi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rbx+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN305@DrawIcon:
	movsxd	rdx, DWORD PTR [rbx+120]
	mov	rcx, QWORD PTR [rbx+128]
	mov	rax, QWORD PTR $T10[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 216  :                 if (innerColor & 0xFF000000)

	mov	r9d, DWORD PTR innerColor$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	r8d, DWORD PTR [rbx+120]
	inc	r8d
	mov	DWORD PTR [rbx+120], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 216  :                 if (innerColor & 0xFF000000)

	test	r9d, -16777216				; ff000000H
	je	SHORT $LN462@DrawIcon

; 217  :                     drawList->AddConvexPolyFilled(drawList->_Path.Data, drawList->_Path.Size, innerColor);

	mov	rdx, QWORD PTR [rbx+128]
	mov	rcx, rbx
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
$LN462@DrawIcon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rbx+120]
	mov	r9d, edi
	mov	rdx, QWORD PTR [rbx+128]
	mov	rcx, rbx
	movss	DWORD PTR [rsp+40], xmm11
	mov	DWORD PTR [rsp+32], 1
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 221  :         }

	xor	r15d, r15d
	mov	DWORD PTR [rbx+120], r15d
	jmp	$LN27@DrawIcon
?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z ENDP ; ax::Drawing::DrawIcon
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp
;	COMDAT ?Icon@Widgets@ax@@YAXAEBUImVec2@@W4IconType@Drawing@2@_NAEBUImVec4@@3@Z
_TEXT	SEGMENT
$T2 = 64
$T3 = 72
$T4 = 88
cursorPos$5 = 104
__$ArrayPad$ = 112
size$ = 144
type$ = 152
filled$ = 160
color$ = 168
innerColor$ = 176
?Icon@Widgets@ax@@YAXAEBUImVec2@@W4IconType@Drawing@2@_NAEBUImVec4@@3@Z PROC ; ax::Widgets::Icon, COMDAT

; 235  : {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8440 :     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 235  : {

	movzx	edi, r8b
	mov	r11d, edx
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8440 :     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR [r10+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm4, DWORD PTR [rax+316]
	movss	xmm3, DWORD PTR [rax+312]
	movaps	xmm1, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	movss	xmm0, DWORD PTR [rax+636]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	comiss	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, DWORD PTR [rcx]
	addss	xmm1, DWORD PTR [rcx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	jbe	$LN2@Icon
	comiss	xmm1, DWORD PTR [rax+628]
	jbe	$LN2@Icon
	movss	xmm0, DWORD PTR [rax+632]
	comiss	xmm0, xmm3
	jbe	$LN2@Icon
	comiss	xmm2, DWORD PTR [rax+624]
	jbe	$LN2@Icon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10240:     return window->DC.CursorPos;

	movaps	xmm0, xmm3
	unpcklps xmm0, xmm4
	movsd	QWORD PTR cursorPos$5[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2587 :     constexpr ImColor(const ImVec4& col)                            : Value(col) {}

	movups	xmm1, XMMWORD PTR [r9]
	mov	rax, QWORD PTR innerColor$[rsp]
	movups	XMMWORD PTR $T4[rsp], xmm1
	movups	xmm0, XMMWORD PTR [rax]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm1, DWORD PTR cursorPos$5[rsp+4]
	addss	xmm1, DWORD PTR [rcx+4]

; 2587 :     constexpr ImColor(const ImVec4& col)                            : Value(col) {}

	movups	XMMWORD PTR $T3[rsp], xmm0

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm0, DWORD PTR cursorPos$5[rsp]
	addss	xmm0, DWORD PTR [rcx]

; 2590 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	lea	rcx, QWORD PTR $T3[rsp]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp+4], xmm1
	movss	DWORD PTR $T2[rsp], xmm0

; 2590 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	lea	rcx, QWORD PTR $T4[rsp]
	mov	r8d, eax
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ImGuiNodeEditorExt.cpp

; 239  :         ax::Drawing::DrawIcon(drawList, cursorPos, cursorPos + size, type, filled, ImColor(color), ImColor(innerColor));

	mov	rcx, QWORD PTR [r10+16408]
	lea	rdx, QWORD PTR cursorPos$5[rsp]
	mov	DWORD PTR [rsp+48], r8d
	mov	r9d, r11d
	mov	DWORD PTR [rsp+40], eax
	lea	r8, QWORD PTR $T2[rsp]
	mov	BYTE PTR [rsp+32], dil
	mov	rcx, QWORD PTR [rcx+728]
	call	?DrawIcon@Drawing@ax@@YAXPEAUImDrawList@@AEBUImVec2@@1W4IconType@12@_NII@Z ; ax::Drawing::DrawIcon
$LN2@Icon:

; 240  :     }
; 241  : 
; 242  :     ImGui::Dummy(size);

	mov	rcx, rbx
	call	?Dummy@ImGui@@YAXAEBUImVec2@@@Z		; ImGui::Dummy

; 243  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
?Icon@Widgets@ax@@YAXAEBUImVec2@@W4IconType@Drawing@2@_NAEBUImVec4@@3@Z ENDP ; ax::Widgets::Icon
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z PROC ; ImVector<ImVec2>::push_back, COMDAT

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r8d, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rdi, rdx
	cmp	r8d, ecx
	jne	SHORT $LN2@push_back
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN2@push_back:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$ImVector@UImVec2@@@@QEAAXAEBUImVec2@@@Z ENDP ; ImVector<ImVec2>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z PROC		; ImVector<ImVec2>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rcx, rdi
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	r8, DWORD PTR [rbx]
	mov	rcx, rax
	shl	r8, 3
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ENDP		; ImVector<ImVec2>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z PROC	; ImVector<ImVec2>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImVec2@@@@QEBAHH@Z ENDP	; ImVector<ImVec2>::_grow_capacity
_TEXT	ENDS
END
