; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT ?tritsFromT@?1??decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@234@HAEAVBitAccessStream@234@H@Z@4QAY04$$CBIA
CONST	SEGMENT
?tritsFromT@?1??decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@234@HAEAVBitAccessStream@234@H@Z@4QAY04$$CBIA DD 00H ; `basisu::astc::`anonymous namespace'::decodeISETritBlock'::`2'::tritsFromT
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
CONST	ENDS
;	COMDAT ?numDBits@?6??decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@4@0IIIIII@Z@4QBHB
CONST	SEGMENT
?numDBits@?6??decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@4@0IIIIII@Z@4QBHB DD 07H ; `basisu::astc::`anonymous namespace'::decodeHDREndpointMode11'::`7'::numDBits
	DD	06H
	DD	07H
	DD	06H
	DD	05H
	DD	06H
	DD	05H
	DD	06H
CONST	ENDS
;	COMDAT ?shiftAmounts@?1??decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@4@0IIII@Z@4QBHB
CONST	SEGMENT
?shiftAmounts@?1??decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@4@0IIII@Z@4QBHB DD 01H ; `basisu::astc::`anonymous namespace'::decodeHDREndpointMode7'::`2'::shiftAmounts
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
CONST	ENDS
;	COMDAT ?quintsFromQ@?1??decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@234@HAEAVBitAccessStream@234@H@Z@4QAY02$$CBIA
CONST	SEGMENT
?quintsFromQ@?1??decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@234@HAEAVBitAccessStream@234@H@Z@4QAY02$$CBIA DD 00H ; `basisu::astc::`anonymous namespace'::decodeISEQuintBlock'::`2'::quintsFromQ
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	00H
	DD	03H
	DD	00H
	DD	00H
	DD	04H
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DD	00H
	DD	04H
	DD	04H
	DD	00H
	DD	04H
	DD	04H
	DD	04H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	03H
	DD	01H
	DD	00H
	DD	04H
	DD	01H
	DD	00H
	DD	01H
	DD	04H
	DD	00H
	DD	04H
	DD	04H
	DD	01H
	DD	04H
	DD	04H
	DD	04H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	03H
	DD	02H
	DD	00H
	DD	04H
	DD	02H
	DD	00H
	DD	02H
	DD	04H
	DD	00H
	DD	04H
	DD	04H
	DD	02H
	DD	04H
	DD	04H
	DD	04H
	DD	00H
	DD	03H
	DD	00H
	DD	01H
	DD	03H
	DD	00H
	DD	02H
	DD	03H
	DD	00H
	DD	03H
	DD	03H
	DD	00H
	DD	04H
	DD	03H
	DD	00H
	DD	03H
	DD	04H
	DD	00H
	DD	04H
	DD	04H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	02H
	DD	00H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	04H
	DD	00H
	DD	01H
	DD	00H
	DD	04H
	DD	01H
	DD	04H
	DD	00H
	DD	04H
	DD	00H
	DD	04H
	DD	04H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	03H
	DD	01H
	DD	01H
	DD	04H
	DD	01H
	DD	01H
	DD	01H
	DD	04H
	DD	01H
	DD	04H
	DD	01H
	DD	04H
	DD	01H
	DD	04H
	DD	04H
	DD	00H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	03H
	DD	02H
	DD	01H
	DD	04H
	DD	02H
	DD	01H
	DD	02H
	DD	04H
	DD	01H
	DD	04H
	DD	02H
	DD	04H
	DD	02H
	DD	04H
	DD	04H
	DD	00H
	DD	03H
	DD	01H
	DD	01H
	DD	03H
	DD	01H
	DD	02H
	DD	03H
	DD	01H
	DD	03H
	DD	03H
	DD	01H
	DD	04H
	DD	03H
	DD	01H
	DD	03H
	DD	04H
	DD	01H
	DD	04H
	DD	03H
	DD	04H
	DD	03H
	DD	04H
	DD	04H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	00H
	DD	04H
	DD	02H
	DD	02H
	DD	00H
	DD	04H
	DD	03H
	DD	00H
	DD	04H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	03H
	DD	01H
	DD	02H
	DD	04H
	DD	01H
	DD	02H
	DD	01H
	DD	04H
	DD	02H
	DD	02H
	DD	01H
	DD	04H
	DD	03H
	DD	01H
	DD	04H
	DD	00H
	DD	02H
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	02H
	DD	02H
	DD	04H
	DD	02H
	DD	02H
	DD	02H
	DD	04H
	DD	02H
	DD	02H
	DD	02H
	DD	04H
	DD	03H
	DD	02H
	DD	04H
	DD	00H
	DD	03H
	DD	02H
	DD	01H
	DD	03H
	DD	02H
	DD	02H
	DD	03H
	DD	02H
	DD	03H
	DD	03H
	DD	02H
	DD	04H
	DD	03H
	DD	02H
	DD	03H
	DD	04H
	DD	02H
	DD	02H
	DD	03H
	DD	04H
	DD	03H
	DD	03H
	DD	04H
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	00H
	DD	03H
	DD	02H
	DD	00H
	DD	03H
	DD	03H
	DD	00H
	DD	03H
	DD	04H
	DD	00H
	DD	03H
	DD	00H
	DD	04H
	DD	03H
	DD	00H
	DD	00H
	DD	04H
	DD	01H
	DD	00H
	DD	04H
	DD	00H
	DD	01H
	DD	03H
	DD	01H
	DD	01H
	DD	03H
	DD	02H
	DD	01H
	DD	03H
	DD	03H
	DD	01H
	DD	03H
	DD	04H
	DD	01H
	DD	03H
	DD	01H
	DD	04H
	DD	03H
	DD	00H
	DD	01H
	DD	04H
	DD	01H
	DD	01H
	DD	04H
	DD	00H
	DD	02H
	DD	03H
	DD	01H
	DD	02H
	DD	03H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	02H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	02H
	DD	04H
	DD	03H
	DD	00H
	DD	02H
	DD	04H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	DD	03H
	DD	03H
	DD	01H
	DD	03H
	DD	03H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	03H
	DD	00H
	DD	03H
	DD	04H
	DD	01H
	DD	03H
	DD	04H
	ORG $+1536
CONST	ENDS
;	COMDAT ?Ca@?M@??unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@234@AEBUASTCBlockMode@234@@Z@4QBIB
CONST	SEGMENT
?Ca@?M@??unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@234@AEBUASTCBlockMode@234@@Z@4QBIB DD 032H ; `basisu::astc::`anonymous namespace'::unquantizeWeights'::`12'::Ca
	DD	01cH
	DD	017H
	DD	0dH
	DD	0bH
CONST	ENDS
;	COMDAT ?Ca@?4??unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@234@HAEBUISEParams@234@@Z@4QBIB
CONST	SEGMENT
?Ca@?4??unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@234@HAEBUISEParams@234@@Z@4QBIB DD 0ccH ; `basisu::astc::`anonymous namespace'::unquantizeColorEndpoints'::`5'::Ca
	DD	071H
	DD	05dH
	DD	036H
	DD	02cH
	DD	01aH
	DD	016H
	DD	0dH
	DD	0bH
	DD	06H
	DD	05H
CONST	ENDS
;	COMDAT ?map0@?7??unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@234@AEBUASTCBlockMode@234@@Z@4QBIB
CONST	SEGMENT
?map0@?7??unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@234@AEBUASTCBlockMode@234@@Z@4QBIB DD 00H ; `basisu::astc::`anonymous namespace'::unquantizeWeights'::`8'::map0
	DD	020H
	DD	03fH
CONST	ENDS
;	COMDAT ?map1@?7??unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@234@AEBUASTCBlockMode@234@@Z@4QBIB
CONST	SEGMENT
?map1@?7??unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@234@AEBUASTCBlockMode@234@@Z@4QBIB DD 00H ; `basisu::astc::`anonymous namespace'::unquantizeWeights'::`8'::map1
	DD	010H
	DD	020H
	DD	02fH
	DD	03fH
PUBLIC	??$swap@I$0A@@std@@YAXAEAI0@Z			; std::swap<unsigned int,0>
PUBLIC	??$swap@H$0A@@std@@YAXAEAH0@Z			; std::swap<int,0>
PUBLIC	??$max@H@std@@YAAEBHAEBH0@Z			; std::max<int>
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?decompress@astc@basisu@@YA_NPEAEPEBE_NHH@Z	; basisu::astc::decompress
PUBLIC	?asUint@IVec4@basisu@@QEBA?AUUVec4@2@XZ		; basisu::IVec4::asUint
PUBLIC	?w@IVec4@basisu@@QEBAHXZ			; basisu::IVec4::w
PUBLIC	?z@IVec4@basisu@@QEBAHXZ			; basisu::IVec4::z
PUBLIC	?y@IVec4@basisu@@QEBAHXZ			; basisu::IVec4::y
PUBLIC	?x@IVec4@basisu@@QEBAHXZ			; basisu::IVec4::x
PUBLIC	??0IVec4@basisu@@QEAA@HHHH@Z			; basisu::IVec4::IVec4
PUBLIC	??AUVec4@basisu@@QEBAII@Z			; basisu::UVec4::operator[]
PUBLIC	?w@UVec4@basisu@@QEAAAEAIXZ			; basisu::UVec4::w
PUBLIC	?z@UVec4@basisu@@QEAAAEAIXZ			; basisu::UVec4::z
PUBLIC	?y@UVec4@basisu@@QEAAAEAIXZ			; basisu::UVec4::y
PUBLIC	?x@UVec4@basisu@@QEAAAEAIXZ			; basisu::UVec4::x
PUBLIC	??0UVec4@basisu@@QEAA@IIII@Z			; basisu::UVec4::UVec4
PUBLIC	??0UVec4@basisu@@QEAA@XZ			; basisu::UVec4::UVec4
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN12
	DD	imagerel $LN12+67
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decompress@astc@basisu@@YA_NPEAEPEBE_NHH@Z DD imagerel $LN74
	DD	imagerel $LN74+510
	DD	imagerel $unwind$?decompress@astc@basisu@@YA_NPEAEPEBE_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decompressBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z DD imagerel ?decompressBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z
	DD	imagerel ?decompressBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z+2023
	DD	imagerel $unwind$?decompressBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z DD imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+185
	DD	imagerel $unwind$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z DD imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+185
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+302
	DD	imagerel $chain$1$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z DD imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+302
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+320
	DD	imagerel $chain$2$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z DD imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+320
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+1043
	DD	imagerel $chain$3$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z DD imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+1043
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+1059
	DD	imagerel $chain$4$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?computeTexelPartition@?A0xc6621425@astc@basisu@@YAHIIIIH_N@Z DD imagerel ?computeTexelPartition@?A0xc6621425@astc@basisu@@YAHIIIIH_N@Z
	DD	imagerel ?computeTexelPartition@?A0xc6621425@astc@basisu@@YAHIIIIH_N@Z+613
	DD	imagerel $unwind$?computeTexelPartition@?A0xc6621425@astc@basisu@@YAHIIIIH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?computeTexelWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEBVBlock128@123@HHAEBUASTCBlockMode@123@@Z DD imagerel ?computeTexelWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEBVBlock128@123@HHAEBUASTCBlockMode@123@@Z
	DD	imagerel ?computeTexelWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEBVBlock128@123@HHAEBUASTCBlockMode@123@@Z+292
	DD	imagerel $unwind$?computeTexelWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEBVBlock128@123@HHAEBUASTCBlockMode@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z DD imagerel ?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z
	DD	imagerel ?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z+122
	DD	imagerel $unwind$?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z DD imagerel ?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z+122
	DD	imagerel ?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z+573
	DD	imagerel $chain$3$?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z DD imagerel ?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z+573
	DD	imagerel ?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z+583
	DD	imagerel $chain$4$?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+13
	DD	imagerel $unwind$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+13
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+73
	DD	imagerel $chain$1$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+73
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+187
	DD	imagerel $chain$3$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+187
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+342
	DD	imagerel $chain$4$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+342
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+390
	DD	imagerel $chain$5$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+390
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+620
	DD	imagerel $chain$6$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?computeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@AEBVBlock128@123@PEBIHHAEBUISEParams@123@H@Z DD imagerel ?computeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@AEBVBlock128@123@PEBIHHAEBUISEParams@123@H@Z
	DD	imagerel ?computeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@AEBVBlock128@123@PEBIHHAEBUISEParams@123@H@Z+213
	DD	imagerel $unwind$?computeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@AEBVBlock128@123@PEBIHHAEBUISEParams@123@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z DD imagerel ?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z
	DD	imagerel ?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z+33
	DD	imagerel $unwind$?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z DD imagerel ?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z+33
	DD	imagerel ?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z+3078
	DD	imagerel $chain$6$?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z DD imagerel ?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z+3078
	DD	imagerel ?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z+3144
	DD	imagerel $chain$7$?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeHDREndpointMode15@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIIIII@Z DD imagerel ?decodeHDREndpointMode15@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIIIII@Z
	DD	imagerel ?decodeHDREndpointMode15@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIIIII@Z+263
	DD	imagerel $unwind$?decodeHDREndpointMode15@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z DD imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+152
	DD	imagerel $unwind$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z DD imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+152
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+724
	DD	imagerel $chain$4$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z DD imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+724
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+809
	DD	imagerel $chain$5$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z DD imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+809
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+833
	DD	imagerel $chain$6$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z DD imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+833
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+980
	DD	imagerel $chain$7$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIII@Z DD imagerel ?decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIII@Z
	DD	imagerel ?decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIII@Z+716
	DD	imagerel $unwind$?decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clampedRGBA@?A0xc6621425@astc@basisu@@YA?AUUVec4@3@AEBUIVec4@3@@Z DD imagerel ?clampedRGBA@?A0xc6621425@astc@basisu@@YA?AUUVec4@3@AEBUIVec4@3@@Z
	DD	imagerel ?clampedRGBA@?A0xc6621425@astc@basisu@@YA?AUUVec4@3@AEBUIVec4@3@@Z+112
	DD	imagerel $unwind$?clampedRGBA@?A0xc6621425@astc@basisu@@YA?AUUVec4@3@AEBUIVec4@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z DD imagerel ?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z
	DD	imagerel ?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z+49
	DD	imagerel $unwind$?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z DD imagerel ?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z+49
	DD	imagerel ?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z+156
	DD	imagerel $chain$0$?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z DD imagerel ?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z+156
	DD	imagerel ?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z+645
	DD	imagerel $chain$1$?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z DD imagerel ?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z
	DD	imagerel ?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z+891
	DD	imagerel $unwind$?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeISEBitBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@AEAVBitAccessStream@123@H@Z DD imagerel ?decodeISEBitBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@AEAVBitAccessStream@123@H@Z
	DD	imagerel ?decodeISEBitBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@AEAVBitAccessStream@123@H@Z+34
	DD	imagerel $unwind$?decodeISEBitBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@AEAVBitAccessStream@123@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z DD imagerel ?decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z
	DD	imagerel ?decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z+260
	DD	imagerel $unwind$?decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z DD imagerel ?decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z
	DD	imagerel ?decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z+363
	DD	imagerel $unwind$?decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z DD imagerel ?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z
	DD	imagerel ?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z+134
	DD	imagerel $unwind$?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z DD imagerel ?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z+134
	DD	imagerel ?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z+398
	DD	imagerel $chain$3$?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z DD imagerel ?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z+398
	DD	imagerel ?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z+418
	DD	imagerel $chain$4$?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeVoidExtentBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z DD imagerel ?decodeVoidExtentBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z
	DD	imagerel ?decodeVoidExtentBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z+611
	DD	imagerel $unwind$?decodeVoidExtentBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+553
	DD	imagerel $chain$0$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+553
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+579
	DD	imagerel $chain$2$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+579
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+601
	DD	imagerel $chain$4$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+601
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+631
	DD	imagerel $chain$6$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+631
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+648
	DD	imagerel $chain$8$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+648
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+657
	DD	imagerel $chain$9$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+657
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+679
	DD	imagerel $chain$10$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+679
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+697
	DD	imagerel $chain$12$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+697
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+719
	DD	imagerel $chain$14$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+719
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+748
	DD	imagerel $chain$16$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+748
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+796
	DD	imagerel $chain$17$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z DD imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
	DD	imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z+33
	DD	imagerel $unwind$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z DD imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z+33
	DD	imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z+113
	DD	imagerel $chain$1$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z DD imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z+113
	DD	imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z+191
	DD	imagerel $chain$3$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z DD imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z+191
	DD	imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z+198
	DD	imagerel $chain$4$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z DD imagerel ?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z
	DD	imagerel ?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z+23
	DD	imagerel $unwind$?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z DD imagerel ?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z+23
	DD	imagerel ?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z+143
	DD	imagerel $chain$2$?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z DD imagerel ?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z+143
	DD	imagerel ?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z+193
	DD	imagerel $chain$4$?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?computeMaximumRangeISEParams@?A0xc6621425@astc@basisu@@YA?AUISEParams@123@HH@Z DD imagerel ?computeMaximumRangeISEParams@?A0xc6621425@astc@basisu@@YA?AUISEParams@123@HH@Z
	DD	imagerel ?computeMaximumRangeISEParams@?A0xc6621425@astc@basisu@@YA?AUISEParams@123@HH@Z+347
	DD	imagerel $unwind$?computeMaximumRangeISEParams@?A0xc6621425@astc@basisu@@YA?AUISEParams@123@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bitReplicationScale@?A0xc6621425@astc@basisu@@YAIIHH@Z DD imagerel ?bitReplicationScale@?A0xc6621425@astc@basisu@@YAIIHH@Z
	DD	imagerel ?bitReplicationScale@?A0xc6621425@astc@basisu@@YAIIHH@Z+95
	DD	imagerel $unwind$?bitReplicationScale@?A0xc6621425@astc@basisu@@YAIIHH@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bitReplicationScale@?A0xc6621425@astc@basisu@@YAIIHH@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?computeMaximumRangeISEParams@?A0xc6621425@astc@basisu@@YA?AUISEParams@123@HH@Z DD 0c1c01H
	DD	08741cH
	DD	07641cH
	DD	06541cH
	DD	05341cH
	DD	0e01af01cH
	DD	0c016d018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z DD 060021H
	DD	047400H
	DD	036400H
	DD	025400H
	DD	imagerel ?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z
	DD	imagerel ?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z+23
	DD	imagerel $unwind$?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z DD 061621H
	DD	047416H
	DD	03640eH
	DD	025405H
	DD	imagerel ?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z
	DD	imagerel ?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z+23
	DD	imagerel $unwind$?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z DD 021H
	DD	imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
	DD	imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z+33
	DD	imagerel $unwind$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z DD 040021H
	DD	047400H
	DD	063400H
	DD	imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
	DD	imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z+33
	DD	imagerel $unwind$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z DD 041421H
	DD	047414H
	DD	063405H
	DD	imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
	DD	imagerel ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z+33
	DD	imagerel $unwind$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 021H
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 020021H
	DD	037400H
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 020021H
	DD	037400H
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 020021H
	DD	037400H
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 020021H
	DD	037400H
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 021H
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 020021H
	DD	037400H
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 020021H
	DD	037400H
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 020021H
	DD	037400H
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 020021H
	DD	037400H
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 020521H
	DD	037405H
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
	DD	imagerel ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z+99
	DD	imagerel $unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeVoidExtentBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z DD 0c1e01H
	DD	0d741eH
	DD	0c641eH
	DD	0b541eH
	DD	0a341eH
	DD	0f01a521eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z DD 021H
	DD	imagerel ?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z
	DD	imagerel ?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z+134
	DD	imagerel $unwind$?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z DD 040e21H
	DD	04f40eH
	DD	0bc405H
	DD	imagerel ?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z
	DD	imagerel ?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z+134
	DD	imagerel $unwind$?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z DD 094801H
	DD	0dd448H
	DD	0a7443H
	DD	0e006420aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z DD 0c1c01H
	DD	010641cH
	DD	0f541cH
	DD	0e341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0f0145218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeISEBitBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@AEAVBitAccessStream@123@H@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z DD 0a1d01H
	DD	012341dH
	DD	0f019921dH
	DD	0d015e017H
	DD	07011c013H
	DD	0500f6010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z DD 021H
	DD	imagerel ?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z
	DD	imagerel ?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z+49
	DD	imagerel $unwind$?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z DD 020521H
	DD	04e405H
	DD	imagerel ?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z
	DD	imagerel ?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z+49
	DD	imagerel $unwind$?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z DD 091401H
	DD	076414H
	DD	065414H
	DD	053414H
	DD	0c012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clampedRGBA@?A0xc6621425@astc@basisu@@YA?AUUVec4@3@AEBUIVec4@3@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIII@Z DD 091101H
	DD	0f00d4211H
	DD	0d009e00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z DD 021H
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+152
	DD	imagerel $unwind$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z DD 020021H
	DD	02f400H
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+152
	DD	imagerel $unwind$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z DD 040021H
	DD	02f400H
	DD	0ac400H
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+152
	DD	imagerel $unwind$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z DD 0a3421H
	DD	02f434H
	DD	03e42dH
	DD	0ac41dH
	DD	096411H
	DD	085405H
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
	DD	imagerel ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z+152
	DD	imagerel $unwind$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z DD 040901H
	DD	0d0053209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeHDREndpointMode15@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIIIII@Z DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z DD 021H
	DD	imagerel ?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z
	DD	imagerel ?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z+33
	DD	imagerel $unwind$?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z DD 0e4621H
	DD	0ce446H
	DD	0bf428H
	DD	0dc41eH
	DD	0e7418H
	DD	0f6411H
	DD	010540bH
	DD	0113404H
	DD	imagerel ?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z
	DD	imagerel ?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z+33
	DD	imagerel $unwind$?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z DD 032101H
	DD	0120121H
	DD	0d01aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?computeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@AEBVBlock128@123@PEBIHHAEBUISEParams@123@H@Z DD 072219H
	DD	0355410H
	DD	0300110H
	DD	07007e009H
	DD	06006H
	DD	imagerel __GSHandlerCheck
	DD	0170H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD 040021H
	DD	095400H
	DD	083400H
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+13
	DD	imagerel $unwind$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD 021H
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+13
	DD	imagerel $unwind$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD 021H
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+13
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+73
	DD	imagerel $chain$1$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD 040c21H
	DD	0be40cH
	DD	0a6405H
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+13
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+73
	DD	imagerel $chain$1$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD 040a21H
	DD	09540aH
	DD	083405H
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
	DD	imagerel ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z+13
	DD	imagerel $unwind$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z DD 040a01H
	DD	0f006320aH
	DD	07002c004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z DD 021H
	DD	imagerel ?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z
	DD	imagerel ?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z+122
	DD	imagerel $unwind$?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z DD 081621H
	DD	06e416H
	DD	07d411H
	DD	08c40cH
	DD	0f6405H
	DD	imagerel ?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z
	DD	imagerel ?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z+122
	DD	imagerel $unwind$?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z DD 051801H
	DD	0f0148218H
	DD	050117012H
	DD	03010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?computeTexelWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEBVBlock128@123@HHAEBUASTCBlockMode@123@@Z DD 072119H
	DD	091340fH
	DD	08c010fH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0450H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?computeTexelPartition@?A0xc6621425@astc@basisu@@YAHIIIIH_N@Z DD 0a1901H
	DD	095419H
	DD	083419H
	DD	0e017f019H
	DD	0c013d015H
	DD	060107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z DD 021H
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+185
	DD	imagerel $unwind$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z DD 040021H
	DD	0ce400H
	DD	014c400H
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+185
	DD	imagerel $unwind$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z DD 021H
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+185
	DD	imagerel $unwind$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z DD 040d21H
	DD	0ce40dH
	DD	014c408H
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
	DD	imagerel ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z+185
	DD	imagerel $unwind$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z DD 071601H
	DD	0f012c216H
	DD	0700ed010H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decompressBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z DD 0a2d19H
	DD	0149011cH
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0a30H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decompress@astc@basisu@@YA_NPEAEPEBE_NHH@Z DD 051f19H
	DD	012d340dH
	DD	012a010dH
	DD	06006H
	DD	imagerel __GSHandlerCheck
	DD	0940H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??0UVec4@basisu@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0UVec4@basisu@@QEAA@XZ PROC				; basisu::UVec4::UVec4, COMDAT

; 92   : 		{
; 93   : 			m_c[0] = 0;

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 94   : 			m_c[1] = 0;
; 95   : 			m_c[2] = 0;
; 96   : 			m_c[3] = 0;
; 97   : 		}

	mov	rax, rcx
	ret	0
??0UVec4@basisu@@QEAA@XZ ENDP				; basisu::UVec4::UVec4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??0UVec4@basisu@@QEAA@IIII@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
w$ = 40
??0UVec4@basisu@@QEAA@IIII@Z PROC			; basisu::UVec4::UVec4, COMDAT

; 100  : 		{
; 101  : 			m_c[0] = x;
; 102  : 			m_c[1] = y;
; 103  : 			m_c[2] = z;
; 104  : 			m_c[3] = w;

	mov	eax, DWORD PTR w$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 105  : 		}

	mov	rax, rcx
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR [rcx+8], r9d
	ret	0
??0UVec4@basisu@@QEAA@IIII@Z ENDP			; basisu::UVec4::UVec4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?x@UVec4@basisu@@QEAAAEAIXZ
_TEXT	SEGMENT
this$ = 8
?x@UVec4@basisu@@QEAAAEAIXZ PROC			; basisu::UVec4::x, COMDAT

; 112  : 		uint32_t& x() { return m_c[0]; }

	mov	rax, rcx
	ret	0
?x@UVec4@basisu@@QEAAAEAIXZ ENDP			; basisu::UVec4::x
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?y@UVec4@basisu@@QEAAAEAIXZ
_TEXT	SEGMENT
this$ = 8
?y@UVec4@basisu@@QEAAAEAIXZ PROC			; basisu::UVec4::y, COMDAT

; 113  : 		uint32_t& y() { return m_c[1]; }

	lea	rax, QWORD PTR [rcx+4]
	ret	0
?y@UVec4@basisu@@QEAAAEAIXZ ENDP			; basisu::UVec4::y
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?z@UVec4@basisu@@QEAAAEAIXZ
_TEXT	SEGMENT
this$ = 8
?z@UVec4@basisu@@QEAAAEAIXZ PROC			; basisu::UVec4::z, COMDAT

; 114  : 		uint32_t& z() { return m_c[2]; }

	lea	rax, QWORD PTR [rcx+8]
	ret	0
?z@UVec4@basisu@@QEAAAEAIXZ ENDP			; basisu::UVec4::z
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?w@UVec4@basisu@@QEAAAEAIXZ
_TEXT	SEGMENT
this$ = 8
?w@UVec4@basisu@@QEAAAEAIXZ PROC			; basisu::UVec4::w, COMDAT

; 115  : 		uint32_t& w() { return m_c[3]; }

	lea	rax, QWORD PTR [rcx+12]
	ret	0
?w@UVec4@basisu@@QEAAAEAIXZ ENDP			; basisu::UVec4::w
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??AUVec4@basisu@@QEBAII@Z
_TEXT	SEGMENT
this$ = 8
idx$ = 16
??AUVec4@basisu@@QEBAII@Z PROC				; basisu::UVec4::operator[], COMDAT

; 117  : 		uint32_t operator[] (uint32_t idx) const { assert(idx < 4);  return m_c[idx]; }

	mov	eax, edx
	mov	eax, DWORD PTR [rcx+rax*4]
	ret	0
??AUVec4@basisu@@QEBAII@Z ENDP				; basisu::UVec4::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??0IVec4@basisu@@QEAA@HHHH@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
w$ = 40
??0IVec4@basisu@@QEAA@HHHH@Z PROC			; basisu::IVec4::IVec4, COMDAT

; 134  : 		{
; 135  : 			m_c[0] = x;
; 136  : 			m_c[1] = y;
; 137  : 			m_c[2] = z;
; 138  : 			m_c[3] = w;

	mov	eax, DWORD PTR w$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 139  : 		}

	mov	rax, rcx
	mov	DWORD PTR [rcx], edx
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR [rcx+8], r9d
	ret	0
??0IVec4@basisu@@QEAA@HHHH@Z ENDP			; basisu::IVec4::IVec4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?x@IVec4@basisu@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?x@IVec4@basisu@@QEBAHXZ PROC				; basisu::IVec4::x, COMDAT

; 141  : 		int32_t x() const { return m_c[0]; }

	mov	eax, DWORD PTR [rcx]
	ret	0
?x@IVec4@basisu@@QEBAHXZ ENDP				; basisu::IVec4::x
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?y@IVec4@basisu@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?y@IVec4@basisu@@QEBAHXZ PROC				; basisu::IVec4::y, COMDAT

; 142  : 		int32_t y() const { return m_c[1]; }

	mov	eax, DWORD PTR [rcx+4]
	ret	0
?y@IVec4@basisu@@QEBAHXZ ENDP				; basisu::IVec4::y
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?z@IVec4@basisu@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?z@IVec4@basisu@@QEBAHXZ PROC				; basisu::IVec4::z, COMDAT

; 143  : 		int32_t z() const { return m_c[2]; }

	mov	eax, DWORD PTR [rcx+8]
	ret	0
?z@IVec4@basisu@@QEBAHXZ ENDP				; basisu::IVec4::z
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?w@IVec4@basisu@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?w@IVec4@basisu@@QEBAHXZ PROC				; basisu::IVec4::w, COMDAT

; 144  : 		int32_t w() const { return m_c[3]; }

	mov	eax, DWORD PTR [rcx+12]
	ret	0
?w@IVec4@basisu@@QEBAHXZ ENDP				; basisu::IVec4::w
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?asUint@IVec4@basisu@@QEBA?AUUVec4@2@XZ
_TEXT	SEGMENT
$T1 = 8
this$ = 8
$T2 = 16
__$ReturnUdt$ = 16
$T3 = 24
?asUint@IVec4@basisu@@QEBA?AUUVec4@2@XZ PROC		; basisu::IVec4::asUint, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 153  : 			return UVec4(std::max(0, m_c[0]), std::max(0, m_c[1]), std::max(0, m_c[2]), std::max(0, m_c[3]));

	lea	r8, QWORD PTR [rcx+4]
	xor	r9d, r9d
	lea	r10, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 153  : 			return UVec4(std::max(0, m_c[0]), std::max(0, m_c[1]), std::max(0, m_c[2]), std::max(0, m_c[3]));

	mov	DWORD PTR $T3[rsp], r9d
	mov	DWORD PTR $T2[rsp], r9d
	lea	r11, QWORD PTR [rcx+12]
	mov	DWORD PTR $T1[rsp], r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmovg	r9d, eax
	cmp	DWORD PTR [r8], 0
	lea	rax, QWORD PTR $T1[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 101  : 			m_c[0] = x;

	mov	DWORD PTR [rdx], r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmovg	rax, r8
	cmp	DWORD PTR [r10], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 102  : 			m_c[1] = y;

	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rdx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	lea	rax, QWORD PTR $T2[rsp]
	cmovg	rax, r10
	cmp	DWORD PTR [r11], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 103  : 			m_c[2] = z;

	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rdx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	lea	rax, QWORD PTR $T3[rsp]
	cmovg	rax, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 104  : 			m_c[3] = w;

	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rdx+12], eax

; 153  : 			return UVec4(std::max(0, m_c[0]), std::max(0, m_c[1]), std::max(0, m_c[2]), std::max(0, m_c[3]));

	mov	rax, rdx

; 154  : 		}

	ret	0
?asUint@IVec4@basisu@@QEBA?AUUVec4@2@XZ ENDP		; basisu::IVec4::asUint
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?deDivRoundUp32@basisu@@YAIII@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?deDivRoundUp32@basisu@@YAIII@Z PROC			; basisu::deDivRoundUp32, COMDAT

; 192  : 		return (a + b - 1) / b;

	lea	eax, DWORD PTR [rdx-1]
	mov	r8d, edx
	add	eax, ecx
	xor	edx, edx
	div	r8d

; 193  : 	}

	ret	0
?deDivRoundUp32@basisu@@YAIII@Z ENDP			; basisu::deDivRoundUp32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?getBit@?A0xc6621425@astc@basisu@@YAIIH@Z
_TEXT	SEGMENT
src$ = 8
ndx$ = 16
?getBit@?A0xc6621425@astc@basisu@@YAIIH@Z PROC		; basisu::astc::`anonymous namespace'::getBit, COMDAT

; 212  : 			{

	mov	eax, ecx

; 213  : 				DE_ASSERT(basisu::inBounds(ndx, 0, 32));
; 214  : 				return (src >> ndx) & 1;

	mov	ecx, edx
	shr	eax, cl
	and	eax, 1

; 215  : 			}

	ret	0
?getBit@?A0xc6621425@astc@basisu@@YAIIH@Z ENDP		; basisu::astc::`anonymous namespace'::getBit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?getBits@?A0xc6621425@astc@basisu@@YAIIHH@Z
_TEXT	SEGMENT
src$ = 8
low$ = 16
high$ = 24
?getBits@?A0xc6621425@astc@basisu@@YAIIHH@Z PROC	; basisu::astc::`anonymous namespace'::getBits, COMDAT

; 217  : 			{

	mov	eax, r8d
	mov	r8d, ecx

; 218  : 				const int numBits = (high - low) + 1;

	sub	eax, edx
	mov	ecx, edx
	inc	eax
	shr	r8d, cl

; 219  : 				DE_ASSERT(basisu::inRange(numBits, 1, 32));
; 220  : 				if (numBits < 32)

	cmp	eax, 32					; 00000020H
	jge	SHORT $LN2@getBits

; 221  : 					return (deUint32)((src >> low) & ((1u << numBits) - 1));

	mov	ecx, eax
	mov	eax, 1
	shl	eax, cl
	dec	eax
	and	eax, r8d

; 224  : 			}

	ret	0
$LN2@getBits:

; 222  : 				else
; 223  : 					return (deUint32)((src >> low) & 0xFFFFFFFFu);

	mov	eax, r8d

; 224  : 			}

	ret	0
?getBits@?A0xc6621425@astc@basisu@@YAIIHH@Z ENDP	; basisu::astc::`anonymous namespace'::getBits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?isBitSet@?A0xc6621425@astc@basisu@@YA_NIH@Z
_TEXT	SEGMENT
src$ = 8
ndx$ = 16
?isBitSet@?A0xc6621425@astc@basisu@@YA_NIH@Z PROC	; basisu::astc::`anonymous namespace'::isBitSet, COMDAT

; 226  : 			{

	mov	eax, ecx

; 214  : 				return (src >> ndx) & 1;

	mov	ecx, edx
	shr	eax, cl
	and	al, 1

; 227  : 				return getBit(src, ndx) != 0;
; 228  : 			}

	ret	0
?isBitSet@?A0xc6621425@astc@basisu@@YA_NIH@Z ENDP	; basisu::astc::`anonymous namespace'::isBitSet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?reverseBits@?A0xc6621425@astc@basisu@@YAIIH@Z
_TEXT	SEGMENT
src$ = 8
numBits$ = 16
?reverseBits@?A0xc6621425@astc@basisu@@YAIIH@Z PROC	; basisu::astc::`anonymous namespace'::reverseBits, COMDAT

; 231  : 				DE_ASSERT(basisu::inRange(numBits, 0, 32));
; 232  : 				deUint32 result = 0;

	xor	eax, eax
	mov	r11d, ecx
	mov	r9d, eax

; 233  : 				for (int i = 0; i < numBits; i++)

	test	edx, edx
	jle	SHORT $LN10@reverseBit

; 231  : 				DE_ASSERT(basisu::inRange(numBits, 0, 32));
; 232  : 				deUint32 result = 0;

	lea	r10d, DWORD PTR [rdx-1]
$LL4@reverseBit:

; 234  : 					result |= ((src >> i) & 1) << (numBits - 1 - i);

	mov	ecx, r9d
	mov	r8d, r11d
	shr	r8d, cl
	inc	r9d
	and	r8d, 1
	mov	ecx, r10d
	shl	r8d, cl
	dec	r10d
	or	eax, r8d
	cmp	r9d, edx
	jl	SHORT $LL4@reverseBit
$LN10@reverseBit:

; 235  : 				return result;
; 236  : 			}

	ret	0
?reverseBits@?A0xc6621425@astc@basisu@@YAIIH@Z ENDP	; basisu::astc::`anonymous namespace'::reverseBits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?bitReplicationScale@?A0xc6621425@astc@basisu@@YAIIHH@Z
_TEXT	SEGMENT
src$ = 8
numSrcBits$ = 16
numDstBits$ = 24
?bitReplicationScale@?A0xc6621425@astc@basisu@@YAIIHH@Z PROC ; basisu::astc::`anonymous namespace'::bitReplicationScale, COMDAT

; 238  : 			{

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 239  : 				DE_ASSERT(numSrcBits <= numDstBits);
; 240  : 				DE_ASSERT((src & ((1 << numSrcBits) - 1)) == src);
; 241  : 				deUint32 dst = 0;
; 242  : 				for (int shift = numDstBits - numSrcBits; shift > -numSrcBits; shift -= numSrcBits)

	mov	r11d, edx
	xor	eax, eax
	neg	r11d
	sub	r8d, edx
	mov	edi, edx
	mov	ebx, ecx
	cmp	r8d, r11d
	jle	SHORT $LN12@bitReplica
	mov	r10d, r8d
	neg	r10d
	npad	12
$LL4@bitReplica:

; 243  : 					dst |= shift >= 0 ? src << shift : src >> -shift;

	mov	ecx, r10d
	mov	r9d, ebx
	shr	r9d, cl
	mov	edx, ebx
	mov	ecx, r8d
	shl	edx, cl
	test	r8d, r8d
	cmovs	edx, r9d
	sub	r8d, edi
	or	eax, edx
	sub	r10d, r11d
	cmp	r8d, r11d
	jg	SHORT $LL4@bitReplica
$LN12@bitReplica:

; 244  : 				return dst;
; 245  : 			}

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
?bitReplicationScale@?A0xc6621425@astc@basisu@@YAIIHH@Z ENDP ; basisu::astc::`anonymous namespace'::bitReplicationScale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?signExtend@?A0xc6621425@astc@basisu@@YAHHH@Z
_TEXT	SEGMENT
src$ = 8
numSrcBits$ = 16
?signExtend@?A0xc6621425@astc@basisu@@YAHHH@Z PROC	; basisu::astc::`anonymous namespace'::signExtend, COMDAT

; 248  : 			{

	mov	r8d, ecx

; 249  : 				DE_ASSERT(basisu::inRange(numSrcBits, 2, 31));
; 250  : 				const bool negative = (src & (1 << (numSrcBits - 1))) != 0;

	lea	ecx, DWORD PTR [rdx-1]
	movzx	eax, cl
	bt	r8d, eax

; 251  : 				return src | (negative ? ~((1 << numSrcBits) - 1) : 0);

	jae	SHORT $LN3@signExtend
	mov	ecx, edx
	mov	eax, -1
	shl	eax, cl
	or	eax, r8d

; 252  : 			}

	ret	0
$LN3@signExtend:

; 251  : 				return src | (negative ? ~((1 << numSrcBits) - 1) : 0);

	xor	eax, eax
	or	eax, r8d

; 252  : 			}

	ret	0
?signExtend@?A0xc6621425@astc@basisu@@YAHHH@Z ENDP	; basisu::astc::`anonymous namespace'::signExtend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??0ISEParams@?A0xc6621425@astc@basisu@@QEAA@W4ISEMode@123@H@Z
_TEXT	SEGMENT
this$ = 8
mode_$ = 16
numBits_$ = 24
??0ISEParams@?A0xc6621425@astc@basisu@@QEAA@W4ISEMode@123@H@Z PROC ; basisu::astc::`anonymous namespace'::ISEParams::ISEParams, COMDAT

; 270  : 				ISEParams(ISEMode mode_, int numBits_) : mode(mode_), numBits(numBits_) {}

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	DWORD PTR [rcx+4], r8d
	ret	0
??0ISEParams@?A0xc6621425@astc@basisu@@QEAA@W4ISEMode@123@H@Z ENDP ; basisu::astc::`anonymous namespace'::ISEParams::ISEParams
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?computeNumRequiredBits@?A0xc6621425@astc@basisu@@YAHAEBUISEParams@123@H@Z
_TEXT	SEGMENT
iseParams$ = 8
numValues$ = 16
?computeNumRequiredBits@?A0xc6621425@astc@basisu@@YAHAEBUISEParams@123@H@Z PROC ; basisu::astc::`anonymous namespace'::computeNumRequiredBits, COMDAT

; 274  : 				switch (iseParams.mode)

	mov	r8d, DWORD PTR [rcx]
	test	r8d, r8d
	je	SHORT $LN4@computeNum
	sub	r8d, 1
	je	SHORT $LN5@computeNum
	cmp	r8d, 1
	je	SHORT $LN6@computeNum

; 279  : 				default:
; 280  : 					DE_ASSERT(false);
; 281  : 					return -1;

	mov	eax, -1

; 282  : 				}
; 283  : 			}

	ret	0
$LN6@computeNum:

; 278  : 				case ISEMODE_PLAIN_BIT:		return numValues * iseParams.numBits;

	imul	edx, DWORD PTR [rcx+4]
	mov	eax, edx

; 282  : 				}
; 283  : 			}

	ret	0
$LN5@computeNum:

; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	mov	r8d, edx

; 192  : 		return (a + b - 1) / b;

	mov	eax, -1431655765			; aaaaaaabH

; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	imul	r8d, DWORD PTR [rcx+4]
	imul	ecx, edx, 7

; 192  : 		return (a + b - 1) / b;

	add	ecx, 2
	mul	ecx
	shr	edx, 1

; 282  : 				}
; 283  : 			}

	lea	eax, DWORD PTR [rdx+r8]
	ret	0
$LN4@computeNum:

; 275  : 				{
; 276  : 				case ISEMODE_TRIT:			return deDivRoundUp32(numValues * 8, 5) + numValues * iseParams.numBits;

	mov	r8d, edx

; 192  : 		return (a + b - 1) / b;

	mov	eax, -858993459				; cccccccdH

; 275  : 				{
; 276  : 				case ISEMODE_TRIT:			return deDivRoundUp32(numValues * 8, 5) + numValues * iseParams.numBits;

	imul	r8d, DWORD PTR [rcx+4]

; 192  : 		return (a + b - 1) / b;

	lea	ecx, DWORD PTR [rdx*8+4]
	mul	ecx
	shr	edx, 2

; 282  : 				}
; 283  : 			}

	lea	eax, DWORD PTR [rdx+r8]
	ret	0
?computeNumRequiredBits@?A0xc6621425@astc@basisu@@YAHAEBUISEParams@123@H@Z ENDP ; basisu::astc::`anonymous namespace'::computeNumRequiredBits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?computeMaximumRangeISEParams@?A0xc6621425@astc@basisu@@YA?AUISEParams@123@HH@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 40
numAvailableBits$ = 48
numValuesInSequence$ = 56
?computeMaximumRangeISEParams@?A0xc6621425@astc@basisu@@YA?AUISEParams@123@HH@Z PROC ; basisu::astc::`anonymous namespace'::computeMaximumRangeISEParams, COMDAT

; 285  : 			{

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r13
	push	r14
	push	r15

; 286  : 				int curBitsForTritMode = 6;
; 287  : 				int curBitsForQuintMode = 5;

	mov	ebx, 5
	lea	r14d, DWORD PTR [r8*2]
	add	r14d, r8d
	lea	r15d, DWORD PTR [r8*4]
	add	r14d, r14d
	lea	ebp, DWORD PTR [r8*8]
	add	r15d, r8d
	mov	esi, r8d
	neg	esi

; 288  : 				int curBitsForPlainBitMode = 8;

	lea	edi, QWORD PTR [rbx+3]
	mov	r13d, r8d
	lea	r11d, QWORD PTR [rbx+1]
	mov	r12d, edx
	mov	r10, rcx
$LL2@computeMax:

; 289  : 				while (true)
; 290  : 				{
; 291  : 					DE_ASSERT(curBitsForTritMode > 0 || curBitsForQuintMode > 0 || curBitsForPlainBitMode > 0);
; 292  : 					const int tritRange = curBitsForTritMode > 0 ? (3 << curBitsForTritMode) - 1 : -1;

	test	r11d, r11d
	jle	SHORT $LN12@computeMax
	mov	ecx, r11d
	mov	r9d, 3
	shl	r9d, cl
	dec	r9d
	jmp	SHORT $LN13@computeMax
$LN12@computeMax:
	mov	r9d, -1
$LN13@computeMax:

; 293  : 					const int quintRange = curBitsForQuintMode > 0 ? (5 << curBitsForQuintMode) - 1 : -1;

	test	ebx, ebx
	jle	SHORT $LN14@computeMax
	mov	ecx, ebx
	mov	r8d, 5
	shl	r8d, cl
	dec	r8d
	jmp	SHORT $LN15@computeMax
$LN14@computeMax:
	mov	r8d, -1
$LN15@computeMax:

; 294  : 					const int plainBitRange = curBitsForPlainBitMode > 0 ? (1 << curBitsForPlainBitMode) - 1 : -1;

	test	edi, edi
	jle	SHORT $LN16@computeMax
	mov	ecx, edi
	mov	edx, 1
	shl	edx, cl
	dec	edx
	jmp	SHORT $LN17@computeMax
$LN16@computeMax:
	mov	edx, -1
$LN17@computeMax:

; 68   : 		return (a > b) ? a : b;

	cmp	r9d, r8d
	mov	eax, r8d
	cmovg	eax, r9d
	cmp	eax, edx
	cmovg	edx, eax

; 295  : 					const int maxRange = basisu::max(basisu::max(tritRange, quintRange), plainBitRange);
; 296  : 					if (maxRange == tritRange)

	cmp	edx, r9d
	jne	SHORT $LN4@computeMax

; 192  : 		return (a + b - 1) / b;

	lea	ecx, DWORD PTR [r13*8]
	mov	eax, -858993459				; cccccccdH
	add	ecx, 4
	mul	ecx
	shr	edx, 2

; 276  : 				case ISEMODE_TRIT:			return deDivRoundUp32(numValues * 8, 5) + numValues * iseParams.numBits;

	lea	eax, DWORD PTR [rdx+r14]

; 297  : 					{
; 298  : 						const ISEParams params(ISEMODE_TRIT, curBitsForTritMode);
; 299  : 						if (computeNumRequiredBits(params, numValuesInSequence) <= numAvailableBits)

	cmp	eax, r12d
	jle	SHORT $LN72@computeMax

; 301  : 						curBitsForTritMode--;

	dec	r11d
	add	r14d, esi

; 302  : 					}

	jmp	$LL2@computeMax
$LN4@computeMax:

; 303  : 					else if (maxRange == quintRange)

	cmp	edx, r8d
	jne	SHORT $LN7@computeMax

; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	imul	ecx, r13d, 7

; 192  : 		return (a + b - 1) / b;

	mov	eax, -1431655765			; aaaaaaabH
	add	ecx, 2
	mul	ecx
	shr	edx, 1

; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	lea	eax, DWORD PTR [rdx+r15]

; 304  : 					{
; 305  : 						const ISEParams params(ISEMODE_QUINT, curBitsForQuintMode);
; 306  : 						if (computeNumRequiredBits(params, numValuesInSequence) <= numAvailableBits)

	cmp	eax, r12d
	jle	SHORT $LN73@computeMax

; 308  : 						curBitsForQuintMode--;

	dec	ebx
	add	r15d, esi

; 309  : 					}

	jmp	$LL2@computeMax
$LN7@computeMax:

; 310  : 					else
; 311  : 					{
; 312  : 						const ISEParams params(ISEMODE_PLAIN_BIT, curBitsForPlainBitMode);
; 313  : 						DE_ASSERT(maxRange == plainBitRange);
; 314  : 						if (computeNumRequiredBits(params, numValuesInSequence) <= numAvailableBits)

	cmp	ebp, r12d
	jle	SHORT $LN74@computeMax

; 315  : 							return ISEParams(ISEMODE_PLAIN_BIT, curBitsForPlainBitMode);
; 316  : 						curBitsForPlainBitMode--;

	dec	edi
	add	ebp, esi

; 317  : 					}
; 318  : 				}

	jmp	$LL2@computeMax
$LN72@computeMax:

; 270  : 				ISEParams(ISEMode mode_, int numBits_) : mode(mode_), numBits(numBits_) {}

	mov	DWORD PTR [r10], 0
	mov	DWORD PTR [r10+4], r11d

; 300  : 							return ISEParams(ISEMODE_TRIT, curBitsForTritMode);

	jmp	SHORT $LN85@computeMax
$LN73@computeMax:

; 270  : 				ISEParams(ISEMode mode_, int numBits_) : mode(mode_), numBits(numBits_) {}

	mov	DWORD PTR [r10], 1
	mov	DWORD PTR [r10+4], ebx

; 307  : 							return ISEParams(ISEMODE_QUINT, curBitsForQuintMode);

	jmp	SHORT $LN85@computeMax
$LN74@computeMax:

; 270  : 				ISEParams(ISEMode mode_, int numBits_) : mode(mode_), numBits(numBits_) {}

	mov	DWORD PTR [r10], 2
	mov	DWORD PTR [r10+4], edi
$LN85@computeMax:

; 319  : 			}

	mov	rbx, QWORD PTR [rsp+40]
	mov	rax, r10
	mov	rbp, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	ret	0
?computeMaximumRangeISEParams@?A0xc6621425@astc@basisu@@YA?AUISEParams@123@HH@Z ENDP ; basisu::astc::`anonymous namespace'::computeMaximumRangeISEParams
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?computeNumColorEndpointValues@?A0xc6621425@astc@basisu@@YAHI@Z
_TEXT	SEGMENT
endpointMode$ = 8
?computeNumColorEndpointValues@?A0xc6621425@astc@basisu@@YAHI@Z PROC ; basisu::astc::`anonymous namespace'::computeNumColorEndpointValues, COMDAT

; 322  : 				DE_ASSERT(endpointMode < 16);
; 323  : 				return (endpointMode / 4 + 1) * 2;

	shr	ecx, 2
	lea	eax, DWORD PTR [rcx*2+2]

; 324  : 			}

	ret	0
?computeNumColorEndpointValues@?A0xc6621425@astc@basisu@@YAHI@Z ENDP ; basisu::astc::`anonymous namespace'::computeNumColorEndpointValues
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??0Block128@?A0xc6621425@astc@basisu@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
??0Block128@?A0xc6621425@astc@basisu@@QEAA@PEBE@Z PROC	; basisu::astc::`anonymous namespace'::Block128::Block128, COMDAT

; 346  : 				{
; 347  : 					for (int wordNdx = 0; wordNdx < NUM_WORDS; wordNdx++)

	mov	r10, rcx
	lea	rax, QWORD PTR [rdx+5]
	sub	r10, rdx
	mov	r9, rcx
	xor	r11d, r11d
	mov	r8d, 2
	npad	10
$LL4@Block128:

; 348  : 					{
; 349  : 						m_words[wordNdx] = 0;

	mov	QWORD PTR [rax+r10-5], r11

; 350  : 						for (int byteNdx = 0; byteNdx < WORD_BYTES; byteNdx++)
; 351  : 							m_words[wordNdx] |= (Word)src[wordNdx * WORD_BYTES + byteNdx] << (8 * byteNdx);

	movzx	ecx, BYTE PTR [rax+1]
	movzx	edx, BYTE PTR [rax+2]
	lea	rax, QWORD PTR [rax+8]
	shl	rdx, 8
	or	rdx, rcx
	movzx	ecx, BYTE PTR [rax-8]
	shl	rdx, 8
	or	rdx, rcx
	movzx	ecx, BYTE PTR [rax-9]
	shl	rdx, 8
	or	rdx, rcx
	movzx	ecx, BYTE PTR [rax-10]
	shl	rdx, 8
	or	rdx, rcx
	movzx	ecx, BYTE PTR [rax-11]
	shl	rdx, 8
	or	rdx, rcx
	movzx	ecx, BYTE PTR [rax-12]
	shl	rdx, 8
	or	rdx, rcx
	movzx	ecx, BYTE PTR [rax-13]
	shl	rdx, 8
	or	rdx, rcx
	mov	QWORD PTR [rax+r10-13], rdx
	sub	r8, 1
	jne	SHORT $LL4@Block128

; 352  : 					}
; 353  : 				}

	mov	rax, r9
	ret	0
??0Block128@?A0xc6621425@astc@basisu@@QEAA@PEBE@Z ENDP	; basisu::astc::`anonymous namespace'::Block128::Block128
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?getBit@Block128@?A0xc6621425@astc@basisu@@QEBAIH@Z
_TEXT	SEGMENT
this$ = 8
ndx$ = 16
?getBit@Block128@?A0xc6621425@astc@basisu@@QEBAIH@Z PROC ; basisu::astc::`anonymous namespace'::Block128::getBit, COMDAT

; 356  : 					DE_ASSERT(basisu::inBounds(ndx, 0, 128));
; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	mov	eax, edx
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	mov	r8d, eax
	and	eax, 63					; 0000003fH
	sar	r8d, 6
	sub	eax, edx
	movsxd	rdx, r8d
	mov	r8, QWORD PTR [rcx+rdx*8]
	mov	ecx, eax
	shr	r8, cl
	and	r8d, 1
	mov	eax, r8d

; 358  : 				}

	ret	0
?getBit@Block128@?A0xc6621425@astc@basisu@@QEBAIH@Z ENDP ; basisu::astc::`anonymous namespace'::Block128::getBit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z
_TEXT	SEGMENT
this$ = 16
low$ = 24
high$ = 32
?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z PROC ; basisu::astc::`anonymous namespace'::Block128::getBits, COMDAT

; 360  : 				{

	push	rbx

; 361  : 					DE_ASSERT(basisu::inBounds(low, 0, 128));
; 362  : 					DE_ASSERT(basisu::inBounds(high, 0, 128));
; 363  : 					DE_ASSERT(basisu::inRange(high - low + 1, 0, 32));
; 364  : 					if (high - low + 1 == 0)

	mov	eax, r8d
	mov	r9d, r8d
	sub	eax, edx
	mov	r10d, edx
	mov	rbx, rcx
	add	eax, 1
	jne	SHORT $LN2@getBits

; 375  : 							(deUint32)((m_words[word1Ndx] & (((Word)1 << high % WORD_BITS << 1) - 1)) << (high - low - high % WORD_BITS));
; 376  : 					}
; 377  : 				}

	pop	rbx
	ret	0
$LN2@getBits:
	mov	QWORD PTR [rsp+16], rbp

; 365  : 						return 0;
; 366  : 					const int word0Ndx = low / WORD_BITS;

	mov	eax, r10d
	cdq
	mov	QWORD PTR [rsp+24], rsi
	and	edx, 63					; 0000003fH
	mov	QWORD PTR [rsp+32], rdi
	add	eax, edx
	mov	r8d, eax
	and	eax, 63					; 0000003fH
	sub	eax, edx
	sar	r8d, 6
	mov	ebp, eax

; 367  : 					const int word1Ndx = high / WORD_BITS;

	mov	eax, r9d
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	mov	edi, eax
	and	eax, 63					; 0000003fH
	sub	eax, edx
	sar	edi, 6
	mov	ecx, eax
	mov	edx, 1
	shl	rdx, cl
	mov	esi, eax
	movsxd	rcx, r8d
	lea	rdx, QWORD PTR [rdx*2-1]
	lea	r11, QWORD PTR [rbx+rcx*8]

; 368  : 					// \note "foo << bar << 1" done instead of "foo << (bar+1)" to avoid overflow, i.e. shift amount being too big.
; 369  : 					if (word0Ndx == word1Ndx)

	cmp	r8d, edi
	jne	SHORT $LN3@getBits

; 370  : 						return (deUint32)((m_words[word0Ndx] & ((((Word)1 << high % WORD_BITS << 1) - 1))) >> ((Word)low % WORD_BITS));

	and	rdx, QWORD PTR [r11]
	mov	ecx, r10d
	mov	rsi, QWORD PTR [rsp+24]
	and	cl, 63					; 0000003fH
	mov	rbp, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+32]
	shr	rdx, cl
	mov	eax, edx

; 375  : 							(deUint32)((m_words[word1Ndx] & (((Word)1 << high % WORD_BITS << 1) - 1)) << (high - low - high % WORD_BITS));
; 376  : 					}
; 377  : 				}

	pop	rbx
	ret	0
$LN3@getBits:

; 371  : 					else
; 372  : 					{
; 373  : 						DE_ASSERT(word1Ndx == word0Ndx + 1);
; 374  : 						return (deUint32)(m_words[word0Ndx] >> (low % WORD_BITS)) |

	sub	r9d, esi
	movsxd	rax, edi
	mov	rsi, QWORD PTR [rsp+24]
	sub	r9d, r10d
	mov	rdi, QWORD PTR [rsp+32]
	movzx	ecx, r9b
	mov	rax, QWORD PTR [rbx+rax*8]
	and	rax, rdx
	mov	rdx, QWORD PTR [r11]
	shl	rax, cl
	mov	ecx, ebp
	mov	rbp, QWORD PTR [rsp+16]
	shr	rdx, cl
	or	eax, edx

; 375  : 							(deUint32)((m_words[word1Ndx] & (((Word)1 << high % WORD_BITS << 1) - 1)) << (high - low - high % WORD_BITS));
; 376  : 					}
; 377  : 				}

	pop	rbx
	ret	0
?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ENDP ; basisu::astc::`anonymous namespace'::Block128::getBits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?isBitSet@Block128@?A0xc6621425@astc@basisu@@QEBA_NH@Z
_TEXT	SEGMENT
this$ = 8
ndx$ = 16
?isBitSet@Block128@?A0xc6621425@astc@basisu@@QEBA_NH@Z PROC ; basisu::astc::`anonymous namespace'::Block128::isBitSet, COMDAT

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	mov	eax, edx
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	mov	r8d, eax
	and	eax, 63					; 0000003fH
	sar	r8d, 6
	sub	eax, edx
	movsxd	rdx, r8d
	mov	r8, QWORD PTR [rcx+rdx*8]
	mov	ecx, eax
	shr	r8, cl
	and	r8b, 1

; 380  : 					DE_ASSERT(basisu::inBounds(ndx, 0, 128));
; 381  : 					return getBit(ndx) != 0;

	movzx	eax, r8b

; 382  : 				}

	ret	0
?isBitSet@Block128@?A0xc6621425@astc@basisu@@QEBA_NH@Z ENDP ; basisu::astc::`anonymous namespace'::Block128::isBitSet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??0BitAccessStream@?A0xc6621425@astc@basisu@@QEAA@AEBVBlock128@123@HH_N@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
startNdxInSrc$ = 24
length$ = 32
forward$ = 40
??0BitAccessStream@?A0xc6621425@astc@basisu@@QEAA@AEBVBlock128@123@HH_N@Z PROC ; basisu::astc::`anonymous namespace'::BitAccessStream::BitAccessStream, COMDAT

; 394  : 					, m_forward(forward)

	movzx	eax, BYTE PTR forward$[rsp]
	mov	BYTE PTR [rcx+16], al

; 397  : 				}

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx
	mov	DWORD PTR [rcx+8], r8d
	mov	DWORD PTR [rcx+12], r9d
	mov	DWORD PTR [rcx+20], 0
	ret	0
??0BitAccessStream@?A0xc6621425@astc@basisu@@QEAA@AEBVBlock128@123@HH_N@Z ENDP ; basisu::astc::`anonymous namespace'::BitAccessStream::BitAccessStream
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z
_TEXT	SEGMENT
this$ = 48
num$ = 56
?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z PROC ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext, COMDAT

; 400  : 				{

	sub	rsp, 40					; 00000028H

; 401  : 					if (num == 0 || m_ndx >= m_length)

	test	edx, edx
	je	$LN3@getNext
	mov	r9d, DWORD PTR [rcx+20]
	mov	r8d, DWORD PTR [rcx+12]
	cmp	r9d, r8d
	jge	$LN3@getNext

; 403  : 					const int end = m_ndx + num;

	lea	eax, DWORD PTR [r9+rdx]
	mov	QWORD PTR [rsp+48], rbx

; 408  : 					return m_forward ? m_src.getBits(m_startNdxInSrc + low, m_startNdxInSrc + high)

	mov	edx, DWORD PTR [rcx+8]
	lea	r10d, DWORD PTR [r9-1]

; 74   : 		return (a < b) ? a : b;

	cmp	r8d, eax

; 401  : 					if (num == 0 || m_ndx >= m_length)

	mov	QWORD PTR [rsp+32], rdi

; 74   : 		return (a < b) ? a : b;

	mov	edi, eax

; 407  : 					m_ndx += num;

	mov	DWORD PTR [rcx+20], eax

; 408  : 					return m_forward ? m_src.getBits(m_startNdxInSrc + low, m_startNdxInSrc + high)

	mov	rax, QWORD PTR [rcx]

; 74   : 		return (a < b) ? a : b;

	cmovl	edi, r8d

; 404  : 					const int numBitsFromSrc = basisu::max(0, basisu::min(m_length, end) - m_ndx);

	sub	edi, r9d

; 68   : 		return (a > b) ? a : b;

	mov	ebx, 0
	cmovs	edi, ebx

; 405  : 					const int low = m_ndx;
; 406  : 					const int high = m_ndx + numBitsFromSrc - 1;

	add	r10d, edi

; 408  : 					return m_forward ? m_src.getBits(m_startNdxInSrc + low, m_startNdxInSrc + high)

	cmp	BYTE PTR [rcx+16], bl
	mov	rcx, rax
	je	SHORT $LN5@getNext
	lea	r8d, DWORD PTR [rdx+r10]
	add	edx, r9d
	mov	rdi, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 409  : 						: reverseBits(m_src.getBits(m_startNdxInSrc - high, m_startNdxInSrc - low), numBitsFromSrc);
; 410  : 				}

	add	rsp, 40					; 00000028H

; 408  : 					return m_forward ? m_src.getBits(m_startNdxInSrc + low, m_startNdxInSrc + high)

	jmp	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
$LN5@getNext:
	mov	r8d, edx
	sub	edx, r10d
	sub	r8d, r9d
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
	mov	edx, ebx

; 233  : 				for (int i = 0; i < numBits; i++)

	test	edi, edi
	jle	SHORT $LN13@getNext

; 408  : 					return m_forward ? m_src.getBits(m_startNdxInSrc + low, m_startNdxInSrc + high)

	lea	r9d, DWORD PTR [rdi-1]
	npad	7
$LL14@getNext:

; 234  : 					result |= ((src >> i) & 1) << (numBits - 1 - i);

	mov	ecx, edx
	mov	r8d, eax
	shr	r8d, cl
	inc	edx
	and	r8d, 1
	mov	ecx, r9d
	shl	r8d, cl
	dec	r9d
	or	ebx, r8d
	cmp	edx, edi
	jl	SHORT $LL14@getNext
$LN13@getNext:

; 408  : 					return m_forward ? m_src.getBits(m_startNdxInSrc + low, m_startNdxInSrc + high)

	mov	rdi, QWORD PTR [rsp+32]
	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp+48]

; 409  : 						: reverseBits(m_src.getBits(m_startNdxInSrc - high, m_startNdxInSrc - low), numBitsFromSrc);
; 410  : 				}

	add	rsp, 40					; 00000028H
	ret	0
$LN3@getNext:

; 402  : 						return 0;

	xor	eax, eax

; 409  : 						: reverseBits(m_src.getBits(m_startNdxInSrc - high, m_startNdxInSrc - low), numBitsFromSrc);
; 410  : 				}

	add	rsp, 40					; 00000028H
	ret	0
?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ENDP ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??0ASTCBlockMode@?A0xc6621425@astc@basisu@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ASTCBlockMode@?A0xc6621425@astc@basisu@@QEAA@XZ PROC	; basisu::astc::`anonymous namespace'::ASTCBlockMode::ASTCBlockMode, COMDAT

; 271  : 			};
; 272  : 			inline int computeNumRequiredBits(const ISEParams& iseParams, int numValues)
; 273  : 			{
; 274  : 				switch (iseParams.mode)
; 275  : 				{
; 276  : 				case ISEMODE_TRIT:			return deDivRoundUp32(numValues * 8, 5) + numValues * iseParams.numBits;
; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;
; 278  : 				case ISEMODE_PLAIN_BIT:		return numValues * iseParams.numBits;
; 279  : 				default:
; 280  : 					DE_ASSERT(false);
; 281  : 					return -1;
; 282  : 				}
; 283  : 			}
; 284  : 			ISEParams computeMaximumRangeISEParams(int numAvailableBits, int numValuesInSequence)
; 285  : 			{
; 286  : 				int curBitsForTritMode = 6;
; 287  : 				int curBitsForQuintMode = 5;
; 288  : 				int curBitsForPlainBitMode = 8;
; 289  : 				while (true)
; 290  : 				{
; 291  : 					DE_ASSERT(curBitsForTritMode > 0 || curBitsForQuintMode > 0 || curBitsForPlainBitMode > 0);
; 292  : 					const int tritRange = curBitsForTritMode > 0 ? (3 << curBitsForTritMode) - 1 : -1;
; 293  : 					const int quintRange = curBitsForQuintMode > 0 ? (5 << curBitsForQuintMode) - 1 : -1;
; 294  : 					const int plainBitRange = curBitsForPlainBitMode > 0 ? (1 << curBitsForPlainBitMode) - 1 : -1;
; 295  : 					const int maxRange = basisu::max(basisu::max(tritRange, quintRange), plainBitRange);
; 296  : 					if (maxRange == tritRange)
; 297  : 					{
; 298  : 						const ISEParams params(ISEMODE_TRIT, curBitsForTritMode);
; 299  : 						if (computeNumRequiredBits(params, numValuesInSequence) <= numAvailableBits)
; 300  : 							return ISEParams(ISEMODE_TRIT, curBitsForTritMode);
; 301  : 						curBitsForTritMode--;
; 302  : 					}
; 303  : 					else if (maxRange == quintRange)
; 304  : 					{
; 305  : 						const ISEParams params(ISEMODE_QUINT, curBitsForQuintMode);
; 306  : 						if (computeNumRequiredBits(params, numValuesInSequence) <= numAvailableBits)
; 307  : 							return ISEParams(ISEMODE_QUINT, curBitsForQuintMode);
; 308  : 						curBitsForQuintMode--;
; 309  : 					}
; 310  : 					else
; 311  : 					{
; 312  : 						const ISEParams params(ISEMODE_PLAIN_BIT, curBitsForPlainBitMode);
; 313  : 						DE_ASSERT(maxRange == plainBitRange);
; 314  : 						if (computeNumRequiredBits(params, numValuesInSequence) <= numAvailableBits)
; 315  : 							return ISEParams(ISEMODE_PLAIN_BIT, curBitsForPlainBitMode);
; 316  : 						curBitsForPlainBitMode--;
; 317  : 					}
; 318  : 				}
; 319  : 			}
; 320  : 			inline int computeNumColorEndpointValues(deUint32 endpointMode)
; 321  : 			{
; 322  : 				DE_ASSERT(endpointMode < 16);
; 323  : 				return (endpointMode / 4 + 1) * 2;
; 324  : 			}
; 325  : 			// Decompression utilities
; 326  : 			enum DecompressResult
; 327  : 			{
; 328  : 				DECOMPRESS_RESULT_VALID_BLOCK = 0,	//!< Decompressed valid block
; 329  : 				DECOMPRESS_RESULT_ERROR,				//!< Encountered error while decompressing, error color written
; 330  : 				DECOMPRESS_RESULT_LAST
; 331  : 			};
; 332  : 			// A helper for getting bits from a 128-bit block.
; 333  : 			class Block128
; 334  : 			{
; 335  : 			private:
; 336  : 				typedef deUint64 Word;
; 337  : 				enum
; 338  : 				{
; 339  : 					WORD_BYTES = sizeof(Word),
; 340  : 					WORD_BITS = 8 * WORD_BYTES,
; 341  : 					NUM_WORDS = 128 / WORD_BITS
; 342  : 				};
; 343  : 				//DE_STATIC_ASSERT(128 % WORD_BITS == 0);
; 344  : 			public:
; 345  : 				Block128(const deUint8* src)
; 346  : 				{
; 347  : 					for (int wordNdx = 0; wordNdx < NUM_WORDS; wordNdx++)
; 348  : 					{
; 349  : 						m_words[wordNdx] = 0;
; 350  : 						for (int byteNdx = 0; byteNdx < WORD_BYTES; byteNdx++)
; 351  : 							m_words[wordNdx] |= (Word)src[wordNdx * WORD_BYTES + byteNdx] << (8 * byteNdx);
; 352  : 					}
; 353  : 				}
; 354  : 				deUint32 getBit(int ndx) const
; 355  : 				{
; 356  : 					DE_ASSERT(basisu::inBounds(ndx, 0, 128));
; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;
; 358  : 				}
; 359  : 				deUint32 getBits(int low, int high) const
; 360  : 				{
; 361  : 					DE_ASSERT(basisu::inBounds(low, 0, 128));
; 362  : 					DE_ASSERT(basisu::inBounds(high, 0, 128));
; 363  : 					DE_ASSERT(basisu::inRange(high - low + 1, 0, 32));
; 364  : 					if (high - low + 1 == 0)
; 365  : 						return 0;
; 366  : 					const int word0Ndx = low / WORD_BITS;
; 367  : 					const int word1Ndx = high / WORD_BITS;
; 368  : 					// \note "foo << bar << 1" done instead of "foo << (bar+1)" to avoid overflow, i.e. shift amount being too big.
; 369  : 					if (word0Ndx == word1Ndx)
; 370  : 						return (deUint32)((m_words[word0Ndx] & ((((Word)1 << high % WORD_BITS << 1) - 1))) >> ((Word)low % WORD_BITS));
; 371  : 					else
; 372  : 					{
; 373  : 						DE_ASSERT(word1Ndx == word0Ndx + 1);
; 374  : 						return (deUint32)(m_words[word0Ndx] >> (low % WORD_BITS)) |
; 375  : 							(deUint32)((m_words[word1Ndx] & (((Word)1 << high % WORD_BITS << 1) - 1)) << (high - low - high % WORD_BITS));
; 376  : 					}
; 377  : 				}
; 378  : 				bool isBitSet(int ndx) const
; 379  : 				{
; 380  : 					DE_ASSERT(basisu::inBounds(ndx, 0, 128));
; 381  : 					return getBit(ndx) != 0;
; 382  : 				}
; 383  : 			private:
; 384  : 				Word m_words[NUM_WORDS];
; 385  : 			};
; 386  : 			// A helper for sequential access into a Block128.
; 387  : 			class BitAccessStream
; 388  : 			{
; 389  : 			public:
; 390  : 				BitAccessStream(const Block128& src, int startNdxInSrc, int length, bool forward)
; 391  : 					: m_src(src)
; 392  : 					, m_startNdxInSrc(startNdxInSrc)
; 393  : 					, m_length(length)
; 394  : 					, m_forward(forward)
; 395  : 					, m_ndx(0)
; 396  : 				{
; 397  : 				}
; 398  : 				// Get the next num bits. Bits at positions greater than or equal to m_length are zeros.
; 399  : 				deUint32 getNext(int num)
; 400  : 				{
; 401  : 					if (num == 0 || m_ndx >= m_length)
; 402  : 						return 0;
; 403  : 					const int end = m_ndx + num;
; 404  : 					const int numBitsFromSrc = basisu::max(0, basisu::min(m_length, end) - m_ndx);
; 405  : 					const int low = m_ndx;
; 406  : 					const int high = m_ndx + numBitsFromSrc - 1;
; 407  : 					m_ndx += num;
; 408  : 					return m_forward ? m_src.getBits(m_startNdxInSrc + low, m_startNdxInSrc + high)
; 409  : 						: reverseBits(m_src.getBits(m_startNdxInSrc - high, m_startNdxInSrc - low), numBitsFromSrc);
; 410  : 				}
; 411  : 			private:
; 412  : 				const Block128& m_src;
; 413  : 				const int			m_startNdxInSrc;
; 414  : 				const int			m_length;
; 415  : 				const bool			m_forward;
; 416  : 				int					m_ndx;
; 417  : 			};
; 418  : 			struct ISEDecodedResult
; 419  : 			{
; 420  : 				deUint32 m;
; 421  : 				deUint32 tq; //!< Trit or quint value, depending on ISE mode.
; 422  : 				deUint32 v;
; 423  : 			};
; 424  : 			// Data from an ASTC block's "block mode" part (i.e. bits [0,10]).
; 425  : 			struct ASTCBlockMode
; 426  : 			{
; 427  : 				bool		isError;
; 428  : 				// \note Following fields only relevant if !isError.
; 429  : 				bool		isVoidExtent;
; 430  : 				// \note Following fields only relevant if !isVoidExtent.
; 431  : 				bool		isDualPlane;
; 432  : 				int			weightGridWidth;
; 433  : 				int			weightGridHeight;
; 434  : 				ISEParams	weightISEParams;
; 435  : 				ASTCBlockMode(void)
; 436  : 					: isError(true)

	mov	WORD PTR [rcx], 257			; 00000101H

; 443  : 				}

	mov	rax, rcx
	mov	BYTE PTR [rcx+2], 1
	mov	QWORD PTR [rcx+4], -1

; 270  : 				ISEParams(ISEMode mode_, int numBits_) : mode(mode_), numBits(numBits_) {}

	mov	DWORD PTR [rcx+12], 3
	mov	DWORD PTR [rcx+16], -1

; 443  : 				}

	ret	0
??0ASTCBlockMode@?A0xc6621425@astc@basisu@@QEAA@XZ ENDP	; basisu::astc::`anonymous namespace'::ASTCBlockMode::ASTCBlockMode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?computeNumWeights@?A0xc6621425@astc@basisu@@YAHAEBUASTCBlockMode@123@@Z
_TEXT	SEGMENT
mode$ = 8
?computeNumWeights@?A0xc6621425@astc@basisu@@YAHAEBUASTCBlockMode@123@@Z PROC ; basisu::astc::`anonymous namespace'::computeNumWeights, COMDAT

; 447  : 				return mode.weightGridWidth * mode.weightGridHeight * (mode.isDualPlane ? 2 : 1);

	xor	eax, eax
	cmp	BYTE PTR [rcx+2], al
	setne	al
	inc	eax
	imul	eax, DWORD PTR [rcx+8]
	imul	eax, DWORD PTR [rcx+4]

; 448  : 			}

	ret	0
?computeNumWeights@?A0xc6621425@astc@basisu@@YAHAEBUASTCBlockMode@123@@Z ENDP ; basisu::astc::`anonymous namespace'::computeNumWeights
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 16
blockModeData$ = 24
?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z PROC ; basisu::astc::`anonymous namespace'::getASTCBlockMode, COMDAT

; 459  : 			{

	push	rbx

; 438  : 					, isDualPlane(true)

	mov	BYTE PTR [rcx+2], 1

; 459  : 			{

	mov	r8, rcx

; 439  : 					, weightGridWidth(-1)

	mov	QWORD PTR [rcx+4], -1

; 459  : 			{

	mov	r10d, edx

; 270  : 				ISEParams(ISEMode mode_, int numBits_) : mode(mode_), numBits(numBits_) {}

	mov	DWORD PTR [rcx+12], 3
	mov	DWORD PTR [rcx+16], -1

; 460  : 				ASTCBlockMode blockMode;
; 461  : 				blockMode.isError = true; // \note Set to false later, if not error.

	mov	BYTE PTR [rcx], 1

; 462  : 				blockMode.isVoidExtent = getBits(blockModeData, 0, 8) == 0x1fc;

	mov	ecx, edx
	and	ecx, 511				; 000001ffH
	cmp	ecx, 508				; 000001fcH
	sete	al
	mov	BYTE PTR [r8+1], al

; 463  : 				if (!blockMode.isVoidExtent)

	je	$LN43@getASTCBlo

; 464  : 				{
; 465  : 					if ((getBits(blockModeData, 0, 1) == 0 && getBits(blockModeData, 6, 8) == 7) || getBits(blockModeData, 0, 3) == 0)

	mov	ebx, edx
	and	ebx, 3
	jne	SHORT $LN13@getASTCBlo
	mov	eax, edx
	and	eax, 448				; 000001c0H
	cmp	eax, 448				; 000001c0H
	je	$LN12@getASTCBlo
$LN13@getASTCBlo:
	test	r10b, 15
	je	$LN12@getASTCBlo

; 466  : 						return blockMode; // Invalid ("reserved").
; 467  : 					deUint32 r = (deUint32)-1; // \note Set in the following branches.
; 468  : 					if (getBits(blockModeData, 0, 1) == 0)

	mov	QWORD PTR [rsp+24], rdi
	mov	r11d, r10d
	mov	edi, r10d
	shr	r11d, 2
	shr	edi, 4
	mov	ecx, r10d
	mov	r9d, r10d
	shr	ecx, 5
	and	edi, 1
	shr	r9d, 7
	test	ebx, ebx
	jne	$LN14@getASTCBlo

; 214  : 				return (src >> ndx) & 1;

	and	r11d, 1
	mov	eax, r10d
	add	r11d, r11d
	shr	eax, 1
	and	eax, 4

; 469  : 					{
; 470  : 						const deUint32 r0 = getBit(blockModeData, 4);
; 471  : 						const deUint32 r1 = getBit(blockModeData, 2);
; 472  : 						const deUint32 r2 = getBit(blockModeData, 3);
; 473  : 						const deUint32 i78 = getBits(blockModeData, 7, 8);
; 474  : 						r = (r2 << 2) | (r1 << 1) | (r0 << 0);

	and	r9d, 3
	or	r11d, eax
	or	r11d, edi

; 475  : 						if (i78 == 3)

	cmp	r9d, 3
	jne	SHORT $LN16@getASTCBlo

; 476  : 						{
; 477  : 							const bool i5 = isBitSet(blockModeData, 5);
; 478  : 							blockMode.weightGridWidth = i5 ? 10 : 6;

	and	ecx, 1
	lea	eax, DWORD PTR [rcx*4+6]

; 479  : 							blockMode.weightGridHeight = i5 ? 6 : 10;

	xor	ecx, 1
	mov	DWORD PTR [r8+4], eax
	lea	eax, DWORD PTR [rcx*4+6]

; 480  : 						}

	jmp	SHORT $LN164@getASTCBlo
$LN16@getASTCBlo:

; 481  : 						else
; 482  : 						{
; 483  : 							const deUint32 a = getBits(blockModeData, 5, 6);
; 484  : 							switch (i78)

	and	ecx, 3
	mov	eax, r9d
	test	r9d, r9d
	je	SHORT $LN18@getASTCBlo
	sub	eax, 1
	je	SHORT $LN19@getASTCBlo
	cmp	eax, 1
	jne	SHORT $LN21@getASTCBlo

; 488  : 							case 2:		blockMode.weightGridWidth = a + 6;	blockMode.weightGridHeight = getBits(blockModeData, 9, 10) + 6;		break;

	lea	eax, DWORD PTR [rcx+6]
	mov	DWORD PTR [r8+4], eax
	mov	eax, r10d
	shr	eax, 9
	and	eax, 3
	add	eax, 6
	jmp	SHORT $LN164@getASTCBlo
$LN19@getASTCBlo:

; 487  : 							case 1:		blockMode.weightGridWidth = a + 2;	blockMode.weightGridHeight = 12;									break;

	lea	eax, DWORD PTR [rcx+2]
	mov	DWORD PTR [r8+8], 12
	mov	DWORD PTR [r8+4], eax
	jmp	SHORT $LN21@getASTCBlo
$LN18@getASTCBlo:

; 485  : 							{
; 486  : 							case 0:		blockMode.weightGridWidth = 12;		blockMode.weightGridHeight = a + 2;									break;

	mov	DWORD PTR [r8+4], 12
	lea	eax, DWORD PTR [rcx+2]
$LN164@getASTCBlo:

; 516  : 							default: DE_ASSERT(false);
; 517  : 							}
; 518  : 						}
; 519  : 					}
; 520  : 					const bool	zeroDH = getBits(blockModeData, 0, 1) == 0 && getBits(blockModeData, 7, 8) == 2;

	mov	DWORD PTR [r8+8], eax
$LN21@getASTCBlo:
	cmp	r9d, 2
	jne	$LN49@getASTCBlo

; 521  : 					const bool	h = zeroDH ? 0 : isBitSet(blockModeData, 9);
; 522  : 					blockMode.isDualPlane = zeroDH ? 0 : isBitSet(blockModeData, 10);

	xor	ecx, ecx
	mov	BYTE PTR [r8+2], 0
	add	r11d, -2				; fffffffeH
	mov	QWORD PTR [r8+12], 2
$LN28@getASTCBlo:

; 537  : 							case 7:												b = 5;	break;
; 538  : 							default:	DE_ASSERT(false);
; 539  : 							}
; 540  : 						}
; 541  : 						else
; 542  : 						{
; 543  : 							switch (r)

	cmp	r11d, 5
	ja	$LN163@getASTCBlo
	lea	r9, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN145@getASTCBlo[r9+r11*4]
	add	rax, r9
	jmp	rax
$LN14@getASTCBlo:

; 218  : 				const int numBits = (high - low) + 1;

	and	r11d, 3

; 489  : 							default: DE_ASSERT(false);
; 490  : 							}
; 491  : 						}
; 492  : 					}
; 493  : 					else
; 494  : 					{
; 495  : 						const deUint32 r0 = getBit(blockModeData, 4);
; 496  : 						const deUint32 r1 = getBit(blockModeData, 0);
; 497  : 						const deUint32 r2 = getBit(blockModeData, 1);
; 498  : 						const deUint32 i23 = getBits(blockModeData, 2, 3);
; 499  : 						const deUint32 a = getBits(blockModeData, 5, 6);
; 500  : 						r = (r2 << 2) | (r1 << 1) | (r0 << 0);

	and	ecx, 3

; 218  : 				const int numBits = (high - low) + 1;

	mov	eax, r11d

; 489  : 							default: DE_ASSERT(false);
; 490  : 							}
; 491  : 						}
; 492  : 					}
; 493  : 					else
; 494  : 					{
; 495  : 						const deUint32 r0 = getBit(blockModeData, 4);
; 496  : 						const deUint32 r1 = getBit(blockModeData, 0);
; 497  : 						const deUint32 r2 = getBit(blockModeData, 1);
; 498  : 						const deUint32 i23 = getBits(blockModeData, 2, 3);
; 499  : 						const deUint32 a = getBits(blockModeData, 5, 6);
; 500  : 						r = (r2 << 2) | (r1 << 1) | (r0 << 0);

	lea	r11d, DWORD PTR [rbx+rbx]
	or	r11d, edi

; 501  : 						if (i23 == 3)

	cmp	eax, 3
	jne	SHORT $LN22@getASTCBlo

; 214  : 				return (src >> ndx) & 1;

	mov	eax, r10d
	and	r9d, 1
	shr	eax, 8
	test	al, 1

; 502  : 						{
; 503  : 							const deUint32	b = getBit(blockModeData, 7);
; 504  : 							const bool		i8 = isBitSet(blockModeData, 8);
; 505  : 							blockMode.weightGridWidth = i8 ? b + 2 : a + 2;

	je	SHORT $LN45@getASTCBlo
	lea	eax, DWORD PTR [r9+2]
	add	ecx, 2

; 506  : 							blockMode.weightGridHeight = i8 ? a + 2 : b + 6;

	mov	DWORD PTR [r8+4], eax
	mov	DWORD PTR [r8+8], ecx

; 507  : 						}

	jmp	SHORT $LN49@getASTCBlo
$LN45@getASTCBlo:

; 502  : 						{
; 503  : 							const deUint32	b = getBit(blockModeData, 7);
; 504  : 							const bool		i8 = isBitSet(blockModeData, 8);
; 505  : 							blockMode.weightGridWidth = i8 ? b + 2 : a + 2;

	lea	eax, DWORD PTR [rcx+2]

; 506  : 							blockMode.weightGridHeight = i8 ? a + 2 : b + 6;

	lea	ecx, DWORD PTR [r9+6]
	mov	DWORD PTR [r8+4], eax
	mov	DWORD PTR [r8+8], ecx

; 507  : 						}

	jmp	SHORT $LN49@getASTCBlo
$LN22@getASTCBlo:

; 508  : 						else
; 509  : 						{
; 510  : 							const deUint32 b = getBits(blockModeData, 7, 8);
; 511  : 							switch (i23)

	and	r9d, 3
	test	eax, eax
	je	SHORT $LN24@getASTCBlo
	sub	eax, 1
	je	SHORT $LN25@getASTCBlo
	cmp	eax, 1
	jne	SHORT $LN49@getASTCBlo

; 515  : 							case 2:		blockMode.weightGridWidth = a + 2;	blockMode.weightGridHeight = b + 8;	break;

	lea	eax, DWORD PTR [rcx+2]
	mov	DWORD PTR [r8+4], eax
	lea	eax, DWORD PTR [r9+8]
	jmp	SHORT $LN166@getASTCBlo
$LN25@getASTCBlo:

; 514  : 							case 1:		blockMode.weightGridWidth = b + 8;	blockMode.weightGridHeight = a + 2;	break;

	lea	eax, DWORD PTR [r9+8]
	jmp	SHORT $LN167@getASTCBlo
$LN24@getASTCBlo:

; 512  : 							{
; 513  : 							case 0:		blockMode.weightGridWidth = b + 4;	blockMode.weightGridHeight = a + 2;	break;

	lea	eax, DWORD PTR [r9+4]
$LN167@getASTCBlo:

; 214  : 				return (src >> ndx) & 1;

	mov	DWORD PTR [r8+4], eax
	lea	eax, DWORD PTR [rcx+2]
$LN166@getASTCBlo:
	mov	DWORD PTR [r8+8], eax
$LN49@getASTCBlo:
	mov	eax, r10d

; 527  : 						b = 0;

	xor	ecx, ecx

; 214  : 				return (src >> ndx) & 1;

	shr	r10d, 10

; 527  : 						b = 0;

	add	r11d, -2				; fffffffeH
	and	r10b, 1

; 214  : 				return (src >> ndx) & 1;

	shr	eax, 9

; 521  : 					const bool	h = zeroDH ? 0 : isBitSet(blockModeData, 9);
; 522  : 					blockMode.isDualPlane = zeroDH ? 0 : isBitSet(blockModeData, 10);

	mov	BYTE PTR [r8+2], r10b

; 523  : 					{
; 524  : 						ISEMode& m = blockMode.weightISEParams.mode;
; 525  : 						int& b = blockMode.weightISEParams.numBits;
; 526  : 						m = ISEMODE_PLAIN_BIT;

	mov	QWORD PTR [r8+12], 2

; 214  : 				return (src >> ndx) & 1;

	test	al, 1

; 528  : 						if (h)

	je	$LN28@getASTCBlo

; 529  : 						{
; 530  : 							switch (r)

	cmp	r11d, 5
	ja	$LN163@getASTCBlo
	lea	r9, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN146@getASTCBlo[r9+r11*4]
	add	rax, r9
	jmp	rax
$LN30@getASTCBlo:
	mov	rdi, QWORD PTR [rsp+24]

; 557  : 				return blockMode;
; 558  : 			}

	mov	rax, r8
	mov	DWORD PTR [r8+12], 1
	mov	DWORD PTR [r8+16], 1
	mov	BYTE PTR [r8], 0
	pop	rbx
	ret	0
$LN31@getASTCBlo:
	mov	rdi, QWORD PTR [rsp+24]
	mov	rax, r8
	mov	DWORD PTR [r8+12], ecx
	mov	DWORD PTR [r8+16], 2
	mov	BYTE PTR [r8], 0
	pop	rbx
	ret	0
$LN32@getASTCBlo:
	mov	rdi, QWORD PTR [rsp+24]
	mov	rax, r8
	mov	DWORD PTR [r8+16], 4
	mov	BYTE PTR [r8], 0
	pop	rbx
	ret	0
$LN33@getASTCBlo:

; 531  : 							{
; 532  : 							case 2:							m = ISEMODE_QUINT;	b = 1;	break;
; 533  : 							case 3:		m = ISEMODE_TRIT;						b = 2;	break;
; 534  : 							case 4:												b = 4;	break;
; 535  : 							case 5:							m = ISEMODE_QUINT;	b = 2;	break;

	mov	DWORD PTR [r8+12], 1
$LN39@getASTCBlo:
	mov	rdi, QWORD PTR [rsp+24]

; 557  : 				return blockMode;
; 558  : 			}

	mov	rax, r8
	mov	DWORD PTR [r8+16], 2
	mov	BYTE PTR [r8], 0
	pop	rbx
	ret	0
$LN34@getASTCBlo:

; 536  : 							case 6:		m = ISEMODE_TRIT;						b = 3;	break;

	mov	DWORD PTR [r8+12], ecx
$LN42@getASTCBlo:

; 550  : 							case 7:												b = 3;	break;

	mov	DWORD PTR [r8+16], 3
$LN163@getASTCBlo:
	mov	rdi, QWORD PTR [rsp+24]
$LN43@getASTCBlo:

; 551  : 							default:	DE_ASSERT(false);
; 552  : 							}
; 553  : 						}
; 554  : 					}
; 555  : 				}
; 556  : 				blockMode.isError = false;

	mov	BYTE PTR [r8], 0
$LN12@getASTCBlo:

; 557  : 				return blockMode;
; 558  : 			}

	mov	rax, r8
	pop	rbx
	ret	0
$LN35@getASTCBlo:
	mov	rdi, QWORD PTR [rsp+24]
	mov	rax, r8
	mov	DWORD PTR [r8+16], 5
	mov	BYTE PTR [r8], 0
	pop	rbx
	ret	0
$LN38@getASTCBlo:
	mov	rdi, QWORD PTR [rsp+24]
	mov	rax, r8
	mov	DWORD PTR [r8+12], ecx
	mov	BYTE PTR [r8], 0
	pop	rbx
	ret	0
$LN40@getASTCBlo:
	mov	rdi, QWORD PTR [rsp+24]
	mov	rax, r8
	mov	DWORD PTR [r8+12], 1
	mov	BYTE PTR [r8], 0
	pop	rbx
	ret	0
$LN41@getASTCBlo:

; 544  : 							{
; 545  : 							case 2:												b = 1;	break;
; 546  : 							case 3:		m = ISEMODE_TRIT;								break;
; 547  : 							case 4:												b = 2;	break;
; 548  : 							case 5:							m = ISEMODE_QUINT;			break;
; 549  : 							case 6:		m = ISEMODE_TRIT;						b = 1;	break;

	mov	DWORD PTR [r8+12], ecx
$LN37@getASTCBlo:
	mov	rdi, QWORD PTR [rsp+24]

; 557  : 				return blockMode;
; 558  : 			}

	mov	rax, r8
	mov	DWORD PTR [r8+16], 1
	mov	BYTE PTR [r8], 0
	pop	rbx
	ret	0
	npad	3
$LN145@getASTCBlo:
	DD	$LN37@getASTCBlo
	DD	$LN38@getASTCBlo
	DD	$LN39@getASTCBlo
	DD	$LN40@getASTCBlo
	DD	$LN41@getASTCBlo
	DD	$LN42@getASTCBlo
$LN146@getASTCBlo:
	DD	$LN30@getASTCBlo
	DD	$LN31@getASTCBlo
	DD	$LN32@getASTCBlo
	DD	$LN33@getASTCBlo
	DD	$LN34@getASTCBlo
	DD	$LN35@getASTCBlo
?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z ENDP ; basisu::astc::`anonymous namespace'::getASTCBlockMode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?setASTCErrorColorBlock@?A0xc6621425@astc@basisu@@YAXPEAXHH_N@Z
_TEXT	SEGMENT
dst$ = 8
blockWidth$ = 16
blockHeight$ = 24
isSRGB$dead$ = 32
?setASTCErrorColorBlock@?A0xc6621425@astc@basisu@@YAXPEAXHH_N@Z PROC ; basisu::astc::`anonymous namespace'::setASTCErrorColorBlock, COMDAT

; 560  : 			{

	imul	edx, r8d

; 561  : 				if (isSRGB)
; 562  : 				{
; 563  : 					deUint8* const dstU = (deUint8*)dst;
; 564  : 					for (int i = 0; i < blockWidth * blockHeight; i++)
; 565  : 					{
; 566  : 						dstU[4 * i + 0] = 0xff;
; 567  : 						dstU[4 * i + 1] = 0;
; 568  : 						dstU[4 * i + 2] = 0xff;
; 569  : 						dstU[4 * i + 3] = 0xff;
; 570  : 					}
; 571  : 				}
; 572  : 				else
; 573  : 				{
; 574  : 					float* const dstF = (float*)dst;
; 575  : 					for (int i = 0; i < blockWidth * blockHeight; i++)

	movsxd	r8, edx
	test	edx, edx
	jle	SHORT $LN6@setASTCErr
	lea	rax, QWORD PTR [rcx+8]
	npad	1
$LL7@setASTCErr:

; 576  : 					{
; 577  : 						dstF[4 * i + 0] = 1.0f;

	mov	QWORD PTR [rax-8], 1065353216		; 3f800000H

; 578  : 						dstF[4 * i + 1] = 0.0f;
; 579  : 						dstF[4 * i + 2] = 1.0f;

	mov	DWORD PTR [rax], 1065353216		; 3f800000H

; 580  : 						dstF[4 * i + 3] = 1.0f;

	mov	DWORD PTR [rax+4], 1065353216		; 3f800000H
	lea	rax, QWORD PTR [rax+16]
	sub	r8, 1
	jne	SHORT $LL7@setASTCErr
$LN6@setASTCErr:

; 581  : 					}
; 582  : 				}
; 583  : 			}

	ret	0
?setASTCErrorColorBlock@?A0xc6621425@astc@basisu@@YAXPEAXHH_N@Z ENDP ; basisu::astc::`anonymous namespace'::setASTCErrorColorBlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decodeVoidExtentBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z
_TEXT	SEGMENT
rgba$ = 32
dst$ = 80
blockData$ = 88
blockWidth$ = 96
blockHeight$ = 104
isSRGB$dead$ = 112
isLDRMode$dead$ = 120
?decodeVoidExtentBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z PROC ; basisu::astc::`anonymous namespace'::decodeVoidExtentBlock, COMDAT

; 585  : 			{

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rdi, rdx
	mov	ebx, r8d

; 586  : 				const deUint32	minSExtent = blockData.getBits(12, 24);

	mov	edx, 12
	mov	r12, rcx
	mov	rcx, rdi
	mov	r14d, r9d
	lea	r8d, QWORD PTR [rdx+12]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits

; 587  : 				const deUint32	maxSExtent = blockData.getBits(25, 37);

	mov	edx, 25
	mov	rcx, rdi
	mov	r15d, eax
	lea	r8d, QWORD PTR [rdx+12]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits

; 588  : 				const deUint32	minTExtent = blockData.getBits(38, 50);

	mov	edx, 38					; 00000026H
	mov	rcx, rdi
	mov	ebp, eax
	lea	r8d, QWORD PTR [rdx+12]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits

; 589  : 				const deUint32	maxTExtent = blockData.getBits(51, 63);

	mov	edx, 51					; 00000033H
	mov	rcx, rdi
	mov	esi, eax
	lea	r8d, QWORD PTR [rdx+12]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
	mov	edx, eax

; 590  : 				const bool		allExtentsAllOnes = minSExtent == 0x1fff && maxSExtent == 0x1fff && minTExtent == 0x1fff && maxTExtent == 0x1fff;

	cmp	r15d, 8191				; 00001fffH
	jne	SHORT $LN23@decodeVoid
	cmp	ebp, r15d
	jne	SHORT $LN23@decodeVoid
	cmp	esi, r15d
	jne	SHORT $LN23@decodeVoid
	cmp	eax, r15d
	jne	SHORT $LN23@decodeVoid
	mov	cl, 1
	jmp	SHORT $LN24@decodeVoid
$LN23@decodeVoid:
	xor	cl, cl
$LN24@decodeVoid:

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	mov	eax, DWORD PTR [rdi]
	shr	rax, 9
	test	al, 1

; 591  : 				const bool		isHDRBlock = blockData.isBitSet(9);
; 592  : 				if ((isLDRMode && isHDRBlock) || (!allExtentsAllOnes && (minSExtent >= maxSExtent || minTExtent >= maxTExtent)))

	jne	$LN17@decodeVoid
	test	cl, cl
	jne	SHORT $LN14@decodeVoid
	cmp	r15d, ebp
	jae	$LN17@decodeVoid
	cmp	esi, edx
	jae	$LN17@decodeVoid
$LN14@decodeVoid:

; 596  : 				}
; 597  : 				const deUint32 rgba[4] =
; 598  : 				{
; 599  : 					blockData.getBits(64,  79),

	mov	edx, 64					; 00000040H
	mov	rcx, rdi
	lea	r8d, QWORD PTR [rdx+15]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits

; 600  : 					blockData.getBits(80,  95),

	mov	edx, 80					; 00000050H
	mov	DWORD PTR rgba$[rsp], eax
	mov	rcx, rdi
	lea	r8d, QWORD PTR [rdx+15]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits

; 601  : 					blockData.getBits(96,  111),

	mov	edx, 96					; 00000060H
	mov	DWORD PTR rgba$[rsp+4], eax
	mov	rcx, rdi
	lea	r8d, QWORD PTR [rdx+15]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits

; 602  : 					blockData.getBits(112, 127)

	mov	edx, 112				; 00000070H
	mov	DWORD PTR rgba$[rsp+8], eax
	mov	rcx, rdi
	lea	r8d, QWORD PTR [rdx+15]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits

; 603  : 				};
; 604  : 				if (isSRGB)
; 605  : 				{
; 606  : 					deUint8* const dstU = (deUint8*)dst;
; 607  : 					for (int i = 0; i < blockWidth * blockHeight; i++)
; 608  : 						for (int c = 0; c < 4; c++)
; 609  : 							dstU[i * 4 + c] = (deUint8)((rgba[c] & 0xff00) >> 8);
; 610  : 				}
; 611  : 				else
; 612  : 				{
; 613  : 					float* const dstF = (float*)dst;
; 614  : 					if (isHDRBlock)
; 615  : 					{
; 616  : 						// rg - REMOVING HDR SUPPORT FOR NOW
; 617  : #if 0
; 618  : 						for (int c = 0; c < 4; c++)
; 619  : 						{
; 620  : 							if (isFloat16InfOrNan((deFloat16)rgba[c]))
; 621  : 								throw InternalError("Infinity or NaN color component in HDR void extent block in ASTC texture (behavior undefined by ASTC specification)");
; 622  : 						}
; 623  : 						for (int i = 0; i < blockWidth * blockHeight; i++)
; 624  : 							for (int c = 0; c < 4; c++)
; 625  : 								dstF[i * 4 + c] = deFloat16To32((deFloat16)rgba[c]);
; 626  : #endif
; 627  : 					}
; 628  : 					else
; 629  : 					{
; 630  : 						for (int i = 0; i < blockWidth * blockHeight; i++)

	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm3, DWORD PTR __real@37800000
	imul	ebx, r14d

; 631  : 							for (int c = 0; c < 4; c++)

	xor	edi, edi
	mov	DWORD PTR rgba$[rsp+12], eax
	mov	r11d, edi
	lea	esi, QWORD PTR [rdi+4]
	movsxd	rbx, ebx
	npad	5
$LL10@decodeVoid:
	lea	r9, QWORD PTR [r11*4]
	mov	r10, rdi
	cmp	rbx, 4
	jl	SHORT $LN79@decodeVoid
	mov	r8d, DWORD PTR rgba$[rsp+r9]
	lea	rcx, QWORD PTR [r12+32]
	lea	rdx, QWORD PTR [rbx-4]
	add	rcx, r9
	shr	rdx, 2
	xorps	xmm1, xmm1
	inc	rdx
	cvtsi2ss xmm1, r8
	lea	r10, QWORD PTR [rdx*4]
	npad	7
$LL69@decodeVoid:

; 632  : 								dstF[i * 4 + c] = rgba[c] == 65535 ? 1.0f : (float)rgba[c] / 65536.0f;

	cmp	r8d, 65535				; 0000ffffH
	jne	SHORT $LN61@decodeVoid
	xorps	xmm1, xmm1
	movss	DWORD PTR [rcx-32], xmm2
	cvtsi2ss xmm1, r8
	movss	DWORD PTR [rcx-16], xmm2
	movaps	xmm0, xmm2
	movss	DWORD PTR [rcx], xmm2
	jmp	SHORT $LN68@decodeVoid
$LN61@decodeVoid:
	movaps	xmm0, xmm1
	mulss	xmm0, xmm3
	movss	DWORD PTR [rcx-32], xmm0
	movss	DWORD PTR [rcx-16], xmm0
	movss	DWORD PTR [rcx], xmm0
$LN68@decodeVoid:
	movss	DWORD PTR [rcx+16], xmm0
	add	rcx, 64					; 00000040H
	sub	rdx, 1
	jne	SHORT $LL69@decodeVoid
$LN79@decodeVoid:

; 631  : 							for (int c = 0; c < 4; c++)

	cmp	r10, rbx
	jge	SHORT $LN8@decodeVoid
	mov	r8d, DWORD PTR rgba$[rsp+r9]
	lea	rax, QWORD PTR [r11+r10*4]
	mov	rdx, rbx
	lea	rcx, QWORD PTR [r12+rax*4]
	sub	rdx, r10
$LC13@decodeVoid:

; 632  : 								dstF[i * 4 + c] = rgba[c] == 65535 ? 1.0f : (float)rgba[c] / 65536.0f;

	cmp	r8d, 65535				; 0000ffffH
	jne	SHORT $LN25@decodeVoid
	movaps	xmm0, xmm2
	jmp	SHORT $LN26@decodeVoid
$LN25@decodeVoid:
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r8
	mulss	xmm0, xmm3
$LN26@decodeVoid:
	movss	DWORD PTR [rcx], xmm0
	add	rcx, 16
	sub	rdx, 1
	jne	SHORT $LC13@decodeVoid
$LN8@decodeVoid:

; 603  : 				};
; 604  : 				if (isSRGB)
; 605  : 				{
; 606  : 					deUint8* const dstU = (deUint8*)dst;
; 607  : 					for (int i = 0; i < blockWidth * blockHeight; i++)
; 608  : 						for (int c = 0; c < 4; c++)
; 609  : 							dstU[i * 4 + c] = (deUint8)((rgba[c] & 0xff00) >> 8);
; 610  : 				}
; 611  : 				else
; 612  : 				{
; 613  : 					float* const dstF = (float*)dst;
; 614  : 					if (isHDRBlock)
; 615  : 					{
; 616  : 						// rg - REMOVING HDR SUPPORT FOR NOW
; 617  : #if 0
; 618  : 						for (int c = 0; c < 4; c++)
; 619  : 						{
; 620  : 							if (isFloat16InfOrNan((deFloat16)rgba[c]))
; 621  : 								throw InternalError("Infinity or NaN color component in HDR void extent block in ASTC texture (behavior undefined by ASTC specification)");
; 622  : 						}
; 623  : 						for (int i = 0; i < blockWidth * blockHeight; i++)
; 624  : 							for (int c = 0; c < 4; c++)
; 625  : 								dstF[i * 4 + c] = deFloat16To32((deFloat16)rgba[c]);
; 626  : #endif
; 627  : 					}
; 628  : 					else
; 629  : 					{
; 630  : 						for (int i = 0; i < blockWidth * blockHeight; i++)

	inc	r11
	sub	rsi, 1
	jne	$LL10@decodeVoid

; 633  : 					}
; 634  : 				}
; 635  : 				return DECOMPRESS_RESULT_VALID_BLOCK;

	xor	eax, eax
	jmp	SHORT $LN1@decodeVoid
$LN17@decodeVoid:

; 561  : 				if (isSRGB)

	imul	ebx, r14d

; 562  : 				{
; 563  : 					deUint8* const dstU = (deUint8*)dst;
; 564  : 					for (int i = 0; i < blockWidth * blockHeight; i++)
; 565  : 					{
; 566  : 						dstU[4 * i + 0] = 0xff;
; 567  : 						dstU[4 * i + 1] = 0;
; 568  : 						dstU[4 * i + 2] = 0xff;
; 569  : 						dstU[4 * i + 3] = 0xff;
; 570  : 					}
; 571  : 				}
; 572  : 				else
; 573  : 				{
; 574  : 					float* const dstF = (float*)dst;
; 575  : 					for (int i = 0; i < blockWidth * blockHeight; i++)

	movsxd	rcx, ebx
	test	ebx, ebx
	jle	SHORT $LN36@decodeVoid
	lea	rax, QWORD PTR [r12+8]
	npad	7
$LL37@decodeVoid:

; 576  : 					{
; 577  : 						dstF[4 * i + 0] = 1.0f;

	mov	QWORD PTR [rax-8], 1065353216		; 3f800000H

; 578  : 						dstF[4 * i + 1] = 0.0f;
; 579  : 						dstF[4 * i + 2] = 1.0f;

	mov	DWORD PTR [rax], 1065353216		; 3f800000H

; 580  : 						dstF[4 * i + 3] = 1.0f;

	mov	DWORD PTR [rax+4], 1065353216		; 3f800000H
	lea	rax, QWORD PTR [rax+16]
	sub	rcx, 1
	jne	SHORT $LL37@decodeVoid
$LN36@decodeVoid:

; 593  : 				{
; 594  : 					setASTCErrorColorBlock(dst, blockWidth, blockHeight, isSRGB);
; 595  : 					return DECOMPRESS_RESULT_ERROR;

	mov	eax, 1
$LN1@decodeVoid:

; 636  : 			}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	ret	0
?decodeVoidExtentBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z ENDP ; basisu::astc::`anonymous namespace'::decodeVoidExtentBlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z
_TEXT	SEGMENT
endpointModesDst$ = 80
blockData$ = 88
tv638 = 96
numPartitions$ = 96
extraCemBitsStart$ = 104
?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z PROC ; basisu::astc::`anonymous namespace'::decodeColorEndpointModes, COMDAT

; 638  : 			{

	push	rbx
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 40					; 00000028H
	mov	ebx, r8d
	mov	r14, rcx

; 639  : 				if (numPartitions == 1)

	mov	rcx, rdx
	mov	ebp, r9d
	mov	rsi, rdx
	cmp	r8d, 1
	jne	SHORT $LN8@decodeColo

; 640  : 					endpointModesDst[0] = blockData.getBits(13, 16);

	lea	edx, QWORD PTR [r8+12]
	lea	r8d, QWORD PTR [rdx+3]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
	mov	DWORD PTR [r14], eax

; 660  : 						}
; 661  : 					}
; 662  : 				}
; 663  : 			}

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN8@decodeColo:

; 641  : 				else
; 642  : 				{
; 643  : 					const deUint32 highLevelSelector = blockData.getBits(23, 24);

	mov	edx, 23
	mov	QWORD PTR [rsp+80], rdi
	mov	QWORD PTR [rsp+104], r13
	lea	r8d, QWORD PTR [rdx+1]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
	mov	r13d, eax

; 644  : 					if (highLevelSelector == 0)

	test	eax, eax
	jne	SHORT $LN10@decodeColo

; 645  : 					{
; 646  : 						const deUint32 mode = blockData.getBits(25, 28);

	lea	edx, QWORD PTR [rax+25]
	mov	rcx, rsi
	lea	r8d, QWORD PTR [rax+28]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits

; 647  : 						for (int i = 0; i < numPartitions; i++)

	test	ebx, ebx
	jle	$LN47@decodeColo

; 645  : 					{
; 646  : 						const deUint32 mode = blockData.getBits(25, 28);

	movsxd	rcx, ebx
	mov	rdi, r14
	mov	eax, eax
	rep stosd

; 648  : 							endpointModesDst[i] = mode;
; 649  : 					}

	jmp	$LN47@decodeColo
$LN10@decodeColo:

; 650  : 					else
; 651  : 					{
; 652  : 						for (int partNdx = 0; partNdx < numPartitions; partNdx++)

	test	ebx, ebx
	jle	$LN47@decodeColo
	mov	QWORD PTR [rsp+88], r12
	lea	r9d, DWORD PTR [rbp-3]
	mov	QWORD PTR [rsp+32], r15
	mov	r12d, 4
	sub	r12d, ebp
	mov	r15d, 29
	sub	r15d, ebp
	mov	r11d, 28
	sub	r11d, ebp
	add	r9d, ebx
	mov	r8d, 3
	mov	edi, 25
	sub	r8d, ebp
	mov	ebp, -1					; ffffffffH
	mov	DWORD PTR tv638[rsp], r8d
	npad	6
$LL7@decodeColo:

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	mov	ecx, edi
	mov	eax, edi
	and	ecx, 63					; 0000003fH
	test	edi, edi
	jns	SHORT $LN36@decodeColo
	lea	eax, DWORD PTR [rdi+63]
	sub	ecx, 64					; 00000040H
$LN36@decodeColo:
	sar	eax, 6

; 653  : 						{
; 654  : 							const deUint32 cemClass = highLevelSelector - (blockData.isBitSet(25 + partNdx) ? 0 : 1);

	mov	r10d, r13d

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	cdqe
	mov	rdx, QWORD PTR [rsi+rax*8]

; 655  : 							const deUint32 lowBit0Ndx = numPartitions + 2 * partNdx;
; 656  : 							const deUint32 lowBit1Ndx = numPartitions + 2 * partNdx + 1;
; 657  : 							const deUint32 lowBit0 = blockData.getBit(lowBit0Ndx < 4 ? 25 + lowBit0Ndx : extraCemBitsStart + lowBit0Ndx - 4);

	lea	eax, DWORD PTR [r8+r9]

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	shr	rdx, cl
	mov	ecx, r11d
	not	dl
	and	edx, 1

; 653  : 						{
; 654  : 							const deUint32 cemClass = highLevelSelector - (blockData.isBitSet(25 + partNdx) ? 0 : 1);

	sub	r10d, edx

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	cmp	eax, 4
	cmovae	ecx, ebp
	add	ecx, r9d
	mov	eax, ecx
	jns	SHORT $LN35@decodeColo
	lea	eax, DWORD PTR [rcx+63]
$LN35@decodeColo:
	sar	eax, 6
	movsxd	r8, eax
	and	ecx, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN34@decodeColo
	dec	ecx
	or	ecx, -64				; ffffffffffffffc0H
	inc	ecx
$LN34@decodeColo:
	mov	r8, QWORD PTR [rsi+r8*8]

; 658  : 							const deUint32 lowBit1 = blockData.getBit(lowBit1Ndx < 4 ? 25 + lowBit1Ndx : extraCemBitsStart + lowBit1Ndx - 4);

	lea	eax, DWORD PTR [r12+r9]

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	shr	r8, cl
	and	r8d, 1

; 658  : 							const deUint32 lowBit1 = blockData.getBit(lowBit1Ndx < 4 ? 25 + lowBit1Ndx : extraCemBitsStart + lowBit1Ndx - 4);

	cmp	eax, 4
	lea	eax, DWORD PTR [r15+r9]
	jb	SHORT $LN16@decodeColo
	mov	eax, r9d
$LN16@decodeColo:

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	mov	ecx, eax
	and	ecx, 63					; 0000003fH
	test	eax, eax
	jns	SHORT $LN33@decodeColo
	add	eax, 63					; 0000003fH
	sub	ecx, 64					; 00000040H
$LN33@decodeColo:
	sar	eax, 6

; 650  : 					else
; 651  : 					{
; 652  : 						for (int partNdx = 0; partNdx < numPartitions; partNdx++)

	inc	edi

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	cdqe

; 650  : 					else
; 651  : 					{
; 652  : 						for (int partNdx = 0; partNdx < numPartitions; partNdx++)

	add	r9d, 2

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	mov	rdx, QWORD PTR [rsi+rax*8]

; 659  : 							endpointModesDst[partNdx] = (cemClass << 2) | (lowBit1 << 1) | lowBit0;

	lea	eax, DWORD PTR [r10+r10]

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	shr	rdx, cl

; 659  : 							endpointModesDst[partNdx] = (cemClass << 2) | (lowBit1 << 1) | lowBit0;

	and	edx, 1
	or	edx, eax
	add	edx, edx
	or	edx, r8d
	mov	r8d, DWORD PTR tv638[rsp]
	mov	DWORD PTR [r14], edx
	add	r14, 4
	sub	rbx, 1
	jne	$LL7@decodeColo

; 650  : 					else
; 651  : 					{
; 652  : 						for (int partNdx = 0; partNdx < numPartitions; partNdx++)

	mov	r15, QWORD PTR [rsp+32]
	mov	r12, QWORD PTR [rsp+88]
$LN47@decodeColo:
	mov	rdi, QWORD PTR [rsp+80]
	mov	r13, QWORD PTR [rsp+104]

; 660  : 						}
; 661  : 					}
; 662  : 				}
; 663  : 			}

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?decodeColorEndpointModes@?A0xc6621425@astc@basisu@@YAXPEAIAEBVBlock128@123@HH@Z ENDP ; basisu::astc::`anonymous namespace'::decodeColorEndpointModes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?computeNumColorEndpointValues@?A0xc6621425@astc@basisu@@YAHPEBIH@Z
_TEXT	SEGMENT
endpointModes$ = 8
numPartitions$ = 16
?computeNumColorEndpointValues@?A0xc6621425@astc@basisu@@YAHPEBIH@Z PROC ; basisu::astc::`anonymous namespace'::computeNumColorEndpointValues, COMDAT

; 666  : 				int result = 0;

	xor	eax, eax

; 667  : 				for (int i = 0; i < numPartitions; i++)

	movsxd	r9, edx
	test	edx, edx
	jle	SHORT $LN14@computeNum
	mov	edx, eax
	npad	5
$LL10@computeNum:

; 323  : 				return (endpointMode / 4 + 1) * 2;

	mov	r8d, DWORD PTR [rcx+rdx*4]

; 667  : 				for (int i = 0; i < numPartitions; i++)

	inc	rdx

; 323  : 				return (endpointMode / 4 + 1) * 2;

	shr	r8d, 2

; 668  : 					result += computeNumColorEndpointValues(endpointModes[i]);

	lea	eax, DWORD PTR [rax+r8*2]
	add	eax, 2
	cmp	rdx, r9
	jl	SHORT $LL10@computeNum
$LN14@computeNum:

; 669  : 				return result;
; 670  : 			}

	ret	0
?computeNumColorEndpointValues@?A0xc6621425@astc@basisu@@YAHPEBIH@Z ENDP ; basisu::astc::`anonymous namespace'::computeNumColorEndpointValues
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z
_TEXT	SEGMENT
m$ = 32
dst$ = 112
numValues$ = 120
data$ = 128
numBits$ = 136
?decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z PROC ; basisu::astc::`anonymous namespace'::decodeISETritBlock, COMDAT

; 672  : 			{

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	esi, edx
	mov	r13, rcx

; 673  : 				DE_ASSERT(basisu::inRange(numValues, 1, 5));
; 674  : 				deUint32 m[5];
; 675  : 				m[0] = data.getNext(numBits);

	mov	edx, r9d
	mov	rcx, r8
	mov	edi, r9d
	mov	rbx, r8
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 676  : 				deUint32 T01 = data.getNext(2);

	mov	edx, 2
	mov	DWORD PTR m$[rsp], eax
	mov	rcx, rbx
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 677  : 				m[1] = data.getNext(numBits);

	mov	edx, edi
	mov	r12d, eax
	mov	rcx, rbx
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 678  : 				deUint32 T23 = data.getNext(2);

	mov	edx, 2
	mov	DWORD PTR m$[rsp+4], eax
	mov	rcx, rbx
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 679  : 				m[2] = data.getNext(numBits);

	mov	edx, edi
	mov	rcx, rbx
	mov	ebp, eax
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 680  : 				deUint32 T4 = data.getNext(1);

	mov	edx, 1
	mov	DWORD PTR m$[rsp+8], eax
	mov	rcx, rbx
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 681  : 				m[3] = data.getNext(numBits);

	mov	edx, edi
	mov	rcx, rbx
	mov	r14d, eax
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 682  : 				deUint32 T56 = data.getNext(2);

	mov	edx, 2
	mov	DWORD PTR m$[rsp+12], eax
	mov	rcx, rbx
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 683  : 				m[4] = data.getNext(numBits);

	mov	edx, edi
	mov	rcx, rbx
	mov	r15d, eax
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 684  : 				deUint32 T7 = data.getNext(1);

	mov	edx, 1
	mov	DWORD PTR m$[rsp+16], eax
	mov	rcx, rbx
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 685  : 				switch (numValues)

	mov	edx, esi
	sub	edx, 1
	je	SHORT $LN7@decodeISET
	sub	edx, 1
	je	SHORT $LN8@decodeISET
	sub	edx, 1
	je	SHORT $LN9@decodeISET
	cmp	edx, 1
	je	SHORT $LN10@decodeISET
	jmp	SHORT $LN12@decodeISET
$LN7@decodeISET:

; 686  : 				{
; 687  : 					// \note Fall-throughs.
; 688  : 				case 1: T23 = 0;

	xor	ebp, ebp
$LN8@decodeISET:

; 689  : 				case 2: T4 = 0;

	xor	r14d, r14d
$LN9@decodeISET:

; 690  : 				case 3: T56 = 0;

	xor	r15d, r15d
$LN10@decodeISET:

; 691  : 				case 4: T7 = 0;

	xor	eax, eax
$LN12@decodeISET:

; 692  : 				case 5: break;
; 693  : 				default:
; 694  : 					DE_ASSERT(false);
; 695  : 				}
; 696  : 				const deUint32 T = (T7 << 7) | (T56 << 5) | (T4 << 4) | (T23 << 2) | (T01 << 0);

	lea	eax, DWORD PTR [rax*4]
	or	eax, r15d
	lea	ecx, DWORD PTR [rax+rax]
	or	ecx, r14d
	shl	ecx, 2
	or	ecx, ebp
	shl	ecx, 2
	or	rcx, r12

; 697  : 				static const deUint32 tritsFromT[256][5] =
; 698  : 				{
; 699  : 					{ 0,0,0,0,0 }, { 1,0,0,0,0 }, { 2,0,0,0,0 }, { 0,0,2,0,0 }, { 0,1,0,0,0 }, { 1,1,0,0,0 }, { 2,1,0,0,0 }, { 1,0,2,0,0 }, { 0,2,0,0,0 }, { 1,2,0,0,0 }, { 2,2,0,0,0 }, { 2,0,2,0,0 }, { 0,2,2,0,0 }, { 1,2,2,0,0 }, { 2,2,2,0,0 }, { 2,0,2,0,0 },
; 700  : 					{ 0,0,1,0,0 }, { 1,0,1,0,0 }, { 2,0,1,0,0 }, { 0,1,2,0,0 }, { 0,1,1,0,0 }, { 1,1,1,0,0 }, { 2,1,1,0,0 }, { 1,1,2,0,0 }, { 0,2,1,0,0 }, { 1,2,1,0,0 }, { 2,2,1,0,0 }, { 2,1,2,0,0 }, { 0,0,0,2,2 }, { 1,0,0,2,2 }, { 2,0,0,2,2 }, { 0,0,2,2,2 },
; 701  : 					{ 0,0,0,1,0 }, { 1,0,0,1,0 }, { 2,0,0,1,0 }, { 0,0,2,1,0 }, { 0,1,0,1,0 }, { 1,1,0,1,0 }, { 2,1,0,1,0 }, { 1,0,2,1,0 }, { 0,2,0,1,0 }, { 1,2,0,1,0 }, { 2,2,0,1,0 }, { 2,0,2,1,0 }, { 0,2,2,1,0 }, { 1,2,2,1,0 }, { 2,2,2,1,0 }, { 2,0,2,1,0 },
; 702  : 					{ 0,0,1,1,0 }, { 1,0,1,1,0 }, { 2,0,1,1,0 }, { 0,1,2,1,0 }, { 0,1,1,1,0 }, { 1,1,1,1,0 }, { 2,1,1,1,0 }, { 1,1,2,1,0 }, { 0,2,1,1,0 }, { 1,2,1,1,0 }, { 2,2,1,1,0 }, { 2,1,2,1,0 }, { 0,1,0,2,2 }, { 1,1,0,2,2 }, { 2,1,0,2,2 }, { 1,0,2,2,2 },
; 703  : 					{ 0,0,0,2,0 }, { 1,0,0,2,0 }, { 2,0,0,2,0 }, { 0,0,2,2,0 }, { 0,1,0,2,0 }, { 1,1,0,2,0 }, { 2,1,0,2,0 }, { 1,0,2,2,0 }, { 0,2,0,2,0 }, { 1,2,0,2,0 }, { 2,2,0,2,0 }, { 2,0,2,2,0 }, { 0,2,2,2,0 }, { 1,2,2,2,0 }, { 2,2,2,2,0 }, { 2,0,2,2,0 },
; 704  : 					{ 0,0,1,2,0 }, { 1,0,1,2,0 }, { 2,0,1,2,0 }, { 0,1,2,2,0 }, { 0,1,1,2,0 }, { 1,1,1,2,0 }, { 2,1,1,2,0 }, { 1,1,2,2,0 }, { 0,2,1,2,0 }, { 1,2,1,2,0 }, { 2,2,1,2,0 }, { 2,1,2,2,0 }, { 0,2,0,2,2 }, { 1,2,0,2,2 }, { 2,2,0,2,2 }, { 2,0,2,2,2 },
; 705  : 					{ 0,0,0,0,2 }, { 1,0,0,0,2 }, { 2,0,0,0,2 }, { 0,0,2,0,2 }, { 0,1,0,0,2 }, { 1,1,0,0,2 }, { 2,1,0,0,2 }, { 1,0,2,0,2 }, { 0,2,0,0,2 }, { 1,2,0,0,2 }, { 2,2,0,0,2 }, { 2,0,2,0,2 }, { 0,2,2,0,2 }, { 1,2,2,0,2 }, { 2,2,2,0,2 }, { 2,0,2,0,2 },
; 706  : 					{ 0,0,1,0,2 }, { 1,0,1,0,2 }, { 2,0,1,0,2 }, { 0,1,2,0,2 }, { 0,1,1,0,2 }, { 1,1,1,0,2 }, { 2,1,1,0,2 }, { 1,1,2,0,2 }, { 0,2,1,0,2 }, { 1,2,1,0,2 }, { 2,2,1,0,2 }, { 2,1,2,0,2 }, { 0,2,2,2,2 }, { 1,2,2,2,2 }, { 2,2,2,2,2 }, { 2,0,2,2,2 },
; 707  : 					{ 0,0,0,0,1 }, { 1,0,0,0,1 }, { 2,0,0,0,1 }, { 0,0,2,0,1 }, { 0,1,0,0,1 }, { 1,1,0,0,1 }, { 2,1,0,0,1 }, { 1,0,2,0,1 }, { 0,2,0,0,1 }, { 1,2,0,0,1 }, { 2,2,0,0,1 }, { 2,0,2,0,1 }, { 0,2,2,0,1 }, { 1,2,2,0,1 }, { 2,2,2,0,1 }, { 2,0,2,0,1 },
; 708  : 					{ 0,0,1,0,1 }, { 1,0,1,0,1 }, { 2,0,1,0,1 }, { 0,1,2,0,1 }, { 0,1,1,0,1 }, { 1,1,1,0,1 }, { 2,1,1,0,1 }, { 1,1,2,0,1 }, { 0,2,1,0,1 }, { 1,2,1,0,1 }, { 2,2,1,0,1 }, { 2,1,2,0,1 }, { 0,0,1,2,2 }, { 1,0,1,2,2 }, { 2,0,1,2,2 }, { 0,1,2,2,2 },
; 709  : 					{ 0,0,0,1,1 }, { 1,0,0,1,1 }, { 2,0,0,1,1 }, { 0,0,2,1,1 }, { 0,1,0,1,1 }, { 1,1,0,1,1 }, { 2,1,0,1,1 }, { 1,0,2,1,1 }, { 0,2,0,1,1 }, { 1,2,0,1,1 }, { 2,2,0,1,1 }, { 2,0,2,1,1 }, { 0,2,2,1,1 }, { 1,2,2,1,1 }, { 2,2,2,1,1 }, { 2,0,2,1,1 },
; 710  : 					{ 0,0,1,1,1 }, { 1,0,1,1,1 }, { 2,0,1,1,1 }, { 0,1,2,1,1 }, { 0,1,1,1,1 }, { 1,1,1,1,1 }, { 2,1,1,1,1 }, { 1,1,2,1,1 }, { 0,2,1,1,1 }, { 1,2,1,1,1 }, { 2,2,1,1,1 }, { 2,1,2,1,1 }, { 0,1,1,2,2 }, { 1,1,1,2,2 }, { 2,1,1,2,2 }, { 1,1,2,2,2 },
; 711  : 					{ 0,0,0,2,1 }, { 1,0,0,2,1 }, { 2,0,0,2,1 }, { 0,0,2,2,1 }, { 0,1,0,2,1 }, { 1,1,0,2,1 }, { 2,1,0,2,1 }, { 1,0,2,2,1 }, { 0,2,0,2,1 }, { 1,2,0,2,1 }, { 2,2,0,2,1 }, { 2,0,2,2,1 }, { 0,2,2,2,1 }, { 1,2,2,2,1 }, { 2,2,2,2,1 }, { 2,0,2,2,1 },
; 712  : 					{ 0,0,1,2,1 }, { 1,0,1,2,1 }, { 2,0,1,2,1 }, { 0,1,2,2,1 }, { 0,1,1,2,1 }, { 1,1,1,2,1 }, { 2,1,1,2,1 }, { 1,1,2,2,1 }, { 0,2,1,2,1 }, { 1,2,1,2,1 }, { 2,2,1,2,1 }, { 2,1,2,2,1 }, { 0,2,1,2,2 }, { 1,2,1,2,2 }, { 2,2,1,2,2 }, { 2,1,2,2,2 },
; 713  : 					{ 0,0,0,1,2 }, { 1,0,0,1,2 }, { 2,0,0,1,2 }, { 0,0,2,1,2 }, { 0,1,0,1,2 }, { 1,1,0,1,2 }, { 2,1,0,1,2 }, { 1,0,2,1,2 }, { 0,2,0,1,2 }, { 1,2,0,1,2 }, { 2,2,0,1,2 }, { 2,0,2,1,2 }, { 0,2,2,1,2 }, { 1,2,2,1,2 }, { 2,2,2,1,2 }, { 2,0,2,1,2 },
; 714  : 					{ 0,0,1,1,2 }, { 1,0,1,1,2 }, { 2,0,1,1,2 }, { 0,1,2,1,2 }, { 0,1,1,1,2 }, { 1,1,1,1,2 }, { 2,1,1,1,2 }, { 1,1,2,1,2 }, { 0,2,1,1,2 }, { 1,2,1,1,2 }, { 2,2,1,1,2 }, { 2,1,2,1,2 }, { 0,2,2,2,2 }, { 1,2,2,2,2 }, { 2,2,2,2,2 }, { 2,1,2,2,2 }
; 715  : 				};
; 716  : 				const deUint32(&trits)[5] = tritsFromT[T];

	lea	rax, QWORD PTR [rcx+rcx*4]
	lea	rcx, OFFSET FLAT:?tritsFromT@?1??decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@234@HAEAVBitAccessStream@234@H@Z@4QAY04$$CBIA
	lea	rax, QWORD PTR [rcx+rax*4]

; 717  : 				for (int i = 0; i < numValues; i++)

	test	esi, esi
	jle	SHORT $LN5@decodeISET
	lea	r11, QWORD PTR m$[rsp]
	mov	r10, rsi
	sub	r11, rax
	lea	r9, QWORD PTR [r13+8]
	npad	7
$LL6@decodeISET:

; 718  : 				{
; 719  : 					dst[i].m = m[i];

	mov	r8d, DWORD PTR [r11+rax]
	lea	rax, QWORD PTR [rax+4]
	mov	DWORD PTR [r9-8], r8d
	lea	r9, QWORD PTR [r9+12]

; 720  : 					dst[i].tq = trits[i];

	mov	ecx, DWORD PTR [rax-4]
	mov	DWORD PTR [r9-16], ecx

; 721  : 					dst[i].v = (trits[i] << numBits) + m[i];

	mov	ecx, edi
	mov	edx, DWORD PTR [rax-4]
	shl	edx, cl
	add	edx, r8d
	mov	DWORD PTR [r9-12], edx
	sub	r10, 1
	jne	SHORT $LL6@decodeISET
$LN5@decodeISET:

; 722  : 				}
; 723  : 			}

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z ENDP ; basisu::astc::`anonymous namespace'::decodeISETritBlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z
_TEXT	SEGMENT
m$ = 32
dst$ = 80
numValues$ = 88
data$ = 96
numBits$ = 104
?decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z PROC ; basisu::astc::`anonymous namespace'::decodeISEQuintBlock, COMDAT

; 725  : 			{

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	esi, edx
	mov	r14, rcx

; 726  : 				DE_ASSERT(basisu::inRange(numValues, 1, 3));
; 727  : 				deUint32 m[3];
; 728  : 				m[0] = data.getNext(numBits);

	mov	edx, r9d
	mov	rcx, r8
	mov	edi, r9d
	mov	rbx, r8
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 729  : 				deUint32 Q012 = data.getNext(3);

	mov	edx, 3
	mov	DWORD PTR m$[rsp], eax
	mov	rcx, rbx
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 730  : 				m[1] = data.getNext(numBits);

	mov	edx, edi
	mov	r15d, eax
	mov	rcx, rbx
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 731  : 				deUint32 Q34 = data.getNext(2);

	mov	edx, 2
	mov	DWORD PTR m$[rsp+4], eax
	mov	rcx, rbx
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 732  : 				m[2] = data.getNext(numBits);

	mov	edx, edi
	mov	rcx, rbx
	mov	ebp, eax
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 733  : 				deUint32 Q56 = data.getNext(2);

	mov	edx, 2
	mov	DWORD PTR m$[rsp+8], eax
	mov	rcx, rbx
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 734  : 				switch (numValues)

	mov	edx, esi
	sub	edx, 1
	je	SHORT $LN7@decodeISEQ
	cmp	edx, 1
	je	SHORT $LN8@decodeISEQ
	jmp	SHORT $LN10@decodeISEQ
$LN7@decodeISEQ:

; 735  : 				{
; 736  : 					// \note Fall-throughs.
; 737  : 				case 1: Q34 = 0;

	xor	ebp, ebp
$LN8@decodeISEQ:

; 738  : 				case 2: Q56 = 0;

	xor	eax, eax
$LN10@decodeISEQ:

; 739  : 				case 3: break;
; 740  : 				default:
; 741  : 					DE_ASSERT(false);
; 742  : 				}
; 743  : 				const deUint32 Q = (Q56 << 5) | (Q34 << 3) | (Q012 << 0);

	lea	ecx, DWORD PTR [rax*4]
	or	ecx, ebp
	shl	ecx, 3
	or	rcx, r15

; 744  : 				static const deUint32 quintsFromQ[256][3] =
; 745  : 				{
; 746  : 					{ 0,0,0 }, { 1,0,0 }, { 2,0,0 }, { 3,0,0 }, { 4,0,0 }, { 0,4,0 }, { 4,4,0 }, { 4,4,4 }, { 0,1,0 }, { 1,1,0 }, { 2,1,0 }, { 3,1,0 }, { 4,1,0 }, { 1,4,0 }, { 4,4,1 }, { 4,4,4 },
; 747  : 					{ 0,2,0 }, { 1,2,0 }, { 2,2,0 }, { 3,2,0 }, { 4,2,0 }, { 2,4,0 }, { 4,4,2 }, { 4,4,4 }, { 0,3,0 }, { 1,3,0 }, { 2,3,0 }, { 3,3,0 }, { 4,3,0 }, { 3,4,0 }, { 4,4,3 }, { 4,4,4 },
; 748  : 					{ 0,0,1 }, { 1,0,1 }, { 2,0,1 }, { 3,0,1 }, { 4,0,1 }, { 0,4,1 }, { 4,0,4 }, { 0,4,4 }, { 0,1,1 }, { 1,1,1 }, { 2,1,1 }, { 3,1,1 }, { 4,1,1 }, { 1,4,1 }, { 4,1,4 }, { 1,4,4 },
; 749  : 					{ 0,2,1 }, { 1,2,1 }, { 2,2,1 }, { 3,2,1 }, { 4,2,1 }, { 2,4,1 }, { 4,2,4 }, { 2,4,4 }, { 0,3,1 }, { 1,3,1 }, { 2,3,1 }, { 3,3,1 }, { 4,3,1 }, { 3,4,1 }, { 4,3,4 }, { 3,4,4 },
; 750  : 					{ 0,0,2 }, { 1,0,2 }, { 2,0,2 }, { 3,0,2 }, { 4,0,2 }, { 0,4,2 }, { 2,0,4 }, { 3,0,4 }, { 0,1,2 }, { 1,1,2 }, { 2,1,2 }, { 3,1,2 }, { 4,1,2 }, { 1,4,2 }, { 2,1,4 }, { 3,1,4 },
; 751  : 					{ 0,2,2 }, { 1,2,2 }, { 2,2,2 }, { 3,2,2 }, { 4,2,2 }, { 2,4,2 }, { 2,2,4 }, { 3,2,4 }, { 0,3,2 }, { 1,3,2 }, { 2,3,2 }, { 3,3,2 }, { 4,3,2 }, { 3,4,2 }, { 2,3,4 }, { 3,3,4 },
; 752  : 					{ 0,0,3 }, { 1,0,3 }, { 2,0,3 }, { 3,0,3 }, { 4,0,3 }, { 0,4,3 }, { 0,0,4 }, { 1,0,4 }, { 0,1,3 }, { 1,1,3 }, { 2,1,3 }, { 3,1,3 }, { 4,1,3 }, { 1,4,3 }, { 0,1,4 }, { 1,1,4 },
; 753  : 					{ 0,2,3 }, { 1,2,3 }, { 2,2,3 }, { 3,2,3 }, { 4,2,3 }, { 2,4,3 }, { 0,2,4 }, { 1,2,4 }, { 0,3,3 }, { 1,3,3 }, { 2,3,3 }, { 3,3,3 }, { 4,3,3 }, { 3,4,3 }, { 0,3,4 }, { 1,3,4 }
; 754  : 				};
; 755  : 				const deUint32(&quints)[3] = quintsFromQ[Q];

	lea	rax, QWORD PTR [rcx+rcx*2]
	lea	rcx, OFFSET FLAT:?quintsFromQ@?1??decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@234@HAEAVBitAccessStream@234@H@Z@4QAY02$$CBIA
	lea	rax, QWORD PTR [rcx+rax*4]

; 756  : 				for (int i = 0; i < numValues; i++)

	test	esi, esi
	jle	SHORT $LN5@decodeISEQ
	lea	r11, QWORD PTR m$[rsp]
	mov	r10, rsi
	sub	r11, rax
	lea	r9, QWORD PTR [r14+8]
	npad	3
$LL6@decodeISEQ:

; 757  : 				{
; 758  : 					dst[i].m = m[i];

	mov	r8d, DWORD PTR [r11+rax]
	lea	rax, QWORD PTR [rax+4]
	mov	DWORD PTR [r9-8], r8d
	lea	r9, QWORD PTR [r9+12]

; 759  : 					dst[i].tq = quints[i];

	mov	ecx, DWORD PTR [rax-4]
	mov	DWORD PTR [r9-16], ecx

; 760  : 					dst[i].v = (quints[i] << numBits) + m[i];

	mov	ecx, edi
	mov	edx, DWORD PTR [rax-4]
	shl	edx, cl
	add	edx, r8d
	mov	DWORD PTR [r9-12], edx
	sub	r10, 1
	jne	SHORT $LL6@decodeISEQ
$LN5@decodeISEQ:

; 761  : 				}
; 762  : 			}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@H@Z ENDP ; basisu::astc::`anonymous namespace'::decodeISEQuintBlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decodeISEBitBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@AEAVBitAccessStream@123@H@Z
_TEXT	SEGMENT
dst$ = 48
data$ = 56
numBits$ = 64
?decodeISEBitBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@AEAVBitAccessStream@123@H@Z PROC ; basisu::astc::`anonymous namespace'::decodeISEBitBlock, COMDAT

; 764  : 			{

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, rdx
	mov	rbx, rcx

; 765  : 				dst[0].m = data.getNext(numBits);

	mov	rcx, rax
	mov	edx, r8d
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext
	mov	DWORD PTR [rbx], eax

; 766  : 				dst[0].v = dst[0].m;

	mov	DWORD PTR [rbx+8], eax

; 767  : 			}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?decodeISEBitBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@AEAVBitAccessStream@123@H@Z ENDP ; basisu::astc::`anonymous namespace'::decodeISEBitBlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z
_TEXT	SEGMENT
T4$1$ = 32
T23$1$ = 36
tv1029 = 40
tv1027 = 40
m$1 = 48
m$2 = 48
dst$ = 144
numValues$ = 152
data$ = 160
params$ = 168
?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z PROC ; basisu::astc::`anonymous namespace'::decodeISE, COMDAT

; 769  : 			{

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+16], edx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 770  : 				if (params.mode == ISEMODE_TRIT)

	mov	eax, DWORD PTR [r9]
	mov	rsi, r8
	movsxd	r8, edx
	mov	rbx, rcx
	test	eax, eax
	jne	$LN11@decodeISE

; 192  : 		return (a + b - 1) / b;

	lea	r10d, DWORD PTR [r8+4]
	mov	eax, -858993459				; cccccccdH
	mul	r10d

; 771  : 				{
; 772  : 					const int numBlocks = deDivRoundUp32(numValues, 5);
; 773  : 					for (int blockNdx = 0; blockNdx < numBlocks; blockNdx++)

	xor	ebp, ebp

; 192  : 		return (a + b - 1) / b;

	mov	r15d, edx
	shr	r15d, 2

; 771  : 				{
; 772  : 					const int numBlocks = deDivRoundUp32(numValues, 5);
; 773  : 					for (int blockNdx = 0; blockNdx < numBlocks; blockNdx++)

	mov	r12d, r15d
	test	r15d, r15d
	jle	$LN9@decodeISE
	lea	eax, DWORD PTR [r15-1]
	lea	r14, QWORD PTR [rcx+8]
	npad	6
$LL4@decodeISE:

; 774  : 					{
; 775  : 						const int numValuesInBlock = blockNdx == numBlocks - 1 ? numValues - 5 * (numBlocks - 1) : 5;

	cmp	ebp, eax
	jne	SHORT $LN16@decodeISE
	lea	eax, DWORD PTR [r15+r15*4]
	mov	ebx, r8d
	sub	ebx, eax
	add	ebx, 5
	jmp	SHORT $LN17@decodeISE
$LN16@decodeISE:
	mov	ebx, 5
$LN17@decodeISE:

; 776  : 						decodeISETritBlock(&dst[5 * blockNdx], numValuesInBlock, data, params.numBits);

	mov	edi, DWORD PTR [r9+4]

; 675  : 				m[0] = data.getNext(numBits);

	mov	rcx, rsi
	mov	edx, edi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 676  : 				deUint32 T01 = data.getNext(2);

	mov	edx, 2
	mov	DWORD PTR m$2[rsp], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 677  : 				m[1] = data.getNext(numBits);

	mov	edx, edi
	mov	DWORD PTR tv1029[rsp], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 678  : 				deUint32 T23 = data.getNext(2);

	mov	edx, 2
	mov	DWORD PTR m$2[rsp+4], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 679  : 				m[2] = data.getNext(numBits);

	mov	edx, edi
	mov	DWORD PTR T23$1$[rsp], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 680  : 				deUint32 T4 = data.getNext(1);

	mov	edx, 1
	mov	DWORD PTR m$2[rsp+8], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 681  : 				m[3] = data.getNext(numBits);

	mov	edx, edi
	mov	DWORD PTR T4$1$[rsp], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 682  : 				deUint32 T56 = data.getNext(2);

	mov	edx, 2
	mov	DWORD PTR m$2[rsp+12], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 683  : 				m[4] = data.getNext(numBits);

	mov	edx, edi
	mov	rcx, rsi
	mov	r13d, eax
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 684  : 				deUint32 T7 = data.getNext(1);

	mov	edx, 1
	mov	DWORD PTR m$2[rsp+16], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 685  : 				switch (numValues)

	mov	edx, ebx
	sub	edx, 1
	je	SHORT $LN28@decodeISE
	sub	edx, 1
	je	SHORT $LN29@decodeISE
	sub	edx, 1
	je	SHORT $LN30@decodeISE
	cmp	edx, 1
	je	SHORT $LN31@decodeISE
	jmp	SHORT $LN33@decodeISE
$LN28@decodeISE:

; 686  : 				{
; 687  : 					// \note Fall-throughs.
; 688  : 				case 1: T23 = 0;

	mov	DWORD PTR T23$1$[rsp], 0
$LN29@decodeISE:

; 689  : 				case 2: T4 = 0;

	mov	DWORD PTR T4$1$[rsp], 0
$LN30@decodeISE:

; 690  : 				case 3: T56 = 0;

	xor	r13d, r13d
$LN31@decodeISE:

; 691  : 				case 4: T7 = 0;

	xor	eax, eax
$LN33@decodeISE:

; 692  : 				case 5: break;
; 693  : 				default:
; 694  : 					DE_ASSERT(false);
; 695  : 				}
; 696  : 				const deUint32 T = (T7 << 7) | (T56 << 5) | (T4 << 4) | (T23 << 2) | (T01 << 0);

	lea	eax, DWORD PTR [rax*4]
	or	eax, r13d
	lea	ecx, DWORD PTR [rax+rax]
	mov	eax, DWORD PTR tv1029[rsp]
	or	ecx, DWORD PTR T4$1$[rsp]
	shl	ecx, 2
	or	ecx, DWORD PTR T23$1$[rsp]
	shl	ecx, 2
	or	rcx, rax

; 697  : 				static const deUint32 tritsFromT[256][5] =
; 698  : 				{
; 699  : 					{ 0,0,0,0,0 }, { 1,0,0,0,0 }, { 2,0,0,0,0 }, { 0,0,2,0,0 }, { 0,1,0,0,0 }, { 1,1,0,0,0 }, { 2,1,0,0,0 }, { 1,0,2,0,0 }, { 0,2,0,0,0 }, { 1,2,0,0,0 }, { 2,2,0,0,0 }, { 2,0,2,0,0 }, { 0,2,2,0,0 }, { 1,2,2,0,0 }, { 2,2,2,0,0 }, { 2,0,2,0,0 },
; 700  : 					{ 0,0,1,0,0 }, { 1,0,1,0,0 }, { 2,0,1,0,0 }, { 0,1,2,0,0 }, { 0,1,1,0,0 }, { 1,1,1,0,0 }, { 2,1,1,0,0 }, { 1,1,2,0,0 }, { 0,2,1,0,0 }, { 1,2,1,0,0 }, { 2,2,1,0,0 }, { 2,1,2,0,0 }, { 0,0,0,2,2 }, { 1,0,0,2,2 }, { 2,0,0,2,2 }, { 0,0,2,2,2 },
; 701  : 					{ 0,0,0,1,0 }, { 1,0,0,1,0 }, { 2,0,0,1,0 }, { 0,0,2,1,0 }, { 0,1,0,1,0 }, { 1,1,0,1,0 }, { 2,1,0,1,0 }, { 1,0,2,1,0 }, { 0,2,0,1,0 }, { 1,2,0,1,0 }, { 2,2,0,1,0 }, { 2,0,2,1,0 }, { 0,2,2,1,0 }, { 1,2,2,1,0 }, { 2,2,2,1,0 }, { 2,0,2,1,0 },
; 702  : 					{ 0,0,1,1,0 }, { 1,0,1,1,0 }, { 2,0,1,1,0 }, { 0,1,2,1,0 }, { 0,1,1,1,0 }, { 1,1,1,1,0 }, { 2,1,1,1,0 }, { 1,1,2,1,0 }, { 0,2,1,1,0 }, { 1,2,1,1,0 }, { 2,2,1,1,0 }, { 2,1,2,1,0 }, { 0,1,0,2,2 }, { 1,1,0,2,2 }, { 2,1,0,2,2 }, { 1,0,2,2,2 },
; 703  : 					{ 0,0,0,2,0 }, { 1,0,0,2,0 }, { 2,0,0,2,0 }, { 0,0,2,2,0 }, { 0,1,0,2,0 }, { 1,1,0,2,0 }, { 2,1,0,2,0 }, { 1,0,2,2,0 }, { 0,2,0,2,0 }, { 1,2,0,2,0 }, { 2,2,0,2,0 }, { 2,0,2,2,0 }, { 0,2,2,2,0 }, { 1,2,2,2,0 }, { 2,2,2,2,0 }, { 2,0,2,2,0 },
; 704  : 					{ 0,0,1,2,0 }, { 1,0,1,2,0 }, { 2,0,1,2,0 }, { 0,1,2,2,0 }, { 0,1,1,2,0 }, { 1,1,1,2,0 }, { 2,1,1,2,0 }, { 1,1,2,2,0 }, { 0,2,1,2,0 }, { 1,2,1,2,0 }, { 2,2,1,2,0 }, { 2,1,2,2,0 }, { 0,2,0,2,2 }, { 1,2,0,2,2 }, { 2,2,0,2,2 }, { 2,0,2,2,2 },
; 705  : 					{ 0,0,0,0,2 }, { 1,0,0,0,2 }, { 2,0,0,0,2 }, { 0,0,2,0,2 }, { 0,1,0,0,2 }, { 1,1,0,0,2 }, { 2,1,0,0,2 }, { 1,0,2,0,2 }, { 0,2,0,0,2 }, { 1,2,0,0,2 }, { 2,2,0,0,2 }, { 2,0,2,0,2 }, { 0,2,2,0,2 }, { 1,2,2,0,2 }, { 2,2,2,0,2 }, { 2,0,2,0,2 },
; 706  : 					{ 0,0,1,0,2 }, { 1,0,1,0,2 }, { 2,0,1,0,2 }, { 0,1,2,0,2 }, { 0,1,1,0,2 }, { 1,1,1,0,2 }, { 2,1,1,0,2 }, { 1,1,2,0,2 }, { 0,2,1,0,2 }, { 1,2,1,0,2 }, { 2,2,1,0,2 }, { 2,1,2,0,2 }, { 0,2,2,2,2 }, { 1,2,2,2,2 }, { 2,2,2,2,2 }, { 2,0,2,2,2 },
; 707  : 					{ 0,0,0,0,1 }, { 1,0,0,0,1 }, { 2,0,0,0,1 }, { 0,0,2,0,1 }, { 0,1,0,0,1 }, { 1,1,0,0,1 }, { 2,1,0,0,1 }, { 1,0,2,0,1 }, { 0,2,0,0,1 }, { 1,2,0,0,1 }, { 2,2,0,0,1 }, { 2,0,2,0,1 }, { 0,2,2,0,1 }, { 1,2,2,0,1 }, { 2,2,2,0,1 }, { 2,0,2,0,1 },
; 708  : 					{ 0,0,1,0,1 }, { 1,0,1,0,1 }, { 2,0,1,0,1 }, { 0,1,2,0,1 }, { 0,1,1,0,1 }, { 1,1,1,0,1 }, { 2,1,1,0,1 }, { 1,1,2,0,1 }, { 0,2,1,0,1 }, { 1,2,1,0,1 }, { 2,2,1,0,1 }, { 2,1,2,0,1 }, { 0,0,1,2,2 }, { 1,0,1,2,2 }, { 2,0,1,2,2 }, { 0,1,2,2,2 },
; 709  : 					{ 0,0,0,1,1 }, { 1,0,0,1,1 }, { 2,0,0,1,1 }, { 0,0,2,1,1 }, { 0,1,0,1,1 }, { 1,1,0,1,1 }, { 2,1,0,1,1 }, { 1,0,2,1,1 }, { 0,2,0,1,1 }, { 1,2,0,1,1 }, { 2,2,0,1,1 }, { 2,0,2,1,1 }, { 0,2,2,1,1 }, { 1,2,2,1,1 }, { 2,2,2,1,1 }, { 2,0,2,1,1 },
; 710  : 					{ 0,0,1,1,1 }, { 1,0,1,1,1 }, { 2,0,1,1,1 }, { 0,1,2,1,1 }, { 0,1,1,1,1 }, { 1,1,1,1,1 }, { 2,1,1,1,1 }, { 1,1,2,1,1 }, { 0,2,1,1,1 }, { 1,2,1,1,1 }, { 2,2,1,1,1 }, { 2,1,2,1,1 }, { 0,1,1,2,2 }, { 1,1,1,2,2 }, { 2,1,1,2,2 }, { 1,1,2,2,2 },
; 711  : 					{ 0,0,0,2,1 }, { 1,0,0,2,1 }, { 2,0,0,2,1 }, { 0,0,2,2,1 }, { 0,1,0,2,1 }, { 1,1,0,2,1 }, { 2,1,0,2,1 }, { 1,0,2,2,1 }, { 0,2,0,2,1 }, { 1,2,0,2,1 }, { 2,2,0,2,1 }, { 2,0,2,2,1 }, { 0,2,2,2,1 }, { 1,2,2,2,1 }, { 2,2,2,2,1 }, { 2,0,2,2,1 },
; 712  : 					{ 0,0,1,2,1 }, { 1,0,1,2,1 }, { 2,0,1,2,1 }, { 0,1,2,2,1 }, { 0,1,1,2,1 }, { 1,1,1,2,1 }, { 2,1,1,2,1 }, { 1,1,2,2,1 }, { 0,2,1,2,1 }, { 1,2,1,2,1 }, { 2,2,1,2,1 }, { 2,1,2,2,1 }, { 0,2,1,2,2 }, { 1,2,1,2,2 }, { 2,2,1,2,2 }, { 2,1,2,2,2 },
; 713  : 					{ 0,0,0,1,2 }, { 1,0,0,1,2 }, { 2,0,0,1,2 }, { 0,0,2,1,2 }, { 0,1,0,1,2 }, { 1,1,0,1,2 }, { 2,1,0,1,2 }, { 1,0,2,1,2 }, { 0,2,0,1,2 }, { 1,2,0,1,2 }, { 2,2,0,1,2 }, { 2,0,2,1,2 }, { 0,2,2,1,2 }, { 1,2,2,1,2 }, { 2,2,2,1,2 }, { 2,0,2,1,2 },
; 714  : 					{ 0,0,1,1,2 }, { 1,0,1,1,2 }, { 2,0,1,1,2 }, { 0,1,2,1,2 }, { 0,1,1,1,2 }, { 1,1,1,1,2 }, { 2,1,1,1,2 }, { 1,1,2,1,2 }, { 0,2,1,1,2 }, { 1,2,1,1,2 }, { 2,2,1,1,2 }, { 2,1,2,1,2 }, { 0,2,2,2,2 }, { 1,2,2,2,2 }, { 2,2,2,2,2 }, { 2,1,2,2,2 }
; 715  : 				};
; 716  : 				const deUint32(&trits)[5] = tritsFromT[T];

	lea	rax, QWORD PTR [rcx+rcx*4]
	lea	rcx, OFFSET FLAT:__ImageBase
	lea	r8, QWORD PTR ?tritsFromT@?1??decodeISETritBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@234@HAEAVBitAccessStream@234@H@Z@4QAY04$$CBIA[rcx]
	lea	r8, QWORD PTR [r8+rax*4]

; 717  : 				for (int i = 0; i < numValues; i++)

	test	ebx, ebx
	jle	SHORT $LN2@decodeISE

; 692  : 				case 5: break;
; 693  : 				default:
; 694  : 					DE_ASSERT(false);
; 695  : 				}
; 696  : 				const deUint32 T = (T7 << 7) | (T56 << 5) | (T4 << 4) | (T23 << 2) | (T01 << 0);

	lea	r11, QWORD PTR m$2[rsp]
	mov	r10d, ebx
	sub	r11, r8
	mov	r9, r14
	npad	8
$LL27@decodeISE:

; 718  : 				{
; 719  : 					dst[i].m = m[i];

	mov	edx, DWORD PTR [r8+r11]

; 720  : 					dst[i].tq = trits[i];
; 721  : 					dst[i].v = (trits[i] << numBits) + m[i];

	mov	ecx, edi
	mov	DWORD PTR [r9-8], edx
	lea	r9, QWORD PTR [r9+12]
	mov	eax, DWORD PTR [r8]
	lea	r8, QWORD PTR [r8+4]
	mov	DWORD PTR [r9-16], eax
	mov	eax, DWORD PTR [r8-4]
	shl	eax, cl
	add	eax, edx
	mov	DWORD PTR [r9-12], eax
	sub	r10, 1
	jne	SHORT $LL27@decodeISE
$LN2@decodeISE:

; 771  : 				{
; 772  : 					const int numBlocks = deDivRoundUp32(numValues, 5);
; 773  : 					for (int blockNdx = 0; blockNdx < numBlocks; blockNdx++)

	mov	r8d, DWORD PTR numValues$[rsp]
	lea	eax, DWORD PTR [r15-1]
	mov	r9, QWORD PTR params$[rsp]
	inc	ebp
	add	r14, 60					; 0000003cH
	sub	r12, 1
	jne	$LL4@decodeISE

; 777  : 					}
; 778  : 				}

	jmp	$LN9@decodeISE
$LN11@decodeISE:

; 779  : 				else if (params.mode == ISEMODE_QUINT)

	cmp	eax, 1
	jne	$LN13@decodeISE

; 192  : 		return (a + b - 1) / b;

	lea	ecx, DWORD PTR [r8+2]
	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx

; 780  : 				{
; 781  : 					const int numBlocks = deDivRoundUp32(numValues, 3);
; 782  : 					for (int blockNdx = 0; blockNdx < numBlocks; blockNdx++)

	xor	ebp, ebp

; 192  : 		return (a + b - 1) / b;

	mov	r15d, edx
	shr	r15d, 1

; 780  : 				{
; 781  : 					const int numBlocks = deDivRoundUp32(numValues, 3);
; 782  : 					for (int blockNdx = 0; blockNdx < numBlocks; blockNdx++)

	mov	r13d, r15d
	test	r15d, r15d
	jle	$LN9@decodeISE
	lea	eax, DWORD PTR [r15-1]
	lea	r14, QWORD PTR [rbx+8]
$LL7@decodeISE:

; 783  : 					{
; 784  : 						const int numValuesInBlock = blockNdx == numBlocks - 1 ? numValues - 3 * (numBlocks - 1) : 3;

	cmp	ebp, eax
	jne	SHORT $LN18@decodeISE
	lea	eax, DWORD PTR [r15+r15*2]
	mov	ebx, r8d
	sub	ebx, eax
	add	ebx, 3
	jmp	SHORT $LN19@decodeISE
$LN18@decodeISE:
	mov	ebx, 3
$LN19@decodeISE:

; 785  : 						decodeISEQuintBlock(&dst[3 * blockNdx], numValuesInBlock, data, params.numBits);

	mov	edi, DWORD PTR [r9+4]

; 728  : 				m[0] = data.getNext(numBits);

	mov	rcx, rsi
	mov	edx, edi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 729  : 				deUint32 Q012 = data.getNext(3);

	mov	edx, 3
	mov	DWORD PTR m$1[rsp], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 730  : 				m[1] = data.getNext(numBits);

	mov	edx, edi
	mov	DWORD PTR tv1027[rsp], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 731  : 				deUint32 Q34 = data.getNext(2);

	mov	edx, 2
	mov	DWORD PTR m$1[rsp+4], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 732  : 				m[2] = data.getNext(numBits);

	mov	edx, edi
	mov	rcx, rsi
	mov	r12d, eax
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 733  : 				deUint32 Q56 = data.getNext(2);

	mov	edx, 2
	mov	DWORD PTR m$1[rsp+8], eax
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 734  : 				switch (numValues)

	mov	edx, ebx
	sub	edx, 1
	je	SHORT $LN43@decodeISE
	cmp	edx, 1
	je	SHORT $LN44@decodeISE
	jmp	SHORT $LN46@decodeISE
$LN43@decodeISE:

; 735  : 				{
; 736  : 					// \note Fall-throughs.
; 737  : 				case 1: Q34 = 0;

	xor	r12d, r12d
$LN44@decodeISE:

; 738  : 				case 2: Q56 = 0;

	xor	eax, eax
$LN46@decodeISE:

; 739  : 				case 3: break;
; 740  : 				default:
; 741  : 					DE_ASSERT(false);
; 742  : 				}
; 743  : 				const deUint32 Q = (Q56 << 5) | (Q34 << 3) | (Q012 << 0);

	lea	ecx, DWORD PTR [rax*4]
	mov	eax, DWORD PTR tv1027[rsp]
	or	ecx, r12d
	shl	ecx, 3
	or	rcx, rax

; 744  : 				static const deUint32 quintsFromQ[256][3] =
; 745  : 				{
; 746  : 					{ 0,0,0 }, { 1,0,0 }, { 2,0,0 }, { 3,0,0 }, { 4,0,0 }, { 0,4,0 }, { 4,4,0 }, { 4,4,4 }, { 0,1,0 }, { 1,1,0 }, { 2,1,0 }, { 3,1,0 }, { 4,1,0 }, { 1,4,0 }, { 4,4,1 }, { 4,4,4 },
; 747  : 					{ 0,2,0 }, { 1,2,0 }, { 2,2,0 }, { 3,2,0 }, { 4,2,0 }, { 2,4,0 }, { 4,4,2 }, { 4,4,4 }, { 0,3,0 }, { 1,3,0 }, { 2,3,0 }, { 3,3,0 }, { 4,3,0 }, { 3,4,0 }, { 4,4,3 }, { 4,4,4 },
; 748  : 					{ 0,0,1 }, { 1,0,1 }, { 2,0,1 }, { 3,0,1 }, { 4,0,1 }, { 0,4,1 }, { 4,0,4 }, { 0,4,4 }, { 0,1,1 }, { 1,1,1 }, { 2,1,1 }, { 3,1,1 }, { 4,1,1 }, { 1,4,1 }, { 4,1,4 }, { 1,4,4 },
; 749  : 					{ 0,2,1 }, { 1,2,1 }, { 2,2,1 }, { 3,2,1 }, { 4,2,1 }, { 2,4,1 }, { 4,2,4 }, { 2,4,4 }, { 0,3,1 }, { 1,3,1 }, { 2,3,1 }, { 3,3,1 }, { 4,3,1 }, { 3,4,1 }, { 4,3,4 }, { 3,4,4 },
; 750  : 					{ 0,0,2 }, { 1,0,2 }, { 2,0,2 }, { 3,0,2 }, { 4,0,2 }, { 0,4,2 }, { 2,0,4 }, { 3,0,4 }, { 0,1,2 }, { 1,1,2 }, { 2,1,2 }, { 3,1,2 }, { 4,1,2 }, { 1,4,2 }, { 2,1,4 }, { 3,1,4 },
; 751  : 					{ 0,2,2 }, { 1,2,2 }, { 2,2,2 }, { 3,2,2 }, { 4,2,2 }, { 2,4,2 }, { 2,2,4 }, { 3,2,4 }, { 0,3,2 }, { 1,3,2 }, { 2,3,2 }, { 3,3,2 }, { 4,3,2 }, { 3,4,2 }, { 2,3,4 }, { 3,3,4 },
; 752  : 					{ 0,0,3 }, { 1,0,3 }, { 2,0,3 }, { 3,0,3 }, { 4,0,3 }, { 0,4,3 }, { 0,0,4 }, { 1,0,4 }, { 0,1,3 }, { 1,1,3 }, { 2,1,3 }, { 3,1,3 }, { 4,1,3 }, { 1,4,3 }, { 0,1,4 }, { 1,1,4 },
; 753  : 					{ 0,2,3 }, { 1,2,3 }, { 2,2,3 }, { 3,2,3 }, { 4,2,3 }, { 2,4,3 }, { 0,2,4 }, { 1,2,4 }, { 0,3,3 }, { 1,3,3 }, { 2,3,3 }, { 3,3,3 }, { 4,3,3 }, { 3,4,3 }, { 0,3,4 }, { 1,3,4 }
; 754  : 				};
; 755  : 				const deUint32(&quints)[3] = quintsFromQ[Q];

	lea	rax, QWORD PTR [rcx+rcx*2]
	lea	rax, QWORD PTR ?quintsFromQ@?1??decodeISEQuintBlock@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@234@HAEAVBitAccessStream@234@H@Z@4QAY02$$CBIA[rax*4]
	lea	rcx, OFFSET FLAT:__ImageBase
	add	rax, rcx

; 756  : 				for (int i = 0; i < numValues; i++)

	test	ebx, ebx
	jle	SHORT $LN5@decodeISE

; 739  : 				case 3: break;
; 740  : 				default:
; 741  : 					DE_ASSERT(false);
; 742  : 				}
; 743  : 				const deUint32 Q = (Q56 << 5) | (Q34 << 3) | (Q012 << 0);

	lea	r11, QWORD PTR m$1[rsp]
	mov	r10d, ebx
	sub	r11, rax
	mov	r9, r14
	npad	10
$LL42@decodeISE:

; 757  : 				{
; 758  : 					dst[i].m = m[i];

	mov	r8d, DWORD PTR [rax+r11]
	lea	rax, QWORD PTR [rax+4]
	mov	DWORD PTR [r9-8], r8d
	lea	r9, QWORD PTR [r9+12]

; 759  : 					dst[i].tq = quints[i];

	mov	ecx, DWORD PTR [rax-4]
	mov	DWORD PTR [r9-16], ecx

; 760  : 					dst[i].v = (quints[i] << numBits) + m[i];

	mov	ecx, edi
	mov	edx, DWORD PTR [rax-4]
	shl	edx, cl
	add	edx, r8d
	mov	DWORD PTR [r9-12], edx
	sub	r10, 1
	jne	SHORT $LL42@decodeISE
$LN5@decodeISE:

; 780  : 				{
; 781  : 					const int numBlocks = deDivRoundUp32(numValues, 3);
; 782  : 					for (int blockNdx = 0; blockNdx < numBlocks; blockNdx++)

	mov	r8d, DWORD PTR numValues$[rsp]
	lea	eax, DWORD PTR [r15-1]
	mov	r9, QWORD PTR params$[rsp]
	inc	ebp
	add	r14, 36					; 00000024H
	sub	r13, 1
	jne	$LL7@decodeISE

; 786  : 					}
; 787  : 				}

	jmp	SHORT $LN9@decodeISE
$LN13@decodeISE:

; 788  : 				else
; 789  : 				{
; 790  : 					DE_ASSERT(params.mode == ISEMODE_PLAIN_BIT);
; 791  : 					for (int i = 0; i < numValues; i++)

	mov	rdi, r8
	test	edx, edx
	jle	SHORT $LN9@decodeISE
	npad	8
$LL10@decodeISE:

; 765  : 				dst[0].m = data.getNext(numBits);

	mov	edx, DWORD PTR [r9+4]
	mov	rcx, rsi
	call	?getNext@BitAccessStream@?A0xc6621425@astc@basisu@@QEAAIH@Z ; basisu::astc::`anonymous namespace'::BitAccessStream::getNext

; 788  : 				else
; 789  : 				{
; 790  : 					DE_ASSERT(params.mode == ISEMODE_PLAIN_BIT);
; 791  : 					for (int i = 0; i < numValues; i++)

	mov	r9, QWORD PTR params$[rsp]

; 765  : 				dst[0].m = data.getNext(numBits);

	mov	DWORD PTR [rbx], eax

; 766  : 				dst[0].v = dst[0].m;

	mov	DWORD PTR [rbx+8], eax

; 788  : 				else
; 789  : 				{
; 790  : 					DE_ASSERT(params.mode == ISEMODE_PLAIN_BIT);
; 791  : 					for (int i = 0; i < numValues; i++)

	lea	rbx, QWORD PTR [rbx+12]
	sub	rdi, 1
	jne	SHORT $LL10@decodeISE
$LN9@decodeISE:

; 792  : 						decodeISEBitBlock(&dst[i], data, params.numBits);
; 793  : 				}
; 794  : 			}

	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z ENDP ; basisu::astc::`anonymous namespace'::decodeISE
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z
_TEXT	SEGMENT
dst$ = 32
iseResults$ = 40
numEndpoints$ = 48
iseParams$ = 56
?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z PROC ; basisu::astc::`anonymous namespace'::unquantizeColorEndpoints, COMDAT

; 796  : 			{

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r15

; 797  : 				if (iseParams.mode == ISEMODE_TRIT || iseParams.mode == ISEMODE_QUINT)

	mov	eax, DWORD PTR [r9]
	mov	r15, r9
	mov	rsi, rdx
	mov	r12, rcx
	cmp	eax, 1
	jbe	SHORT $LN10@unquantize

; 826  : 					}
; 827  : 				}
; 828  : 				else
; 829  : 				{
; 830  : 					DE_ASSERT(iseParams.mode == ISEMODE_PLAIN_BIT);
; 831  : 					for (int endpointNdx = 0; endpointNdx < numEndpoints; endpointNdx++)

	movsxd	rbp, r8d
	test	r8d, r8d
	jle	$LN3@unquantize
	mov	QWORD PTR [rsp+32], r14
	xor	edi, edi
	lea	r14, QWORD PTR [rdx+8]
	npad	4
$LL7@unquantize:

; 832  : 						dst[endpointNdx] = bitReplicationScale(iseResults[endpointNdx].v, iseParams.numBits, 8);

	mov	esi, DWORD PTR [r15+4]

; 241  : 				deUint32 dst = 0;

	xor	r11d, r11d

; 832  : 						dst[endpointNdx] = bitReplicationScale(iseResults[endpointNdx].v, iseParams.numBits, 8);

	mov	ebx, DWORD PTR [r14]

; 242  : 				for (int shift = numDstBits - numSrcBits; shift > -numSrcBits; shift -= numSrcBits)

	mov	r10d, esi
	neg	r10d
	lea	r8d, DWORD PTR [r10+8]
	cmp	r8d, r10d
	jle	SHORT $LN48@unquantize

; 832  : 						dst[endpointNdx] = bitReplicationScale(iseResults[endpointNdx].v, iseParams.numBits, 8);

	mov	r9d, r8d
	neg	r9d
	npad	1
$LL49@unquantize:

; 243  : 					dst |= shift >= 0 ? src << shift : src >> -shift;

	mov	ecx, r9d
	mov	edx, ebx
	shr	edx, cl
	mov	eax, ebx
	mov	ecx, r8d
	shl	eax, cl
	test	r8d, r8d
	cmovs	eax, edx
	sub	r8d, esi
	or	r11d, eax
	sub	r9d, r10d
	cmp	r8d, r10d
	jg	SHORT $LL49@unquantize
$LN48@unquantize:

; 832  : 						dst[endpointNdx] = bitReplicationScale(iseResults[endpointNdx].v, iseParams.numBits, 8);

	mov	DWORD PTR [r12+rdi*4], r11d
	add	r14, 12
	inc	rdi
	cmp	rdi, rbp
	jl	SHORT $LL7@unquantize

; 797  : 				if (iseParams.mode == ISEMODE_TRIT || iseParams.mode == ISEMODE_QUINT)

	mov	r14, QWORD PTR [rsp+32]
	jmp	$LN3@unquantize
$LN10@unquantize:

; 798  : 				{
; 799  : 					const int rangeCase = iseParams.numBits * 2 - (iseParams.mode == ISEMODE_TRIT ? 2 : 1);

	mov	edx, DWORD PTR [r9+4]

; 800  : 					DE_ASSERT(basisu::inRange(rangeCase, 0, 10));
; 801  : 					static const deUint32	Ca[11] = { 204, 113, 93, 54, 44, 26, 22, 13, 11, 6, 5 };
; 802  : 					const deUint32			C = Ca[rangeCase];

	lea	rbp, OFFSET FLAT:?Ca@?4??unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@234@HAEBUISEParams@234@@Z@4QBIB
	neg	eax
	sbb	eax, eax
	add	edx, edx
	add	eax, 2
	sub	edx, eax
	movsxd	rax, edx
	mov	ebp, DWORD PTR [rbp+rax*4]

; 803  : 					for (int endpointNdx = 0; endpointNdx < numEndpoints; endpointNdx++)

	test	r8d, r8d
	jle	$LN3@unquantize

; 812  : 						const deUint32 B = rangeCase == 0 ? 0

	mov	edi, r8d
	npad	11
$LL4@unquantize:

; 214  : 				return (src >> ndx) & 1;

	mov	eax, DWORD PTR [rsi]
	mov	ecx, eax
	mov	r8d, eax
	shr	ecx, 1
	mov	r9d, eax
	shr	r8d, 2
	mov	r10d, eax
	shr	r9d, 3
	mov	ebx, eax
	shr	r10d, 4
	shr	ebx, 5
	and	ecx, 1
	and	r8d, 1
	and	r9d, 1
	and	r10d, 1
	and	ebx, 1
	and	al, 1

; 804  : 					{
; 805  : 						const deUint32 a = getBit(iseResults[endpointNdx].m, 0);
; 806  : 						const deUint32 b = getBit(iseResults[endpointNdx].m, 1);
; 807  : 						const deUint32 c = getBit(iseResults[endpointNdx].m, 2);
; 808  : 						const deUint32 d = getBit(iseResults[endpointNdx].m, 3);
; 809  : 						const deUint32 e = getBit(iseResults[endpointNdx].m, 4);
; 810  : 						const deUint32 f = getBit(iseResults[endpointNdx].m, 5);
; 811  : 						const deUint32 A = a == 0 ? 0 : (1 << 9) - 1;

	neg	al
	sbb	r11d, r11d
	and	r11d, 511				; 000001ffH

; 812  : 						const deUint32 B = rangeCase == 0 ? 0

	test	edx, edx
	jne	SHORT $LN32@unquantize
	xor	eax, eax
	jmp	$LN13@unquantize
$LN32@unquantize:
	cmp	edx, 1
	jne	SHORT $LN30@unquantize
	xor	eax, eax
	jmp	$LN13@unquantize
$LN30@unquantize:
	cmp	edx, 2
	jne	SHORT $LN28@unquantize
	mov	eax, ecx
	shl	eax, 4
	or	eax, ecx
	shl	eax, 2
	or	eax, ecx
	add	eax, eax
	or	eax, ecx
	add	eax, eax
	jmp	$LN13@unquantize
$LN28@unquantize:
	cmp	edx, 3
	jne	SHORT $LN26@unquantize
	mov	eax, ecx
	shl	eax, 5
	or	eax, ecx
	add	eax, eax
	or	eax, ecx
	shl	eax, 2
	jmp	$LN13@unquantize
$LN26@unquantize:
	cmp	edx, 4
	jne	SHORT $LN24@unquantize
	lea	eax, DWORD PTR [r8+r8]
	or	eax, ecx
	shl	eax, 4
	or	eax, r8d
	add	eax, eax
	or	eax, ecx
	add	eax, eax
	or	eax, r8d
	add	eax, eax
	or	eax, ecx
	jmp	$LN13@unquantize
$LN24@unquantize:
	cmp	edx, 5
	jne	SHORT $LN22@unquantize
	lea	eax, DWORD PTR [r8+r8]
	or	eax, ecx
	shl	eax, 5
	or	eax, r8d
	add	eax, eax
	or	eax, ecx
	add	eax, eax
	or	eax, r8d
	jmp	$LN13@unquantize
$LN22@unquantize:
	cmp	edx, 6
	jne	SHORT $LN20@unquantize
	lea	eax, DWORD PTR [r9+r9]
	or	eax, r8d
	add	eax, eax
	or	eax, ecx
	shl	eax, 4
	or	eax, r9d
	add	eax, eax
	or	eax, r8d
	add	eax, eax
	or	eax, ecx
	jmp	$LN13@unquantize
$LN20@unquantize:
	cmp	edx, 7
	jne	SHORT $LN18@unquantize
	lea	eax, DWORD PTR [r9+r9]
	or	eax, r8d
	add	eax, eax
	or	eax, ecx
	shl	eax, 5
	or	eax, r9d
	add	eax, eax
	or	eax, r8d
	jmp	SHORT $LN13@unquantize
$LN18@unquantize:
	cmp	edx, 8
	jne	SHORT $LN16@unquantize
	lea	eax, DWORD PTR [r10+r10]
	or	eax, r9d
	add	eax, eax
	or	eax, r8d
	add	eax, eax
	or	eax, ecx
	shl	eax, 4
	or	eax, r10d
	add	eax, eax
	or	eax, r9d
	jmp	SHORT $LN13@unquantize
$LN16@unquantize:
	cmp	edx, 9
	jne	SHORT $LN14@unquantize
	lea	eax, DWORD PTR [r10+r10]
	or	eax, r9d
	add	eax, eax
	or	eax, r8d
	add	eax, eax
	or	eax, ecx
	shl	eax, 5
	or	eax, r10d
	jmp	SHORT $LN13@unquantize
$LN14@unquantize:
	cmp	edx, 10
	jne	SHORT $LN12@unquantize
	lea	eax, DWORD PTR [rbx+rbx]
	or	eax, r10d
	add	eax, eax
	or	eax, r9d
	add	eax, eax
	or	eax, r8d
	add	eax, eax
	or	eax, ecx
	shl	eax, 4
	or	eax, ebx
	jmp	SHORT $LN13@unquantize
$LN12@unquantize:
	mov	eax, -1					; ffffffffH
$LN13@unquantize:

; 813  : 							: rangeCase == 1 ? 0
; 814  : 							: rangeCase == 2 ? (b << 8) | (b << 4) | (b << 2) | (b << 1)
; 815  : 							: rangeCase == 3 ? (b << 8) | (b << 3) | (b << 2)
; 816  : 							: rangeCase == 4 ? (c << 8) | (b << 7) | (c << 3) | (b << 2) | (c << 1) | (b << 0)
; 817  : 							: rangeCase == 5 ? (c << 8) | (b << 7) | (c << 2) | (b << 1) | (c << 0)
; 818  : 							: rangeCase == 6 ? (d << 8) | (c << 7) | (b << 6) | (d << 2) | (c << 1) | (b << 0)
; 819  : 							: rangeCase == 7 ? (d << 8) | (c << 7) | (b << 6) | (d << 1) | (c << 0)
; 820  : 							: rangeCase == 8 ? (e << 8) | (d << 7) | (c << 6) | (b << 5) | (e << 1) | (d << 0)
; 821  : 							: rangeCase == 9 ? (e << 8) | (d << 7) | (c << 6) | (b << 5) | (e << 0)
; 822  : 							: rangeCase == 10 ? (f << 8) | (e << 7) | (d << 6) | (c << 5) | (b << 4) | (f << 0)
; 823  : 							: (deUint32)-1;
; 824  : 						DE_ASSERT(B != (deUint32)-1);
; 825  : 						dst[endpointNdx] = (((iseResults[endpointNdx].tq * C + B) ^ A) >> 2) | (A & 0x80);

	mov	ecx, ebp
	imul	ecx, DWORD PTR [rsi+4]
	add	rsi, 12
	add	ecx, eax
	xor	ecx, r11d
	and	r11d, 128				; 00000080H
	shr	ecx, 2
	or	ecx, r11d
	mov	DWORD PTR [r12], ecx
	add	r12, 4
	sub	rdi, 1
	jne	$LL4@unquantize
$LN3@unquantize:

; 833  : 				}
; 834  : 			}

	mov	rbx, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	pop	r15
	pop	r12
	pop	rdi
	ret	0
?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z ENDP ; basisu::astc::`anonymous namespace'::unquantizeColorEndpoints
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?bitTransferSigned@?A0xc6621425@astc@basisu@@YAXAEAH0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?bitTransferSigned@?A0xc6621425@astc@basisu@@YAXAEAH0@Z PROC ; basisu::astc::`anonymous namespace'::bitTransferSigned, COMDAT

; 837  : 				b >>= 1;
; 838  : 				b |= a & 0x80;

	mov	r9d, DWORD PTR [rcx]
	mov	eax, r9d
	mov	r8d, DWORD PTR [rdx]
	and	eax, 128				; 00000080H

; 839  : 				a >>= 1;
; 840  : 				a &= 0x3f;

	sar	r9d, 1
	and	r9d, 63					; 0000003fH
	sar	r8d, 1
	or	r8d, eax
	mov	DWORD PTR [rcx], r9d

; 214  : 				return (src >> ndx) & 1;

	mov	eax, r9d

; 837  : 				b >>= 1;
; 838  : 				b |= a & 0x80;

	mov	DWORD PTR [rdx], r8d

; 214  : 				return (src >> ndx) & 1;

	shr	eax, 5

; 841  : 				if (isBitSet(a, 5))

	test	al, al
	je	SHORT $LN2@bitTransfe

; 842  : 					a -= 0x40;

	lea	eax, DWORD PTR [r9-64]
	mov	DWORD PTR [rcx], eax
$LN2@bitTransfe:

; 843  : 			}

	ret	0
?bitTransferSigned@?A0xc6621425@astc@basisu@@YAXAEAH0@Z ENDP ; basisu::astc::`anonymous namespace'::bitTransferSigned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?clampedRGBA@?A0xc6621425@astc@basisu@@YA?AUUVec4@3@AEBUIVec4@3@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
rgba$ = 16
?clampedRGBA@?A0xc6621425@astc@basisu@@YA?AUUVec4@3@AEBUIVec4@3@@Z PROC ; basisu::astc::`anonymous namespace'::clampedRGBA, COMDAT

; 845  : 			{

	mov	QWORD PTR [rsp+8], rbx

; 846  : 				return UVec4(basisu::clamp(rgba.x(), 0, 0xff),

	mov	r9d, DWORD PTR [rdx+12]

; 80   : 		if (a < l)

	xor	eax, eax

; 845  : 			{

	mov	r10, rdx
	mov	r8, rcx

; 80   : 		if (a < l)

	mov	ebx, 255				; 000000ffH
	test	r9d, r9d
	jns	SHORT $LN4@clampedRGB

; 81   : 			return l;

	mov	r9d, eax
	jmp	SHORT $LN6@clampedRGB
$LN4@clampedRGB:

; 82   : 		else if (a > h)

	cmp	r9d, ebx
	cmovg	r9d, ebx
$LN6@clampedRGB:

; 846  : 				return UVec4(basisu::clamp(rgba.x(), 0, 0xff),

	mov	ecx, DWORD PTR [rdx+8]

; 80   : 		if (a < l)

	test	ecx, ecx
	jns	SHORT $LN9@clampedRGB

; 81   : 			return l;

	mov	ecx, eax
	jmp	SHORT $LN11@clampedRGB
$LN9@clampedRGB:

; 82   : 		else if (a > h)

	cmp	ecx, ebx
	cmovg	ecx, ebx
$LN11@clampedRGB:

; 846  : 				return UVec4(basisu::clamp(rgba.x(), 0, 0xff),

	mov	edx, DWORD PTR [rdx+4]

; 80   : 		if (a < l)

	test	edx, edx
	jns	SHORT $LN14@clampedRGB

; 81   : 			return l;

	mov	edx, eax
	jmp	SHORT $LN16@clampedRGB
$LN14@clampedRGB:

; 82   : 		else if (a > h)

	cmp	edx, ebx
	cmovg	edx, ebx
$LN16@clampedRGB:

; 846  : 				return UVec4(basisu::clamp(rgba.x(), 0, 0xff),

	mov	r11d, DWORD PTR [r10]

; 80   : 		if (a < l)

	test	r11d, r11d
	js	SHORT $LN21@clampedRGB

; 82   : 		else if (a > h)

	cmp	r11d, ebx
	mov	eax, r11d
	cmovg	eax, ebx
$LN21@clampedRGB:

; 847  : 					basisu::clamp(rgba.y(), 0, 0xff),
; 848  : 					basisu::clamp(rgba.z(), 0, 0xff),
; 849  : 					basisu::clamp(rgba.w(), 0, 0xff));
; 850  : 			}

	mov	rbx, QWORD PTR [rsp+8]

; 101  : 			m_c[0] = x;

	mov	DWORD PTR [r8], eax

; 846  : 				return UVec4(basisu::clamp(rgba.x(), 0, 0xff),

	mov	rax, r8

; 102  : 			m_c[1] = y;

	mov	DWORD PTR [r8+4], edx

; 103  : 			m_c[2] = z;

	mov	DWORD PTR [r8+8], ecx

; 104  : 			m_c[3] = w;

	mov	DWORD PTR [r8+12], r9d

; 847  : 					basisu::clamp(rgba.y(), 0, 0xff),
; 848  : 					basisu::clamp(rgba.z(), 0, 0xff),
; 849  : 					basisu::clamp(rgba.w(), 0, 0xff));
; 850  : 			}

	ret	0
?clampedRGBA@?A0xc6621425@astc@basisu@@YA?AUUVec4@3@AEBUIVec4@3@@Z ENDP ; basisu::astc::`anonymous namespace'::clampedRGBA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?blueContract@?A0xc6621425@astc@basisu@@YA?AUIVec4@3@HHHH@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
r$ = 16
g$ = 24
b$ = 32
a$ = 40
?blueContract@?A0xc6621425@astc@basisu@@YA?AUIVec4@3@HHHH@Z PROC ; basisu::astc::`anonymous namespace'::blueContract, COMDAT

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	lea	eax, DWORD PTR [rdx+r9]

; 137  : 			m_c[2] = z;

	mov	DWORD PTR [rcx+8], r9d

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	sar	eax, 1

; 135  : 			m_c[0] = x;

	mov	DWORD PTR [rcx], eax

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	lea	eax, DWORD PTR [r8+r9]
	sar	eax, 1

; 136  : 			m_c[1] = y;

	mov	DWORD PTR [rcx+4], eax

; 138  : 			m_c[3] = w;

	mov	eax, DWORD PTR a$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	mov	rax, rcx

; 854  : 			}

	ret	0
?blueContract@?A0xc6621425@astc@basisu@@YA?AUIVec4@3@HHHH@Z ENDP ; basisu::astc::`anonymous namespace'::blueContract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?isColorEndpointModeHDR@?A0xc6621425@astc@basisu@@YA_NI@Z
_TEXT	SEGMENT
mode$ = 8
?isColorEndpointModeHDR@?A0xc6621425@astc@basisu@@YA_NI@Z PROC ; basisu::astc::`anonymous namespace'::isColorEndpointModeHDR, COMDAT

; 857  : 				return mode == 2 ||

	cmp	ecx, 15
	ja	SHORT $LN5@isColorEnd
	mov	eax, 51340				; 0000c88cH
	bt	eax, ecx
	jae	SHORT $LN5@isColorEnd
	mov	al, 1

; 858  : 					mode == 3 ||
; 859  : 					mode == 7 ||
; 860  : 					mode == 11 ||
; 861  : 					mode == 14 ||
; 862  : 					mode == 15;
; 863  : 			}

	ret	0
$LN5@isColorEnd:

; 857  : 				return mode == 2 ||

	xor	al, al

; 858  : 					mode == 3 ||
; 859  : 					mode == 7 ||
; 860  : 					mode == 11 ||
; 861  : 					mode == 14 ||
; 862  : 					mode == 15;
; 863  : 			}

	ret	0
?isColorEndpointModeHDR@?A0xc6621425@astc@basisu@@YA_NI@Z ENDP ; basisu::astc::`anonymous namespace'::isColorEndpointModeHDR
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIII@Z
_TEXT	SEGMENT
x5$1$ = 0
e1$1$ = 8
e0$1$ = 16
e0$ = 112
e1$ = 120
v0$ = 128
v1$ = 136
v2$ = 144
v3$ = 152
?decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIII@Z PROC ; basisu::astc::`anonymous namespace'::decodeHDREndpointMode7, COMDAT

; 865  : 			{

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR e0$1$[rsp], rcx

; 866  : 				const deUint32 m10 = getBit(v1, 7) | (getBit(v2, 7) << 1);

	mov	r10d, r9d
	mov	ecx, DWORD PTR v2$[rsp]

; 867  : 				const deUint32 m23 = getBits(v0, 6, 7);
; 868  : 				const deUint32 majComp = m10 != 3 ? m10

	mov	ebx, r8d
	shr	r10d, 1
	mov	eax, ecx
	and	r10d, 64				; 00000040H
	shr	ebx, 6
	and	eax, 128				; 00000080H
	mov	QWORD PTR e1$1$[rsp], rdx
	or	r10d, eax
	and	ebx, 3
	shr	r10d, 6
	xor	edx, edx
	cmp	r10d, 3
	jne	SHORT $LN37@decodeHDRE
	cmp	ebx, 3

; 869  : 					: m23 != 3 ? m23
; 870  : 					: 0;
; 871  : 				const deUint32 mode = m10 != 3 ? m23

	mov	eax, edx
	mov	r10d, edx
	sete	al
	cmovne	r10d, ebx
	lea	ebx, DWORD PTR [rax+4]
$LN37@decodeHDRE:

; 877  : 				deInt32			scale = (deInt32)getBits(v3, 0, 4);

	mov	edi, DWORD PTR v3$[rsp]

; 878  : 				{
; 879  : #define SHOR(DST_VAR, SHIFT, BIT_VAR) (DST_VAR) |= (BIT_VAR) << (SHIFT)
; 880  : #define ASSIGN_X_BITS(V0,S0, V1,S1, V2,S2, V3,S3, V4,S4, V5,S5, V6,S6) do { SHOR(V0,S0,x0); SHOR(V1,S1,x1); SHOR(V2,S2,x2); SHOR(V3,S3,x3); SHOR(V4,S4,x4); SHOR(V5,S5,x5); SHOR(V6,S6,x6); } while (false)
; 881  : 					const deUint32	x0 = getBit(v1, 6);
; 882  : 					const deUint32	x1 = getBit(v1, 5);
; 883  : 					const deUint32	x2 = getBit(v2, 6);
; 884  : 					const deUint32	x3 = getBit(v2, 5);
; 885  : 					const deUint32	x4 = getBit(v3, 7);
; 886  : 					const deUint32	x5 = getBit(v3, 6);
; 887  : 					const deUint32	x6 = getBit(v3, 5);
; 888  : 					deInt32& R = red;
; 889  : 					deInt32& G = green;
; 890  : 					deInt32& B = blue;
; 891  : 					deInt32& S = scale;
; 892  : 					switch (mode)

	lea	r15, OFFSET FLAT:__ImageBase

; 214  : 				return (src >> ndx) & 1;

	mov	eax, edi
	mov	r12d, r9d
	shr	eax, 6
	mov	r13d, ecx
	mov	r14d, edi
	shr	r12d, 6
	and	eax, 1
	shr	r13d, 6

; 221  : 					return (deUint32)((src >> low) & ((1u << numBits) - 1));

	mov	esi, r9d

; 214  : 				return (src >> ndx) & 1;

	shr	r14d, 7

; 872  : 					: m23 != 3 ? 4
; 873  : 					: 5;
; 874  : 				deInt32			red = (deInt32)getBits(v0, 0, 5);
; 875  : 				deInt32			green = (deInt32)getBits(v1, 0, 4);
; 876  : 				deInt32			blue = (deInt32)getBits(v2, 0, 4);

	mov	ebp, ecx

; 214  : 				return (src >> ndx) & 1;

	shr	r9d, 5

; 877  : 				deInt32			scale = (deInt32)getBits(v3, 0, 4);

	mov	r11d, edi

; 214  : 				return (src >> ndx) & 1;

	shr	ecx, 5
	shr	edi, 5

; 221  : 					return (deUint32)((src >> low) & ((1u << numBits) - 1));

	and	r8d, 63					; 0000003fH

; 214  : 				return (src >> ndx) & 1;

	mov	DWORD PTR x5$1$[rsp], eax

; 221  : 					return (deUint32)((src >> low) & ((1u << numBits) - 1));

	and	esi, 31

; 878  : 				{
; 879  : #define SHOR(DST_VAR, SHIFT, BIT_VAR) (DST_VAR) |= (BIT_VAR) << (SHIFT)
; 880  : #define ASSIGN_X_BITS(V0,S0, V1,S1, V2,S2, V3,S3, V4,S4, V5,S5, V6,S6) do { SHOR(V0,S0,x0); SHOR(V1,S1,x1); SHOR(V2,S2,x2); SHOR(V3,S3,x3); SHOR(V4,S4,x4); SHOR(V5,S5,x5); SHOR(V6,S6,x6); } while (false)
; 881  : 					const deUint32	x0 = getBit(v1, 6);
; 882  : 					const deUint32	x1 = getBit(v1, 5);
; 883  : 					const deUint32	x2 = getBit(v2, 6);
; 884  : 					const deUint32	x3 = getBit(v2, 5);
; 885  : 					const deUint32	x4 = getBit(v3, 7);
; 886  : 					const deUint32	x5 = getBit(v3, 6);
; 887  : 					const deUint32	x6 = getBit(v3, 5);
; 888  : 					deInt32& R = red;
; 889  : 					deInt32& G = green;
; 890  : 					deInt32& B = blue;
; 891  : 					deInt32& S = scale;
; 892  : 					switch (mode)

	mov	eax, DWORD PTR $LN114@decodeHDRE[r15+rbx*4]
	and	ebp, 31
	and	r11d, 31

; 214  : 				return (src >> ndx) & 1;

	and	r12d, 1
	and	r9d, 1
	and	r13d, 1
	and	ecx, 1
	and	r14d, 1
	and	edi, 1

; 878  : 				{
; 879  : #define SHOR(DST_VAR, SHIFT, BIT_VAR) (DST_VAR) |= (BIT_VAR) << (SHIFT)
; 880  : #define ASSIGN_X_BITS(V0,S0, V1,S1, V2,S2, V3,S3, V4,S4, V5,S5, V6,S6) do { SHOR(V0,S0,x0); SHOR(V1,S1,x1); SHOR(V2,S2,x2); SHOR(V3,S3,x3); SHOR(V4,S4,x4); SHOR(V5,S5,x5); SHOR(V6,S6,x6); } while (false)
; 881  : 					const deUint32	x0 = getBit(v1, 6);
; 882  : 					const deUint32	x1 = getBit(v1, 5);
; 883  : 					const deUint32	x2 = getBit(v2, 6);
; 884  : 					const deUint32	x3 = getBit(v2, 5);
; 885  : 					const deUint32	x4 = getBit(v3, 7);
; 886  : 					const deUint32	x5 = getBit(v3, 6);
; 887  : 					const deUint32	x6 = getBit(v3, 5);
; 888  : 					deInt32& R = red;
; 889  : 					deInt32& G = green;
; 890  : 					deInt32& B = blue;
; 891  : 					deInt32& S = scale;
; 892  : 					switch (mode)

	add	rax, r15
	mov	r15, QWORD PTR e1$1$[rsp]
	jmp	rax
$LN6@decodeHDRE:

; 893  : 					{
; 894  : 					case 0: ASSIGN_X_BITS(R, 9, R, 8, R, 7, R, 10, R, 6, S, 6, S, 5); break;

	lea	eax, DWORD PTR [rcx+rcx]
	or	eax, r12d
	add	eax, eax
	or	eax, r9d
	add	eax, eax
	or	eax, r13d
	add	eax, eax
	or	eax, r14d
	shl	eax, 6
	or	r8d, eax
	jmp	$LN124@decodeHDRE
$LN9@decodeHDRE:

; 895  : 					case 1: ASSIGN_X_BITS(R, 8, G, 5, R, 7, B, 5, R, 6, R, 10, R, 9); break;

	shl	ecx, 5
	or	ebp, ecx
	shl	r9d, 5
	mov	ecx, DWORD PTR x5$1$[rsp]
	or	esi, r9d
	lea	eax, DWORD PTR [rcx+rcx]
	or	eax, edi
	add	eax, eax
	or	eax, r12d
	add	eax, eax
	or	eax, r13d
	add	eax, eax
	or	eax, r14d
	shl	eax, 6
	or	r8d, eax
	jmp	$LN28@decodeHDRE
$LN12@decodeHDRE:

; 896  : 					case 2: ASSIGN_X_BITS(R, 9, R, 8, R, 7, R, 6, S, 7, S, 6, S, 5); break;

	lea	eax, DWORD PTR [r12+r12]
	or	eax, r9d
	add	eax, eax
	or	eax, r13d
	add	eax, eax
	or	eax, ecx
	shl	eax, 6
	or	r8d, eax
	lea	eax, DWORD PTR [r14+r14]
	or	eax, DWORD PTR x5$1$[rsp]
	add	eax, eax
	jmp	SHORT $LN125@decodeHDRE
$LN15@decodeHDRE:

; 897  : 					case 3: ASSIGN_X_BITS(R, 8, G, 5, R, 7, B, 5, R, 6, S, 6, S, 5); break;

	shl	r9d, 5
	lea	eax, DWORD PTR [r12+r12]
	or	eax, r13d
	shl	ecx, 5
	add	eax, eax
	or	esi, r9d
	or	eax, r14d
	or	ebp, ecx
	shl	eax, 6
	or	r8d, eax
	jmp	SHORT $LN124@decodeHDRE
$LN18@decodeHDRE:

; 898  : 					case 4: ASSIGN_X_BITS(G, 6, G, 5, B, 6, B, 5, R, 6, R, 7, S, 5); break;

	lea	eax, DWORD PTR [r12+r12]
	shl	edi, 5
	or	eax, r9d
	shl	eax, 5
	or	esi, eax
	lea	eax, DWORD PTR [r13*2]
	or	eax, ecx
	mov	ecx, DWORD PTR x5$1$[rsp]
	shl	eax, 5
	or	ebp, eax
	lea	eax, DWORD PTR [rcx+rcx]
	or	eax, r14d
	shl	eax, 6
	or	r8d, eax
	or	r11d, edi
	jmp	SHORT $LN28@decodeHDRE
$LN21@decodeHDRE:

; 899  : 					case 5: ASSIGN_X_BITS(G, 6, G, 5, B, 6, B, 5, R, 6, S, 6, S, 5); break;

	lea	eax, DWORD PTR [r12+r12]
	shl	r14d, 6
	or	eax, r9d
	shl	eax, 5
	or	esi, eax
	lea	eax, DWORD PTR [r13*2]
	or	eax, ecx
	shl	eax, 5
	or	ebp, eax
	or	r8d, r14d
$LN124@decodeHDRE:

; 900  : 					default:
; 901  : 						DE_ASSERT(false);
; 902  : 					}
; 903  : #undef ASSIGN_X_BITS
; 904  : #undef SHOR
; 905  : 				}
; 906  : 				static const int shiftAmounts[] = { 1, 1, 2, 3, 4, 5 };
; 907  : 				DE_ASSERT(mode < DE_LENGTH_OF_ARRAY(shiftAmounts));
; 908  : 				red <<= shiftAmounts[mode];

	mov	ecx, DWORD PTR x5$1$[rsp]
	lea	eax, DWORD PTR [rcx+rcx]
$LN125@decodeHDRE:
	or	eax, edi
	shl	eax, 5
	or	r11d, eax
$LN28@decodeHDRE:
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR ?shiftAmounts@?1??decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@4@0IIII@Z@4QBHB[rcx+rbx*4]
	shl	r8d, cl

; 909  : 				green <<= shiftAmounts[mode];

	shl	ebp, cl

; 910  : 				blue <<= shiftAmounts[mode];
; 911  : 				scale <<= shiftAmounts[mode];
; 912  : 				if (mode != 5)
; 913  : 				{
; 914  : 					green = red - green;
; 915  : 					blue = red - blue;
; 916  : 				}
; 917  : 				if (majComp == 1)

	mov	eax, r8d
	shl	esi, cl
	sub	eax, ebp
	shl	r11d, cl
	mov	edi, r8d
	cmp	ebx, 5
	mov	ecx, r8d
	cmove	eax, ebp
	sub	ecx, esi
	cmp	ebx, 5
	mov	r9d, eax
	cmove	ecx, esi
	cmp	r10d, 1
	jne	SHORT $LN30@decodeHDRE
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	edi, ecx

; 101  :     _Right   = _STD move(_Tmp);

	mov	ecx, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 918  : 					std::swap(red, green);

	jmp	SHORT $LN113@decodeHDRE
$LN30@decodeHDRE:

; 919  : 				else if (majComp == 2)

	cmp	r10d, 2
	jne	SHORT $LN113@decodeHDRE
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	edi, eax

; 101  :     _Right   = _STD move(_Tmp);

	mov	r9d, r8d
	mov	eax, r8d
$LN113@decodeHDRE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 921  : 				e0 = UVec4(basisu::clamp(red - scale, 0, 0xfff),

	sub	r9d, r11d
	mov	ebx, 4095				; 00000fffH

; 80   : 		if (a < l)

	jns	SHORT $LN77@decodeHDRE

; 81   : 			return l;

	mov	r9d, edx
	jmp	SHORT $LN79@decodeHDRE
$LN77@decodeHDRE:

; 82   : 		else if (a > h)

	cmp	r9d, ebx
	cmovg	r9d, ebx
$LN79@decodeHDRE:

; 921  : 				e0 = UVec4(basisu::clamp(red - scale, 0, 0xfff),

	mov	r10d, ecx
	sub	r10d, r11d

; 80   : 		if (a < l)

	jns	SHORT $LN82@decodeHDRE

; 81   : 			return l;

	mov	r10d, edx
	jmp	SHORT $LN84@decodeHDRE
$LN82@decodeHDRE:

; 82   : 		else if (a > h)

	cmp	r10d, ebx
	cmovg	r10d, ebx
$LN84@decodeHDRE:

; 921  : 				e0 = UVec4(basisu::clamp(red - scale, 0, 0xfff),

	mov	r8d, edi
	sub	r8d, r11d

; 80   : 		if (a < l)

	jns	SHORT $LN87@decodeHDRE

; 81   : 			return l;

	mov	r8d, edx
	jmp	SHORT $LN89@decodeHDRE
$LN87@decodeHDRE:

; 82   : 		else if (a > h)

	cmp	r8d, ebx
	cmovg	r8d, ebx
$LN89@decodeHDRE:

; 921  : 				e0 = UVec4(basisu::clamp(red - scale, 0, 0xfff),

	mov	r11, QWORD PTR e0$1$[rsp]
	mov	DWORD PTR [r11], r8d
	mov	DWORD PTR [r11+4], r10d
	mov	DWORD PTR [r11+8], r9d
	mov	DWORD PTR [r11+12], 1920		; 00000780H

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN94@decodeHDRE

; 81   : 			return l;

	mov	eax, edx
	jmp	SHORT $LN96@decodeHDRE
$LN94@decodeHDRE:

; 82   : 		else if (a > h)

	cmp	eax, ebx
	cmovg	eax, ebx
$LN96@decodeHDRE:

; 80   : 		if (a < l)

	test	ecx, ecx
	jns	SHORT $LN99@decodeHDRE

; 81   : 			return l;

	mov	ecx, edx
	jmp	SHORT $LN101@decodeHDRE
$LN99@decodeHDRE:

; 82   : 		else if (a > h)

	cmp	ecx, ebx
	cmovg	ecx, ebx
$LN101@decodeHDRE:

; 80   : 		if (a < l)

	test	edi, edi
	js	SHORT $LN106@decodeHDRE

; 82   : 		else if (a > h)

	cmp	edi, ebx
	mov	edx, edi
	cmovg	edx, ebx
$LN106@decodeHDRE:

; 922  : 					basisu::clamp(green - scale, 0, 0xfff),
; 923  : 					basisu::clamp(blue - scale, 0, 0xfff),
; 924  : 					0x780);
; 925  : 				e1 = UVec4(basisu::clamp(red, 0, 0xfff),

	mov	DWORD PTR [r15], edx
	mov	DWORD PTR [r15+4], ecx
	mov	DWORD PTR [r15+8], eax
	mov	DWORD PTR [r15+12], 1920		; 00000780H

; 926  : 					basisu::clamp(green, 0, 0xfff),
; 927  : 					basisu::clamp(blue, 0, 0xfff),
; 928  : 					0x780);
; 929  : 			}

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
	npad	2
$LN114@decodeHDRE:
	DD	$LN6@decodeHDRE
	DD	$LN9@decodeHDRE
	DD	$LN12@decodeHDRE
	DD	$LN15@decodeHDRE
	DD	$LN18@decodeHDRE
	DD	$LN21@decodeHDRE
?decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIII@Z ENDP ; basisu::astc::`anonymous namespace'::decodeHDREndpointMode7
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z
_TEXT	SEGMENT
major$1$ = 0
e0$ = 64
e1$ = 72
v0$ = 80
v1$ = 88
v2$ = 96
v3$ = 104
numSrcBits$1$ = 112
x2$1$ = 112
v4$ = 112
shiftAmount$1$ = 120
v5$ = 120
?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z PROC ; basisu::astc::`anonymous namespace'::decodeHDREndpointMode11, COMDAT

; 931  : 			{

	push	rbx
	push	rdi
	push	r13
	sub	rsp, 32					; 00000020H

; 932  : 				const deUint32 major = (getBit(v5, 7) << 1) | getBit(v4, 7);

	mov	r10d, DWORD PTR v4$[rsp]
	mov	rbx, rdx
	mov	r11d, DWORD PTR v5$[rsp]
	mov	r13d, r10d
	shr	r13d, 1
	mov	eax, r11d
	and	r13d, 64				; 00000040H
	and	eax, 128				; 00000080H
	or	r13d, eax
	mov	rdi, rcx
	shr	r13d, 6
	mov	DWORD PTR major$1$[rsp], r13d

; 933  : 				if (major == 3)

	cmp	r13d, 3
	jne	SHORT $LN28@decodeHDRE

; 934  : 				{
; 935  : 					e0 = UVec4(v0 << 4, v2 << 4, getBits(v4, 0, 6) << 5, 0x780);

	mov	eax, DWORD PTR v2$[rsp]
	and	r10d, 127				; 0000007fH
	shl	eax, 4

; 936  : 					e1 = UVec4(v1 << 4, v3 << 4, getBits(v5, 0, 6) << 5, 0x780);

	and	r11d, 127				; 0000007fH
	shl	r8d, 4
	mov	DWORD PTR [rcx], r8d
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR v3$[rsp]
	shl	eax, 4
	shl	r10d, 5
	mov	DWORD PTR [rcx+8], r10d
	mov	DWORD PTR [rcx+12], 1920		; 00000780H
	shl	r11d, 5
	shl	r9d, 4
	mov	DWORD PTR [rdx], r9d
	mov	DWORD PTR [rdx+4], eax
	mov	DWORD PTR [rdx+8], r11d
	mov	DWORD PTR [rdx+12], 1920		; 00000780H

; 1002 : 			}

	add	rsp, 32					; 00000020H
	pop	r13
	pop	rdi
	pop	rbx
	ret	0
$LN28@decodeHDRE:

; 937  : 				}
; 938  : 				else
; 939  : 				{
; 940  : 					const deUint32 mode = (getBit(v3, 7) << 2) | (getBit(v2, 7) << 1) | getBit(v1, 7);

	mov	ecx, DWORD PTR v2$[rsp]

; 947  : 					{
; 948  : #define SHOR(DST_VAR, SHIFT, BIT_VAR) (DST_VAR) |= (BIT_VAR) << (SHIFT)
; 949  : #define ASSIGN_X_BITS(V0,S0, V1,S1, V2,S2, V3,S3, V4,S4, V5,S5) do { SHOR(V0,S0,x0); SHOR(V1,S1,x1); SHOR(V2,S2,x2); SHOR(V3,S3,x3); SHOR(V4,S4,x4); SHOR(V5,S5,x5); } while (false)
; 950  : 						const deUint32 x0 = getBit(v2, 6);
; 951  : 						const deUint32 x1 = getBit(v3, 6);
; 952  : 						const deUint32 x2 = getBit(v4, 6);
; 953  : 						const deUint32 x3 = getBit(v5, 6);
; 954  : 						const deUint32 x4 = getBit(v4, 5);
; 955  : 						const deUint32 x5 = getBit(v5, 5);
; 956  : 						switch (mode)

	lea	r13, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+64], rbp
	mov	eax, ecx
	and	eax, 128				; 00000080H
	mov	QWORD PTR [rsp+72], rsi
	mov	esi, DWORD PTR v3$[rsp]
	mov	ebp, r11d
	mov	QWORD PTR [rsp+80], r12
	mov	edx, r9d
	shr	edx, 1
	mov	r12d, esi
	and	edx, 64					; 00000040H
	mov	QWORD PTR [rsp+24], r14
	or	edx, eax
	mov	QWORD PTR [rsp+16], r15
	shr	edx, 1
	mov	eax, esi
	and	eax, 128				; 00000080H

; 214  : 				return (src >> ndx) & 1;

	shr	esi, 6

; 937  : 				}
; 938  : 				else
; 939  : 				{
; 940  : 					const deUint32 mode = (getBit(v3, 7) << 2) | (getBit(v2, 7) << 1) | getBit(v1, 7);

	or	edx, eax

; 214  : 				return (src >> ndx) & 1;

	mov	r14d, r11d

; 937  : 				}
; 938  : 				else
; 939  : 				{
; 940  : 					const deUint32 mode = (getBit(v3, 7) << 2) | (getBit(v2, 7) << 1) | getBit(v1, 7);

	shr	edx, 5

; 214  : 				return (src >> ndx) & 1;

	mov	eax, r10d

; 937  : 				}
; 938  : 				else
; 939  : 				{
; 940  : 					const deUint32 mode = (getBit(v3, 7) << 2) | (getBit(v2, 7) << 1) | getBit(v1, 7);

	mov	DWORD PTR shiftAmount$1$[rsp], edx

; 942  : 					deInt32 c = (deInt32)(getBits(v1, 0, 5));
; 943  : 					deInt32 b0 = (deInt32)(getBits(v2, 0, 5));

	mov	r15d, ecx

; 214  : 				return (src >> ndx) & 1;

	shr	eax, 6

; 941  : 					deInt32 a = (deInt32)((getBit(v1, 6) << 8) | v0);

	mov	edx, r9d

; 214  : 				return (src >> ndx) & 1;

	and	eax, 1
	shr	ecx, 6

; 941  : 					deInt32 a = (deInt32)((getBit(v1, 6) << 8) | v0);

	and	edx, 64					; 00000040H

; 214  : 				return (src >> ndx) & 1;

	mov	DWORD PTR x2$1$[rsp], eax

; 947  : 					{
; 948  : #define SHOR(DST_VAR, SHIFT, BIT_VAR) (DST_VAR) |= (BIT_VAR) << (SHIFT)
; 949  : #define ASSIGN_X_BITS(V0,S0, V1,S1, V2,S2, V3,S3, V4,S4, V5,S5) do { SHOR(V0,S0,x0); SHOR(V1,S1,x1); SHOR(V2,S2,x2); SHOR(V3,S3,x3); SHOR(V4,S4,x4); SHOR(V5,S5,x5); } while (false)
; 950  : 						const deUint32 x0 = getBit(v2, 6);
; 951  : 						const deUint32 x1 = getBit(v3, 6);
; 952  : 						const deUint32 x2 = getBit(v4, 6);
; 953  : 						const deUint32 x3 = getBit(v5, 6);
; 954  : 						const deUint32 x4 = getBit(v4, 5);
; 955  : 						const deUint32 x5 = getBit(v5, 5);
; 956  : 						switch (mode)

	mov	eax, DWORD PTR shiftAmount$1$[rsp]
	and	r9d, 63					; 0000003fH
	shl	edx, 2
	and	r15d, 63				; 0000003fH
	or	edx, r8d

; 214  : 				return (src >> ndx) & 1;

	shr	r14d, 6

; 944  : 					deInt32 b1 = (deInt32)(getBits(v3, 0, 5));
; 945  : 					deInt32 d0 = (deInt32)(getBits(v4, 0, 4));

	mov	r8d, r10d

; 214  : 				return (src >> ndx) & 1;

	shr	r11d, 5

; 947  : 					{
; 948  : #define SHOR(DST_VAR, SHIFT, BIT_VAR) (DST_VAR) |= (BIT_VAR) << (SHIFT)
; 949  : #define ASSIGN_X_BITS(V0,S0, V1,S1, V2,S2, V3,S3, V4,S4, V5,S5) do { SHOR(V0,S0,x0); SHOR(V1,S1,x1); SHOR(V2,S2,x2); SHOR(V3,S3,x3); SHOR(V4,S4,x4); SHOR(V5,S5,x5); } while (false)
; 950  : 						const deUint32 x0 = getBit(v2, 6);
; 951  : 						const deUint32 x1 = getBit(v3, 6);
; 952  : 						const deUint32 x2 = getBit(v4, 6);
; 953  : 						const deUint32 x3 = getBit(v5, 6);
; 954  : 						const deUint32 x4 = getBit(v4, 5);
; 955  : 						const deUint32 x5 = getBit(v5, 5);
; 956  : 						switch (mode)

	mov	eax, DWORD PTR $LN149@decodeHDRE[r13+rax*4]
	and	r12d, 63				; 0000003fH

; 214  : 				return (src >> ndx) & 1;

	shr	r10d, 5

; 944  : 					deInt32 b1 = (deInt32)(getBits(v3, 0, 5));
; 945  : 					deInt32 d0 = (deInt32)(getBits(v4, 0, 4));

	and	r8d, 31

; 214  : 				return (src >> ndx) & 1;

	and	r10d, 1

; 946  : 					deInt32 d1 = (deInt32)(getBits(v5, 0, 4));

	and	ebp, 31

; 214  : 				return (src >> ndx) & 1;

	and	ecx, 1
	and	esi, 1
	and	r14d, 1
	and	r11d, 1

; 947  : 					{
; 948  : #define SHOR(DST_VAR, SHIFT, BIT_VAR) (DST_VAR) |= (BIT_VAR) << (SHIFT)
; 949  : #define ASSIGN_X_BITS(V0,S0, V1,S1, V2,S2, V3,S3, V4,S4, V5,S5) do { SHOR(V0,S0,x0); SHOR(V1,S1,x1); SHOR(V2,S2,x2); SHOR(V3,S3,x3); SHOR(V4,S4,x4); SHOR(V5,S5,x5); } while (false)
; 950  : 						const deUint32 x0 = getBit(v2, 6);
; 951  : 						const deUint32 x1 = getBit(v3, 6);
; 952  : 						const deUint32 x2 = getBit(v4, 6);
; 953  : 						const deUint32 x3 = getBit(v5, 6);
; 954  : 						const deUint32 x4 = getBit(v4, 5);
; 955  : 						const deUint32 x5 = getBit(v5, 5);
; 956  : 						switch (mode)

	add	rax, r13
	mov	r13d, DWORD PTR major$1$[rsp]
	jmp	rax
$LN6@decodeHDRE:

; 957  : 						{
; 958  : 						case 0: ASSIGN_X_BITS(b0, 6, b1, 6, d0, 6, d1, 6, d0, 5, d1, 5); break;

	shl	ecx, 6
	or	r15d, ecx
	shl	esi, 6
	or	r12d, esi
$LN162@decodeHDRE:

; 966  : 						default:
; 967  : 							DE_ASSERT(false);
; 968  : 						}
; 969  : #undef ASSIGN_X_BITS
; 970  : #undef SHOR
; 971  : 					}
; 972  : 					static const int numDBits[] = { 7, 6, 7, 6, 5, 6, 5, 6 };
; 973  : 					DE_ASSERT(mode < DE_LENGTH_OF_ARRAY(numDBits));
; 974  : 					d0 = signExtend(d0, numDBits[mode]);

	mov	eax, DWORD PTR x2$1$[rsp]
	add	eax, eax
	or	eax, r10d
	shl	eax, 5
	or	r8d, eax
	lea	eax, DWORD PTR [r14+r14]
	or	eax, r11d
	shl	eax, 5
	or	ebp, eax
	jmp	$LN38@decodeHDRE
$LN9@decodeHDRE:

; 959  : 						case 1: ASSIGN_X_BITS(b0, 6, b1, 6, b0, 7, b1, 7, d0, 5, d1, 5); break;

	mov	eax, DWORD PTR x2$1$[rsp]
	add	eax, eax
	or	eax, ecx
	shl	eax, 6
	or	r15d, eax
	lea	eax, DWORD PTR [r14+r14]
	or	eax, esi
	shl	eax, 6
	or	r12d, eax
	jmp	$LN160@decodeHDRE
$LN12@decodeHDRE:

; 960  : 						case 2: ASSIGN_X_BITS(a, 9, c, 6, d0, 6, d1, 6, d0, 5, d1, 5); break;

	shl	ecx, 9
	or	edx, ecx
	shl	esi, 6
	or	r9d, esi
	jmp	SHORT $LN162@decodeHDRE
$LN15@decodeHDRE:

; 961  : 						case 3: ASSIGN_X_BITS(b0, 6, b1, 6, a, 9, c, 6, d0, 5, d1, 5); break;

	mov	eax, DWORD PTR x2$1$[rsp]
	shl	ecx, 6
	or	r15d, ecx
	shl	esi, 6
	or	r12d, esi
	jmp	SHORT $LN161@decodeHDRE
$LN18@decodeHDRE:

; 962  : 						case 4: ASSIGN_X_BITS(b0, 6, b1, 6, b0, 7, b1, 7, a, 9, a, 10); break;

	mov	eax, DWORD PTR x2$1$[rsp]
	add	eax, eax
	or	eax, ecx
	shl	eax, 6
	or	r15d, eax
	lea	eax, DWORD PTR [r14+r14]
	or	eax, esi
	shl	eax, 6
	or	r12d, eax
	lea	eax, DWORD PTR [r11+r11]
	or	eax, r10d
	shl	eax, 9
	or	edx, eax
	jmp	SHORT $LN38@decodeHDRE
$LN21@decodeHDRE:

; 963  : 						case 5: ASSIGN_X_BITS(a, 9, a, 10, c, 7, c, 6, d0, 5, d1, 5); break;

	lea	eax, DWORD PTR [rsi+rsi]
	or	eax, ecx
	shl	eax, 9
	or	edx, eax
	mov	eax, DWORD PTR x2$1$[rsp]
	add	eax, eax
	or	eax, r14d
	shl	eax, 6
	or	r9d, eax
	jmp	SHORT $LN160@decodeHDRE
$LN24@decodeHDRE:

; 964  : 						case 6: ASSIGN_X_BITS(b0, 6, b1, 6, a, 11, c, 6, a, 9, a, 10); break;

	mov	eax, DWORD PTR x2$1$[rsp]
	add	eax, eax
	shl	ecx, 6
	or	eax, r11d
	shl	esi, 6
	add	eax, eax
	shl	r14d, 6
	or	eax, r10d
	or	r15d, ecx
	shl	eax, 9
	or	r12d, esi
	or	r9d, r14d
	or	edx, eax
	jmp	SHORT $LN38@decodeHDRE
$LN27@decodeHDRE:

; 965  : 						case 7: ASSIGN_X_BITS(a, 9, a, 10, a, 11, c, 6, d0, 5, d1, 5); break;

	mov	eax, DWORD PTR x2$1$[rsp]
	add	eax, eax
	or	eax, esi
	add	eax, eax
	or	eax, ecx
$LN161@decodeHDRE:

; 966  : 						default:
; 967  : 							DE_ASSERT(false);
; 968  : 						}
; 969  : #undef ASSIGN_X_BITS
; 970  : #undef SHOR
; 971  : 					}
; 972  : 					static const int numDBits[] = { 7, 6, 7, 6, 5, 6, 5, 6 };
; 973  : 					DE_ASSERT(mode < DE_LENGTH_OF_ARRAY(numDBits));
; 974  : 					d0 = signExtend(d0, numDBits[mode]);

	shl	eax, 9
	or	edx, eax
	shl	r14d, 6
	or	r9d, r14d
$LN160@decodeHDRE:
	shl	r10d, 5
	or	r8d, r10d
	shl	r11d, 5
	or	ebp, r11d
$LN38@decodeHDRE:
	mov	r11d, DWORD PTR shiftAmount$1$[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase

; 250  : 				const bool negative = (src & (1 << (numSrcBits - 1))) != 0;

	xor	r10d, r10d
	mov	esi, 1

; 966  : 						default:
; 967  : 							DE_ASSERT(false);
; 968  : 						}
; 969  : #undef ASSIGN_X_BITS
; 970  : #undef SHOR
; 971  : 					}
; 972  : 					static const int numDBits[] = { 7, 6, 7, 6, 5, 6, 5, 6 };
; 973  : 					DE_ASSERT(mode < DE_LENGTH_OF_ARRAY(numDBits));
; 974  : 					d0 = signExtend(d0, numDBits[mode]);

	mov	r14d, DWORD PTR ?numDBits@?6??decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@4@0IIIIII@Z@4QBHB[rcx+r11*4]
	mov	DWORD PTR numSrcBits$1$[rsp], r14d

; 250  : 				const bool negative = (src & (1 << (numSrcBits - 1))) != 0;

	lea	eax, QWORD PTR [r10-1]
	lea	ecx, DWORD PTR [r14-1]
	shl	esi, cl
	test	esi, r8d

; 251  : 				return src | (negative ? ~((1 << numSrcBits) - 1) : 0);

	je	SHORT $LN101@decodeHDRE
	mov	ecx, r14d
	mov	r14d, eax
	shl	r14d, cl
	jmp	SHORT $LN102@decodeHDRE
$LN101@decodeHDRE:
	mov	r14d, r10d
$LN102@decodeHDRE:

; 975  : 					d1 = signExtend(d1, numDBits[mode]);
; 976  : 					const int shiftAmount = (mode >> 1) ^ 3;

	xor	r11d, 6
	or	r8d, r14d

; 977  : 					a <<= shiftAmount;
; 978  : 					c <<= shiftAmount;
; 979  : 					b0 <<= shiftAmount;
; 980  : 					b1 <<= shiftAmount;
; 981  : 					d0 <<= shiftAmount;
; 982  : 					d1 <<= shiftAmount;
; 983  : 					e0 = UVec4(basisu::clamp(a - c, 0, 0xfff),

	mov	r14, QWORD PTR [rsp+24]
	shr	r11d, 1
	mov	ecx, r11d
	shl	edx, cl
	shl	r9d, cl
	shl	r15d, cl
	shl	r12d, cl
	shl	r8d, cl
	mov	ecx, DWORD PTR numSrcBits$1$[rsp]
	shl	eax, cl
	mov	ecx, r11d

; 250  : 				const bool negative = (src & (1 << (numSrcBits - 1))) != 0;

	test	esi, ebp

; 977  : 					a <<= shiftAmount;
; 978  : 					c <<= shiftAmount;
; 979  : 					b0 <<= shiftAmount;
; 980  : 					b1 <<= shiftAmount;
; 981  : 					d0 <<= shiftAmount;
; 982  : 					d1 <<= shiftAmount;
; 983  : 					e0 = UVec4(basisu::clamp(a - c, 0, 0xfff),

	mov	r11d, 4095				; 00000fffH
	mov	rsi, QWORD PTR [rsp+72]
	cmove	eax, r10d

; 251  : 				return src | (negative ? ~((1 << numSrcBits) - 1) : 0);

	or	eax, ebp

; 977  : 					a <<= shiftAmount;
; 978  : 					c <<= shiftAmount;
; 979  : 					b0 <<= shiftAmount;
; 980  : 					b1 <<= shiftAmount;
; 981  : 					d0 <<= shiftAmount;
; 982  : 					d1 <<= shiftAmount;
; 983  : 					e0 = UVec4(basisu::clamp(a - c, 0, 0xfff),

	mov	rbp, QWORD PTR [rsp+64]
	shl	eax, cl
	mov	ecx, edx
	sub	ecx, eax
	sub	ecx, r12d
	sub	ecx, r9d

; 80   : 		if (a < l)

	jns	SHORT $LN108@decodeHDRE

; 81   : 			return l;

	mov	ecx, r10d
	jmp	SHORT $LN110@decodeHDRE
$LN108@decodeHDRE:

; 82   : 		else if (a > h)

	cmp	ecx, r11d
	cmovg	ecx, r11d
$LN110@decodeHDRE:

; 977  : 					a <<= shiftAmount;
; 978  : 					c <<= shiftAmount;
; 979  : 					b0 <<= shiftAmount;
; 980  : 					b1 <<= shiftAmount;
; 981  : 					d0 <<= shiftAmount;
; 982  : 					d1 <<= shiftAmount;
; 983  : 					e0 = UVec4(basisu::clamp(a - c, 0, 0xfff),

	mov	eax, edx
	sub	eax, r8d
	sub	eax, r15d
	sub	eax, r9d

; 80   : 		if (a < l)

	jns	SHORT $LN113@decodeHDRE

; 81   : 			return l;

	mov	eax, r10d
	jmp	SHORT $LN115@decodeHDRE
$LN113@decodeHDRE:

; 82   : 		else if (a > h)

	cmp	eax, r11d
	cmovg	eax, r11d
$LN115@decodeHDRE:

; 977  : 					a <<= shiftAmount;
; 978  : 					c <<= shiftAmount;
; 979  : 					b0 <<= shiftAmount;
; 980  : 					b1 <<= shiftAmount;
; 981  : 					d0 <<= shiftAmount;
; 982  : 					d1 <<= shiftAmount;
; 983  : 					e0 = UVec4(basisu::clamp(a - c, 0, 0xfff),

	mov	r8d, edx
	sub	r8d, r9d

; 80   : 		if (a < l)

	jns	SHORT $LN118@decodeHDRE

; 81   : 			return l;

	mov	r8d, r10d
	jmp	SHORT $LN120@decodeHDRE
$LN118@decodeHDRE:

; 82   : 		else if (a > h)

	cmp	r8d, r11d
	cmovg	r8d, r11d
$LN120@decodeHDRE:

; 977  : 					a <<= shiftAmount;
; 978  : 					c <<= shiftAmount;
; 979  : 					b0 <<= shiftAmount;
; 980  : 					b1 <<= shiftAmount;
; 981  : 					d0 <<= shiftAmount;
; 982  : 					d1 <<= shiftAmount;
; 983  : 					e0 = UVec4(basisu::clamp(a - c, 0, 0xfff),

	mov	DWORD PTR [rdi], r8d
	mov	DWORD PTR [rdi+4], eax
	mov	DWORD PTR [rdi+8], ecx

; 984  : 						basisu::clamp(a - b0 - c - d0, 0, 0xfff),
; 985  : 						basisu::clamp(a - b1 - c - d1, 0, 0xfff),
; 986  : 						0x780);
; 987  : 					e1 = UVec4(basisu::clamp(a, 0, 0xfff),

	mov	ecx, edx
	sub	ecx, r12d
	mov	DWORD PTR [rdi+12], 1920		; 00000780H
	mov	r12, QWORD PTR [rsp+80]

; 80   : 		if (a < l)

	jns	SHORT $LN125@decodeHDRE

; 81   : 			return l;

	mov	ecx, r10d
	jmp	SHORT $LN127@decodeHDRE
$LN125@decodeHDRE:

; 82   : 		else if (a > h)

	cmp	ecx, r11d
	cmovg	ecx, r11d
$LN127@decodeHDRE:

; 984  : 						basisu::clamp(a - b0 - c - d0, 0, 0xfff),
; 985  : 						basisu::clamp(a - b1 - c - d1, 0, 0xfff),
; 986  : 						0x780);
; 987  : 					e1 = UVec4(basisu::clamp(a, 0, 0xfff),

	mov	eax, edx
	sub	eax, r15d
	mov	r15, QWORD PTR [rsp+16]

; 80   : 		if (a < l)

	jns	SHORT $LN130@decodeHDRE

; 81   : 			return l;

	mov	eax, r10d
	jmp	SHORT $LN132@decodeHDRE
$LN130@decodeHDRE:

; 82   : 		else if (a > h)

	cmp	eax, r11d
	cmovg	eax, r11d
$LN132@decodeHDRE:

; 80   : 		if (a < l)

	test	edx, edx
	js	SHORT $LN137@decodeHDRE

; 82   : 		else if (a > h)

	cmp	edx, r11d
	mov	r10d, edx
	cmovg	r10d, r11d
$LN137@decodeHDRE:

; 984  : 						basisu::clamp(a - b0 - c - d0, 0, 0xfff),
; 985  : 						basisu::clamp(a - b1 - c - d1, 0, 0xfff),
; 986  : 						0x780);
; 987  : 					e1 = UVec4(basisu::clamp(a, 0, 0xfff),

	mov	DWORD PTR [rbx], r10d
	mov	DWORD PTR [rbx+4], eax
	mov	DWORD PTR [rbx+8], ecx
	mov	DWORD PTR [rbx+12], 1920		; 00000780H

; 988  : 						basisu::clamp(a - b0, 0, 0xfff),
; 989  : 						basisu::clamp(a - b1, 0, 0xfff),
; 990  : 						0x780);
; 991  : 					if (major == 1)

	cmp	r13d, 1
	jne	SHORT $LN39@decodeHDRE
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [rdi]

; 100  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR [rdi], eax

; 101  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [rdi+4], ecx

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [rbx]

; 100  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [rbx+4]
	mov	DWORD PTR [rbx], eax

; 101  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [rbx+4], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 1002 : 			}

	add	rsp, 32					; 00000020H
	pop	r13
	pop	rdi
	pop	rbx
	ret	0
$LN39@decodeHDRE:

; 992  : 					{
; 993  : 						std::swap(e0.x(), e0.y());
; 994  : 						std::swap(e1.x(), e1.y());
; 995  : 					}
; 996  : 					else if (major == 2)

	cmp	r13d, 2
	jne	SHORT $LN148@decodeHDRE
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [rdi]

; 100  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [rdi+8]
	mov	DWORD PTR [rdi], eax

; 101  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [rdi+8], ecx

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [rbx]

; 100  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [rbx+8]
	mov	DWORD PTR [rbx], eax

; 101  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [rbx+8], ecx
$LN148@decodeHDRE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 1002 : 			}

	add	rsp, 32					; 00000020H
	pop	r13
	pop	rdi
	pop	rbx
	ret	0
	npad	3
$LN149@decodeHDRE:
	DD	$LN6@decodeHDRE
	DD	$LN9@decodeHDRE
	DD	$LN12@decodeHDRE
	DD	$LN15@decodeHDRE
	DD	$LN18@decodeHDRE
	DD	$LN21@decodeHDRE
	DD	$LN24@decodeHDRE
	DD	$LN27@decodeHDRE
?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z ENDP ; basisu::astc::`anonymous namespace'::decodeHDREndpointMode11
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decodeHDREndpointMode15@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIIIII@Z
_TEXT	SEGMENT
e0$ = 80
e1$ = 88
v0$ = 96
v1$ = 104
v2$ = 112
v3$ = 120
v4$ = 128
v5$ = 136
v6In$ = 144
v7In$ = 152
?decodeHDREndpointMode15@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIIIII@Z PROC ; basisu::astc::`anonymous namespace'::decodeHDREndpointMode15, COMDAT

; 1004 : 			{

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 1005 : 				decodeHDREndpointMode11(e0, e1, v0, v1, v2, v3, v4, v5);

	mov	eax, DWORD PTR v5$[rsp]
	mov	rbx, rdx
	mov	DWORD PTR [rsp+56], eax
	mov	rdi, rcx
	mov	eax, DWORD PTR v4$[rsp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR v3$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR v2$[rsp]
	mov	DWORD PTR [rsp+32], eax
	call	?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z ; basisu::astc::`anonymous namespace'::decodeHDREndpointMode11

; 1006 : 				const deUint32	mode = (getBit(v7In, 7) << 1) | getBit(v6In, 7);

	mov	r10d, DWORD PTR v6In$[rsp]
	mov	r11d, r10d
	mov	r9d, DWORD PTR v7In$[rsp]

; 1007 : 				deInt32			v6 = (deInt32)getBits(v6In, 0, 6);

	and	r10d, 127				; 0000007fH
	shr	r11d, 1
	mov	eax, r9d
	and	r11d, 64				; 00000040H
	and	eax, 128				; 00000080H
	or	r11d, eax

; 1008 : 				deInt32			v7 = (deInt32)getBits(v7In, 0, 6);

	and	r9d, 127				; 0000007fH
	shr	r11d, 6

; 1009 : 				if (mode == 3)

	cmp	r11d, 3
	jne	SHORT $LN2@decodeHDRE

; 1010 : 				{
; 1011 : 					e0.w() = v6 << 5;
; 1012 : 					e1.w() = v7 << 5;

	shl	r9d, 5
	shl	r10d, 5

; 1023 : 					v7 = basisu::clamp(v7, 0, 0xfff);
; 1024 : 					e0.w() = v6;
; 1025 : 					e1.w() = v7;
; 1026 : 				}
; 1027 : 			}

	mov	DWORD PTR [rdi+12], r10d
	mov	DWORD PTR [rbx+12], r9d
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN2@decodeHDRE:

; 1013 : 				}
; 1014 : 				else
; 1015 : 				{
; 1016 : 					v6 |= (v7 << (mode + 1)) & 0x780;

	mov	eax, r9d
	lea	ecx, DWORD PTR [r11+1]
	shl	eax, cl

; 1017 : 					v7 &= (0x3f >> mode);
; 1018 : 					v7 ^= 0x20 >> mode;
; 1019 : 					v7 -= 0x20 >> mode;
; 1020 : 					v6 <<= 4 - mode;

	mov	r8d, 4
	and	eax, 1920				; 00000780H
	sub	r8d, r11d
	or	r10d, eax
	mov	ecx, r8d
	shl	r10d, cl
	mov	eax, 63					; 0000003fH
	mov	ecx, r11d
	mov	edx, 32					; 00000020H
	sar	edx, cl
	sar	eax, cl

; 1021 : 					v7 <<= 4 - mode;

	mov	ecx, r8d
	and	r9d, eax
	xor	r9d, edx
	sub	r9d, edx
	shl	r9d, cl

; 1022 : 					v7 += v6;

	add	r9d, r10d

; 80   : 		if (a < l)

	jns	SHORT $LN18@decodeHDRE

; 81   : 			return l;

	xor	r9d, r9d

; 1023 : 					v7 = basisu::clamp(v7, 0, 0xfff);
; 1024 : 					e0.w() = v6;
; 1025 : 					e1.w() = v7;
; 1026 : 				}
; 1027 : 			}

	mov	DWORD PTR [rdi+12], r10d
	mov	DWORD PTR [rbx+12], r9d
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN18@decodeHDRE:

; 82   : 		else if (a > h)

	mov	eax, 4095				; 00000fffH

; 1023 : 					v7 = basisu::clamp(v7, 0, 0xfff);
; 1024 : 					e0.w() = v6;
; 1025 : 					e1.w() = v7;
; 1026 : 				}
; 1027 : 			}

	mov	DWORD PTR [rdi+12], r10d

; 82   : 		else if (a > h)

	cmp	r9d, eax
	cmovg	r9d, eax

; 1023 : 					v7 = basisu::clamp(v7, 0, 0xfff);
; 1024 : 					e0.w() = v6;
; 1025 : 					e1.w() = v7;
; 1026 : 				}
; 1027 : 			}

	mov	DWORD PTR [rbx+12], r9d
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?decodeHDREndpointMode15@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIIIII@Z ENDP ; basisu::astc::`anonymous namespace'::decodeHDREndpointMode15
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z
_TEXT	SEGMENT
unquantizedNdx$1$ = 64
tv4797 = 68
$T13 = 72
dst$ = 160
unquantizedEndpoints$ = 168
endpointModes$ = 176
numPartitions$ = 184
?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z PROC ; basisu::astc::`anonymous namespace'::decodeColorEndpoints, COMDAT

; 1030 : 				int unquantizedNdx = 0;
; 1031 : 				for (int partitionNdx = 0; partitionNdx < numPartitions; partitionNdx++)

	test	r9d, r9d
	jle	$LN626@decodeColo

; 1029 : 			{

	mov	r11, rsp
	mov	QWORD PTR [r11+24], r8
	mov	QWORD PTR [r11+16], rdx
	mov	QWORD PTR [r11+8], rcx
	push	r13
	sub	rsp, 144				; 00000090H

; 1030 : 				int unquantizedNdx = 0;
; 1031 : 				for (int partitionNdx = 0; partitionNdx < numPartitions; partitionNdx++)

	mov	QWORD PTR [r11-16], rbx
	mov	r13, rdx
	mov	QWORD PTR [r11-24], rbp
	xor	edx, edx
	mov	QWORD PTR [r11-32], rsi
	mov	r10, rcx
	mov	QWORD PTR [r11-40], rdi
	xor	ebp, ebp
	mov	QWORD PTR [r11-48], r12
	mov	r12d, 4095				; 00000fffH
	mov	QWORD PTR [r11-64], r15
	mov	r15d, 255				; 000000ffH
	movsxd	rax, r9d
	lea	r9, OFFSET FLAT:__ImageBase
	mov	DWORD PTR tv4797[rsp], r15d
	mov	QWORD PTR $T13[rsp], rax
	mov	QWORD PTR [r11-56], r14
	npad	9
$LL4@decodeColo:

; 1032 : 				{
; 1033 : 					const deUint32		endpointMode = endpointModes[partitionNdx];

	mov	ecx, DWORD PTR [r8+rbp*4]

; 1034 : 					const deUint32* v = &unquantizedEndpoints[unquantizedNdx];
; 1035 : 					UVec4& e0 = dst[partitionNdx].e0;

	mov	rsi, rbp
	movsxd	rbx, edx

; 323  : 				return (endpointMode / 4 + 1) * 2;

	mov	eax, ecx
	shr	eax, 2

; 1034 : 					const deUint32* v = &unquantizedEndpoints[unquantizedNdx];
; 1035 : 					UVec4& e0 = dst[partitionNdx].e0;

	shl	rsi, 5
	add	rsi, r10

; 1036 : 					UVec4& e1 = dst[partitionNdx].e1;
; 1037 : 					unquantizedNdx += computeNumColorEndpointValues(endpointMode);

	lea	edx, DWORD PTR [rdx+rax*2]
	add	edx, 2
	mov	DWORD PTR unquantizedNdx$1$[rsp], edx

; 1038 : 					switch (endpointMode)

	cmp	ecx, 15
	ja	$LN2@decodeColo
	mov	ecx, DWORD PTR $LN573@decodeColo[r9+rcx*4]
	add	rcx, r9
	jmp	rcx
$LN7@decodeColo:

; 101  : 			m_c[0] = x;

	mov	eax, DWORD PTR [r13+rbx*4]

; 1039 : 					{
; 1040 : 					case 0:
; 1041 : 						e0 = UVec4(v[0], v[0], v[0], 0xff);

	mov	DWORD PTR [rsi], eax
	mov	DWORD PTR [rsi+4], eax
	mov	DWORD PTR [rsi+8], eax
	mov	DWORD PTR [rsi+12], r15d

; 101  : 			m_c[0] = x;

	mov	eax, DWORD PTR [r13+rbx*4+4]

; 1042 : 						e1 = UVec4(v[1], v[1], v[1], 0xff);

	mov	DWORD PTR [rsi+16], eax
	mov	DWORD PTR [rsi+20], eax
	mov	DWORD PTR [rsi+24], eax
	mov	DWORD PTR [rsi+28], r15d

; 1043 : 						break;

	jmp	$LN2@decodeColo
$LN8@decodeColo:

; 1044 : 					case 1:
; 1045 : 					{
; 1046 : 						const deUint32 L0 = (v[0] >> 2) | (getBits(v[1], 6, 7) << 6);

	mov	edx, DWORD PTR [r13+rbx*4+4]
	mov	ecx, edx
	mov	eax, DWORD PTR [r13+rbx*4]

; 1047 : 						const deUint32 L1 = basisu::min(0xffu, L0 + getBits(v[1], 0, 5));

	and	edx, 63					; 0000003fH
	and	ecx, 192				; 000000c0H
	shr	eax, 2
	or	ecx, eax

; 1048 : 						e0 = UVec4(L0, L0, L0, 0xff);

	mov	DWORD PTR [rsi], ecx
	add	edx, ecx
	mov	DWORD PTR [rsi+4], ecx

; 74   : 		return (a < b) ? a : b;

	cmp	edx, r15d

; 1048 : 						e0 = UVec4(L0, L0, L0, 0xff);

	mov	DWORD PTR [rsi+8], ecx
	mov	DWORD PTR [rsi+12], r15d

; 74   : 		return (a < b) ? a : b;

	cmova	edx, r15d

; 1049 : 						e1 = UVec4(L1, L1, L1, 0xff);

	mov	DWORD PTR [rsi+16], edx
	mov	DWORD PTR [rsi+20], edx
	mov	DWORD PTR [rsi+24], edx
	mov	DWORD PTR [rsi+28], r15d

; 1050 : 						break;

	jmp	$LN627@decodeColo
$LN9@decodeColo:

; 1051 : 					}
; 1052 : 					case 2:
; 1053 : 					{
; 1054 : 						const deUint32 v1Gr = v[1] >= v[0];

	mov	eax, DWORD PTR [r13+rbx*4+4]
	mov	edx, DWORD PTR [r13+rbx*4]

; 1055 : 						const deUint32 y0 = v1Gr ? v[0] << 4 : (v[1] << 4) + 8;

	cmp	eax, edx
	jb	SHORT $LN33@decodeColo
	shl	edx, 4
	mov	ecx, edx

; 1056 : 						const deUint32 y1 = v1Gr ? v[1] << 4 : (v[0] << 4) - 8;

	shl	eax, 4
	jmp	SHORT $LN36@decodeColo
$LN33@decodeColo:

; 1055 : 						const deUint32 y0 = v1Gr ? v[0] << 4 : (v[1] << 4) + 8;

	mov	ecx, eax

; 1056 : 						const deUint32 y1 = v1Gr ? v[1] << 4 : (v[0] << 4) - 8;

	mov	eax, edx
	shl	ecx, 4
	add	ecx, 8
	shl	eax, 4
	sub	eax, 8
$LN36@decodeColo:

; 1057 : 						e0 = UVec4(y0, y0, y0, 0x780);

	mov	DWORD PTR [rsi], ecx
	mov	DWORD PTR [rsi+4], ecx
	mov	DWORD PTR [rsi+8], ecx
$LN635@decodeColo:

; 1030 : 				int unquantizedNdx = 0;
; 1031 : 				for (int partitionNdx = 0; partitionNdx < numPartitions; partitionNdx++)

	mov	DWORD PTR [rsi+12], 1920		; 00000780H
	mov	DWORD PTR [rsi+16], eax
	mov	DWORD PTR [rsi+20], eax
	mov	DWORD PTR [rsi+24], eax
	mov	DWORD PTR [rsi+28], 1920		; 00000780H
	jmp	$LN627@decodeColo
$LN10@decodeColo:

; 214  : 				return (src >> ndx) & 1;

	mov	edx, DWORD PTR [r13+rbx*4]
	mov	eax, edx

; 1058 : 						e1 = UVec4(y1, y1, y1, 0x780);
; 1059 : 						break;
; 1060 : 					}
; 1061 : 					case 3:
; 1062 : 					{
; 1063 : 						const bool		m = isBitSet(v[0], 7);
; 1064 : 						const deUint32	y0 = m ? (getBits(v[1], 5, 7) << 9) | (getBits(v[0], 0, 6) << 2)

	mov	ecx, DWORD PTR [r13+rbx*4+4]
	and	edx, 127				; 0000007fH

; 214  : 				return (src >> ndx) & 1;

	shr	eax, 7
	test	al, 1

; 1058 : 						e1 = UVec4(y1, y1, y1, 0x780);
; 1059 : 						break;
; 1060 : 					}
; 1061 : 					case 3:
; 1062 : 					{
; 1063 : 						const bool		m = isBitSet(v[0], 7);
; 1064 : 						const deUint32	y0 = m ? (getBits(v[1], 5, 7) << 9) | (getBits(v[0], 0, 6) << 2)

	mov	eax, ecx
	je	SHORT $LN37@decodeColo

; 221  : 					return (deUint32)((src >> low) & ((1u << numBits) - 1));

	shr	eax, 5
	and	eax, 7

; 1058 : 						e1 = UVec4(y1, y1, y1, 0x780);
; 1059 : 						break;
; 1060 : 					}
; 1061 : 					case 3:
; 1062 : 					{
; 1063 : 						const bool		m = isBitSet(v[0], 7);
; 1064 : 						const deUint32	y0 = m ? (getBits(v[1], 5, 7) << 9) | (getBits(v[0], 0, 6) << 2)

	shl	eax, 7
	or	eax, edx

; 1065 : 							: (getBits(v[1], 4, 7) << 8) | (getBits(v[0], 0, 6) << 1);
; 1066 : 						const deUint32	d = m ? getBits(v[1], 0, 4) << 2

	and	ecx, 31
	lea	edx, DWORD PTR [rax*4]
	lea	ecx, DWORD PTR [rcx*4]
	jmp	SHORT $LN40@decodeColo
$LN37@decodeColo:

; 221  : 					return (deUint32)((src >> low) & ((1u << numBits) - 1));

	shr	eax, 4

; 1065 : 							: (getBits(v[1], 4, 7) << 8) | (getBits(v[0], 0, 6) << 1);
; 1066 : 						const deUint32	d = m ? getBits(v[1], 0, 4) << 2

	and	ecx, 15

; 221  : 					return (deUint32)((src >> low) & ((1u << numBits) - 1));

	and	eax, 15

; 1058 : 						e1 = UVec4(y1, y1, y1, 0x780);
; 1059 : 						break;
; 1060 : 					}
; 1061 : 					case 3:
; 1062 : 					{
; 1063 : 						const bool		m = isBitSet(v[0], 7);
; 1064 : 						const deUint32	y0 = m ? (getBits(v[1], 5, 7) << 9) | (getBits(v[0], 0, 6) << 2)

	shl	eax, 7
	or	eax, edx

; 1065 : 							: (getBits(v[1], 4, 7) << 8) | (getBits(v[0], 0, 6) << 1);
; 1066 : 						const deUint32	d = m ? getBits(v[1], 0, 4) << 2

	add	ecx, ecx
	lea	edx, DWORD PTR [rax+rax]
$LN40@decodeColo:

; 1067 : 							: getBits(v[1], 0, 3) << 1;
; 1068 : 						const deUint32	y1 = basisu::min(0xfffu, y0 + d);

	lea	eax, DWORD PTR [rcx+rdx]

; 1069 : 						e0 = UVec4(y0, y0, y0, 0x780);

	mov	DWORD PTR [rsi], edx

; 74   : 		return (a < b) ? a : b;

	cmp	eax, r12d

; 1069 : 						e0 = UVec4(y0, y0, y0, 0x780);

	mov	DWORD PTR [rsi+4], edx
	mov	DWORD PTR [rsi+8], edx

; 74   : 		return (a < b) ? a : b;

	cmova	eax, r12d

; 1070 : 						e1 = UVec4(y1, y1, y1, 0x780);
; 1071 : 						break;

	jmp	SHORT $LN635@decodeColo
$LN11@decodeColo:

; 101  : 			m_c[0] = x;

	mov	ecx, DWORD PTR [r13+rbx*4]

; 104  : 			m_c[3] = w;

	mov	eax, DWORD PTR [r13+rbx*4+8]

; 1072 : 					}
; 1073 : 					case 4:
; 1074 : 						e0 = UVec4(v[0], v[0], v[0], v[2]);

	mov	DWORD PTR [rsi], ecx
	mov	DWORD PTR [rsi+4], ecx
	mov	DWORD PTR [rsi+8], ecx
	mov	DWORD PTR [rsi+12], eax

; 101  : 			m_c[0] = x;

	mov	ecx, DWORD PTR [r13+rbx*4+4]

; 104  : 			m_c[3] = w;

	mov	eax, DWORD PTR [r13+rbx*4+12]

; 1075 : 						e1 = UVec4(v[1], v[1], v[1], v[3]);

	mov	DWORD PTR [rsi+16], ecx
	mov	DWORD PTR [rsi+20], ecx
	mov	DWORD PTR [rsi+24], ecx
	mov	DWORD PTR [rsi+28], eax

; 1076 : 						break;

	jmp	$LN2@decodeColo
$LN12@decodeColo:

; 1077 : 					case 5:
; 1078 : 					{
; 1079 : 						deInt32 v0 = (deInt32)v[0];
; 1080 : 						deInt32 v1 = (deInt32)v[1];

	mov	ecx, DWORD PTR [r13+rbx*4+4]

; 838  : 				b |= a & 0x80;

	mov	r8d, ecx

; 1081 : 						deInt32 v2 = (deInt32)v[2];
; 1082 : 						deInt32 v3 = (deInt32)v[3];

	mov	edx, DWORD PTR [r13+rbx*4+12]

; 838  : 				b |= a & 0x80;

	and	r8d, 128				; 00000080H
	mov	eax, DWORD PTR [r13+rbx*4]
	sar	eax, 1
	or	r8d, eax

; 839  : 				a >>= 1;
; 840  : 				a &= 0x3f;

	sar	ecx, 1
	and	ecx, 63					; 0000003fH

; 214  : 				return (src >> ndx) & 1;

	mov	eax, ecx
	shr	eax, 5

; 838  : 				b |= a & 0x80;

	test	al, al
	mov	eax, edx
	lea	r11d, DWORD PTR [rcx-64]
	cmove	r11d, ecx
	mov	ecx, DWORD PTR [r13+rbx*4+8]
	and	eax, 128				; 00000080H

; 839  : 				a >>= 1;
; 840  : 				a &= 0x3f;

	sar	edx, 1
	and	edx, 63					; 0000003fH
	sar	ecx, 1
	or	ecx, eax

; 214  : 				return (src >> ndx) & 1;

	mov	eax, edx
	shr	eax, 5

; 135  : 			m_c[0] = x;

	test	al, al
	lea	ebx, DWORD PTR [rdx-64]
	cmove	ebx, edx

; 80   : 		if (a < l)

	test	ecx, ecx
	jns	SHORT $LN72@decodeColo

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN74@decodeColo
$LN72@decodeColo:

; 82   : 		else if (a > h)

	cmp	ecx, r15d
	mov	eax, ecx
	cmovg	eax, r15d
$LN74@decodeColo:

; 80   : 		if (a < l)

	test	r8d, r8d
	jns	SHORT $LN77@decodeColo

; 81   : 			return l;

	xor	edx, edx
	xor	r9d, r9d
	xor	r10d, r10d
	jmp	SHORT $LN86@decodeColo
$LN77@decodeColo:

; 82   : 		else if (a > h)

	cmp	r8d, r15d
	jle	SHORT $LN79@decodeColo

; 83   : 			return h;

	mov	edx, r15d
	mov	r9d, r15d
	mov	r10d, r15d
	jmp	SHORT $LN86@decodeColo
$LN79@decodeColo:

; 84   : 		return a;

	mov	edx, r8d
	mov	r9d, r8d
	mov	r10d, r8d
$LN86@decodeColo:

; 1083 : 						bitTransferSigned(v1, v0);
; 1084 : 						bitTransferSigned(v3, v2);
; 1085 : 						e0 = clampedRGBA(IVec4(v0, v0, v0, v2));
; 1086 : 						e1 = clampedRGBA(IVec4(v0 + v1, v0 + v1, v0 + v1, v2 + v3));

	add	ecx, ebx
	mov	DWORD PTR [rsi], r10d
	mov	DWORD PTR [rsi+4], r9d
	mov	DWORD PTR [rsi+8], edx
	mov	DWORD PTR [rsi+12], eax
	lea	eax, DWORD PTR [r11+r8]

; 80   : 		if (a < l)

	jns	SHORT $LN98@decodeColo

; 81   : 			return l;

	xor	ecx, ecx
	jmp	SHORT $LN100@decodeColo
$LN98@decodeColo:

; 82   : 		else if (a > h)

	cmp	ecx, r15d
	cmovg	ecx, r15d
$LN100@decodeColo:

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN103@decodeColo

; 81   : 			return l;

	xor	eax, eax
	xor	edx, edx
	xor	r8d, r8d

; 1083 : 						bitTransferSigned(v1, v0);
; 1084 : 						bitTransferSigned(v3, v2);
; 1085 : 						e0 = clampedRGBA(IVec4(v0, v0, v0, v2));
; 1086 : 						e1 = clampedRGBA(IVec4(v0 + v1, v0 + v1, v0 + v1, v2 + v3));

	mov	DWORD PTR [rsi+16], r8d
	mov	DWORD PTR [rsi+20], edx
	mov	DWORD PTR [rsi+24], eax
	mov	DWORD PTR [rsi+28], ecx

; 1087 : 						break;

	jmp	$LN628@decodeColo
$LN103@decodeColo:

; 82   : 		else if (a > h)

	cmp	eax, r15d
	jle	SHORT $LN105@decodeColo

; 1083 : 						bitTransferSigned(v1, v0);
; 1084 : 						bitTransferSigned(v3, v2);
; 1085 : 						e0 = clampedRGBA(IVec4(v0, v0, v0, v2));
; 1086 : 						e1 = clampedRGBA(IVec4(v0 + v1, v0 + v1, v0 + v1, v2 + v3));

	mov	DWORD PTR [rsi+16], r15d

; 83   : 			return h;

	mov	edx, r15d

; 1083 : 						bitTransferSigned(v1, v0);
; 1084 : 						bitTransferSigned(v3, v2);
; 1085 : 						e0 = clampedRGBA(IVec4(v0, v0, v0, v2));
; 1086 : 						e1 = clampedRGBA(IVec4(v0 + v1, v0 + v1, v0 + v1, v2 + v3));

	mov	DWORD PTR [rsi+20], edx

; 83   : 			return h;

	mov	eax, r15d

; 1083 : 						bitTransferSigned(v1, v0);
; 1084 : 						bitTransferSigned(v3, v2);
; 1085 : 						e0 = clampedRGBA(IVec4(v0, v0, v0, v2));
; 1086 : 						e1 = clampedRGBA(IVec4(v0 + v1, v0 + v1, v0 + v1, v2 + v3));

	mov	DWORD PTR [rsi+24], eax

; 83   : 			return h;

	mov	r8d, r15d

; 1083 : 						bitTransferSigned(v1, v0);
; 1084 : 						bitTransferSigned(v3, v2);
; 1085 : 						e0 = clampedRGBA(IVec4(v0, v0, v0, v2));
; 1086 : 						e1 = clampedRGBA(IVec4(v0 + v1, v0 + v1, v0 + v1, v2 + v3));

	mov	DWORD PTR [rsi+28], ecx

; 1087 : 						break;

	jmp	$LN628@decodeColo
$LN105@decodeColo:

; 1083 : 						bitTransferSigned(v1, v0);
; 1084 : 						bitTransferSigned(v3, v2);
; 1085 : 						e0 = clampedRGBA(IVec4(v0, v0, v0, v2));
; 1086 : 						e1 = clampedRGBA(IVec4(v0 + v1, v0 + v1, v0 + v1, v2 + v3));

	mov	DWORD PTR [rsi+16], eax

; 84   : 		return a;

	mov	edx, eax

; 1083 : 						bitTransferSigned(v1, v0);
; 1084 : 						bitTransferSigned(v3, v2);
; 1085 : 						e0 = clampedRGBA(IVec4(v0, v0, v0, v2));
; 1086 : 						e1 = clampedRGBA(IVec4(v0 + v1, v0 + v1, v0 + v1, v2 + v3));

	mov	DWORD PTR [rsi+20], eax

; 84   : 		return a;

	mov	r8d, eax

; 1083 : 						bitTransferSigned(v1, v0);
; 1084 : 						bitTransferSigned(v3, v2);
; 1085 : 						e0 = clampedRGBA(IVec4(v0, v0, v0, v2));
; 1086 : 						e1 = clampedRGBA(IVec4(v0 + v1, v0 + v1, v0 + v1, v2 + v3));

	mov	DWORD PTR [rsi+24], eax
	mov	DWORD PTR [rsi+28], ecx

; 1087 : 						break;

	jmp	$LN628@decodeColo
$LN13@decodeColo:

; 1088 : 					}
; 1089 : 					case 6:
; 1090 : 						e0 = UVec4((v[0] * v[3]) >> 8, (v[1] * v[3]) >> 8, (v[2] * v[3]) >> 8, 0xff);

	mov	edx, DWORD PTR [r13+rbx*4+12]
	mov	ecx, edx
	imul	ecx, DWORD PTR [r13+rbx*4+4]
	mov	eax, edx
	imul	eax, DWORD PTR [r13+rbx*4+8]
	imul	edx, DWORD PTR [r13+rbx*4]
	shr	ecx, 8
	shr	eax, 8
	shr	edx, 8
	mov	DWORD PTR [rsi], edx
	mov	DWORD PTR [rsi+4], ecx
	mov	DWORD PTR [rsi+8], eax
	mov	DWORD PTR [rsi+12], r15d

; 102  : 			m_c[1] = y;

	mov	ecx, DWORD PTR [r13+rbx*4+4]

; 103  : 			m_c[2] = z;

	mov	edx, DWORD PTR [r13+rbx*4+8]

; 1091 : 						e1 = UVec4(v[0], v[1], v[2], 0xff);

	mov	eax, DWORD PTR [r13+rbx*4]
	mov	DWORD PTR [rsi+16], eax
	mov	DWORD PTR [rsi+20], ecx
	mov	DWORD PTR [rsi+24], edx
	mov	DWORD PTR [rsi+28], r15d

; 1092 : 						break;

	jmp	$LN627@decodeColo
$LN14@decodeColo:

; 1093 : 					case 7:
; 1094 : 						decodeHDREndpointMode7(e0, e1, v[0], v[1], v[2], v[3]);

	mov	eax, DWORD PTR [r13+rbx*4+12]
	lea	rdx, QWORD PTR [rsi+16]
	mov	r9d, DWORD PTR [r13+rbx*4+4]
	mov	rcx, rsi
	mov	r8d, DWORD PTR [r13+rbx*4]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [r13+rbx*4+8]
	mov	DWORD PTR [rsp+32], eax
	call	?decodeHDREndpointMode7@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIII@Z ; basisu::astc::`anonymous namespace'::decodeHDREndpointMode7

; 1095 : 						break;

	jmp	$LN628@decodeColo
$LN15@decodeColo:

; 1096 : 					case 8:
; 1097 : 						if (v[1] + v[3] + v[5] >= v[0] + v[2] + v[4])

	mov	r9d, DWORD PTR [r13+rbx*4+12]
	mov	edx, DWORD PTR [r13+rbx*4+16]
	mov	r8d, DWORD PTR [r13+rbx*4+8]
	mov	r10d, DWORD PTR [r13+rbx*4+20]
	add	r9d, r10d
	mov	r14d, DWORD PTR [r13+rbx*4+4]
	mov	r11d, DWORD PTR [r13+rbx*4]
	lea	ecx, DWORD PTR [rdx+r8]
	add	ecx, r11d
	lea	eax, DWORD PTR [r14+r9]
	cmp	eax, ecx
	jb	SHORT $LN16@decodeColo

; 1098 : 						{
; 1099 : 							e0 = UVec4(v[0], v[2], v[4], 0xff);

	mov	DWORD PTR [rsi], r11d
	mov	DWORD PTR [rsi+4], r8d
	mov	DWORD PTR [rsi+8], edx
	mov	DWORD PTR [rsi+12], r15d

; 102  : 			m_c[1] = y;

	mov	ecx, DWORD PTR [r13+rbx*4+12]

; 103  : 			m_c[2] = z;

	mov	edx, DWORD PTR [r13+rbx*4+20]

; 1100 : 							e1 = UVec4(v[1], v[3], v[5], 0xff);

	mov	eax, DWORD PTR [r13+rbx*4+4]
	mov	DWORD PTR [rsi+16], eax
	mov	DWORD PTR [rsi+20], ecx
	mov	DWORD PTR [rsi+24], edx

; 1106 : 						}
; 1107 : 						break;

	mov	ecx, 12
	mov	eax, r15d
	mov	DWORD PTR [rsi+rcx+16], eax
	jmp	$LN628@decodeColo
$LN16@decodeColo:

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	sar	r9d, 1
	lea	r8d, DWORD PTR [r14+r10]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	sar	r8d, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	test	r9d, r9d
	cmovg	edx, r9d
	xor	ecx, ecx
	test	r10d, r10d
	cmovg	ecx, r10d
	xor	eax, eax
	test	r8d, r8d
	cmovg	eax, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 1104 : 							e0 = blueContract(v[1], v[3], v[5], 0xff).asUint();

	mov	DWORD PTR [rsi], eax
	mov	DWORD PTR [rsi+4], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 1104 : 							e0 = blueContract(v[1], v[3], v[5], 0xff).asUint();

	mov	DWORD PTR [rsi+8], ecx
	mov	DWORD PTR [rsi+12], r15d

; 1105 : 							e1 = blueContract(v[0], v[2], v[4], 0xff).asUint();

	mov	r8d, DWORD PTR [r13+rbx*4+16]

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	mov	r9d, DWORD PTR [r13+rbx*4]
	mov	ecx, DWORD PTR [r13+rbx*4+8]
	add	r9d, r8d
	add	ecx, r8d
	sar	r9d, 1
	sar	ecx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	test	ecx, ecx
	cmovg	edx, ecx
	xor	ecx, ecx
	test	r8d, r8d
	cmovg	ecx, r8d
	xor	eax, eax
	test	r9d, r9d
	cmovg	eax, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp

; 1105 : 							e1 = blueContract(v[0], v[2], v[4], 0xff).asUint();

	mov	DWORD PTR [rsi+16], eax
	mov	DWORD PTR [rsi+20], edx
	mov	DWORD PTR [rsi+24], ecx

; 1106 : 						}
; 1107 : 						break;

	mov	ecx, 12
	mov	eax, r15d
	mov	DWORD PTR [rsi+rcx+16], eax
	jmp	$LN628@decodeColo
$LN18@decodeColo:

; 1108 : 					case 9:
; 1109 : 					{
; 1110 : 						deInt32 v0 = (deInt32)v[0];
; 1111 : 						deInt32 v1 = (deInt32)v[1];

	mov	ecx, DWORD PTR [r13+rbx*4+4]

; 838  : 				b |= a & 0x80;

	mov	r10d, ecx

; 1112 : 						deInt32 v2 = (deInt32)v[2];
; 1113 : 						deInt32 v3 = (deInt32)v[3];

	mov	edx, DWORD PTR [r13+rbx*4+12]

; 838  : 				b |= a & 0x80;

	and	r10d, 128				; 00000080H

; 1114 : 						deInt32 v4 = (deInt32)v[4];
; 1115 : 						deInt32 v5 = (deInt32)v[5];

	mov	r8d, DWORD PTR [r13+rbx*4+20]

; 837  : 				b >>= 1;

	mov	eax, DWORD PTR [r13+rbx*4]
	mov	r9d, DWORD PTR [r13+rbx*4+8]
	sar	eax, 1

; 838  : 				b |= a & 0x80;

	or	r10d, eax

; 839  : 				a >>= 1;
; 840  : 				a &= 0x3f;

	sar	ecx, 1
	and	ecx, 63					; 0000003fH

; 214  : 				return (src >> ndx) & 1;

	mov	eax, ecx
	shr	eax, 5

; 838  : 				b |= a & 0x80;

	test	al, al
	mov	eax, edx
	lea	r11d, DWORD PTR [rcx-64]
	cmove	r11d, ecx

; 837  : 				b >>= 1;

	mov	ecx, DWORD PTR [r13+rbx*4+16]

; 838  : 				b |= a & 0x80;

	and	eax, 128				; 00000080H

; 839  : 				a >>= 1;
; 840  : 				a &= 0x3f;

	sar	edx, 1
	and	edx, 63					; 0000003fH
	sar	r9d, 1
	or	r9d, eax

; 214  : 				return (src >> ndx) & 1;

	mov	eax, edx
	shr	eax, 5

; 838  : 				b |= a & 0x80;

	test	al, al
	mov	eax, r8d
	lea	r14d, DWORD PTR [rdx-64]
	cmove	r14d, edx
	and	eax, 128				; 00000080H

; 839  : 				a >>= 1;
; 840  : 				a &= 0x3f;

	sar	r8d, 1
	and	r8d, 63					; 0000003fH
	sar	ecx, 1
	or	ecx, eax

; 214  : 				return (src >> ndx) & 1;

	mov	eax, r8d
	shr	eax, 5

; 1116 : 						bitTransferSigned(v1, v0);
; 1117 : 						bitTransferSigned(v3, v2);
; 1118 : 						bitTransferSigned(v5, v4);
; 1119 : 						if (v1 + v3 + v5 >= 0)

	test	al, al
	lea	ebx, DWORD PTR [r8-64]
	cmove	ebx, r8d
	lea	eax, DWORD PTR [rbx+r14]
	add	eax, r11d
	js	$LN19@decodeColo

; 80   : 		if (a < l)

	test	ecx, ecx
	jns	SHORT $LN237@decodeColo

; 81   : 			return l;

	xor	r8d, r8d
	jmp	SHORT $LN239@decodeColo
$LN237@decodeColo:

; 82   : 		else if (a > h)

	cmp	ecx, r15d
	mov	r8d, ecx
	cmovg	r8d, r15d
$LN239@decodeColo:

; 80   : 		if (a < l)

	test	r9d, r9d
	jns	SHORT $LN242@decodeColo

; 81   : 			return l;

	xor	edx, edx
	jmp	SHORT $LN244@decodeColo
$LN242@decodeColo:

; 82   : 		else if (a > h)

	cmp	r9d, r15d
	mov	edx, r9d
	cmovg	edx, r15d
$LN244@decodeColo:

; 80   : 		if (a < l)

	test	r10d, r10d
	jns	SHORT $LN247@decodeColo

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN249@decodeColo
$LN247@decodeColo:

; 82   : 		else if (a > h)

	cmp	r10d, r15d
	mov	eax, r10d
	cmovg	eax, r15d
$LN249@decodeColo:

; 1120 : 						{
; 1121 : 							e0 = clampedRGBA(IVec4(v0, v2, v4, 0xff));

	mov	DWORD PTR [rsi], eax

; 1122 : 							e1 = clampedRGBA(IVec4(v0 + v1, v2 + v3, v4 + v5, 0xff));

	lea	eax, DWORD PTR [r14+r9]
	mov	DWORD PTR [rsi+4], edx
	lea	edx, DWORD PTR [r11+r10]
	mov	DWORD PTR [rsi+8], r8d
	lea	r8d, DWORD PTR [rbx+rcx]
	mov	DWORD PTR [rsi+12], r15d

; 80   : 		if (a < l)

	test	r8d, r8d
	jns	SHORT $LN263@decodeColo

; 81   : 			return l;

	xor	r8d, r8d
	jmp	SHORT $LN265@decodeColo
$LN263@decodeColo:

; 82   : 		else if (a > h)

	cmp	r8d, r15d
	cmovg	r8d, r15d
$LN265@decodeColo:

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN268@decodeColo

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN270@decodeColo
$LN268@decodeColo:

; 82   : 		else if (a > h)

	cmp	eax, r15d
	cmovg	eax, r15d
$LN270@decodeColo:

; 80   : 		if (a < l)

	test	edx, edx
	jns	SHORT $LN273@decodeColo

; 81   : 			return l;

	xor	edx, edx

; 1122 : 							e1 = clampedRGBA(IVec4(v0 + v1, v2 + v3, v4 + v5, 0xff));

	mov	DWORD PTR [rsi+16], edx
	mov	DWORD PTR [rsi+20], eax
	mov	DWORD PTR [rsi+24], r8d

; 1128 : 						}
; 1129 : 						break;

	mov	ecx, 12
	mov	eax, r15d
	mov	DWORD PTR [rsi+rcx+16], eax
	jmp	$LN628@decodeColo
$LN273@decodeColo:

; 82   : 		else if (a > h)

	cmp	edx, r15d
	cmovg	edx, r15d

; 1122 : 							e1 = clampedRGBA(IVec4(v0 + v1, v2 + v3, v4 + v5, 0xff));

	mov	DWORD PTR [rsi+16], edx
	mov	DWORD PTR [rsi+20], eax
	mov	DWORD PTR [rsi+24], r8d

; 1128 : 						}
; 1129 : 						break;

	mov	ecx, 12
	mov	eax, r15d
	mov	DWORD PTR [rsi+rcx+16], eax
	jmp	$LN628@decodeColo
$LN19@decodeColo:

; 1123 : 						}
; 1124 : 						else
; 1125 : 						{
; 1126 : 							e0 = clampedRGBA(blueContract(v0 + v1, v2 + v3, v4 + v5, 0xff));

	lea	r8d, DWORD PTR [rbx+rcx]

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	lea	edx, DWORD PTR [r8+r11]
	add	edx, r10d
	lea	eax, DWORD PTR [r8+r14]
	add	eax, r9d
	sar	edx, 1
	sar	eax, 1

; 80   : 		if (a < l)

	test	r8d, r8d
	jns	SHORT $LN291@decodeColo

; 81   : 			return l;

	xor	r8d, r8d
	jmp	SHORT $LN293@decodeColo
$LN291@decodeColo:

; 82   : 		else if (a > h)

	cmp	r8d, r15d
	cmovg	r8d, r15d
$LN293@decodeColo:

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN296@decodeColo

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN298@decodeColo
$LN296@decodeColo:

; 82   : 		else if (a > h)

	cmp	eax, r15d
	cmovg	eax, r15d
$LN298@decodeColo:

; 80   : 		if (a < l)

	test	edx, edx
	jns	SHORT $LN301@decodeColo

; 81   : 			return l;

	xor	edx, edx
	jmp	SHORT $LN303@decodeColo
$LN301@decodeColo:

; 82   : 		else if (a > h)

	cmp	edx, r15d
	cmovg	edx, r15d
$LN303@decodeColo:

; 1123 : 						}
; 1124 : 						else
; 1125 : 						{
; 1126 : 							e0 = clampedRGBA(blueContract(v0 + v1, v2 + v3, v4 + v5, 0xff));

	mov	DWORD PTR [rsi], edx

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	lea	edx, DWORD PTR [rcx+r10]

; 1123 : 						}
; 1124 : 						else
; 1125 : 						{
; 1126 : 							e0 = clampedRGBA(blueContract(v0 + v1, v2 + v3, v4 + v5, 0xff));

	mov	DWORD PTR [rsi+4], eax

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	lea	eax, DWORD PTR [rcx+r9]
	sar	eax, 1
	sar	edx, 1

; 1123 : 						}
; 1124 : 						else
; 1125 : 						{
; 1126 : 							e0 = clampedRGBA(blueContract(v0 + v1, v2 + v3, v4 + v5, 0xff));

	mov	DWORD PTR [rsi+8], r8d
	mov	DWORD PTR [rsi+12], r15d

; 80   : 		if (a < l)

	test	ecx, ecx
	jns	SHORT $LN319@decodeColo

; 81   : 			return l;

	xor	ecx, ecx
	jmp	SHORT $LN321@decodeColo
$LN319@decodeColo:

; 82   : 		else if (a > h)

	cmp	ecx, r15d
	cmovg	ecx, r15d
$LN321@decodeColo:

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN324@decodeColo

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN326@decodeColo
$LN324@decodeColo:

; 82   : 		else if (a > h)

	cmp	eax, r15d
	cmovg	eax, r15d
$LN326@decodeColo:

; 80   : 		if (a < l)

	test	edx, edx
	jns	SHORT $LN329@decodeColo

; 81   : 			return l;

	xor	edx, edx
	jmp	SHORT $LN331@decodeColo
$LN329@decodeColo:

; 82   : 		else if (a > h)

	cmp	edx, r15d
	cmovg	edx, r15d
$LN331@decodeColo:

; 1127 : 							e1 = clampedRGBA(blueContract(v0, v2, v4, 0xff));

	mov	DWORD PTR [rsi+16], edx
	mov	DWORD PTR [rsi+20], eax
	mov	DWORD PTR [rsi+24], ecx

; 1128 : 						}
; 1129 : 						break;

	mov	ecx, 12
	mov	eax, r15d
	mov	DWORD PTR [rsi+rcx+16], eax
	jmp	$LN628@decodeColo
$LN21@decodeColo:

; 1130 : 					}
; 1131 : 					case 10:
; 1132 : 						e0 = UVec4((v[0] * v[3]) >> 8, (v[1] * v[3]) >> 8, (v[2] * v[3]) >> 8, v[4]);

	mov	r8d, DWORD PTR [r13+rbx*4+12]
	mov	edx, r8d
	imul	edx, DWORD PTR [r13+rbx*4+4]
	mov	ecx, r8d
	imul	ecx, DWORD PTR [r13+rbx*4+8]
	imul	r8d, DWORD PTR [r13+rbx*4]

; 104  : 			m_c[3] = w;

	mov	eax, DWORD PTR [r13+rbx*4+16]

; 1130 : 					}
; 1131 : 					case 10:
; 1132 : 						e0 = UVec4((v[0] * v[3]) >> 8, (v[1] * v[3]) >> 8, (v[2] * v[3]) >> 8, v[4]);

	shr	edx, 8
	shr	ecx, 8
	shr	r8d, 8
	mov	DWORD PTR [rsi], r8d
	mov	DWORD PTR [rsi+4], edx
	mov	DWORD PTR [rsi+8], ecx
	mov	DWORD PTR [rsi+12], eax

; 102  : 			m_c[1] = y;

	mov	ecx, DWORD PTR [r13+rbx*4+4]

; 103  : 			m_c[2] = z;

	mov	edx, DWORD PTR [r13+rbx*4+8]

; 104  : 			m_c[3] = w;

	mov	r8d, DWORD PTR [r13+rbx*4+20]

; 1133 : 						e1 = UVec4(v[0], v[1], v[2], v[5]);

	mov	eax, DWORD PTR [r13+rbx*4]
	mov	DWORD PTR [rsi+16], eax
	mov	DWORD PTR [rsi+20], ecx
	mov	DWORD PTR [rsi+24], edx
	mov	DWORD PTR [rsi+28], r8d

; 1134 : 						break;

	jmp	$LN631@decodeColo
$LN22@decodeColo:

; 1135 : 					case 11:
; 1136 : 						decodeHDREndpointMode11(e0, e1, v[0], v[1], v[2], v[3], v[4], v[5]);

	mov	eax, DWORD PTR [r13+rbx*4+20]
	lea	rdx, QWORD PTR [rsi+16]
	mov	r9d, DWORD PTR [r13+rbx*4+4]
	mov	rcx, rsi
	mov	r8d, DWORD PTR [r13+rbx*4]
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR [r13+rbx*4+16]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR [r13+rbx*4+12]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [r13+rbx*4+8]
	mov	DWORD PTR [rsp+32], eax
	call	?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z ; basisu::astc::`anonymous namespace'::decodeHDREndpointMode11

; 1137 : 						break;

	jmp	$LN628@decodeColo
$LN23@decodeColo:

; 1138 : 					case 12:
; 1139 : 						if (v[1] + v[3] + v[5] >= v[0] + v[2] + v[4])

	mov	edx, DWORD PTR [r13+rbx*4+12]
	mov	r10d, DWORD PTR [r13+rbx*4+16]
	mov	r11d, DWORD PTR [r13+rbx*4+8]
	mov	r8d, DWORD PTR [r13+rbx*4+20]
	add	edx, r8d
	mov	r9d, DWORD PTR [r13+rbx*4+4]
	mov	r14d, DWORD PTR [r13+rbx*4]
	lea	ecx, DWORD PTR [r10+r11]
	add	ecx, r14d
	lea	eax, DWORD PTR [r9+rdx]
	cmp	eax, ecx
	jb	SHORT $LN24@decodeColo

; 104  : 			m_c[3] = w;

	mov	eax, DWORD PTR [r13+rbx*4+24]

; 1140 : 						{
; 1141 : 							e0 = UVec4(v[0], v[2], v[4], v[6]);

	mov	DWORD PTR [rsi], r14d
	mov	DWORD PTR [rsi+4], r11d
	mov	DWORD PTR [rsi+8], r10d
	mov	DWORD PTR [rsi+12], eax

; 1142 : 							e1 = UVec4(v[1], v[3], v[5], v[7]);

	mov	eax, DWORD PTR [r13+rbx*4+4]

; 102  : 			m_c[1] = y;

	mov	ecx, DWORD PTR [r13+rbx*4+12]

; 103  : 			m_c[2] = z;

	mov	edx, DWORD PTR [r13+rbx*4+20]

; 104  : 			m_c[3] = w;

	mov	r9d, DWORD PTR [r13+rbx*4+28]

; 1142 : 							e1 = UVec4(v[1], v[3], v[5], v[7]);

	mov	DWORD PTR [rsi+16], eax

; 1148 : 						}
; 1149 : 						break;

	mov	eax, 12
	mov	DWORD PTR [rsi+20], ecx
	mov	DWORD PTR [rsi+24], edx
	mov	DWORD PTR [rsi+rax+16], r9d
	jmp	$LN628@decodeColo
$LN24@decodeColo:

; 138  : 			m_c[3] = w;

	mov	ecx, DWORD PTR [r13+rbx*4+28]

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	lea	eax, DWORD PTR [r9+r8]
	sar	eax, 1
	sar	edx, 1

; 80   : 		if (a < l)

	test	ecx, ecx
	jns	SHORT $LN436@decodeColo

; 81   : 			return l;

	xor	ecx, ecx
	jmp	SHORT $LN438@decodeColo
$LN436@decodeColo:

; 82   : 		else if (a > h)

	cmp	ecx, r15d
	cmovg	ecx, r15d
$LN438@decodeColo:

; 80   : 		if (a < l)

	test	r8d, r8d
	jns	SHORT $LN441@decodeColo

; 81   : 			return l;

	xor	r8d, r8d
	jmp	SHORT $LN443@decodeColo
$LN441@decodeColo:

; 82   : 		else if (a > h)

	cmp	r8d, r15d
	cmovg	r8d, r15d
$LN443@decodeColo:

; 80   : 		if (a < l)

	test	edx, edx
	jns	SHORT $LN446@decodeColo

; 81   : 			return l;

	xor	edx, edx
	jmp	SHORT $LN448@decodeColo
$LN446@decodeColo:

; 82   : 		else if (a > h)

	cmp	edx, r15d
	cmovg	edx, r15d
$LN448@decodeColo:

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN451@decodeColo

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN453@decodeColo
$LN451@decodeColo:

; 82   : 		else if (a > h)

	cmp	eax, r15d
	cmovg	eax, r15d
$LN453@decodeColo:

; 1143 : 						}
; 1144 : 						else
; 1145 : 						{
; 1146 : 							e0 = clampedRGBA(blueContract(v[1], v[3], v[5], v[7]));

	mov	DWORD PTR [rsi], eax
	mov	DWORD PTR [rsi+4], edx
	mov	DWORD PTR [rsi+8], r8d
	mov	DWORD PTR [rsi+12], ecx

; 1147 : 							e1 = clampedRGBA(blueContract(v[0], v[2], v[4], v[6]));

	mov	r8d, DWORD PTR [r13+rbx*4+16]

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	mov	edx, DWORD PTR [r13+rbx*4]
	mov	ecx, DWORD PTR [r13+rbx*4+8]
	add	edx, r8d

; 138  : 			m_c[3] = w;

	mov	r9d, DWORD PTR [r13+rbx*4+24]

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	add	ecx, r8d
	sar	edx, 1
	sar	ecx, 1

; 80   : 		if (a < l)

	test	r9d, r9d
	jns	SHORT $LN364@decodeColo

; 81   : 			return l;

	xor	r9d, r9d
	jmp	SHORT $LN366@decodeColo
$LN364@decodeColo:

; 82   : 		else if (a > h)

	cmp	r9d, r15d
	cmovg	r9d, r15d
$LN366@decodeColo:

; 80   : 		if (a < l)

	test	r8d, r8d
	jns	SHORT $LN369@decodeColo

; 81   : 			return l;

	xor	r8d, r8d
	jmp	SHORT $LN371@decodeColo
$LN369@decodeColo:

; 82   : 		else if (a > h)

	cmp	r8d, r15d
	cmovg	r8d, r15d
$LN371@decodeColo:

; 80   : 		if (a < l)

	test	ecx, ecx
	jns	SHORT $LN374@decodeColo

; 81   : 			return l;

	xor	ecx, ecx
	jmp	SHORT $LN376@decodeColo
$LN374@decodeColo:

; 82   : 		else if (a > h)

	cmp	ecx, r15d
	cmovg	ecx, r15d
$LN376@decodeColo:

; 80   : 		if (a < l)

	test	edx, edx
	jns	SHORT $LN379@decodeColo

; 81   : 			return l;

	xor	edx, edx
	jmp	SHORT $LN381@decodeColo
$LN379@decodeColo:

; 82   : 		else if (a > h)

	cmp	edx, r15d
	cmovg	edx, r15d
$LN381@decodeColo:

; 1147 : 							e1 = clampedRGBA(blueContract(v[0], v[2], v[4], v[6]));

	mov	DWORD PTR [rsi+16], edx

; 1148 : 						}
; 1149 : 						break;

	mov	eax, 12
	mov	DWORD PTR [rsi+20], ecx
	mov	DWORD PTR [rsi+24], r8d
	mov	DWORD PTR [rsi+rax+16], r9d
	jmp	$LN628@decodeColo
$LN26@decodeColo:

; 1150 : 					case 13:
; 1151 : 					{
; 1152 : 						deInt32 v0 = (deInt32)v[0];
; 1153 : 						deInt32 v1 = (deInt32)v[1];

	mov	ecx, DWORD PTR [r13+rbx*4+4]

; 838  : 				b |= a & 0x80;

	mov	r14d, ecx

; 1154 : 						deInt32 v2 = (deInt32)v[2];
; 1155 : 						deInt32 v3 = (deInt32)v[3];

	mov	edx, DWORD PTR [r13+rbx*4+12]

; 838  : 				b |= a & 0x80;

	and	r14d, 128				; 00000080H

; 1156 : 						deInt32 v4 = (deInt32)v[4];
; 1157 : 						deInt32 v5 = (deInt32)v[5];

	mov	r8d, DWORD PTR [r13+rbx*4+20]

; 837  : 				b >>= 1;

	mov	eax, DWORD PTR [r13+rbx*4]

; 1158 : 						deInt32 v6 = (deInt32)v[6];
; 1159 : 						deInt32 v7 = (deInt32)v[7];

	mov	r9d, DWORD PTR [r13+rbx*4+28]

; 837  : 				b >>= 1;

	mov	r11d, DWORD PTR [r13+rbx*4+8]
	sar	eax, 1

; 838  : 				b |= a & 0x80;

	or	r14d, eax

; 839  : 				a >>= 1;
; 840  : 				a &= 0x3f;

	sar	ecx, 1
	and	ecx, 63					; 0000003fH

; 214  : 				return (src >> ndx) & 1;

	mov	eax, ecx
	shr	eax, 5

; 838  : 				b |= a & 0x80;

	test	al, al
	mov	eax, edx
	lea	r15d, DWORD PTR [rcx-64]
	cmove	r15d, ecx

; 837  : 				b >>= 1;

	mov	rcx, QWORD PTR unquantizedEndpoints$[rsp]

; 838  : 				b |= a & 0x80;

	and	eax, 128				; 00000080H

; 839  : 				a >>= 1;
; 840  : 				a &= 0x3f;

	sar	edx, 1
	and	edx, 63					; 0000003fH
	sar	r11d, 1
	or	r11d, eax

; 214  : 				return (src >> ndx) & 1;

	mov	eax, edx

; 837  : 				b >>= 1;

	mov	ecx, DWORD PTR [rcx+rbx*4+24]

; 214  : 				return (src >> ndx) & 1;

	shr	eax, 5

; 838  : 				b |= a & 0x80;

	test	al, al
	lea	r12d, DWORD PTR [rdx-64]
	mov	eax, r8d
	cmove	r12d, edx
	mov	edx, DWORD PTR [r13+rbx*4+16]
	and	eax, 128				; 00000080H

; 839  : 				a >>= 1;
; 840  : 				a &= 0x3f;

	sar	r8d, 1
	and	r8d, 63					; 0000003fH
	sar	edx, 1
	or	edx, eax

; 214  : 				return (src >> ndx) & 1;

	mov	eax, r8d
	shr	eax, 5

; 838  : 				b |= a & 0x80;

	test	al, al
	mov	eax, r9d
	lea	r13d, DWORD PTR [r8-64]
	cmove	r13d, r8d
	and	eax, 128				; 00000080H

; 839  : 				a >>= 1;
; 840  : 				a &= 0x3f;

	sar	r9d, 1
	and	r9d, 63					; 0000003fH
	sar	ecx, 1
	or	ecx, eax

; 214  : 				return (src >> ndx) & 1;

	mov	eax, r9d
	shr	eax, 5

; 1160 : 						bitTransferSigned(v1, v0);
; 1161 : 						bitTransferSigned(v3, v2);
; 1162 : 						bitTransferSigned(v5, v4);
; 1163 : 						bitTransferSigned(v7, v6);
; 1164 : 						if (v1 + v3 + v5 >= 0)

	test	al, al
	lea	eax, DWORD PTR [r12+r13]
	lea	ebx, DWORD PTR [r9-64]
	cmove	ebx, r9d
	add	eax, r15d
	js	$LN27@decodeColo

; 80   : 		if (a < l)

	mov	eax, 255				; 000000ffH
	test	ecx, ecx
	jns	SHORT $LN412@decodeColo

; 81   : 			return l;

	xor	r10d, r10d
	jmp	SHORT $LN414@decodeColo
$LN412@decodeColo:

; 82   : 		else if (a > h)

	cmp	ecx, eax
	mov	r10d, ecx
	cmovg	r10d, eax
$LN414@decodeColo:

; 80   : 		if (a < l)

	test	edx, edx
	jns	SHORT $LN417@decodeColo

; 81   : 			return l;

	xor	r9d, r9d
	jmp	SHORT $LN419@decodeColo
$LN417@decodeColo:

; 82   : 		else if (a > h)

	cmp	edx, eax
	mov	r9d, edx
	cmovg	r9d, eax
$LN419@decodeColo:

; 80   : 		if (a < l)

	test	r11d, r11d
	jns	SHORT $LN422@decodeColo

; 81   : 			return l;

	xor	r8d, r8d
	jmp	SHORT $LN424@decodeColo
$LN422@decodeColo:

; 82   : 		else if (a > h)

	cmp	r11d, eax
	mov	r8d, r11d
	cmovg	r8d, eax
$LN424@decodeColo:

; 80   : 		if (a < l)

	test	r14d, r14d
	jns	SHORT $LN427@decodeColo

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN429@decodeColo
$LN427@decodeColo:

; 82   : 		else if (a > h)

	cmp	r14d, 255				; 000000ffH
	mov	eax, r14d
	cmovg	eax, DWORD PTR tv4797[rsp]
$LN429@decodeColo:

; 1165 : 						{
; 1166 : 							e0 = clampedRGBA(IVec4(v0, v2, v4, v6));
; 1167 : 							e1 = clampedRGBA(IVec4(v0 + v1, v2 + v3, v4 + v5, v6 + v7));

	add	ecx, ebx
	mov	DWORD PTR [rsi], eax
	mov	DWORD PTR [rsi+4], r8d
	lea	eax, DWORD PTR [r12+r11]
	mov	DWORD PTR [rsi+8], r9d
	lea	r8d, DWORD PTR [r15+r14]
	lea	r9d, DWORD PTR [rdx+r13]
	mov	DWORD PTR [rsi+12], r10d

; 80   : 		if (a < l)

	mov	edx, 255				; 000000ffH
	jns	SHORT $LN460@decodeColo

; 81   : 			return l;

	xor	ecx, ecx
	jmp	SHORT $LN462@decodeColo
$LN460@decodeColo:

; 82   : 		else if (a > h)

	cmp	ecx, edx
	cmovg	ecx, edx
$LN462@decodeColo:

; 80   : 		if (a < l)

	test	r9d, r9d
	jns	SHORT $LN465@decodeColo

; 81   : 			return l;

	xor	r9d, r9d
	jmp	SHORT $LN467@decodeColo
$LN465@decodeColo:

; 82   : 		else if (a > h)

	cmp	r9d, edx
	cmovg	r9d, edx
$LN467@decodeColo:

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN470@decodeColo

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN472@decodeColo
$LN470@decodeColo:

; 82   : 		else if (a > h)

	cmp	eax, edx
	cmovg	eax, edx
$LN472@decodeColo:

; 80   : 		if (a < l)

	test	r8d, r8d
	jns	SHORT $LN475@decodeColo

; 81   : 			return l;

	xor	r8d, r8d

; 1165 : 						{
; 1166 : 							e0 = clampedRGBA(IVec4(v0, v2, v4, v6));
; 1167 : 							e1 = clampedRGBA(IVec4(v0 + v1, v2 + v3, v4 + v5, v6 + v7));

	mov	DWORD PTR [rsi+16], r8d
	mov	DWORD PTR [rsi+20], eax
	mov	DWORD PTR [rsi+24], r9d

; 1168 : 						}

	jmp	$LN633@decodeColo
$LN475@decodeColo:

; 82   : 		else if (a > h)

	cmp	r8d, edx
	cmovg	r8d, edx

; 1165 : 						{
; 1166 : 							e0 = clampedRGBA(IVec4(v0, v2, v4, v6));
; 1167 : 							e1 = clampedRGBA(IVec4(v0 + v1, v2 + v3, v4 + v5, v6 + v7));

	mov	DWORD PTR [rsi+16], r8d
	mov	DWORD PTR [rsi+20], eax
	mov	DWORD PTR [rsi+24], r9d

; 1168 : 						}

	jmp	$LN633@decodeColo
$LN27@decodeColo:

; 1169 : 						else
; 1170 : 						{
; 1171 : 							e0 = clampedRGBA(blueContract(v0 + v1, v2 + v3, v4 + v5, v6 + v7));

	lea	r9d, DWORD PTR [rdx+r13]
	lea	r10d, DWORD PTR [rbx+rcx]

; 80   : 		if (a < l)

	mov	ebx, 255				; 000000ffH

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	lea	r8d, DWORD PTR [r9+r15]
	add	r8d, r14d
	lea	eax, DWORD PTR [r9+r12]
	add	eax, r11d
	sar	r8d, 1
	sar	eax, 1

; 80   : 		if (a < l)

	test	r10d, r10d
	jns	SHORT $LN488@decodeColo

; 81   : 			return l;

	xor	r10d, r10d
	jmp	SHORT $LN490@decodeColo
$LN488@decodeColo:

; 82   : 		else if (a > h)

	cmp	r10d, ebx
	cmovg	r10d, ebx
$LN490@decodeColo:

; 80   : 		if (a < l)

	test	r9d, r9d
	jns	SHORT $LN493@decodeColo

; 81   : 			return l;

	xor	r9d, r9d
	jmp	SHORT $LN495@decodeColo
$LN493@decodeColo:

; 82   : 		else if (a > h)

	cmp	r9d, ebx
	cmovg	r9d, ebx
$LN495@decodeColo:

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN498@decodeColo

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN500@decodeColo
$LN498@decodeColo:

; 82   : 		else if (a > h)

	cmp	eax, ebx
	cmovg	eax, ebx
$LN500@decodeColo:

; 80   : 		if (a < l)

	test	r8d, r8d
	jns	SHORT $LN503@decodeColo

; 81   : 			return l;

	xor	r8d, r8d
	jmp	SHORT $LN505@decodeColo
$LN503@decodeColo:

; 82   : 		else if (a > h)

	cmp	r8d, ebx
	cmovg	r8d, ebx
$LN505@decodeColo:

; 1169 : 						else
; 1170 : 						{
; 1171 : 							e0 = clampedRGBA(blueContract(v0 + v1, v2 + v3, v4 + v5, v6 + v7));

	mov	DWORD PTR [rsi], r8d

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	lea	r8d, DWORD PTR [rdx+r14]

; 1169 : 						else
; 1170 : 						{
; 1171 : 							e0 = clampedRGBA(blueContract(v0 + v1, v2 + v3, v4 + v5, v6 + v7));

	mov	DWORD PTR [rsi+4], eax

; 853  : 				return IVec4((r + b) >> 1, (g + b) >> 1, b, a);

	lea	eax, DWORD PTR [rdx+r11]
	sar	eax, 1
	sar	r8d, 1

; 1169 : 						else
; 1170 : 						{
; 1171 : 							e0 = clampedRGBA(blueContract(v0 + v1, v2 + v3, v4 + v5, v6 + v7));

	mov	DWORD PTR [rsi+8], r9d
	mov	DWORD PTR [rsi+12], r10d

; 80   : 		if (a < l)

	test	ecx, ecx
	jns	SHORT $LN516@decodeColo

; 81   : 			return l;

	xor	ecx, ecx
	jmp	SHORT $LN518@decodeColo
$LN516@decodeColo:

; 82   : 		else if (a > h)

	cmp	ecx, ebx
	cmovg	ecx, ebx
$LN518@decodeColo:

; 80   : 		if (a < l)

	test	edx, edx
	jns	SHORT $LN521@decodeColo

; 81   : 			return l;

	xor	edx, edx
	jmp	SHORT $LN523@decodeColo
$LN521@decodeColo:

; 82   : 		else if (a > h)

	cmp	edx, ebx
	cmovg	edx, ebx
$LN523@decodeColo:

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN526@decodeColo

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN528@decodeColo
$LN526@decodeColo:

; 82   : 		else if (a > h)

	cmp	eax, ebx
	cmovg	eax, ebx
$LN528@decodeColo:

; 80   : 		if (a < l)

	test	r8d, r8d
	jns	SHORT $LN531@decodeColo

; 81   : 			return l;

	xor	r8d, r8d
	jmp	SHORT $LN533@decodeColo
$LN531@decodeColo:

; 82   : 		else if (a > h)

	cmp	r8d, ebx
	cmovg	r8d, ebx
$LN533@decodeColo:

; 1172 : 							e1 = clampedRGBA(blueContract(v0, v2, v4, v6));

	mov	DWORD PTR [rsi+16], r8d
	mov	DWORD PTR [rsi+20], eax
	mov	DWORD PTR [rsi+24], edx
$LN633@decodeColo:

; 1173 : 						}
; 1174 : 						break;

	mov	eax, 12
	mov	r12d, 4095				; 00000fffH
	mov	DWORD PTR [rsi+rax+16], ecx
	mov	r13, QWORD PTR unquantizedEndpoints$[rsp]
	jmp	$LN634@decodeColo
$LN29@decodeColo:

; 1175 : 					}
; 1176 : 					case 14:
; 1177 : 						decodeHDREndpointMode11(e0, e1, v[0], v[1], v[2], v[3], v[4], v[5]);

	mov	eax, DWORD PTR [r13+rbx*4+20]
	lea	rdx, QWORD PTR [rsi+16]
	mov	r9d, DWORD PTR [r13+rbx*4+4]
	mov	rcx, rsi
	mov	r8d, DWORD PTR [r13+rbx*4]
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR [r13+rbx*4+16]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR [r13+rbx*4+12]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [r13+rbx*4+8]
	mov	DWORD PTR [rsp+32], eax
	call	?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z ; basisu::astc::`anonymous namespace'::decodeHDREndpointMode11

; 1178 : 						e0.w() = v[6];

	mov	eax, DWORD PTR [r13+rbx*4+24]
	mov	DWORD PTR [rsi+12], eax

; 1179 : 						e1.w() = v[7];

	mov	eax, DWORD PTR [r13+rbx*4+28]
	mov	DWORD PTR [rsi+28], eax

; 1180 : 						break;

	jmp	$LN628@decodeColo
$LN30@decodeColo:

; 1005 : 				decodeHDREndpointMode11(e0, e1, v0, v1, v2, v3, v4, v5);

	mov	eax, DWORD PTR [r13+rbx*4+20]
	lea	rdx, QWORD PTR [rsi+16]
	mov	r9d, DWORD PTR [r13+rbx*4+4]
	mov	rcx, rsi
	mov	r8d, DWORD PTR [r13+rbx*4]

; 1181 : 					case 15:
; 1182 : 						decodeHDREndpointMode15(e0, e1, v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7]);

	mov	r14d, DWORD PTR [r13+rbx*4+28]
	mov	r15d, DWORD PTR [r13+rbx*4+24]

; 1005 : 				decodeHDREndpointMode11(e0, e1, v0, v1, v2, v3, v4, v5);

	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR [r13+rbx*4+16]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR [r13+rbx*4+12]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [r13+rbx*4+8]
	mov	DWORD PTR [rsp+32], eax
	call	?decodeHDREndpointMode11@?A0xc6621425@astc@basisu@@YAXAEAUUVec4@3@0IIIIII@Z ; basisu::astc::`anonymous namespace'::decodeHDREndpointMode11

; 1006 : 				const deUint32	mode = (getBit(v7In, 7) << 1) | getBit(v6In, 7);

	mov	r9d, r15d
	mov	eax, r14d
	shr	r9d, 1
	and	eax, 128				; 00000080H
	and	r9d, 64					; 00000040H

; 1007 : 				deInt32			v6 = (deInt32)getBits(v6In, 0, 6);

	and	r15d, 127				; 0000007fH
	or	r9d, eax

; 221  : 					return (deUint32)((src >> low) & ((1u << numBits) - 1));

	and	r14d, 127				; 0000007fH

; 1006 : 				const deUint32	mode = (getBit(v7In, 7) << 1) | getBit(v6In, 7);

	shr	r9d, 6

; 1008 : 				deInt32			v7 = (deInt32)getBits(v7In, 0, 6);
; 1009 : 				if (mode == 3)

	cmp	r9d, 3
	jne	SHORT $LN175@decodeColo

; 1010 : 				{
; 1011 : 					e0.w() = v6 << 5;

	shl	r15d, 5

; 1012 : 					e1.w() = v7 << 5;

	shl	r14d, 5
	mov	DWORD PTR [rsi+12], r15d
	mov	DWORD PTR [rsi+28], r14d

; 1013 : 				}

	jmp	SHORT $LN634@decodeColo
$LN175@decodeColo:

; 1014 : 				else
; 1015 : 				{
; 1016 : 					v6 |= (v7 << (mode + 1)) & 0x780;

	lea	ecx, DWORD PTR [r9+1]
	mov	r10d, r14d
	shl	r10d, cl

; 1017 : 					v7 &= (0x3f >> mode);
; 1018 : 					v7 ^= 0x20 >> mode;
; 1019 : 					v7 -= 0x20 >> mode;
; 1020 : 					v6 <<= 4 - mode;

	mov	edx, 4
	and	r10d, 1920				; 00000780H
	sub	edx, r9d
	or	r10d, r15d
	mov	ecx, edx
	shl	r10d, cl
	mov	r8d, 63					; 0000003fH
	mov	ecx, r9d
	mov	eax, 32					; 00000020H
	sar	r8d, cl
	and	r8d, r14d
	sar	eax, cl
	xor	r8d, eax

; 1021 : 					v7 <<= 4 - mode;

	mov	ecx, edx
	sub	r8d, eax
	shl	r8d, cl

; 1022 : 					v7 += v6;

	add	r8d, r10d

; 80   : 		if (a < l)

	jns	SHORT $LN191@decodeColo

; 81   : 			return l;

	xor	r8d, r8d
	jmp	SHORT $LN193@decodeColo
$LN191@decodeColo:

; 82   : 		else if (a > h)

	cmp	r8d, r12d
	cmovg	r8d, r12d
$LN193@decodeColo:

; 1024 : 					e0.w() = v6;

	mov	DWORD PTR [rsi+12], r10d

; 1025 : 					e1.w() = v7;

	mov	DWORD PTR [rsi+28], r8d
$LN634@decodeColo:

; 1030 : 				int unquantizedNdx = 0;
; 1031 : 				for (int partitionNdx = 0; partitionNdx < numPartitions; partitionNdx++)

	mov	r15d, 255				; 000000ffH
$LN628@decodeColo:
	mov	r10, QWORD PTR dst$[rsp]
	lea	r9, OFFSET FLAT:__ImageBase
$LN631@decodeColo:
	mov	r8, QWORD PTR endpointModes$[rsp]
$LN627@decodeColo:
	mov	edx, DWORD PTR unquantizedNdx$1$[rsp]
$LN2@decodeColo:
	inc	rbp
	cmp	rbp, QWORD PTR $T13[rsp]
	jl	$LL4@decodeColo
	mov	r15, QWORD PTR [rsp+88]
	mov	r14, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+104]
	mov	rdi, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	mov	rbp, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+136]

; 1183 : 						break;
; 1184 : 					default:
; 1185 : 						DE_ASSERT(false);
; 1186 : 					}
; 1187 : 				}
; 1188 : 			}

	add	rsp, 144				; 00000090H
	pop	r13
$LN626@decodeColo:
	ret	0
	npad	1
$LN573@decodeColo:
	DD	$LN7@decodeColo
	DD	$LN8@decodeColo
	DD	$LN9@decodeColo
	DD	$LN10@decodeColo
	DD	$LN11@decodeColo
	DD	$LN12@decodeColo
	DD	$LN13@decodeColo
	DD	$LN14@decodeColo
	DD	$LN15@decodeColo
	DD	$LN18@decodeColo
	DD	$LN21@decodeColo
	DD	$LN22@decodeColo
	DD	$LN23@decodeColo
	DD	$LN26@decodeColo
	DD	$LN29@decodeColo
	DD	$LN30@decodeColo
?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z ENDP ; basisu::astc::`anonymous namespace'::decodeColorEndpoints
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?computeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@AEBVBlock128@123@PEBIHHAEBUISEParams@123@H@Z
_TEXT	SEGMENT
dataStream$1 = 32
unquantizedEndpoints$2 = 64
colorEndpointData$ = 144
__$ArrayPad$ = 368
dst$ = 416
blockData$ = 424
endpointModes$ = 432
numPartitions$ = 440
numColorEndpointValues$ = 448
iseParams$ = 456
numBitsAvailable$ = 464
?computeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@AEBVBlock128@123@PEBIHHAEBUISEParams@123@H@Z PROC ; basisu::astc::`anonymous namespace'::computeColorEndpoints, COMDAT

; 1190 : 			{

	mov	QWORD PTR [rsp+16], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 384				; 00000180H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, QWORD PTR iseParams$[rsp]
	mov	rsi, rcx

; 1191 : 				const int			colorEndpointDataStart = numPartitions == 1 ? 17 : 29;

	cmp	r9d, 1

; 391  : 					: m_src(src)

	mov	QWORD PTR dataStream$1[rsp], rdx

; 1192 : 				ISEDecodedResult	colorEndpointData[18];
; 1193 : 				{
; 1194 : 					BitAccessStream dataStream(blockData, colorEndpointDataStart, numBitsAvailable, true);
; 1195 : 					decodeISE(&colorEndpointData[0], numColorEndpointValues, dataStream, iseParams);

	mov	edx, DWORD PTR numColorEndpointValues$[rsp]
	mov	ecx, 17
	mov	eax, 29

; 394  : 					, m_forward(forward)

	mov	BYTE PTR dataStream$1[rsp+16], 1

; 1191 : 				const int			colorEndpointDataStart = numPartitions == 1 ? 17 : 29;

	cmove	eax, ecx

; 395  : 					, m_ndx(0)

	mov	DWORD PTR dataStream$1[rsp+20], 0
	mov	DWORD PTR dataStream$1[rsp+8], eax

; 1192 : 				ISEDecodedResult	colorEndpointData[18];
; 1193 : 				{
; 1194 : 					BitAccessStream dataStream(blockData, colorEndpointDataStart, numBitsAvailable, true);
; 1195 : 					decodeISE(&colorEndpointData[0], numColorEndpointValues, dataStream, iseParams);

	lea	rcx, QWORD PTR colorEndpointData$[rsp]

; 393  : 					, m_length(length)

	mov	eax, DWORD PTR numBitsAvailable$[rsp]

; 1190 : 			{

	mov	r14d, r9d
	mov	rbp, r8

; 393  : 					, m_length(length)

	mov	DWORD PTR dataStream$1[rsp+12], eax

; 1192 : 				ISEDecodedResult	colorEndpointData[18];
; 1193 : 				{
; 1194 : 					BitAccessStream dataStream(blockData, colorEndpointDataStart, numBitsAvailable, true);
; 1195 : 					decodeISE(&colorEndpointData[0], numColorEndpointValues, dataStream, iseParams);

	mov	r9, rdi
	lea	r8, QWORD PTR dataStream$1[rsp]
	call	?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z ; basisu::astc::`anonymous namespace'::decodeISE

; 1196 : 				}
; 1197 : 				{
; 1198 : 					deUint32 unquantizedEndpoints[18];
; 1199 : 					unquantizeColorEndpoints(&unquantizedEndpoints[0], &colorEndpointData[0], numColorEndpointValues, iseParams);

	mov	r8d, DWORD PTR numColorEndpointValues$[rsp]
	lea	rdx, QWORD PTR colorEndpointData$[rsp]
	mov	r9, rdi
	lea	rcx, QWORD PTR unquantizedEndpoints$2[rsp]
	call	?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z ; basisu::astc::`anonymous namespace'::unquantizeColorEndpoints

; 1200 : 					decodeColorEndpoints(dst, &unquantizedEndpoints[0], &endpointModes[0], numPartitions);

	mov	r9d, r14d
	lea	rdx, QWORD PTR unquantizedEndpoints$2[rsp]
	mov	r8, rbp
	mov	rcx, rsi
	call	?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z ; basisu::astc::`anonymous namespace'::decodeColorEndpoints

; 1201 : 				}
; 1202 : 			}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbp, QWORD PTR [rsp+424]
	add	rsp, 384				; 00000180H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?computeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@AEBVBlock128@123@PEBIHHAEBUISEParams@123@H@Z ENDP ; basisu::astc::`anonymous namespace'::computeColorEndpoints
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z
_TEXT	SEGMENT
dst$ = 64
weightGrid$ = 72
blockMode$ = 80
?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z PROC ; basisu::astc::`anonymous namespace'::unquantizeWeights, COMDAT

; 1204 : 			{

	push	rdi
	push	r12
	push	r15
	sub	rsp, 32					; 00000020H

; 447  : 				return mode.weightGridWidth * mode.weightGridHeight * (mode.isDualPlane ? 2 : 1);

	xor	r12d, r12d

; 1204 : 			{

	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rbp
	mov	r15, rcx
	mov	rbp, r8
	mov	r8, rdx

; 447  : 				return mode.weightGridWidth * mode.weightGridHeight * (mode.isDualPlane ? 2 : 1);

	cmp	BYTE PTR [rbp+2], r12b

; 1205 : 				const int			numWeights = computeNumWeights(blockMode);
; 1206 : 				const ISEParams& iseParams = blockMode.weightISEParams;
; 1207 : 				if (iseParams.mode == ISEMODE_TRIT || iseParams.mode == ISEMODE_QUINT)

	mov	eax, DWORD PTR [rbp+12]

; 447  : 				return mode.weightGridWidth * mode.weightGridHeight * (mode.isDualPlane ? 2 : 1);

	setne	r12b
	inc	r12d
	imul	r12d, DWORD PTR [rbp+8]
	imul	r12d, DWORD PTR [rbp+4]

; 1205 : 				const int			numWeights = computeNumWeights(blockMode);
; 1206 : 				const ISEParams& iseParams = blockMode.weightISEParams;
; 1207 : 				if (iseParams.mode == ISEMODE_TRIT || iseParams.mode == ISEMODE_QUINT)

	movsxd	rdi, r12d
	cmp	eax, 1
	jbe	SHORT $LN19@unquantize

; 1239 : 						}
; 1240 : 					}
; 1241 : 				}
; 1242 : 				else
; 1243 : 				{
; 1244 : 					DE_ASSERT(iseParams.mode == ISEMODE_PLAIN_BIT);
; 1245 : 					for (int weightNdx = 0; weightNdx < numWeights; weightNdx++)

	test	r12d, r12d
	jle	$LN12@unquantize
	mov	QWORD PTR [rsp+80], rsi
	xor	ebx, ebx
	mov	QWORD PTR [rsp+88], r14
	lea	r14, QWORD PTR [rdx+8]
	npad	7
$LL10@unquantize:

; 1246 : 						dst[weightNdx] = bitReplicationScale(weightGrid[weightNdx].v, iseParams.numBits, 6);

	mov	esi, DWORD PTR [rbp+16]

; 241  : 				deUint32 dst = 0;

	xor	r10d, r10d

; 1246 : 						dst[weightNdx] = bitReplicationScale(weightGrid[weightNdx].v, iseParams.numBits, 6);

	mov	r11d, DWORD PTR [r14]

; 242  : 				for (int shift = numDstBits - numSrcBits; shift > -numSrcBits; shift -= numSrcBits)

	mov	r9d, esi
	neg	r9d
	lea	edx, DWORD PTR [r9+6]
	cmp	edx, r9d
	jle	SHORT $LN46@unquantize

; 1246 : 						dst[weightNdx] = bitReplicationScale(weightGrid[weightNdx].v, iseParams.numBits, 6);

	mov	r8d, edx
	neg	r8d
	npad	2
$LL47@unquantize:

; 243  : 					dst |= shift >= 0 ? src << shift : src >> -shift;

	mov	eax, r11d
	test	edx, edx
	js	SHORT $LN49@unquantize
	mov	ecx, edx
	shl	eax, cl
	jmp	SHORT $LN50@unquantize
$LN49@unquantize:
	mov	ecx, r8d
	shr	eax, cl
$LN50@unquantize:
	or	r10d, eax
	sub	edx, esi
	sub	r8d, r9d
	cmp	edx, r9d
	jg	SHORT $LL47@unquantize
$LN46@unquantize:

; 1246 : 						dst[weightNdx] = bitReplicationScale(weightGrid[weightNdx].v, iseParams.numBits, 6);

	mov	DWORD PTR [r15+rbx*4], r10d
	add	r14, 12
	inc	rbx
	cmp	rbx, rdi
	jl	SHORT $LL10@unquantize

; 1205 : 				const int			numWeights = computeNumWeights(blockMode);
; 1206 : 				const ISEParams& iseParams = blockMode.weightISEParams;
; 1207 : 				if (iseParams.mode == ISEMODE_TRIT || iseParams.mode == ISEMODE_QUINT)

	mov	r14, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	jmp	SHORT $LN85@unquantize
$LN19@unquantize:

; 1208 : 				{
; 1209 : 					const int rangeCase = iseParams.numBits * 2 + (iseParams.mode == ISEMODE_QUINT ? 1 : 0);

	xor	ecx, ecx
	cmp	eax, 1
	mov	eax, DWORD PTR [rbp+16]
	sete	cl
	lea	edx, DWORD PTR [rcx+rax*2]

; 1210 : 					if (rangeCase == 0 || rangeCase == 1)

	cmp	edx, 1
	jbe	$LN22@unquantize

; 1219 : 						}
; 1220 : 					}
; 1221 : 					else
; 1222 : 					{
; 1223 : 						DE_ASSERT(rangeCase <= 6);
; 1224 : 						static const deUint32	Ca[5] = { 50, 28, 23, 13, 11 };
; 1225 : 						const deUint32			C = Ca[rangeCase - 2];

	movsxd	rax, edx
	lea	rbx, OFFSET FLAT:?Ca@?M@??unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@234@AEBUASTCBlockMode@234@@Z@4QBIB
	mov	ebx, DWORD PTR [rbx+rax*4-8]

; 1226 : 						for (int weightNdx = 0; weightNdx < numWeights; weightNdx++)

	test	r12d, r12d
	jle	SHORT $LN12@unquantize

; 1232 : 							const deUint32 B = rangeCase == 2 ? 0

	cmp	edx, 2
	jne	$LN34@unquantize
	xor	edx, edx
$LL7@unquantize:

; 214  : 				return (src >> ndx) & 1;

	mov	eax, DWORD PTR [r8]

; 1226 : 						for (int weightNdx = 0; weightNdx < numWeights; weightNdx++)

	lea	r8, QWORD PTR [r8+12]

; 214  : 				return (src >> ndx) & 1;

	and	al, 1

; 1227 : 						{
; 1228 : 							const deUint32 a = getBit(weightGrid[weightNdx].m, 0);
; 1229 : 							const deUint32 b = getBit(weightGrid[weightNdx].m, 1);
; 1230 : 							const deUint32 c = getBit(weightGrid[weightNdx].m, 2);
; 1231 : 							const deUint32 A = a == 0 ? 0 : (1 << 7) - 1;

	neg	al

; 1233 : 								: rangeCase == 3 ? 0
; 1234 : 								: rangeCase == 4 ? (b << 6) | (b << 2) | (b << 0)
; 1235 : 								: rangeCase == 5 ? (b << 6) | (b << 1)
; 1236 : 								: rangeCase == 6 ? (c << 6) | (b << 5) | (c << 1) | (b << 0)
; 1237 : 								: (deUint32)-1;
; 1238 : 							dst[weightNdx] = (((weightGrid[weightNdx].tq * C + B) ^ A) >> 2) | (A & 0x20);

	mov	eax, ebx
	sbb	ecx, ecx
	imul	eax, DWORD PTR [r8-8]
	and	ecx, 127				; 0000007fH
	xor	eax, ecx
	and	ecx, 32					; 00000020H
	shr	eax, 2
	or	eax, ecx
	mov	DWORD PTR [r15+rdx*4], eax
	inc	rdx
	cmp	rdx, rdi
	jl	SHORT $LL7@unquantize

; 1247 : 				}
; 1248 : 				for (int weightNdx = 0; weightNdx < numWeights; weightNdx++)

	test	r12d, r12d
	jle	SHORT $LN12@unquantize
$LN85@unquantize:
	xor	r8d, r8d
	npad	11
$LL64@unquantize:

; 1249 : 					dst[weightNdx] += dst[weightNdx] > 32 ? 1 : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [r15+r8*4], 32		; 00000020H
	seta	cl
	add	DWORD PTR [r15+r8*4], ecx
	inc	r8
	cmp	r8, rdi
	jl	SHORT $LL64@unquantize
$LN12@unquantize:
	mov	rbp, QWORD PTR [rsp+72]

; 1250 : 				// Initialize nonexistent weights to poison values
; 1251 : 				for (int weightNdx = numWeights; weightNdx < 64; weightNdx++)

	mov	rbx, QWORD PTR [rsp+64]
	cmp	r12d, 64				; 00000040H
	jge	SHORT $LN15@unquantize

; 1252 : 					dst[weightNdx] = ~0u;

	mov	eax, 64					; 00000040H
	lea	rcx, QWORD PTR [r15+rdi*4]
	sub	eax, r12d
	mov	edx, -1					; ffffffffH
	movsxd	r8, eax
	shl	r8, 2

; 1253 : 			}

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rdi

; 1252 : 					dst[weightNdx] = ~0u;

	jmp	memset
$LN15@unquantize:

; 1253 : 			}

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rdi
	ret	0
$LN34@unquantize:

; 1226 : 						for (int weightNdx = 0; weightNdx < numWeights; weightNdx++)

	test	r12d, r12d
	jle	SHORT $LN12@unquantize
	xor	r11d, r11d
	npad	2
$LL63@unquantize:

; 214  : 				return (src >> ndx) & 1;

	mov	eax, DWORD PTR [r8]
	mov	ecx, eax
	mov	r9d, eax
	shr	ecx, 1
	shr	r9d, 2
	and	ecx, 1
	and	r9d, 1
	and	al, 1

; 1227 : 						{
; 1228 : 							const deUint32 a = getBit(weightGrid[weightNdx].m, 0);
; 1229 : 							const deUint32 b = getBit(weightGrid[weightNdx].m, 1);
; 1230 : 							const deUint32 c = getBit(weightGrid[weightNdx].m, 2);
; 1231 : 							const deUint32 A = a == 0 ? 0 : (1 << 7) - 1;

	neg	al
	sbb	r10d, r10d
	and	r10d, 127				; 0000007fH

; 1232 : 							const deUint32 B = rangeCase == 2 ? 0

	cmp	edx, 3
	jne	SHORT $LN32@unquantize
	xor	eax, eax
	jmp	SHORT $LN27@unquantize
$LN32@unquantize:
	cmp	edx, 4
	jne	SHORT $LN30@unquantize
	mov	eax, ecx
	shl	eax, 4
	or	eax, ecx
	shl	eax, 2
	or	eax, ecx
	jmp	SHORT $LN27@unquantize
$LN30@unquantize:
	cmp	edx, 5
	jne	SHORT $LN28@unquantize
	mov	eax, ecx
	shl	eax, 5
	or	eax, ecx
	add	eax, eax
	jmp	SHORT $LN27@unquantize
$LN28@unquantize:
	cmp	edx, 6
	jne	SHORT $LN26@unquantize
	lea	eax, DWORD PTR [r9+r9]
	or	eax, ecx
	shl	eax, 4
	or	eax, r9d
	add	eax, eax
	or	eax, ecx
	jmp	SHORT $LN27@unquantize
$LN26@unquantize:
	mov	eax, -1					; ffffffffH
$LN27@unquantize:

; 1233 : 								: rangeCase == 3 ? 0
; 1234 : 								: rangeCase == 4 ? (b << 6) | (b << 2) | (b << 0)
; 1235 : 								: rangeCase == 5 ? (b << 6) | (b << 1)
; 1236 : 								: rangeCase == 6 ? (c << 6) | (b << 5) | (c << 1) | (b << 0)
; 1237 : 								: (deUint32)-1;
; 1238 : 							dst[weightNdx] = (((weightGrid[weightNdx].tq * C + B) ^ A) >> 2) | (A & 0x20);

	mov	ecx, ebx
	imul	ecx, DWORD PTR [r8+4]
	add	r8, 12
	add	ecx, eax
	xor	ecx, r10d
	and	r10d, 32				; 00000020H
	shr	ecx, 2
	or	ecx, r10d
	mov	DWORD PTR [r15+r11*4], ecx
	inc	r11
	cmp	r11, rdi
	jl	$LL63@unquantize

; 1205 : 				const int			numWeights = computeNumWeights(blockMode);
; 1206 : 				const ISEParams& iseParams = blockMode.weightISEParams;
; 1207 : 				if (iseParams.mode == ISEMODE_TRIT || iseParams.mode == ISEMODE_QUINT)

	jmp	$LN85@unquantize
$LN22@unquantize:

; 1211 : 					{
; 1212 : 						static const deUint32 map0[3] = { 0, 32, 63 };
; 1213 : 						static const deUint32 map1[5] = { 0, 16, 32, 47, 63 };
; 1214 : 						const deUint32* const map = rangeCase == 0 ? &map0[0] : &map1[0];
; 1215 : 						for (int i = 0; i < numWeights; i++)

	test	edx, edx
	lea	rax, OFFSET FLAT:?map1@?7??unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@234@AEBUASTCBlockMode@234@@Z@4QBIB
	lea	r9, OFFSET FLAT:?map0@?7??unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@234@AEBUASTCBlockMode@234@@Z@4QBIB
	cmovne	r9, rax
	test	r12d, r12d
	jle	$LN12@unquantize
	xor	edx, edx
	add	r8, 8
	npad	6
$LL4@unquantize:

; 1216 : 						{
; 1217 : 							DE_ASSERT(weightGrid[i].v < (rangeCase == 0 ? 3u : 5u));
; 1218 : 							dst[i] = map[weightGrid[i].v];

	mov	eax, DWORD PTR [r8]
	lea	r8, QWORD PTR [r8+12]
	mov	ecx, DWORD PTR [r9+rax*4]
	mov	DWORD PTR [r15+rdx*4], ecx
	inc	rdx
	cmp	rdx, rdi
	jl	SHORT $LL4@unquantize
	jmp	$LN85@unquantize
?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z ENDP ; basisu::astc::`anonymous namespace'::unquantizeWeights
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z
_TEXT	SEGMENT
texelY$1$ = 0
texelX$1$ = 4
scaleX$1$ = 8
scaleY$1$ = 12
tv506 = 16
tv517 = 24
tv519 = 32
tv518 = 36
tv507 = 40
dst$ = 112
unquantizedWeights$ = 120
blockWidth$ = 128
blockHeight$ = 136
blockMode$ = 144
?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z PROC ; basisu::astc::`anonymous namespace'::interpolateWeights, COMDAT

; 1255 : 			{

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rdi
	push	r15
	sub	rsp, 72					; 00000048H

; 1256 : 				const int		numWeightsPerTexel = blockMode.isDualPlane ? 2 : 1;

	mov	r11, QWORD PTR blockMode$[rsp]
	xor	eax, eax
	mov	r10, rdx
	mov	rdi, rcx

; 1257 : 				const deUint32	scaleX = (1024 + blockWidth / 2) / (blockWidth - 1);

	lea	ecx, DWORD PTR [r8-1]
	cmp	BYTE PTR [r11+2], al
	setne	al
	lea	ebx, DWORD PTR [rax+1]
	mov	eax, r8d
	cdq
	mov	QWORD PTR tv517[rsp], rbx
	sub	eax, edx
	sar	eax, 1
	add	eax, 1024				; 00000400H
	cdq
	idiv	ecx

; 1258 : 				const deUint32	scaleY = (1024 + blockHeight / 2) / (blockHeight - 1);

	lea	ecx, DWORD PTR [r9-1]
	mov	ebp, eax
	mov	DWORD PTR scaleX$1$[rsp], eax
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1024				; 00000400H
	cdq
	idiv	ecx
	xor	ecx, ecx
	mov	DWORD PTR scaleY$1$[rsp], eax
	mov	r15d, eax
	mov	DWORD PTR texelY$1$[rsp], ecx

; 1259 : 				DE_ASSERT(blockMode.weightGridWidth * blockMode.weightGridHeight * numWeightsPerTexel <= DE_LENGTH_OF_ARRAY(unquantizedWeights));
; 1260 : 				for (int texelY = 0; texelY < blockHeight; texelY++)

	test	r9d, r9d
	jle	$LN3@interpolat
	mov	QWORD PTR [rsp+120], rsi
	xor	eax, eax
	mov	QWORD PTR [rsp+64], r12
	mov	QWORD PTR [rsp+56], r13
	mov	QWORD PTR [rsp+48], r14
	mov	DWORD PTR tv506[rsp], eax
	npad	12
$LL4@interpolat:

; 1261 : 				{
; 1262 : 					for (int texelX = 0; texelX < blockWidth; texelX++)

	xor	esi, esi
	mov	DWORD PTR texelX$1$[rsp], esi
	test	r8d, r8d
	jle	$LN2@interpolat

; 1290 : 							dst[texelY * blockWidth + texelX].w[texelWeightNdx] = (p00 * w00 + p01 * w01 + p10 * w10 + p11 * w11 + 8) >> 4;

	cdqe
	lea	r14, QWORD PTR [rdi+rax*8]
	mov	QWORD PTR tv507[rsp], r14
	npad	6
$LL7@interpolat:

; 1263 : 					{
; 1264 : 						const deUint32 gX = (scaleX * texelX * (blockMode.weightGridWidth - 1) + 32) >> 6;
; 1265 : 						const deUint32 gY = (scaleY * texelY * (blockMode.weightGridHeight - 1) + 32) >> 6;

	mov	r9d, DWORD PTR [r11+4]
	mov	r8d, DWORD PTR [r11+8]
	xor	r11d, r11d
	dec	r8d
	imul	r8d, ecx
	lea	edx, DWORD PTR [r9-1]
	imul	edx, esi
	imul	r8d, r15d
	imul	edx, ebp
	add	r8d, 32					; 00000020H
	shr	r8d, 6
	add	edx, 32					; 00000020H

; 1266 : 						const deUint32 jX = gX >> 4;
; 1267 : 						const deUint32 jY = gY >> 4;
; 1268 : 						const deUint32 fX = gX & 0xf;
; 1269 : 						const deUint32 fY = gY & 0xf;

	mov	eax, r8d
	shr	edx, 6
	and	eax, 15
	mov	ecx, edx
	shr	r8d, 4
	shr	edx, 4
	and	ecx, 15

; 1270 : 						const deUint32 w11 = (fX * fY + 8) >> 4;

	mov	edi, eax

; 1271 : 						const deUint32 w10 = fY - w11;
; 1272 : 						const deUint32 w01 = fX - w11;
; 1273 : 						const deUint32 w00 = 16 - fX - fY + w11;
; 1274 : 						const deUint32 i00 = jY * blockMode.weightGridWidth + jX;

	imul	r8d, r9d
	imul	edi, ecx
	mov	r13d, ecx
	mov	r12d, eax
	add	r8d, edx
	add	edi, 8

; 1275 : 						const deUint32 i01 = i00 + 1;
; 1276 : 						const deUint32 i10 = i00 + blockMode.weightGridWidth;
; 1277 : 						const deUint32 i11 = i00 + blockMode.weightGridWidth + 1;
; 1278 : 						// These addresses can be out of bounds, but respective weights will be 0 then.
; 1279 : 						DE_ASSERT(deInBounds32(i00, 0, blockMode.weightGridWidth * blockMode.weightGridHeight) || w00 == 0);
; 1280 : 						DE_ASSERT(deInBounds32(i01, 0, blockMode.weightGridWidth * blockMode.weightGridHeight) || w01 == 0);
; 1281 : 						DE_ASSERT(deInBounds32(i10, 0, blockMode.weightGridWidth * blockMode.weightGridHeight) || w10 == 0);
; 1282 : 						DE_ASSERT(deInBounds32(i11, 0, blockMode.weightGridWidth * blockMode.weightGridHeight) || w11 == 0);
; 1283 : 						for (int texelWeightNdx = 0; texelWeightNdx < numWeightsPerTexel; texelWeightNdx++)
; 1284 : 						{
; 1285 : 							// & 0x3f clamps address to bounds of unquantizedWeights
; 1286 : 							const deUint32 p00 = unquantizedWeights[(i00 * numWeightsPerTexel + texelWeightNdx) & 0x3f];

	mov	r15d, r8d
	shr	edi, 4
	imul	r15d, ebx
	mov	ebp, edi
	sub	ebp, eax
	sub	r12d, edi
	sub	ebp, ecx
	sub	r13d, edi
	lea	ecx, DWORD PTR [r9+r8]
	xor	eax, eax

; 1287 : 							const deUint32 p01 = unquantizedWeights[(i01 * numWeightsPerTexel + texelWeightNdx) & 0x3f];
; 1288 : 							const deUint32 p10 = unquantizedWeights[(i10 * numWeightsPerTexel + texelWeightNdx) & 0x3f];

	mov	edx, ecx
	imul	edx, ebx
	mov	DWORD PTR tv519[rsp], edx
	lea	edx, DWORD PTR [rcx+1]
	mov	esi, DWORD PTR tv519[rsp]

; 1289 : 							const deUint32 p11 = unquantizedWeights[(i11 * numWeightsPerTexel + texelWeightNdx) & 0x3f];

	imul	edx, ebx
	mov	rbx, r14
	lea	r14d, DWORD PTR [r8+1]
	imul	r14d, DWORD PTR tv517[rsp]
	mov	DWORD PTR tv518[rsp], edx
	sub	r14d, r15d
	npad	8
$LL10@interpolat:

; 1290 : 							dst[texelY * blockWidth + texelX].w[texelWeightNdx] = (p00 * w00 + p01 * w01 + p10 * w10 + p11 * w11 + 8) >> 4;

	lea	r9d, DWORD PTR [r15+rax]
	mov	r8d, r13d
	lea	ecx, DWORD PTR [r14+r9]
	inc	r11
	and	ecx, 63					; 0000003fH
	lea	rbx, QWORD PTR [rbx+4]
	and	r9d, 63					; 0000003fH
	imul	r8d, DWORD PTR [r10+rcx*4]
	lea	ecx, DWORD PTR [rdx+rax]
	and	ecx, 63					; 0000003fH
	mov	edx, edi
	imul	edx, DWORD PTR [r10+rcx*4]
	lea	ecx, DWORD PTR [rsi+rax]
	and	ecx, 63					; 0000003fH
	lea	eax, DWORD PTR [rax+1]
	add	r8d, edx
	mov	edx, r12d
	imul	edx, DWORD PTR [r10+rcx*4]
	add	r8d, edx
	lea	edx, DWORD PTR [rbp+16]
	imul	edx, DWORD PTR [r10+r9*4]
	add	edx, 8
	add	edx, r8d
	shr	edx, 4
	mov	DWORD PTR [rbx-4], edx
	mov	edx, DWORD PTR tv518[rsp]
	cmp	r11, QWORD PTR tv517[rsp]
	jl	SHORT $LL10@interpolat

; 1261 : 				{
; 1262 : 					for (int texelX = 0; texelX < blockWidth; texelX++)

	mov	esi, DWORD PTR texelX$1$[rsp]
	mov	r14, QWORD PTR tv507[rsp]
	inc	esi
	mov	r8d, DWORD PTR blockWidth$[rsp]
	add	r14, 8
	mov	rbx, QWORD PTR tv517[rsp]
	mov	ecx, DWORD PTR texelY$1$[rsp]
	mov	r11, QWORD PTR blockMode$[rsp]
	mov	ebp, DWORD PTR scaleX$1$[rsp]
	mov	r15d, DWORD PTR scaleY$1$[rsp]
	mov	DWORD PTR texelX$1$[rsp], esi
	mov	QWORD PTR tv507[rsp], r14
	cmp	esi, r8d
	jl	$LL7@interpolat
	mov	eax, DWORD PTR tv506[rsp]
	mov	r9d, DWORD PTR blockHeight$[rsp]
	mov	rdi, QWORD PTR dst$[rsp]
$LN2@interpolat:

; 1259 : 				DE_ASSERT(blockMode.weightGridWidth * blockMode.weightGridHeight * numWeightsPerTexel <= DE_LENGTH_OF_ARRAY(unquantizedWeights));
; 1260 : 				for (int texelY = 0; texelY < blockHeight; texelY++)

	inc	ecx
	add	eax, r8d
	mov	DWORD PTR texelY$1$[rsp], ecx
	mov	DWORD PTR tv506[rsp], eax
	cmp	ecx, r9d
	jl	$LL4@interpolat
	mov	r14, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+120]
$LN3@interpolat:

; 1291 : 						}
; 1292 : 					}
; 1293 : 				}
; 1294 : 			}

	add	rsp, 72					; 00000048H
	pop	r15
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z ENDP ; basisu::astc::`anonymous namespace'::interpolateWeights
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?computeTexelWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEBVBlock128@123@HHAEBUASTCBlockMode@123@@Z
_TEXT	SEGMENT
dataStream$1 = 48
unquantizedWeights$2 = 80
weightGrid$ = 336
__$ArrayPad$ = 1104
dst$ = 1152
blockData$ = 1160
blockWidth$ = 1168
blockHeight$ = 1176
blockMode$ = 1184
?computeTexelWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEBVBlock128@123@HHAEBUASTCBlockMode@123@@Z PROC ; basisu::astc::`anonymous namespace'::computeTexelWeights, COMDAT

; 1296 : 			{

	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 1120				; 00000460H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, QWORD PTR blockMode$[rsp]

; 447  : 				return mode.weightGridWidth * mode.weightGridHeight * (mode.isDualPlane ? 2 : 1);

	xor	r10d, r10d

; 1296 : 			{

	mov	ebp, r9d
	mov	rdi, rcx

; 274  : 				switch (iseParams.mode)

	mov	ecx, DWORD PTR [rbx+12]

; 1297 : 				ISEDecodedResult weightGrid[64];
; 1298 : 				{
; 1299 : 					BitAccessStream dataStream(blockData, 127, computeNumRequiredBits(blockMode.weightISEParams, computeNumWeights(blockMode)), false);

	lea	r9, QWORD PTR [rbx+12]
	mov	esi, r8d
	mov	r8, rdx

; 447  : 				return mode.weightGridWidth * mode.weightGridHeight * (mode.isDualPlane ? 2 : 1);

	cmp	BYTE PTR [rbx+2], r10b
	setne	r10b
	inc	r10d
	imul	r10d, DWORD PTR [rbx+8]
	imul	r10d, DWORD PTR [rbx+4]

; 274  : 				switch (iseParams.mode)

	test	ecx, ecx
	je	SHORT $LN8@computeTex
	sub	ecx, 1
	je	SHORT $LN9@computeTex
	cmp	ecx, 1
	je	SHORT $LN10@computeTex

; 279  : 				default:
; 280  : 					DE_ASSERT(false);
; 281  : 					return -1;

	mov	edx, -1
	jmp	SHORT $LN5@computeTex
$LN10@computeTex:

; 278  : 				case ISEMODE_PLAIN_BIT:		return numValues * iseParams.numBits;

	mov	edx, r10d
	imul	edx, DWORD PTR [r9+4]
	jmp	SHORT $LN5@computeTex
$LN9@computeTex:

; 275  : 				{
; 276  : 				case ISEMODE_TRIT:			return deDivRoundUp32(numValues * 8, 5) + numValues * iseParams.numBits;
; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	imul	ecx, r10d, 7

; 192  : 		return (a + b - 1) / b;

	mov	eax, -1431655765			; aaaaaaabH
	add	ecx, 2
	mul	ecx
	shr	edx, 1

; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	jmp	SHORT $LN24@computeTex
$LN8@computeTex:

; 192  : 		return (a + b - 1) / b;

	lea	ecx, DWORD PTR [r10*8+4]
	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 2
$LN24@computeTex:

; 391  : 					: m_src(src)

	mov	eax, r10d
	imul	eax, DWORD PTR [r9+4]
	add	edx, eax
$LN5@computeTex:
	mov	QWORD PTR dataStream$1[rsp], r8

; 1300 : 					decodeISE(&weightGrid[0], computeNumWeights(blockMode), dataStream, blockMode.weightISEParams);

	lea	rcx, QWORD PTR weightGrid$[rsp]

; 393  : 					, m_length(length)

	mov	DWORD PTR dataStream$1[rsp+12], edx

; 1300 : 					decodeISE(&weightGrid[0], computeNumWeights(blockMode), dataStream, blockMode.weightISEParams);

	lea	r8, QWORD PTR dataStream$1[rsp]
	mov	edx, r10d

; 392  : 					, m_startNdxInSrc(startNdxInSrc)

	mov	DWORD PTR dataStream$1[rsp+8], 127	; 0000007fH

; 394  : 					, m_forward(forward)

	mov	BYTE PTR dataStream$1[rsp+16], 0

; 395  : 					, m_ndx(0)

	mov	DWORD PTR dataStream$1[rsp+20], 0

; 1300 : 					decodeISE(&weightGrid[0], computeNumWeights(blockMode), dataStream, blockMode.weightISEParams);

	call	?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z ; basisu::astc::`anonymous namespace'::decodeISE

; 1301 : 				}
; 1302 : 				{
; 1303 : 					deUint32 unquantizedWeights[64];
; 1304 : 					unquantizeWeights(&unquantizedWeights[0], &weightGrid[0], blockMode);

	mov	r8, rbx
	lea	rdx, QWORD PTR weightGrid$[rsp]
	lea	rcx, QWORD PTR unquantizedWeights$2[rsp]
	call	?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z ; basisu::astc::`anonymous namespace'::unquantizeWeights

; 1305 : 					interpolateWeights(dst, unquantizedWeights, blockWidth, blockHeight, blockMode);

	mov	r9d, ebp
	mov	QWORD PTR [rsp+32], rbx
	mov	r8d, esi
	lea	rdx, QWORD PTR unquantizedWeights$2[rsp]
	mov	rcx, rdi
	call	?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z ; basisu::astc::`anonymous namespace'::interpolateWeights

; 1306 : 				}
; 1307 : 			}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+1160]
	add	rsp, 1120				; 00000460H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?computeTexelWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEBVBlock128@123@HHAEBUASTCBlockMode@123@@Z ENDP ; basisu::astc::`anonymous namespace'::computeTexelWeights
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?hash52@?A0xc6621425@astc@basisu@@YAII@Z
_TEXT	SEGMENT
v$ = 8
?hash52@?A0xc6621425@astc@basisu@@YAII@Z PROC		; basisu::astc::`anonymous namespace'::hash52, COMDAT

; 1310 : 				deUint32 p = v;
; 1311 : 				p ^= p >> 15;	p -= p << 17;	p += p << 7;	p += p << 4;

	mov	eax, ecx
	shr	eax, 15
	xor	eax, ecx
	imul	ecx, eax, -287438703			; eede0891H

; 1312 : 				p ^= p >> 5;	p += p << 16;	p ^= p >> 7;	p ^= p >> 3;

	mov	eax, ecx
	shr	eax, 5
	xor	eax, ecx
	imul	ecx, eax, 65537				; 00010001H
	mov	eax, ecx
	shr	eax, 7
	xor	ecx, eax
	mov	eax, ecx
	shr	eax, 3
	xor	ecx, eax

; 1313 : 				p ^= p << 6;	p ^= p >> 17;

	mov	eax, ecx
	shl	eax, 6
	xor	ecx, eax
	mov	eax, ecx
	shr	eax, 17
	xor	eax, ecx

; 1314 : 				return p;
; 1315 : 			}

	ret	0
?hash52@?A0xc6621425@astc@basisu@@YAII@Z ENDP		; basisu::astc::`anonymous namespace'::hash52
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?computeTexelPartition@?A0xc6621425@astc@basisu@@YAHIIIIH_N@Z
_TEXT	SEGMENT
tv798 = 56
seedIn$ = 56
xIn$ = 64
yIn$ = 72
tv876 = 80
zIn$dead$ = 80
numPartitions$ = 88
tv799 = 96
smallBlock$ = 96
?computeTexelPartition@?A0xc6621425@astc@basisu@@YAHIIIIH_N@Z PROC ; basisu::astc::`anonymous namespace'::computeTexelPartition, COMDAT

; 1317 : 			{

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	DWORD PTR [rsp+32], r9d
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15

; 1318 : 				DE_ASSERT(zIn == 0);
; 1319 : 				const deUint32	x = smallBlock ? xIn << 1 : xIn;
; 1320 : 				const deUint32	y = smallBlock ? yIn << 1 : yIn;

	movzx	eax, BYTE PTR smallBlock$[rsp]
	lea	r14d, DWORD PTR [rdx+rdx]

; 1321 : 				const deUint32	z = smallBlock ? zIn << 1 : zIn;
; 1322 : 				const deUint32	seed = seedIn + 1024 * (numPartitions - 1);

	mov	r11d, DWORD PTR numPartitions$[rsp]
	lea	r15d, DWORD PTR [r8+r8]
	test	al, al
	cmove	r14d, edx
	cmove	r15d, r8d
	add	ecx, -1024				; fffffc00H
	shl	r11d, 10
	add	r11d, ecx

; 1311 : 				p ^= p >> 15;	p -= p << 17;	p += p << 7;	p += p << 4;

	mov	eax, r11d
	shr	eax, 15
	xor	eax, r11d
	imul	ecx, eax, -287438703			; eede0891H

; 1312 : 				p ^= p >> 5;	p += p << 16;	p ^= p >> 7;	p ^= p >> 3;

	mov	eax, ecx
	shr	eax, 5
	xor	eax, ecx
	imul	ecx, eax, 65537				; 00010001H
	mov	eax, ecx
	shr	eax, 7
	xor	ecx, eax
	mov	eax, ecx
	shr	eax, 3
	xor	ecx, eax

; 1313 : 				p ^= p << 6;	p ^= p >> 17;

	mov	eax, ecx
	shl	eax, 6
	xor	ecx, eax

; 1342 : 				seed7 = (deUint8)(seed7 * seed7);
; 1343 : 				seed8 = (deUint8)(seed8 * seed8);
; 1344 : 				seed9 = (deUint8)(seed9 * seed9);
; 1345 : 				seed10 = (deUint8)(seed10 * seed10);
; 1346 : 				seed11 = (deUint8)(seed11 * seed11);
; 1347 : 				seed12 = (deUint8)(seed12 * seed12);
; 1348 : 				const int shA = (seed & 2) != 0 ? 4 : 5;

	mov	eax, r11d
	shr	eax, 1

; 1313 : 				p ^= p << 6;	p ^= p >> 17;

	mov	ebp, ecx

; 1342 : 				seed7 = (deUint8)(seed7 * seed7);
; 1343 : 				seed8 = (deUint8)(seed8 * seed8);
; 1344 : 				seed9 = (deUint8)(seed9 * seed9);
; 1345 : 				seed10 = (deUint8)(seed10 * seed10);
; 1346 : 				seed11 = (deUint8)(seed11 * seed11);
; 1347 : 				seed12 = (deUint8)(seed12 * seed12);
; 1348 : 				const int shA = (seed & 2) != 0 ? 4 : 5;

	not	eax

; 1313 : 				p ^= p << 6;	p ^= p >> 17;

	shr	ebp, 17
	xor	ebp, ecx

; 1342 : 				seed7 = (deUint8)(seed7 * seed7);
; 1343 : 				seed8 = (deUint8)(seed8 * seed8);
; 1344 : 				seed9 = (deUint8)(seed9 * seed9);
; 1345 : 				seed10 = (deUint8)(seed10 * seed10);
; 1346 : 				seed11 = (deUint8)(seed11 * seed11);
; 1347 : 				seed12 = (deUint8)(seed12 * seed12);
; 1348 : 				const int shA = (seed & 2) != 0 ? 4 : 5;

	and	eax, 1
	or	eax, 4
	mov	r10d, ebp

; 1349 : 				const int shB = numPartitions == 3 ? 6 : 5;
; 1350 : 				const int sh1 = (seed & 1) != 0 ? shA : shB;

	movzx	r8d, al
	mov	esi, ebp
	shr	r10d, 4
	mov	edi, ebp
	shr	esi, 8
	and	r10b, 15
	shr	edi, 12
	and	sil, 15
	and	dil, 15
	mov	r12d, ebp
	shr	r12d, 16
	mov	r13d, ebp
	shr	r13d, 20
	and	r12b, 15
	and	r13b, 15
	mov	ecx, ebp
	shr	ecx, 24
	movzx	ebx, bpl
	and	cl, 15
	and	bl, 15
	mov	r9d, ebp
	shr	r9d, 28
	cmp	DWORD PTR numPartitions$[rsp], 3
	sete	al
	add	al, 5
	movzx	edx, al
	bt	r11d, 0
	mov	eax, edx
	cmovb	eax, r8d
	movzx	eax, al
	mov	DWORD PTR tv799[rsp], eax
	movzx	eax, cl
	movzx	ecx, cl
	imul	ecx, eax
	movzx	eax, r9b
	mov	DWORD PTR tv876[rsp], ecx

; 1351 : 				const int sh2 = (seed & 1) != 0 ? shB : shA;
; 1352 : 				const int sh3 = (seed & 0x10) != 0 ? sh1 : sh2;
; 1353 : 				seed1 = (deUint8)(seed1 >> sh1);
; 1354 : 				seed2 = (deUint8)(seed2 >> sh2);
; 1355 : 				seed3 = (deUint8)(seed3 >> sh1);
; 1356 : 				seed4 = (deUint8)(seed4 >> sh2);
; 1357 : 				seed5 = (deUint8)(seed5 >> sh1);
; 1358 : 				seed6 = (deUint8)(seed6 >> sh2);
; 1359 : 				seed7 = (deUint8)(seed7 >> sh1);

	movzx	ecx, BYTE PTR tv799[rsp]
	shr	BYTE PTR tv876[rsp], cl
	bt	r11d, 0
	movzx	r11d, r9b
	cmovb	r8d, edx
	imul	r11d, eax
	movzx	edx, r8b
	mov	DWORD PTR tv798[rsp], edx

; 1360 : 				seed8 = (deUint8)(seed8 >> sh2);

	movzx	ecx, dl
	mov	r8d, DWORD PTR tv799[rsp]
	shr	r11b, cl
	movzx	eax, r10b
	movzx	ecx, r10b
	imul	ecx, eax
	movzx	eax, bl

; 1361 : 				seed9 = (deUint8)(seed9 >> sh3);
; 1362 : 				seed10 = (deUint8)(seed10 >> sh3);
; 1363 : 				seed11 = (deUint8)(seed11 >> sh3);
; 1364 : 				seed12 = (deUint8)(seed12 >> sh3);
; 1365 : 				const int a = 0x3f & (seed1 * x + seed2 * y + seed11 * z + (rnum >> 14));

	movzx	r10d, cl
	movzx	ecx, dl
	shr	r10d, cl
	imul	r10d, r15d
	movzx	ecx, bl

; 1366 : 				const int b = 0x3f & (seed3 * x + seed4 * y + seed12 * z + (rnum >> 10));
; 1367 : 				const int c = numPartitions >= 3 ? 0x3f & (seed5 * x + seed6 * y + seed9 * z + (rnum >> 6)) : 0;

	mov	ebx, DWORD PTR numPartitions$[rsp]
	imul	ecx, eax
	movzx	eax, cl
	movzx	ecx, r8b
	shr	eax, cl
	imul	eax, r14d
	movzx	ecx, dil
	add	r10d, eax
	mov	eax, ebp
	shr	eax, 14
	add	r10d, eax
	movzx	eax, dil
	imul	ecx, eax
	and	r10d, 63				; 0000003fH
	movzx	eax, sil
	movzx	r9d, cl
	movzx	ecx, dl
	shr	r9d, cl
	imul	r9d, r15d
	movzx	ecx, sil
	imul	ecx, eax
	movzx	eax, cl
	movzx	ecx, r8b
	shr	eax, cl
	xor	r8d, r8d
	imul	eax, r14d
	add	r9d, eax
	mov	eax, ebp
	shr	eax, 10
	add	r9d, eax
	and	r9d, 63					; 0000003fH
	cmp	ebx, 3
	jl	SHORT $LN9@computeTex

; 1323 : 				const deUint32	rnum = hash52(seed);
; 1324 : 				deUint8			seed1 = (deUint8)(rnum & 0xf);
; 1325 : 				deUint8			seed2 = (deUint8)((rnum >> 4) & 0xf);
; 1326 : 				deUint8			seed3 = (deUint8)((rnum >> 8) & 0xf);
; 1327 : 				deUint8			seed4 = (deUint8)((rnum >> 12) & 0xf);
; 1328 : 				deUint8			seed5 = (deUint8)((rnum >> 16) & 0xf);
; 1329 : 				deUint8			seed6 = (deUint8)((rnum >> 20) & 0xf);
; 1330 : 				deUint8			seed7 = (deUint8)((rnum >> 24) & 0xf);
; 1331 : 				deUint8			seed8 = (deUint8)((rnum >> 28) & 0xf);
; 1332 : 				deUint8			seed9 = (deUint8)((rnum >> 18) & 0xf);
; 1333 : 				deUint8			seed10 = (deUint8)((rnum >> 22) & 0xf);
; 1334 : 				deUint8			seed11 = (deUint8)((rnum >> 26) & 0xf);
; 1335 : 				deUint8			seed12 = (deUint8)(((rnum >> 30) | (rnum << 2)) & 0xf);
; 1336 : 				seed1 = (deUint8)(seed1 * seed1);
; 1337 : 				seed2 = (deUint8)(seed2 * seed2);
; 1338 : 				seed3 = (deUint8)(seed3 * seed3);
; 1339 : 				seed4 = (deUint8)(seed4 * seed4);
; 1340 : 				seed5 = (deUint8)(seed5 * seed5);
; 1341 : 				seed6 = (deUint8)(seed6 * seed6);

	movzx	eax, r13b
	movzx	ecx, r13b
	imul	ecx, eax
	movzx	eax, r12b

; 1366 : 				const int b = 0x3f & (seed3 * x + seed4 * y + seed12 * z + (rnum >> 10));
; 1367 : 				const int c = numPartitions >= 3 ? 0x3f & (seed5 * x + seed6 * y + seed9 * z + (rnum >> 6)) : 0;

	movzx	edx, cl
	movzx	ecx, BYTE PTR tv798[rsp]
	shr	edx, cl
	imul	edx, r15d
	movzx	ecx, r12b
	imul	ecx, eax
	movzx	eax, cl
	movzx	ecx, BYTE PTR tv799[rsp]
	shr	eax, cl
	imul	eax, r14d
	add	edx, eax
	mov	eax, ebp
	shr	eax, 6
	add	edx, eax
	and	edx, 63					; 0000003fH

; 1368 : 				const int d = numPartitions >= 4 ? 0x3f & (seed7 * x + seed8 * y + seed10 * z + (rnum >> 2)) : 0;

	cmp	ebx, 4
	jl	SHORT $LN11@computeTex
	movzx	eax, BYTE PTR tv876[rsp]
	imul	eax, r14d
	shr	ebp, 2
	movzx	ecx, r11b
	imul	ecx, r15d
	add	ecx, eax
	add	ecx, ebp
	and	ecx, 63					; 0000003fH
	jmp	SHORT $LN12@computeTex
$LN9@computeTex:

; 1366 : 				const int b = 0x3f & (seed3 * x + seed4 * y + seed12 * z + (rnum >> 10));
; 1367 : 				const int c = numPartitions >= 3 ? 0x3f & (seed5 * x + seed6 * y + seed9 * z + (rnum >> 6)) : 0;

	mov	edx, r8d
$LN11@computeTex:

; 1368 : 				const int d = numPartitions >= 4 ? 0x3f & (seed7 * x + seed8 * y + seed10 * z + (rnum >> 2)) : 0;

	mov	ecx, r8d
$LN12@computeTex:

; 1369 : 				return a >= b && a >= c && a >= d ? 0

	cmp	r10d, r9d
	jb	SHORT $LN13@computeTex
	cmp	r10d, edx
	jb	SHORT $LN13@computeTex
	cmp	r10d, ecx
	jb	SHORT $LN13@computeTex
	mov	eax, r8d
	jmp	SHORT $LN15@computeTex
$LN13@computeTex:
	cmp	r9d, edx
	jb	SHORT $LN14@computeTex
	cmp	r9d, ecx
	jb	SHORT $LN14@computeTex
	mov	eax, 1
	jmp	SHORT $LN15@computeTex
$LN14@computeTex:
	cmp	edx, ecx
	setb	r8b
	lea	eax, DWORD PTR [r8+2]
$LN15@computeTex:

; 1370 : 					: b >= c && b >= d ? 1
; 1371 : 					: c >= d ? 2
; 1372 : 					: 3;
; 1373 : 			}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
?computeTexelPartition@?A0xc6621425@astc@basisu@@YAHIIIIH_N@Z ENDP ; basisu::astc::`anonymous namespace'::computeTexelPartition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z
_TEXT	SEGMENT
texelY$1$ = 48
isHDREndpoint$ = 52
tv2086 = 56
tv2090 = 64
tv2091 = 72
tv2085 = 80
tv2089 = 88
dst$ = 160
colorEndpoints$ = 168
texelWeights$ = 176
ccs$ = 184
partitionIndexSeed$ = 192
numPartitions$ = 200
blockWidth$ = 208
blockHeight$ = 216
smallBlock$1$ = 224
isSRGB$dead$ = 224
result$1$ = 232
isLDRMode$dead$ = 232
colorEndpointModes$ = 240
?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z PROC ; basisu::astc::`anonymous namespace'::setTexelColors, COMDAT

; 1376 : 			{

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r15
	sub	rsp, 104				; 00000068H

; 1377 : 				const bool			smallBlock = blockWidth * blockHeight < 31;

	mov	edi, DWORD PTR blockHeight$[rsp]
	mov	rbx, rdx
	mov	edx, DWORD PTR blockWidth$[rsp]
	mov	r15d, r9d

; 1378 : 				DecompressResult	result = DECOMPRESS_RESULT_VALID_BLOCK;
; 1379 : 				bool				isHDREndpoint[4];
; 1380 : 				for (int i = 0; i < numPartitions; i++)

	movsxd	r13, DWORD PTR numPartitions$[rsp]
	mov	eax, edx
	imul	eax, edi
	mov	r11, r8
	mov	rbp, rcx
	cmp	eax, 31
	setl	r9b
	xor	r8d, r8d
	mov	BYTE PTR smallBlock$1$[rsp], r9b
	mov	DWORD PTR result$1$[rsp], r8d
	test	r13d, r13d
	jle	SHORT $LN98@setTexelCo
	mov	rdx, QWORD PTR colorEndpointModes$[rsp]
	xor	eax, eax
	mov	esi, 51340				; 0000c88cH
	npad	5
$LL4@setTexelCo:

; 1381 : 				{
; 1382 : 					isHDREndpoint[i] = isColorEndpointModeHDR(colorEndpointModes[i]);

	mov	ecx, DWORD PTR [rdx+rax*4]

; 857  : 				return mode == 2 ||

	cmp	ecx, 15
	ja	SHORT $LN96@setTexelCo
	bt	esi, ecx
	jb	$LN49@setTexelCo
$LN96@setTexelCo:
	mov	BYTE PTR isHDREndpoint$[rsp+rax], r8b

; 1378 : 				DecompressResult	result = DECOMPRESS_RESULT_VALID_BLOCK;
; 1379 : 				bool				isHDREndpoint[4];
; 1380 : 				for (int i = 0; i < numPartitions; i++)

	inc	rax
	cmp	rax, r13
	jl	SHORT $LL4@setTexelCo
	mov	edx, DWORD PTR blockWidth$[rsp]
$LN98@setTexelCo:

; 1387 : 				}
; 1388 : 
; 1389 : 				for (int texelY = 0; texelY < blockHeight; texelY++)

	xor	ecx, ecx
	mov	DWORD PTR texelY$1$[rsp], ecx
	test	edi, edi
	jle	$LN6@setTexelCo
	movss	xmm1, DWORD PTR __real@3f800000
	xor	r10d, r10d
	movss	xmm2, DWORD PTR __real@37800000
	movsxd	rax, edx
	mov	QWORD PTR [rsp+160], r12
	mov	QWORD PTR [rsp+96], r14
	mov	QWORD PTR tv2091[rsp], r10
	lea	r8, QWORD PTR [rax*8]
	lea	rax, QWORD PTR [rax*4]
	mov	QWORD PTR tv2090[rsp], r8
	mov	QWORD PTR tv2089[rsp], rax
	mov	r14, r8
	lea	eax, DWORD PTR [rdx*4]
	cdqe
	shl	rax, 2
	mov	QWORD PTR tv2086[rsp], rax
	lea	rax, QWORD PTR [rbp+8]
	mov	rsi, QWORD PTR tv2086[rsp]
	mov	QWORD PTR tv2085[rsp], rax
	npad	8
$LL7@setTexelCo:

; 1390 : 					for (int texelX = 0; texelX < blockWidth; texelX++)

	xor	r12d, r12d
	test	edx, edx
	jle	$LN100@setTexelCo
	mov	rdi, r10
	mov	rsi, r11
	mov	r14, rax
$LL10@setTexelCo:

; 1391 : 					{
; 1392 : 						const int				texelNdx = texelY * blockWidth + texelX;
; 1393 : 						const int				colorEndpointNdx = numPartitions == 1 ? 0 : computeTexelPartition(partitionIndexSeed, texelX, texelY, 0, numPartitions, smallBlock);

	cmp	r13d, 1
	jne	SHORT $LN25@setTexelCo
	xor	eax, eax
	jmp	SHORT $LN26@setTexelCo
$LN49@setTexelCo:

; 1383 : 
; 1384 : 					// rg - REMOVING HDR SUPPORT FOR NOW
; 1385 : 					if (isHDREndpoint[i])
; 1386 : 						return DECOMPRESS_RESULT_ERROR;

	mov	eax, 1

; 1453 : 			}

	add	rsp, 104				; 00000068H
	pop	r15
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN25@setTexelCo:

; 1391 : 					{
; 1392 : 						const int				texelNdx = texelY * blockWidth + texelX;
; 1393 : 						const int				colorEndpointNdx = numPartitions == 1 ? 0 : computeTexelPartition(partitionIndexSeed, texelX, texelY, 0, numPartitions, smallBlock);

	mov	r8d, ecx
	mov	BYTE PTR [rsp+40], r9b
	mov	ecx, DWORD PTR partitionIndexSeed$[rsp]
	mov	edx, r12d
	mov	DWORD PTR [rsp+32], r13d
	call	?computeTexelPartition@?A0xc6621425@astc@basisu@@YAHIIIIH_N@Z ; basisu::astc::`anonymous namespace'::computeTexelPartition
	mov	edx, DWORD PTR blockWidth$[rsp]
$LN26@setTexelCo:

; 1394 : 						DE_ASSERT(colorEndpointNdx < numPartitions);
; 1395 : 						const UVec4& e0 = colorEndpoints[colorEndpointNdx].e0;

	movsxd	rcx, eax
	mov	rax, rcx
	shl	rax, 5
	add	rbx, rax

; 1396 : 						const UVec4& e1 = colorEndpoints[colorEndpointNdx].e1;
; 1397 : 						const TexelWeightPair& weight = texelWeights[texelNdx];
; 1398 : 						if (isLDRMode && isHDREndpoint[colorEndpointNdx])

	cmp	BYTE PTR isHDREndpoint$[rsp+rcx], 0
	je	SHORT $LL88@setTexelCo

; 1399 : 						{
; 1400 : 							if (isSRGB)
; 1401 : 							{
; 1402 : 								((deUint8*)dst)[texelNdx * 4 + 0] = 0xff;
; 1403 : 								((deUint8*)dst)[texelNdx * 4 + 1] = 0;
; 1404 : 								((deUint8*)dst)[texelNdx * 4 + 2] = 0xff;
; 1405 : 								((deUint8*)dst)[texelNdx * 4 + 3] = 0xff;
; 1406 : 							}
; 1407 : 							else
; 1408 : 							{
; 1409 : 								((float*)dst)[texelNdx * 4 + 0] = 1.0f;
; 1410 : 								((float*)dst)[texelNdx * 4 + 1] = 0;
; 1411 : 								((float*)dst)[texelNdx * 4 + 2] = 1.0f;
; 1412 : 								((float*)dst)[texelNdx * 4 + 3] = 1.0f;
; 1413 : 							}
; 1414 : 							result = DECOMPRESS_RESULT_ERROR;

	mov	r8d, 1
	mov	QWORD PTR [r14-8], 1065353216		; 3f800000H
	mov	DWORD PTR result$1$[rsp], r8d
	mov	DWORD PTR [r14], 1065353216		; 3f800000H
	mov	DWORD PTR [r14+4], 1065353216		; 3f800000H

; 1415 : 						}

	jmp	$LN8@setTexelCo
	npad	15
$LL88@setTexelCo:

; 1416 : 						else
; 1417 : 						{
; 1418 : 							for (int channelNdx = 0; channelNdx < 4; channelNdx++)
; 1419 : 							{
; 1420 : 								if (!isHDREndpoint[colorEndpointNdx] || (channelNdx == 3 && colorEndpointModes[colorEndpointNdx] == 14)) // \note Alpha for mode 14 is treated the same as LDR.

	xor	r10d, r10d
	xor	r11d, r11d
	lea	r13d, QWORD PTR [r10+4]
	npad	6
$LL27@setTexelCo:

; 1421 : 								{
; 1422 : 									const deUint32 c0 = (e0[channelNdx] << 8) | (isSRGB ? 0x80 : e0[channelNdx]);

	mov	r9d, DWORD PTR [rbx+r10*4]

; 1423 : 									const deUint32 c1 = (e1[channelNdx] << 8) | (isSRGB ? 0x80 : e1[channelNdx]);
; 1424 : 									const deUint32 w = weight.w[ccs == channelNdx ? 1 : 0];

	xor	eax, eax
	mov	r8d, DWORD PTR [rbx+r10*4+16]
	shl	r9d, 8
	or	r9d, DWORD PTR [rbx+r10*4]
	cmp	r15d, r10d
	cmove	rax, r13
	shl	r8d, 8
	or	r8d, DWORD PTR [rbx+r10*4+16]
	mov	ecx, DWORD PTR [rax+rsi]

; 1425 : 									const deUint32 c = (c0 * (64 - w) + c1 * w + 32) / 64;

	mov	eax, 64					; 00000040H
	sub	eax, ecx
	imul	r8d, ecx
	imul	eax, r9d
	lea	ecx, DWORD PTR [rax+32]
	add	ecx, r8d
	shr	ecx, 6

; 1426 : 									if (isSRGB)
; 1427 : 										((deUint8*)dst)[texelNdx * 4 + channelNdx] = (deUint8)((c & 0xff00) >> 8);
; 1428 : 									else
; 1429 : 										((float*)dst)[texelNdx * 4 + channelNdx] = c == 65535 ? 1.0f : (float)c / 65536.0f;

	cmp	ecx, 65535				; 0000ffffH
	jne	SHORT $LN31@setTexelCo
	movaps	xmm0, xmm1
	jmp	SHORT $LN32@setTexelCo
$LN31@setTexelCo:
	xorps	xmm0, xmm0
	mov	eax, ecx
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm2
$LN32@setTexelCo:

; 117  : 		uint32_t operator[] (uint32_t idx) const { assert(idx < 4);  return m_c[idx]; }

	lea	r8d, DWORD PTR [r10+1]

; 1426 : 									if (isSRGB)
; 1427 : 										((deUint8*)dst)[texelNdx * 4 + channelNdx] = (deUint8)((c & 0xff00) >> 8);
; 1428 : 									else
; 1429 : 										((float*)dst)[texelNdx * 4 + channelNdx] = c == 65535 ? 1.0f : (float)c / 65536.0f;

	lea	rax, QWORD PTR [rdi+r11]
	movss	DWORD PTR [rbp+rax*4], xmm0
	xor	eax, eax
	mov	r9d, DWORD PTR [rbx+r8*4]

; 117  : 		uint32_t operator[] (uint32_t idx) const { assert(idx < 4);  return m_c[idx]; }

	mov	edx, DWORD PTR [rbx+r8*4+16]

; 1421 : 								{
; 1422 : 									const deUint32 c0 = (e0[channelNdx] << 8) | (isSRGB ? 0x80 : e0[channelNdx]);

	shl	r9d, 8
	or	r9d, DWORD PTR [rbx+r8*4]

; 1423 : 									const deUint32 c1 = (e1[channelNdx] << 8) | (isSRGB ? 0x80 : e1[channelNdx]);
; 1424 : 									const deUint32 w = weight.w[ccs == channelNdx ? 1 : 0];

	cmp	r15d, r8d
	mov	r8d, edx
	cmove	rax, r13
	shl	r8d, 8
	or	r8d, edx
	mov	ecx, DWORD PTR [rax+rsi]

; 1425 : 									const deUint32 c = (c0 * (64 - w) + c1 * w + 32) / 64;

	mov	eax, 64					; 00000040H
	sub	eax, ecx
	imul	r8d, ecx
	imul	eax, r9d
	lea	ecx, DWORD PTR [rax+32]
	add	ecx, r8d
	shr	ecx, 6

; 1426 : 									if (isSRGB)
; 1427 : 										((deUint8*)dst)[texelNdx * 4 + channelNdx] = (deUint8)((c & 0xff00) >> 8);
; 1428 : 									else
; 1429 : 										((float*)dst)[texelNdx * 4 + channelNdx] = c == 65535 ? 1.0f : (float)c / 65536.0f;

	cmp	ecx, 65535				; 0000ffffH
	jne	SHORT $LN61@setTexelCo
	movaps	xmm0, xmm1
	jmp	SHORT $LN62@setTexelCo
$LN61@setTexelCo:
	xorps	xmm0, xmm0
	mov	eax, ecx
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm2
$LN62@setTexelCo:

; 117  : 		uint32_t operator[] (uint32_t idx) const { assert(idx < 4);  return m_c[idx]; }

	lea	r8d, DWORD PTR [r10+2]

; 1426 : 									if (isSRGB)
; 1427 : 										((deUint8*)dst)[texelNdx * 4 + channelNdx] = (deUint8)((c & 0xff00) >> 8);
; 1428 : 									else
; 1429 : 										((float*)dst)[texelNdx * 4 + channelNdx] = c == 65535 ? 1.0f : (float)c / 65536.0f;

	lea	rax, QWORD PTR [rdi+r11]
	movss	DWORD PTR [rbp+rax*4+4], xmm0
	xor	eax, eax
	mov	r9d, DWORD PTR [rbx+r8*4]

; 117  : 		uint32_t operator[] (uint32_t idx) const { assert(idx < 4);  return m_c[idx]; }

	mov	edx, DWORD PTR [rbx+r8*4+16]

; 1421 : 								{
; 1422 : 									const deUint32 c0 = (e0[channelNdx] << 8) | (isSRGB ? 0x80 : e0[channelNdx]);

	shl	r9d, 8
	or	r9d, DWORD PTR [rbx+r8*4]

; 1423 : 									const deUint32 c1 = (e1[channelNdx] << 8) | (isSRGB ? 0x80 : e1[channelNdx]);
; 1424 : 									const deUint32 w = weight.w[ccs == channelNdx ? 1 : 0];

	cmp	r15d, r8d
	mov	r8d, edx
	cmove	rax, r13
	shl	r8d, 8
	or	r8d, edx
	mov	ecx, DWORD PTR [rax+rsi]

; 1425 : 									const deUint32 c = (c0 * (64 - w) + c1 * w + 32) / 64;

	mov	eax, 64					; 00000040H
	sub	eax, ecx
	imul	r8d, ecx
	imul	eax, r9d
	lea	ecx, DWORD PTR [rax+32]
	add	ecx, r8d
	shr	ecx, 6

; 1426 : 									if (isSRGB)
; 1427 : 										((deUint8*)dst)[texelNdx * 4 + channelNdx] = (deUint8)((c & 0xff00) >> 8);
; 1428 : 									else
; 1429 : 										((float*)dst)[texelNdx * 4 + channelNdx] = c == 65535 ? 1.0f : (float)c / 65536.0f;

	cmp	ecx, 65535				; 0000ffffH
	jne	SHORT $LN71@setTexelCo
	movaps	xmm0, xmm1
	jmp	SHORT $LN72@setTexelCo
$LN71@setTexelCo:
	xorps	xmm0, xmm0
	mov	eax, ecx
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm2
$LN72@setTexelCo:

; 117  : 		uint32_t operator[] (uint32_t idx) const { assert(idx < 4);  return m_c[idx]; }

	lea	r8d, DWORD PTR [r10+3]

; 1426 : 									if (isSRGB)
; 1427 : 										((deUint8*)dst)[texelNdx * 4 + channelNdx] = (deUint8)((c & 0xff00) >> 8);
; 1428 : 									else
; 1429 : 										((float*)dst)[texelNdx * 4 + channelNdx] = c == 65535 ? 1.0f : (float)c / 65536.0f;

	lea	rax, QWORD PTR [rdi+r11]
	movss	DWORD PTR [rbp+rax*4+8], xmm0
	xor	eax, eax
	mov	r9d, DWORD PTR [rbx+r8*4]

; 117  : 		uint32_t operator[] (uint32_t idx) const { assert(idx < 4);  return m_c[idx]; }

	mov	edx, DWORD PTR [rbx+r8*4+16]

; 1421 : 								{
; 1422 : 									const deUint32 c0 = (e0[channelNdx] << 8) | (isSRGB ? 0x80 : e0[channelNdx]);

	shl	r9d, 8
	or	r9d, DWORD PTR [rbx+r8*4]

; 1423 : 									const deUint32 c1 = (e1[channelNdx] << 8) | (isSRGB ? 0x80 : e1[channelNdx]);
; 1424 : 									const deUint32 w = weight.w[ccs == channelNdx ? 1 : 0];

	cmp	r15d, r8d
	mov	r8d, edx
	cmove	rax, r13
	shl	r8d, 8
	or	r8d, edx
	mov	ecx, DWORD PTR [rax+rsi]

; 1425 : 									const deUint32 c = (c0 * (64 - w) + c1 * w + 32) / 64;

	mov	eax, 64					; 00000040H
	sub	eax, ecx
	imul	r8d, ecx
	imul	eax, r9d
	lea	ecx, DWORD PTR [rax+32]
	add	ecx, r8d
	shr	ecx, 6

; 1426 : 									if (isSRGB)
; 1427 : 										((deUint8*)dst)[texelNdx * 4 + channelNdx] = (deUint8)((c & 0xff00) >> 8);
; 1428 : 									else
; 1429 : 										((float*)dst)[texelNdx * 4 + channelNdx] = c == 65535 ? 1.0f : (float)c / 65536.0f;

	cmp	ecx, 65535				; 0000ffffH
	jne	SHORT $LN81@setTexelCo
	movaps	xmm0, xmm1
	jmp	SHORT $LN82@setTexelCo
$LN81@setTexelCo:
	xorps	xmm0, xmm0
	mov	eax, ecx
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm2
$LN82@setTexelCo:
	lea	rax, QWORD PTR [rdi+r11]
	add	r10d, r13d
	add	r11, r13
	movss	DWORD PTR [rbp+rax*4+12], xmm0
	cmp	r10d, r13d
	jl	$LL27@setTexelCo
	mov	r13d, DWORD PTR numPartitions$[rsp]
	mov	edx, DWORD PTR blockWidth$[rsp]
	mov	r8d, DWORD PTR result$1$[rsp]
$LN8@setTexelCo:

; 1390 : 					for (int texelX = 0; texelX < blockWidth; texelX++)

	mov	ecx, DWORD PTR texelY$1$[rsp]
	inc	r12d
	movzx	r9d, BYTE PTR smallBlock$1$[rsp]
	add	rdi, 4
	mov	rbx, QWORD PTR colorEndpoints$[rsp]
	add	rsi, 8
	add	r14, 16
	cmp	r12d, edx
	jl	$LL10@setTexelCo
	mov	r10, QWORD PTR tv2091[rsp]
	mov	rax, QWORD PTR tv2085[rsp]
	mov	r11, QWORD PTR texelWeights$[rsp]
	mov	edi, DWORD PTR blockHeight$[rsp]
	mov	rsi, QWORD PTR tv2086[rsp]
	mov	r14, QWORD PTR tv2090[rsp]
	jmp	SHORT $LN5@setTexelCo
$LN100@setTexelCo:
	mov	r8d, DWORD PTR result$1$[rsp]
$LN5@setTexelCo:

; 1387 : 				}
; 1388 : 
; 1389 : 				for (int texelY = 0; texelY < blockHeight; texelY++)

	add	r10, QWORD PTR tv2089[rsp]
	inc	ecx
	add	r11, r14
	mov	DWORD PTR texelY$1$[rsp], ecx
	add	rax, rsi
	mov	QWORD PTR tv2091[rsp], r10
	mov	QWORD PTR texelWeights$[rsp], r11
	mov	QWORD PTR tv2085[rsp], rax
	cmp	ecx, edi
	jl	$LL7@setTexelCo
	mov	r14, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+160]
$LN6@setTexelCo:

; 1430 : 								}
; 1431 : 								else
; 1432 : 								{
; 1433 : 									//DE_STATIC_ASSERT((basisu::meta::TypesSame<deFloat16, deUint16>::Value));
; 1434 : 									// rg - REMOVING HDR SUPPORT FOR NOW
; 1435 : #if 0
; 1436 : 									const deUint32		c0 = e0[channelNdx] << 4;
; 1437 : 									const deUint32		c1 = e1[channelNdx] << 4;
; 1438 : 									const deUint32		w = weight.w[ccs == channelNdx ? 1 : 0];
; 1439 : 									const deUint32		c = (c0 * (64 - w) + c1 * w + 32) / 64;
; 1440 : 									const deUint32		e = getBits(c, 11, 15);
; 1441 : 									const deUint32		m = getBits(c, 0, 10);
; 1442 : 									const deUint32		mt = m < 512 ? 3 * m
; 1443 : 										: m >= 1536 ? 5 * m - 2048
; 1444 : 										: 4 * m - 512;
; 1445 : 									const deFloat16		cf = (deFloat16)((e << 10) + (mt >> 3));
; 1446 : 									((float*)dst)[texelNdx * 4 + channelNdx] = deFloat16To32(isFloat16InfOrNan(cf) ? 0x7bff : cf);
; 1447 : #endif
; 1448 : 								}
; 1449 : 							}
; 1450 : 						}
; 1451 : 					}
; 1452 : 				return result;

	mov	eax, r8d

; 1453 : 			}

	add	rsp, 104				; 00000068H
	pop	r15
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z ENDP ; basisu::astc::`anonymous namespace'::setTexelColors
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decompressBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z
_TEXT	SEGMENT
tv2701 = 96
numBitsForColorEndpoints$1$ = 100
blockHeight$GSCopy$1$ = 104
numValues$1$ = 108
extraCemBitsStart$1$ = 112
highLevelSelector$1$ = 116
$T1 = 116
blockData$GSCopy$1$ = 128
blockWidth$GSCopy$1$ = 136
dst$GSCopy$1$ = 144
dataStream$2 = 152
dataStream$3 = 152
blockMode$ = 176
colorEndpointModes$ = 200
unquantizedEndpoints$4 = 224
colorEndpoints$ = 304
unquantizedWeights$5 = 432
colorEndpointData$6 = 432
weightGrid$7 = 688
texelWeights$ = 1456
__$ArrayPad$ = 2608
dst$ = 2704
blockData$ = 2712
blockWidth$ = 2720
blockHeight$ = 2728
isSRGB$dead$ = 2736
isLDR$dead$ = 2744
?decompressBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z PROC ; basisu::astc::`anonymous namespace'::decompressBlock, COMDAT

; 1455 : 			{

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-2376]
	sub	rsp, 2632				; 00000a48H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rdi, rdx
	mov	QWORD PTR blockData$GSCopy$1$[rbp-256], rdx

; 1456 : 				DE_ASSERT(isLDR || !isSRGB);
; 1457 : 				// Decode block mode.
; 1458 : 				const ASTCBlockMode blockMode = getASTCBlockMode(blockData.getBits(0, 10));

	xor	edx, edx
	mov	DWORD PTR blockWidth$GSCopy$1$[rbp-256], r8d
	mov	ebx, r9d
	mov	QWORD PTR dst$GSCopy$1$[rbp-256], rcx
	mov	r13d, r8d
	mov	DWORD PTR blockHeight$GSCopy$1$[rsp], ebx
	mov	rsi, rcx
	mov	rcx, rdi
	lea	r8d, QWORD PTR [rdx+10]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
	mov	edx, eax
	lea	rcx, QWORD PTR blockMode$[rbp-256]
	call	?getASTCBlockMode@?A0xc6621425@astc@basisu@@YA?AUASTCBlockMode@123@I@Z ; basisu::astc::`anonymous namespace'::getASTCBlockMode

; 1459 : 				// Check for block mode errors.
; 1460 : 				if (blockMode.isError)

	cmp	BYTE PTR blockMode$[rbp-256], 0
	je	SHORT $LN2@decompress

; 561  : 				if (isSRGB)

	imul	r13d, ebx

; 562  : 				{
; 563  : 					deUint8* const dstU = (deUint8*)dst;
; 564  : 					for (int i = 0; i < blockWidth * blockHeight; i++)
; 565  : 					{
; 566  : 						dstU[4 * i + 0] = 0xff;
; 567  : 						dstU[4 * i + 1] = 0;
; 568  : 						dstU[4 * i + 2] = 0xff;
; 569  : 						dstU[4 * i + 3] = 0xff;
; 570  : 					}
; 571  : 				}
; 572  : 				else
; 573  : 				{
; 574  : 					float* const dstF = (float*)dst;
; 575  : 					for (int i = 0; i < blockWidth * blockHeight; i++)

	movsxd	rcx, r13d
	test	r13d, r13d
	jle	$LN54@decompress
	lea	rax, QWORD PTR [rsi+8]
	npad	4
$LL31@decompress:

; 576  : 					{
; 577  : 						dstF[4 * i + 0] = 1.0f;

	mov	QWORD PTR [rax-8], 1065353216		; 3f800000H

; 578  : 						dstF[4 * i + 1] = 0.0f;
; 579  : 						dstF[4 * i + 2] = 1.0f;

	mov	DWORD PTR [rax], 1065353216		; 3f800000H

; 580  : 						dstF[4 * i + 3] = 1.0f;

	mov	DWORD PTR [rax+4], 1065353216		; 3f800000H
	lea	rax, QWORD PTR [rax+16]
	sub	rcx, 1
	jne	SHORT $LL31@decompress
	jmp	$LN54@decompress
$LN2@decompress:

; 1461 : 				{
; 1462 : 					setASTCErrorColorBlock(dst, blockWidth, blockHeight, isSRGB);
; 1463 : 					return DECOMPRESS_RESULT_ERROR;
; 1464 : 				}
; 1465 : 				// Separate path for void-extent.
; 1466 : 				if (blockMode.isVoidExtent)

	cmp	BYTE PTR blockMode$[rbp-255], 0
	je	SHORT $LN3@decompress

; 1467 : 					return decodeVoidExtentBlock(dst, blockData, blockWidth, blockHeight, isSRGB, isLDR);

	mov	r9d, ebx
	mov	r8d, r13d
	mov	rdx, rdi
	mov	rcx, rsi
	call	?decodeVoidExtentBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z ; basisu::astc::`anonymous namespace'::decodeVoidExtentBlock
	jmp	$LN1@decompress
$LN3@decompress:

; 447  : 				return mode.weightGridWidth * mode.weightGridHeight * (mode.isDualPlane ? 2 : 1);

	movzx	esi, BYTE PTR blockMode$[rbp-254]
	xor	ebx, ebx
	mov	r15d, DWORD PTR blockMode$[rbp-248]
	test	sil, sil
	mov	r14d, DWORD PTR blockMode$[rbp-252]
	mov	r12d, ebx

; 274  : 				switch (iseParams.mode)

	mov	ecx, DWORD PTR blockMode$[rbp-244]

; 447  : 				return mode.weightGridWidth * mode.weightGridHeight * (mode.isDualPlane ? 2 : 1);

	setne	r12b

; 274  : 				switch (iseParams.mode)

	mov	r8d, DWORD PTR blockMode$[rbp-240]

; 447  : 				return mode.weightGridWidth * mode.weightGridHeight * (mode.isDualPlane ? 2 : 1);

	inc	r12d
	imul	r12d, r15d
	imul	r12d, r14d
	mov	DWORD PTR numValues$1$[rsp], r12d

; 274  : 				switch (iseParams.mode)

	test	ecx, ecx
	je	SHORT $LN40@decompress
	sub	ecx, 1
	je	SHORT $LN41@decompress
	cmp	ecx, 1
	je	SHORT $LN42@decompress

; 279  : 				default:
; 280  : 					DE_ASSERT(false);
; 281  : 					return -1;

	lea	edi, QWORD PTR [rbx-1]
	jmp	SHORT $LN37@decompress
$LN42@decompress:

; 278  : 				case ISEMODE_PLAIN_BIT:		return numValues * iseParams.numBits;

	mov	edi, r8d
	imul	edi, r12d
	jmp	SHORT $LN37@decompress
$LN41@decompress:

; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	imul	ecx, r12d, 7

; 192  : 		return (a + b - 1) / b;

	mov	eax, -1431655765			; aaaaaaabH
	add	ecx, 2
	mul	ecx
	mov	edi, edx
	shr	edi, 1

; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	jmp	SHORT $LN342@decompress
$LN40@decompress:

; 192  : 		return (a + b - 1) / b;

	lea	ecx, DWORD PTR [r12*8+4]
	mov	eax, -858993459				; cccccccdH
	mul	ecx
	mov	edi, edx
	shr	edi, 2
$LN342@decompress:

; 1468 : 				// Compute weight grid values.
; 1469 : 				const int numWeights = computeNumWeights(blockMode);
; 1470 : 				const int numWeightDataBits = computeNumRequiredBits(blockMode.weightISEParams, numWeights);
; 1471 : 				const int numPartitions = (int)blockData.getBits(11, 12) + 1;

	mov	eax, r8d
	imul	eax, r12d
	add	edi, eax
$LN37@decompress:
	mov	rcx, QWORD PTR blockData$GSCopy$1$[rbp-256]
	mov	edx, 11
	lea	r8d, QWORD PTR [rdx+1]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
	mov	DWORD PTR tv2701[rsp], eax
	mov	edx, eax

; 1472 : 				// Check for errors in weight grid, partition and dual-plane parameters.
; 1473 : 				if (numWeights > 64 ||
; 1474 : 					numWeightDataBits > 96 ||
; 1475 : 					numWeightDataBits < 24 ||
; 1476 : 					blockMode.weightGridWidth > blockWidth ||
; 1477 : 					blockMode.weightGridHeight > blockHeight ||

	cmp	r12d, 64				; 00000040H
	jg	$LN296@decompress
	lea	eax, DWORD PTR [rdi-24]
	cmp	eax, 72					; 00000048H
	mov	eax, DWORD PTR blockHeight$GSCopy$1$[rsp]
	ja	$LN5@decompress
	cmp	r14d, r13d
	jg	$LN5@decompress
	cmp	r15d, eax
	jg	$LN5@decompress
	lea	r14d, DWORD PTR [rdx+1]
	cmp	r14d, 4
	jne	SHORT $LN4@decompress
	test	sil, sil
	jne	$LN5@decompress

; 1482 : 				}
; 1483 : 				// Compute number of bits available for color endpoint data.
; 1484 : 				const bool	isSingleUniqueCem = numPartitions == 1 || blockData.getBits(23, 24) == 0;

	jmp	SHORT $LN287@decompress
$LN4@decompress:
	cmp	r14d, 1
	je	SHORT $LN9@decompress
$LN287@decompress:
	mov	rcx, QWORD PTR blockData$GSCopy$1$[rbp-256]
	mov	edx, 23
	lea	r8d, QWORD PTR [rdx+1]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
	test	eax, eax
	je	SHORT $LN9@decompress
	xor	al, al
	jmp	SHORT $LN10@decompress
$LN9@decompress:
	mov	al, 1
$LN10@decompress:

; 1485 : 				const int	numConfigDataBits = (numPartitions == 1 ? 17 : isSingleUniqueCem ? 29 : 25 + 3 * numPartitions) +

	mov	r15d, 4
	cmp	r14d, 1
	jne	$LN13@decompress

; 1486 : 					(blockMode.isDualPlane ? 2 : 0);
; 1487 : 				const int	numBitsForColorEndpoints = 128 - numWeightDataBits - numConfigDataBits;

	test	sil, sil
	mov	ecx, 109				; 0000006dH
	mov	r12d, 111				; 0000006fH
	cmovne	r12d, ecx
	sub	r12d, edi
	mov	DWORD PTR numBitsForColorEndpoints$1$[rsp], r12d

; 1488 : 				const int	extraCemBitsStart = 127 - numWeightDataBits - (isSingleUniqueCem ? -1

	test	al, al
	jne	$LN290@decompress
	mov	eax, DWORD PTR tv2701[rsp]
$LN15@decompress:
	cmp	eax, 1
	mov	r13d, ebx
	setne	r13b
	dec	r13d
$LN16@decompress:
	sub	r13d, edi

; 1489 : 					: numPartitions == 4 ? 7
; 1490 : 					: numPartitions == 3 ? 4
; 1491 : 					: numPartitions == 2 ? 1
; 1492 : 					: 0);
; 1493 : 				// Decode color endpoint modes.
; 1494 : 				deUint32 colorEndpointModes[4];
; 1495 : 				decodeColorEndpointModes(&colorEndpointModes[0], blockData, numPartitions, extraCemBitsStart);

	movsxd	r14, r14d
	add	r13d, 127				; 0000007fH
	mov	rsi, r14
	mov	DWORD PTR extraCemBitsStart$1$[rsp], r13d

; 639  : 				if (numPartitions == 1)

	test	eax, eax
	jne	$LN66@decompress

; 640  : 					endpointModesDst[0] = blockData.getBits(13, 16);

	mov	rcx, QWORD PTR blockData$GSCopy$1$[rbp-256]
	lea	edx, QWORD PTR [rax+13]
	lea	r8d, QWORD PTR [rax+16]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
	mov	DWORD PTR colorEndpointModes$[rbp-256], eax
$LN64@decompress:

; 666  : 				int result = 0;

	mov	esi, ebx

; 667  : 				for (int i = 0; i < numPartitions; i++)

	test	r14, r14
	jle	SHORT $LN288@decompress
$LN289@decompress:
	mov	rcx, rbx
	npad	15
$LL249@decompress:

; 323  : 				return (endpointMode / 4 + 1) * 2;

	mov	eax, DWORD PTR colorEndpointModes$[rbp+rcx*4-256]

; 667  : 				for (int i = 0; i < numPartitions; i++)

	inc	rcx

; 323  : 				return (endpointMode / 4 + 1) * 2;

	shr	eax, 2

; 668  : 					result += computeNumColorEndpointValues(endpointModes[i]);

	lea	esi, DWORD PTR [rsi+rax*2]
	add	esi, 2
	mov	eax, esi
	cmp	rcx, r14
	jl	SHORT $LL249@decompress

; 1496 : 				const int numColorEndpointValues = computeNumColorEndpointValues(colorEndpointModes, numPartitions);
; 1497 : 				// Check for errors in color endpoint value count.
; 1498 : 				if (numColorEndpointValues > 18 || numBitsForColorEndpoints < (int)deDivRoundUp32(13 * numColorEndpointValues, 5))

	cmp	eax, 18
	jg	$LN7@decompress
$LN288@decompress:
	imul	ecx, esi, 13

; 192  : 		return (a + b - 1) / b;

	mov	eax, -858993459				; cccccccdH
	add	ecx, 4
	mul	ecx
	shr	edx, 2

; 1496 : 				const int numColorEndpointValues = computeNumColorEndpointValues(colorEndpointModes, numPartitions);
; 1497 : 				// Check for errors in color endpoint value count.
; 1498 : 				if (numColorEndpointValues > 18 || numBitsForColorEndpoints < (int)deDivRoundUp32(13 * numColorEndpointValues, 5))

	cmp	r12d, edx
	jl	$LN7@decompress

; 1499 : 				{
; 1500 : 					setASTCErrorColorBlock(dst, blockWidth, blockHeight, isSRGB);
; 1501 : 					return DECOMPRESS_RESULT_ERROR;
; 1502 : 				}
; 1503 : 				// Compute color endpoints.
; 1504 : 				ColorEndpointPair colorEndpoints[4];

	lea	rax, QWORD PTR colorEndpoints$[rbp-232]
	npad	3
$LL103@decompress:

; 93   : 			m_c[0] = 0;

	mov	QWORD PTR [rax-24], 0
	mov	QWORD PTR [rax-16], 0
	mov	QWORD PTR [rax-8], 0
	mov	QWORD PTR [rax], 0
	lea	rax, QWORD PTR [rax+32]
	sub	r15, 1
	jne	SHORT $LL103@decompress

; 286  : 				int curBitsForTritMode = 6;

	lea	r9d, QWORD PTR [r15+6]

; 287  : 				int curBitsForQuintMode = 5;

	mov	r14d, esi
	lea	r10d, QWORD PTR [r15+5]

; 288  : 				int curBitsForPlainBitMode = 8;

	lea	r11d, QWORD PTR [r15+8]
	lea	r15d, DWORD PTR [rsi+rsi*2]
	add	r15d, r15d
	lea	r12d, DWORD PTR [rsi*8]
	neg	r14d
	lea	r13d, DWORD PTR [rsi+rsi*4]
	npad	2
$LL115@decompress:

; 289  : 				while (true)
; 290  : 				{
; 291  : 					DE_ASSERT(curBitsForTritMode > 0 || curBitsForQuintMode > 0 || curBitsForPlainBitMode > 0);
; 292  : 					const int tritRange = curBitsForTritMode > 0 ? (3 << curBitsForTritMode) - 1 : -1;

	mov	eax, -1
	test	r9d, r9d
	jle	$LN125@decompress
	mov	ecx, r9d
	mov	r8d, 3
	shl	r8d, cl
	dec	r8d
	jmp	$LN126@decompress
$LN13@decompress:

; 1485 : 				const int	numConfigDataBits = (numPartitions == 1 ? 17 : isSingleUniqueCem ? 29 : 25 + 3 * numPartitions) +

	test	al, al
	je	SHORT $LN11@decompress
	test	sil, sil
	mov	eax, 97					; 00000061H
	mov	r12d, 99				; 00000063H
	cmovne	r12d, eax
	sub	r12d, edi
	mov	DWORD PTR numBitsForColorEndpoints$1$[rsp], r12d
$LN290@decompress:

; 1488 : 				const int	extraCemBitsStart = 127 - numWeightDataBits - (isSingleUniqueCem ? -1

	mov	eax, DWORD PTR tv2701[rsp]
	mov	r13d, 1
	jmp	$LN16@decompress
$LN11@decompress:

; 1485 : 				const int	numConfigDataBits = (numPartitions == 1 ? 17 : isSingleUniqueCem ? 29 : 25 + 3 * numPartitions) +

	lea	eax, DWORD PTR [r14*2+25]
	mov	ecx, 126				; 0000007eH
	add	eax, r14d
	mov	r12d, 128				; 00000080H
	test	sil, sil
	cmovne	r12d, ecx
	sub	r12d, edi
	sub	r12d, eax

; 1488 : 				const int	extraCemBitsStart = 127 - numWeightDataBits - (isSingleUniqueCem ? -1

	mov	eax, DWORD PTR tv2701[rsp]
	mov	DWORD PTR numBitsForColorEndpoints$1$[rsp], r12d
	cmp	eax, 3
	jne	SHORT $LN17@decompress
	movsxd	r14, r14d
	mov	r13d, 120				; 00000078H
$LN343@decompress:

; 643  : 					const deUint32 highLevelSelector = blockData.getBits(23, 24);

	sub	r13d, edi
	mov	rsi, r14
	mov	DWORD PTR extraCemBitsStart$1$[rsp], r13d
$LN66@decompress:
	mov	rcx, QWORD PTR blockData$GSCopy$1$[rbp-256]
	mov	edx, 23
	lea	r8d, QWORD PTR [rdx+1]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
	mov	DWORD PTR highLevelSelector$1$[rsp], eax
	mov	edi, eax

; 644  : 					if (highLevelSelector == 0)

	test	eax, eax
	jne	SHORT $LN68@decompress

; 645  : 					{
; 646  : 						const deUint32 mode = blockData.getBits(25, 28);

	mov	rcx, QWORD PTR blockData$GSCopy$1$[rbp-256]
	lea	edx, QWORD PTR [rax+25]
	lea	r8d, QWORD PTR [rax+28]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits

; 647  : 						for (int i = 0; i < numPartitions; i++)

	mov	ecx, DWORD PTR tv2701[rsp]
	inc	ecx
	test	ecx, ecx
	jle	$LN64@decompress

; 645  : 					{
; 646  : 						const deUint32 mode = blockData.getBits(25, 28);

	mov	eax, eax
	lea	rdi, QWORD PTR colorEndpointModes$[rbp-256]
	mov	rcx, rsi
	rep stosd

; 648  : 							endpointModesDst[i] = mode;
; 649  : 					}

	jmp	$LN64@decompress
$LN17@decompress:

; 1488 : 				const int	extraCemBitsStart = 127 - numWeightDataBits - (isSingleUniqueCem ? -1

	cmp	eax, 2
	jne	$LN15@decompress
	movsxd	r14, r14d
	lea	r13d, QWORD PTR [rax+121]
	jmp	SHORT $LN343@decompress
$LN68@decompress:

; 652  : 						for (int partNdx = 0; partNdx < numPartitions; partNdx++)

	test	r14, r14
	jle	$LN64@decompress
	mov	ecx, DWORD PTR tv2701[rsp]
	mov	rsi, rbx
	mov	ebx, r15d
	inc	ecx
	sub	ebx, r13d
	mov	r15d, 3
	sub	r15d, DWORD PTR extraCemBitsStart$1$[rsp]
	mov	r9d, 25
	mov	r12d, r15d
	lea	r8d, DWORD PTR [rcx-3]
	add	r8d, r13d
	mov	r13d, 28
	sub	r13d, DWORD PTR extraCemBitsStart$1$[rsp]
	sub	r12d, ecx
$LL65@decompress:

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	mov	ecx, r9d
	mov	eax, r9d
	and	ecx, 63					; 0000003fH
	test	r9d, r9d
	jns	SHORT $LN293@decompress
	lea	eax, DWORD PTR [r9+63]
	sub	ecx, 64					; 00000040H
$LN293@decompress:
	mov	r10, QWORD PTR blockData$GSCopy$1$[rbp-256]

; 654  : 							const deUint32 cemClass = highLevelSelector - (blockData.isBitSet(25 + partNdx) ? 0 : 1);

	mov	r11d, edi

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	sar	eax, 6
	cdqe
	mov	rdx, QWORD PTR [r10+rax*8]

; 657  : 							const deUint32 lowBit0 = blockData.getBit(lowBit0Ndx < 4 ? 25 + lowBit0Ndx : extraCemBitsStart + lowBit0Ndx - 4);

	lea	eax, DWORD PTR [r15+r8]

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	shr	rdx, cl
	not	dl
	and	edx, 1

; 654  : 							const deUint32 cemClass = highLevelSelector - (blockData.isBitSet(25 + partNdx) ? 0 : 1);

	sub	r11d, edx

; 655  : 							const deUint32 lowBit0Ndx = numPartitions + 2 * partNdx;
; 656  : 							const deUint32 lowBit1Ndx = numPartitions + 2 * partNdx + 1;
; 657  : 							const deUint32 lowBit0 = blockData.getBit(lowBit0Ndx < 4 ? 25 + lowBit0Ndx : extraCemBitsStart + lowBit0Ndx - 4);

	cmp	eax, 4
	lea	eax, DWORD PTR [r8+r13]
	jb	SHORT $LN72@decompress
	lea	eax, DWORD PTR [r8-1]
$LN72@decompress:

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	mov	ecx, eax
	and	ecx, 63					; 0000003fH
	test	eax, eax
	jns	SHORT $LN292@decompress
	add	eax, 63					; 0000003fH
	sub	ecx, 64					; 00000040H
$LN292@decompress:
	sar	eax, 6
	mov	rdx, r10
	cdqe
	mov	r10, QWORD PTR [r10+rax*8]

; 658  : 							const deUint32 lowBit1 = blockData.getBit(lowBit1Ndx < 4 ? 25 + lowBit1Ndx : extraCemBitsStart + lowBit1Ndx - 4);

	lea	eax, DWORD PTR [rbx+r8]

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	shr	r10, cl
	and	r10d, 1

; 658  : 							const deUint32 lowBit1 = blockData.getBit(lowBit1Ndx < 4 ? 25 + lowBit1Ndx : extraCemBitsStart + lowBit1Ndx - 4);

	cmp	eax, 4
	jae	SHORT $LN73@decompress
	mov	ecx, DWORD PTR tv2701[rsp]
	lea	eax, DWORD PTR [r12+r8]
	add	ecx, 27
	add	ecx, eax
	jmp	SHORT $LN74@decompress
$LN73@decompress:
	mov	ecx, r8d
$LN74@decompress:

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	mov	edi, ecx
	and	edi, 63					; 0000003fH
	test	ecx, ecx
	jns	SHORT $LN291@decompress
	add	ecx, 63					; 0000003fH
	sub	edi, 64					; 00000040H
$LN291@decompress:
	sar	ecx, 6

; 652  : 						for (int partNdx = 0; partNdx < numPartitions; partNdx++)

	inc	r9d

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	movsxd	rax, ecx

; 652  : 						for (int partNdx = 0; partNdx < numPartitions; partNdx++)

	add	r8d, 2

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	mov	ecx, edi

; 652  : 						for (int partNdx = 0; partNdx < numPartitions; partNdx++)

	mov	edi, DWORD PTR highLevelSelector$1$[rsp]

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	mov	rdx, QWORD PTR [rdx+rax*8]

; 659  : 							endpointModesDst[partNdx] = (cemClass << 2) | (lowBit1 << 1) | lowBit0;

	lea	eax, DWORD PTR [r11+r11]

; 357  : 					return (m_words[ndx / WORD_BITS] >> (ndx % WORD_BITS)) & 1;

	shr	rdx, cl

; 659  : 							endpointModesDst[partNdx] = (cemClass << 2) | (lowBit1 << 1) | lowBit0;

	and	edx, 1
	or	edx, eax
	add	edx, edx
	or	edx, r10d
	mov	DWORD PTR colorEndpointModes$[rbp+rsi*4-256], edx
	inc	rsi
	cmp	rsi, r14
	jl	$LL65@decompress
	mov	r12d, DWORD PTR numBitsForColorEndpoints$1$[rsp]
	xor	ebx, ebx
	mov	esi, ebx
	lea	r15d, QWORD PTR [rbx+4]
	jmp	$LN289@decompress
$LN125@decompress:

; 292  : 					const int tritRange = curBitsForTritMode > 0 ? (3 << curBitsForTritMode) - 1 : -1;

	mov	r8d, eax
$LN126@decompress:

; 293  : 					const int quintRange = curBitsForQuintMode > 0 ? (5 << curBitsForQuintMode) - 1 : -1;

	test	r10d, r10d
	jle	SHORT $LN127@decompress
	mov	ecx, r10d
	mov	edi, 5
	shl	edi, cl
	dec	edi
	jmp	SHORT $LN128@decompress
$LN127@decompress:
	mov	edi, eax
$LN128@decompress:

; 294  : 					const int plainBitRange = curBitsForPlainBitMode > 0 ? (1 << curBitsForPlainBitMode) - 1 : -1;

	test	r11d, r11d
	jle	SHORT $LN129@decompress
	mov	ecx, r11d
	mov	edx, 1
	shl	edx, cl
	dec	edx
	jmp	SHORT $LN130@decompress
$LN129@decompress:
	mov	edx, eax
$LN130@decompress:

; 68   : 		return (a > b) ? a : b;

	cmp	r8d, edi
	mov	eax, edi
	cmovg	eax, r8d
	cmp	eax, edx
	cmovg	edx, eax

; 296  : 					if (maxRange == tritRange)

	cmp	edx, r8d
	jne	SHORT $LN117@decompress

; 192  : 		return (a + b - 1) / b;

	lea	ecx, DWORD PTR [rsi*8]
	mov	eax, -858993459				; cccccccdH
	add	ecx, 4
	mul	ecx
	shr	edx, 2

; 276  : 				case ISEMODE_TRIT:			return deDivRoundUp32(numValues * 8, 5) + numValues * iseParams.numBits;

	lea	eax, DWORD PTR [rdx+r15]

; 299  : 						if (computeNumRequiredBits(params, numValuesInSequence) <= numAvailableBits)

	cmp	eax, DWORD PTR numBitsForColorEndpoints$1$[rsp]
	jle	SHORT $LN218@decompress

; 301  : 						curBitsForTritMode--;

	dec	r9d
	add	r15d, r14d

; 302  : 					}

	jmp	$LL115@decompress
$LN117@decompress:

; 303  : 					else if (maxRange == quintRange)

	cmp	edx, edi
	jne	SHORT $LN120@decompress

; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	imul	ecx, esi, 7

; 192  : 		return (a + b - 1) / b;

	mov	eax, -1431655765			; aaaaaaabH
	add	ecx, 2
	mul	ecx
	shr	edx, 1

; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	lea	eax, DWORD PTR [rdx+r13]

; 306  : 						if (computeNumRequiredBits(params, numValuesInSequence) <= numAvailableBits)

	cmp	eax, DWORD PTR numBitsForColorEndpoints$1$[rsp]
	jle	SHORT $LN219@decompress

; 308  : 						curBitsForQuintMode--;

	dec	r10d
	add	r13d, r14d

; 309  : 					}

	jmp	$LL115@decompress
$LN120@decompress:

; 310  : 					else
; 311  : 					{
; 312  : 						const ISEParams params(ISEMODE_PLAIN_BIT, curBitsForPlainBitMode);
; 313  : 						DE_ASSERT(maxRange == plainBitRange);
; 314  : 						if (computeNumRequiredBits(params, numValuesInSequence) <= numAvailableBits)

	cmp	r12d, DWORD PTR numBitsForColorEndpoints$1$[rsp]
	jle	SHORT $LN220@decompress

; 315  : 							return ISEParams(ISEMODE_PLAIN_BIT, curBitsForPlainBitMode);
; 316  : 						curBitsForPlainBitMode--;

	dec	r11d
	add	r12d, r14d

; 317  : 					}
; 318  : 				}

	jmp	$LL115@decompress
$LN218@decompress:

; 270  : 				ISEParams(ISEMode mode_, int numBits_) : mode(mode_), numBits(numBits_) {}

	mov	DWORD PTR $T1[rsp], ebx
	mov	DWORD PTR $T1[rsp+4], r9d

; 300  : 							return ISEParams(ISEMODE_TRIT, curBitsForTritMode);

	jmp	SHORT $LN116@decompress
$LN219@decompress:

; 270  : 				ISEParams(ISEMode mode_, int numBits_) : mode(mode_), numBits(numBits_) {}

	mov	DWORD PTR $T1[rsp], 1
	mov	DWORD PTR $T1[rsp+4], r10d

; 307  : 							return ISEParams(ISEMODE_QUINT, curBitsForQuintMode);

	jmp	SHORT $LN116@decompress
$LN220@decompress:

; 270  : 				ISEParams(ISEMode mode_, int numBits_) : mode(mode_), numBits(numBits_) {}

	mov	DWORD PTR $T1[rsp], 2
	mov	DWORD PTR $T1[rsp+4], r11d
$LN116@decompress:

; 1191 : 				const int			colorEndpointDataStart = numPartitions == 1 ? 17 : 29;

	mov	edi, DWORD PTR tv2701[rsp]

; 1192 : 				ISEDecodedResult	colorEndpointData[18];
; 1193 : 				{
; 1194 : 					BitAccessStream dataStream(blockData, colorEndpointDataStart, numBitsAvailable, true);
; 1195 : 					decodeISE(&colorEndpointData[0], numColorEndpointValues, dataStream, iseParams);

	lea	r9, QWORD PTR $T1[rsp]

; 391  : 					: m_src(src)

	mov	r14, QWORD PTR blockData$GSCopy$1$[rbp-256]

; 1195 : 					decodeISE(&colorEndpointData[0], numColorEndpointValues, dataStream, iseParams);

	lea	r8, QWORD PTR dataStream$2[rbp-256]
	mov	eax, 29

; 391  : 					: m_src(src)

	mov	QWORD PTR dataStream$2[rbp-256], r14

; 1191 : 				const int			colorEndpointDataStart = numPartitions == 1 ? 17 : 29;

	mov	ecx, 17

; 394  : 					, m_forward(forward)

	mov	BYTE PTR dataStream$2[rbp-240], 1

; 1191 : 				const int			colorEndpointDataStart = numPartitions == 1 ? 17 : 29;

	test	edi, edi

; 395  : 					, m_ndx(0)

	mov	DWORD PTR dataStream$2[rbp-236], ebx

; 1195 : 					decodeISE(&colorEndpointData[0], numColorEndpointValues, dataStream, iseParams);

	mov	edx, esi
	cmove	eax, ecx
	lea	rcx, QWORD PTR colorEndpointData$6[rbp-256]

; 392  : 					, m_startNdxInSrc(startNdxInSrc)

	mov	DWORD PTR dataStream$2[rbp-248], eax

; 393  : 					, m_length(length)

	mov	eax, DWORD PTR numBitsForColorEndpoints$1$[rsp]
	mov	DWORD PTR dataStream$2[rbp-244], eax

; 1195 : 					decodeISE(&colorEndpointData[0], numColorEndpointValues, dataStream, iseParams);

	call	?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z ; basisu::astc::`anonymous namespace'::decodeISE

; 1196 : 				}
; 1197 : 				{
; 1198 : 					deUint32 unquantizedEndpoints[18];
; 1199 : 					unquantizeColorEndpoints(&unquantizedEndpoints[0], &colorEndpointData[0], numColorEndpointValues, iseParams);

	lea	r9, QWORD PTR $T1[rsp]
	mov	r8d, esi
	lea	rdx, QWORD PTR colorEndpointData$6[rbp-256]
	lea	rcx, QWORD PTR unquantizedEndpoints$4[rbp-256]
	call	?unquantizeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAIPEBUISEDecodedResult@123@HAEBUISEParams@123@@Z ; basisu::astc::`anonymous namespace'::unquantizeColorEndpoints

; 1200 : 					decodeColorEndpoints(dst, &unquantizedEndpoints[0], &endpointModes[0], numPartitions);

	lea	r15d, DWORD PTR [rdi+1]
	mov	r9d, r15d
	lea	r8, QWORD PTR colorEndpointModes$[rbp-256]
	lea	rdx, QWORD PTR unquantizedEndpoints$4[rbp-256]
	lea	rcx, QWORD PTR colorEndpoints$[rbp-256]
	call	?decodeColorEndpoints@?A0xc6621425@astc@basisu@@YAXPEAUColorEndpointPair@123@PEBI1H@Z ; basisu::astc::`anonymous namespace'::decodeColorEndpoints

; 274  : 				switch (iseParams.mode)

	mov	ecx, DWORD PTR blockMode$[rbp-244]
	mov	esi, -1
	mov	edi, DWORD PTR numValues$1$[rsp]
	test	ecx, ecx
	je	SHORT $LN194@decompress
	sub	ecx, 1
	je	SHORT $LN195@decompress
	cmp	ecx, 1
	je	SHORT $LN196@decompress

; 279  : 				default:
; 280  : 					DE_ASSERT(false);
; 281  : 					return -1;

	mov	ecx, esi
	jmp	SHORT $LN191@decompress
$LN196@decompress:

; 278  : 				case ISEMODE_PLAIN_BIT:		return numValues * iseParams.numBits;

	mov	ecx, DWORD PTR blockMode$[rbp-240]
	imul	ecx, edi
	jmp	SHORT $LN191@decompress
$LN195@decompress:

; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	imul	ecx, edi, 7

; 192  : 		return (a + b - 1) / b;

	mov	eax, -1431655765			; aaaaaaabH
	add	ecx, 2
	mul	ecx
	shr	edx, 1

; 277  : 				case ISEMODE_QUINT:			return deDivRoundUp32(numValues * 7, 3) + numValues * iseParams.numBits;

	jmp	SHORT $LN344@decompress
$LN194@decompress:

; 192  : 		return (a + b - 1) / b;

	lea	ecx, DWORD PTR [rdi*8+4]
	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 2
$LN344@decompress:

; 391  : 					: m_src(src)

	mov	ecx, DWORD PTR blockMode$[rbp-240]
	imul	ecx, edi
	add	ecx, edx
$LN191@decompress:

; 393  : 					, m_length(length)

	mov	DWORD PTR dataStream$3[rbp-244], ecx

; 1300 : 					decodeISE(&weightGrid[0], computeNumWeights(blockMode), dataStream, blockMode.weightISEParams);

	lea	r9, QWORD PTR blockMode$[rbp-244]
	lea	rcx, QWORD PTR weightGrid$7[rbp-256]

; 391  : 					: m_src(src)

	mov	QWORD PTR dataStream$3[rbp-256], r14

; 1300 : 					decodeISE(&weightGrid[0], computeNumWeights(blockMode), dataStream, blockMode.weightISEParams);

	lea	r8, QWORD PTR dataStream$3[rbp-256]

; 392  : 					, m_startNdxInSrc(startNdxInSrc)

	mov	DWORD PTR dataStream$3[rbp-248], 127	; 0000007fH

; 1300 : 					decodeISE(&weightGrid[0], computeNumWeights(blockMode), dataStream, blockMode.weightISEParams);

	mov	edx, edi

; 394  : 					, m_forward(forward)

	mov	BYTE PTR dataStream$3[rbp-240], 0

; 395  : 					, m_ndx(0)

	mov	DWORD PTR dataStream$3[rbp-236], ebx

; 1300 : 					decodeISE(&weightGrid[0], computeNumWeights(blockMode), dataStream, blockMode.weightISEParams);

	call	?decodeISE@?A0xc6621425@astc@basisu@@YAXPEAUISEDecodedResult@123@HAEAVBitAccessStream@123@AEBUISEParams@123@@Z ; basisu::astc::`anonymous namespace'::decodeISE

; 1301 : 				}
; 1302 : 				{
; 1303 : 					deUint32 unquantizedWeights[64];
; 1304 : 					unquantizeWeights(&unquantizedWeights[0], &weightGrid[0], blockMode);

	lea	r8, QWORD PTR blockMode$[rbp-256]
	lea	rdx, QWORD PTR weightGrid$7[rbp-256]
	lea	rcx, QWORD PTR unquantizedWeights$5[rbp-256]
	call	?unquantizeWeights@?A0xc6621425@astc@basisu@@YAXQEAIPEBUISEDecodedResult@123@AEBUASTCBlockMode@123@@Z ; basisu::astc::`anonymous namespace'::unquantizeWeights

; 1305 : 					interpolateWeights(dst, unquantizedWeights, blockWidth, blockHeight, blockMode);

	mov	ebx, DWORD PTR blockHeight$GSCopy$1$[rsp]
	lea	rax, QWORD PTR blockMode$[rbp-256]
	mov	edi, DWORD PTR blockWidth$GSCopy$1$[rbp-256]
	lea	rdx, QWORD PTR unquantizedWeights$5[rbp-256]
	mov	r9d, ebx
	mov	QWORD PTR [rsp+32], rax
	mov	r8d, edi
	lea	rcx, QWORD PTR texelWeights$[rbp-256]
	call	?interpolateWeights@?A0xc6621425@astc@basisu@@YAXPEAUTexelWeightPair@123@AEAY0EA@$$CBIHHAEBUASTCBlockMode@123@@Z ; basisu::astc::`anonymous namespace'::interpolateWeights

; 1505 : 				computeColorEndpoints(&colorEndpoints[0], blockData, &colorEndpointModes[0], numPartitions, numColorEndpointValues,
; 1506 : 					computeMaximumRangeISEParams(numBitsForColorEndpoints, numColorEndpointValues), numBitsForColorEndpoints);
; 1507 : 				// Compute texel weights.
; 1508 : 				TexelWeightPair texelWeights[MAX_BLOCK_WIDTH * MAX_BLOCK_HEIGHT];
; 1509 : 				computeTexelWeights(&texelWeights[0], blockData, blockWidth, blockHeight, blockMode);
; 1510 : 				// Set texel colors.
; 1511 : 				const int		ccs = blockMode.isDualPlane ? (int)blockData.getBits(extraCemBitsStart - 2, extraCemBitsStart - 1) : -1;

	cmp	BYTE PTR blockMode$[rbp-254], 0
	je	SHORT $LN21@decompress
	mov	eax, DWORD PTR extraCemBitsStart$1$[rsp]
	mov	rcx, r14
	lea	r8d, DWORD PTR [rax-1]
	lea	edx, DWORD PTR [rax-2]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
	mov	esi, eax
$LN21@decompress:

; 1512 : 				const deUint32	partitionIndexSeed = numPartitions > 1 ? blockData.getBits(13, 22) : (deUint32)-1;

	cmp	r15d, 1
	jle	SHORT $LN23@decompress
	mov	edx, 13
	mov	rcx, r14
	lea	r8d, QWORD PTR [rdx+9]
	call	?getBits@Block128@?A0xc6621425@astc@basisu@@QEBAIHH@Z ; basisu::astc::`anonymous namespace'::Block128::getBits
	jmp	SHORT $LN24@decompress
$LN23@decompress:
	mov	eax, -1					; ffffffffH
$LN24@decompress:

; 1513 : 				return setTexelColors(dst, &colorEndpoints[0], &texelWeights[0], ccs, partitionIndexSeed, numPartitions, blockWidth, blockHeight, isSRGB, isLDR, &colorEndpointModes[0]);

	lea	rcx, QWORD PTR colorEndpointModes$[rbp-256]
	mov	r9d, esi
	mov	QWORD PTR [rsp+80], rcx
	lea	r8, QWORD PTR texelWeights$[rbp-256]
	mov	rcx, QWORD PTR dst$GSCopy$1$[rbp-256]
	lea	rdx, QWORD PTR colorEndpoints$[rbp-256]
	mov	DWORD PTR [rsp+56], ebx
	mov	DWORD PTR [rsp+48], edi
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], eax
	call	?setTexelColors@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXPEAUColorEndpointPair@123@PEAUTexelWeightPair@123@HIHHH_N3PEBI@Z ; basisu::astc::`anonymous namespace'::setTexelColors
	jmp	$LN1@decompress
$LN7@decompress:

; 561  : 				if (isSRGB)

	mov	edi, DWORD PTR blockWidth$GSCopy$1$[rbp-256]
	imul	edi, DWORD PTR blockHeight$GSCopy$1$[rsp]

; 562  : 				{
; 563  : 					deUint8* const dstU = (deUint8*)dst;
; 564  : 					for (int i = 0; i < blockWidth * blockHeight; i++)
; 565  : 					{
; 566  : 						dstU[4 * i + 0] = 0xff;
; 567  : 						dstU[4 * i + 1] = 0;
; 568  : 						dstU[4 * i + 2] = 0xff;
; 569  : 						dstU[4 * i + 3] = 0xff;
; 570  : 					}
; 571  : 				}
; 572  : 				else
; 573  : 				{
; 574  : 					float* const dstF = (float*)dst;
; 575  : 					for (int i = 0; i < blockWidth * blockHeight; i++)

	movsxd	rcx, edi
	test	edi, edi
	jle	SHORT $LN54@decompress
	mov	rax, QWORD PTR dst$GSCopy$1$[rbp-256]
	add	rax, 8
	npad	10
$LL96@decompress:

; 576  : 					{
; 577  : 						dstF[4 * i + 0] = 1.0f;

	mov	QWORD PTR [rax-8], 1065353216		; 3f800000H

; 578  : 						dstF[4 * i + 1] = 0.0f;
; 579  : 						dstF[4 * i + 2] = 1.0f;

	mov	DWORD PTR [rax], 1065353216		; 3f800000H

; 580  : 						dstF[4 * i + 3] = 1.0f;

	mov	DWORD PTR [rax+4], 1065353216		; 3f800000H
	lea	rax, QWORD PTR [rax+16]
	sub	rcx, 1
	jne	SHORT $LL96@decompress
	jmp	SHORT $LN54@decompress
$LN296@decompress:

; 1472 : 				// Check for errors in weight grid, partition and dual-plane parameters.
; 1473 : 				if (numWeights > 64 ||
; 1474 : 					numWeightDataBits > 96 ||
; 1475 : 					numWeightDataBits < 24 ||
; 1476 : 					blockMode.weightGridWidth > blockWidth ||
; 1477 : 					blockMode.weightGridHeight > blockHeight ||

	mov	eax, DWORD PTR blockHeight$GSCopy$1$[rsp]
$LN5@decompress:

; 561  : 				if (isSRGB)

	imul	r13d, eax

; 562  : 				{
; 563  : 					deUint8* const dstU = (deUint8*)dst;
; 564  : 					for (int i = 0; i < blockWidth * blockHeight; i++)
; 565  : 					{
; 566  : 						dstU[4 * i + 0] = 0xff;
; 567  : 						dstU[4 * i + 1] = 0;
; 568  : 						dstU[4 * i + 2] = 0xff;
; 569  : 						dstU[4 * i + 3] = 0xff;
; 570  : 					}
; 571  : 				}
; 572  : 				else
; 573  : 				{
; 574  : 					float* const dstF = (float*)dst;
; 575  : 					for (int i = 0; i < blockWidth * blockHeight; i++)

	movsxd	rdx, r13d
	test	r13d, r13d
	jle	SHORT $LN54@decompress
	mov	rcx, QWORD PTR dst$GSCopy$1$[rbp-256]
	add	rcx, 8
	npad	7
$LL55@decompress:

; 576  : 					{
; 577  : 						dstF[4 * i + 0] = 1.0f;

	mov	QWORD PTR [rcx-8], 1065353216		; 3f800000H

; 578  : 						dstF[4 * i + 1] = 0.0f;
; 579  : 						dstF[4 * i + 2] = 1.0f;

	mov	DWORD PTR [rcx], 1065353216		; 3f800000H

; 580  : 						dstF[4 * i + 3] = 1.0f;

	mov	DWORD PTR [rcx+4], 1065353216		; 3f800000H
	lea	rcx, QWORD PTR [rcx+16]
	sub	rdx, 1
	jne	SHORT $LL55@decompress
$LN54@decompress:

; 1478 : 					(numPartitions == 4 && blockMode.isDualPlane))
; 1479 : 				{
; 1480 : 					setASTCErrorColorBlock(dst, blockWidth, blockHeight, isSRGB);
; 1481 : 					return DECOMPRESS_RESULT_ERROR;

	mov	eax, 1
$LN1@decompress:

; 1514 : 			}

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 2632				; 00000a48H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?decompressBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z ENDP ; basisu::astc::`anonymous namespace'::decompressBlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ?decompress@astc@basisu@@YA_NPEAEPEBE_NHH@Z
_TEXT	SEGMENT
blockData$ = 48
linear$ = 64
__$ArrayPad$ = 2368
pDst$ = 2400
data$ = 2408
isSRGB$dead$ = 2416
blockWidth$ = 2424
blockHeight$ = 2432
?decompress@astc@basisu@@YA_NPEAEPEBE_NHH@Z PROC	; basisu::astc::decompress, COMDAT

; 1519 : 		{

$LN74:
	mov	QWORD PTR [rsp+16], rbx
	push	rsi
	sub	rsp, 2384				; 00000950H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	lea	r10, QWORD PTR blockData$[rsp]
	mov	esi, r9d
	sub	r10, rdx
	lea	r8, QWORD PTR [rdx+6]
	mov	edx, 2
	mov	rbx, rcx
	npad	10
$LL16@decompress:

; 351  : 							m_words[wordNdx] |= (Word)src[wordNdx * WORD_BYTES + byteNdx] << (8 * byteNdx);

	movzx	eax, BYTE PTR [r8]
	movzx	ecx, BYTE PTR [r8+1]
	lea	r8, QWORD PTR [r8+8]
	shl	rcx, 8
	or	rcx, rax
	movzx	eax, BYTE PTR [r8-9]
	shl	rcx, 8
	or	rcx, rax
	movzx	eax, BYTE PTR [r8-10]
	shl	rcx, 8
	or	rcx, rax
	movzx	eax, BYTE PTR [r8-11]
	shl	rcx, 8
	or	rcx, rax
	movzx	eax, BYTE PTR [r8-12]
	shl	rcx, 8
	or	rcx, rax
	movzx	eax, BYTE PTR [r8-13]
	shl	rcx, 8
	or	rcx, rax
	movzx	eax, BYTE PTR [r8-14]
	shl	rcx, 8
	or	rcx, rax
	mov	QWORD PTR [r10+r8-14], rcx
	sub	rdx, 1
	jne	SHORT $LL16@decompress

; 1520 : 			// rg - We only support LDR here, although adding back in HDR would be easy.
; 1521 : 			const bool isLDR = true;
; 1522 : 			DE_ASSERT(isLDR || !isSRGB);
; 1523 : 
; 1524 : 			float linear[MAX_BLOCK_WIDTH * MAX_BLOCK_HEIGHT * 4];
; 1525 : 
; 1526 : 			const Block128 blockData(data);
; 1527 : 			if (decompressBlock(isSRGB ? (void*)pDst : (void*)&linear[0],
; 1528 : 				blockData, blockWidth, blockHeight, isSRGB, isLDR) != DECOMPRESS_RESULT_VALID_BLOCK)

	mov	r9d, DWORD PTR blockHeight$[rsp]
	lea	rdx, QWORD PTR blockData$[rsp]
	mov	r8d, esi
	lea	rcx, QWORD PTR linear$[rsp]
	call	?decompressBlock@?A0xc6621425@astc@basisu@@YA?AW4DecompressResult@123@PEAXAEBVBlock128@123@HH_N2@Z ; basisu::astc::`anonymous namespace'::decompressBlock
	test	eax, eax
	je	SHORT $LN64@decompress

; 1529 : 				return false;

	xor	al, al
	jmp	$LN1@decompress
$LN64@decompress:

; 1530 : 
; 1531 : 			if (!isSRGB)
; 1532 : 			{
; 1533 : 				int pix = 0;
; 1534 : 				for (int i = 0; i < blockHeight; i++)

	cmp	DWORD PTR blockHeight$[rsp], 0
	jle	$LN3@decompress
	mov	r10d, DWORD PTR blockHeight$[rsp]
	xor	ecx, ecx
	movss	xmm1, DWORD PTR __real@47800000
	mov	r11d, 65535				; 0000ffffH
	movss	xmm2, DWORD PTR __real@3f000000
	npad	6
$LL4@decompress:

; 1535 : 				{
; 1536 : 					for (int j = 0; j < blockWidth; j++, pix++)

	test	esi, esi
	jle	$LN2@decompress
	mov	rax, rcx
	lea	r8, QWORD PTR linear$[rsp]
	shl	rax, 4
	lea	rdx, QWORD PTR linear$[rsp+8]
	add	r8, rax
	mov	r9, rsi
	add	rdx, rax
$LL7@decompress:

; 1537 : 					{
; 1538 : 						pDst[4 * pix + 0] = (uint8_t)(basisu::clamp<int>((int)(linear[pix * 4 + 0] * 65536.0f + .5f), 0, 65535) >> 8);

	movss	xmm0, DWORD PTR [r8]
	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	cvttss2si eax, xmm0

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN22@decompress

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN24@decompress
$LN22@decompress:

; 82   : 		else if (a > h)

	cmp	eax, r11d
	cmovg	eax, r11d
$LN24@decompress:

; 1539 : 						pDst[4 * pix + 1] = (uint8_t)(basisu::clamp<int>((int)(linear[pix * 4 + 1] * 65536.0f + .5f), 0, 65535) >> 8);

	movss	xmm0, DWORD PTR [rdx-4]
	sar	eax, 8
	mulss	xmm0, xmm1
	mov	BYTE PTR [rbx+rcx*4], al
	addss	xmm0, xmm2
	cvttss2si eax, xmm0

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN27@decompress

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN29@decompress
$LN27@decompress:

; 82   : 		else if (a > h)

	cmp	eax, r11d
	cmovg	eax, r11d
$LN29@decompress:

; 1540 : 						pDst[4 * pix + 2] = (uint8_t)(basisu::clamp<int>((int)(linear[pix * 4 + 2] * 65536.0f + .5f), 0, 65535) >> 8);

	movss	xmm0, DWORD PTR [rdx]
	sar	eax, 8
	mulss	xmm0, xmm1
	mov	BYTE PTR [rbx+rcx*4+1], al
	addss	xmm0, xmm2
	cvttss2si eax, xmm0

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN32@decompress

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN34@decompress
$LN32@decompress:

; 82   : 		else if (a > h)

	cmp	eax, r11d
	cmovg	eax, r11d
$LN34@decompress:

; 1541 : 						pDst[4 * pix + 3] = (uint8_t)(basisu::clamp<int>((int)(linear[pix * 4 + 3] * 65536.0f + .5f), 0, 65535) >> 8);

	movss	xmm0, DWORD PTR [rdx+4]
	sar	eax, 8
	mulss	xmm0, xmm1
	mov	BYTE PTR [rbx+rcx*4+2], al
	addss	xmm0, xmm2
	cvttss2si eax, xmm0

; 80   : 		if (a < l)

	test	eax, eax
	jns	SHORT $LN37@decompress

; 81   : 			return l;

	xor	eax, eax
	jmp	SHORT $LN39@decompress
$LN37@decompress:

; 82   : 		else if (a > h)

	cmp	eax, r11d
	cmovg	eax, r11d
$LN39@decompress:

; 1541 : 						pDst[4 * pix + 3] = (uint8_t)(basisu::clamp<int>((int)(linear[pix * 4 + 3] * 65536.0f + .5f), 0, 65535) >> 8);

	sar	eax, 8
	add	r8, 16
	mov	BYTE PTR [rbx+rcx*4+3], al
	add	rdx, 16
	inc	rcx
	sub	r9, 1
	jne	$LL7@decompress
$LN2@decompress:

; 1530 : 
; 1531 : 			if (!isSRGB)
; 1532 : 			{
; 1533 : 				int pix = 0;
; 1534 : 				for (int i = 0; i < blockHeight; i++)

	sub	r10, 1
	jne	$LL4@decompress
$LN3@decompress:

; 1542 : 					}
; 1543 : 				}
; 1544 : 			}
; 1545 : 
; 1546 : 			return true;

	mov	al, 1
$LN1@decompress:

; 1547 : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+2408]
	add	rsp, 2384				; 00000950H
	pop	rsi
	ret	0
?decompress@astc@basisu@@YA_NPEAEPEBE_NHH@Z ENDP	; basisu::astc::decompress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??0ColorEndpointPair@?A0xc6621425@astc@basisu@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ColorEndpointPair@?A0xc6621425@astc@basisu@@QEAA@XZ PROC ; basisu::astc::`anonymous namespace'::ColorEndpointPair::ColorEndpointPair, COMDAT

; 93   : 			m_c[0] = 0;

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0ColorEndpointPair@?A0xc6621425@astc@basisu@@QEAA@XZ ENDP ; basisu::astc::`anonymous namespace'::ColorEndpointPair::ColorEndpointPair
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
__t$ = 48
__s$ = 56
__n$ = 64
__f$ = 72
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN12:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r9
	mov	rdi, r8
	mov	rbp, rdx
	mov	rbx, rcx
$LL2@vector:
	mov	rcx, rbx
	call	rsi
	add	rbx, rbp
	sub	rdi, 1
	jne	SHORT $LL2@vector
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$max@H@std@@YAAEBHAEBH0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$max@H@std@@YAAEBHAEBH0@Z PROC			; std::max<int>, COMDAT

; 46   :     // return larger of _Left and _Right
; 47   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	cmovl	rcx, rdx
	mov	rax, rcx

; 48   : }

	ret	0
??$max@H@std@@YAAEBHAEBH0@Z ENDP			; std::max<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??$max@H@basisu@@YAHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$max@H@basisu@@YAHHH@Z PROC				; basisu::max<int>, COMDAT

; 68   : 		return (a > b) ? a : b;

	cmp	ecx, edx
	cmovg	edx, ecx
	mov	eax, edx

; 69   : 	}

	ret	0
??$max@H@basisu@@YAHHH@Z ENDP				; basisu::max<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??$min@H@basisu@@YAHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$min@H@basisu@@YAHHH@Z PROC				; basisu::min<int>, COMDAT

; 74   : 		return (a < b) ? a : b;

	cmp	ecx, edx
	cmovl	edx, ecx
	mov	eax, edx

; 75   : 	}

	ret	0
??$min@H@basisu@@YAHHH@Z ENDP				; basisu::min<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??$clamp@H@basisu@@YAHHHH@Z
_TEXT	SEGMENT
a$ = 8
l$dead$ = 16
h$ = 24
??$clamp@H@basisu@@YAHHHH@Z PROC			; basisu::clamp<int>, COMDAT

; 80   : 		if (a < l)

	test	ecx, ecx
	jns	SHORT $LN2@clamp

; 81   : 			return l;

	xor	eax, eax

; 83   : 			return h;
; 84   : 		return a;
; 85   : 	}

	ret	0
$LN2@clamp:

; 82   : 		else if (a > h)

	cmp	ecx, r8d
	cmovg	ecx, r8d
	mov	eax, ecx

; 83   : 			return h;
; 84   : 		return a;
; 85   : 	}

	ret	0
??$clamp@H@basisu@@YAHHHH@Z ENDP			; basisu::clamp<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$swap@H$0A@@std@@YAXAEAH0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@H$0A@@std@@YAXAEAH0@Z PROC			; std::swap<int,0>, COMDAT

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	r8d, DWORD PTR [rcx]

; 100  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 101  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [rdx], r8d

; 102  : }

	ret	0
??$swap@H$0A@@std@@YAXAEAH0@Z ENDP			; std::swap<int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$swap@I$0A@@std@@YAXAEAI0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@I$0A@@std@@YAXAEAI0@Z PROC			; std::swap<unsigned int,0>, COMDAT

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	r8d, DWORD PTR [rcx]

; 100  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 101  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [rdx], r8d

; 102  : }

	ret	0
??$swap@I$0A@@std@@YAXAEAI0@Z ENDP			; std::swap<unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\astc_decomp.cpp
;	COMDAT ??$min@I@basisu@@YAIII@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$min@I@basisu@@YAIII@Z PROC				; basisu::min<unsigned int>, COMDAT

; 74   : 		return (a < b) ? a : b;

	cmp	ecx, edx
	cmovb	edx, ecx
	mov	eax, edx

; 75   : 	}

	ret	0
??$min@I@basisu@@YAIII@Z ENDP				; basisu::min<unsigned int>
_TEXT	ENDS
END
