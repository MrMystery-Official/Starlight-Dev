; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BI@LLANGCPM@Unknown?5texture?5format?5@	; `string'
PUBLIC	??_C@_0O@PMEMKMJ@TegraSwizzler@			; `string'
;	COMDAT ??_C@_0O@PMEMKMJ@TegraSwizzler@
CONST	SEGMENT
??_C@_0O@PMEMKMJ@TegraSwizzler@ DB 'TegraSwizzler', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LLANGCPM@Unknown?5texture?5format?5@
CONST	SEGMENT
??_C@_0BI@LLANGCPM@Unknown?5texture?5format?5@ DB 'Unknown texture format'
	DB	' ', 00H					; `string'
?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B DD 08H	; Formats
	DD	04H
	DD	04H
	ORG $+4
	DQ	FLAT:?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
	DD	010H
	DD	04H
	DD	04H
	ORG $+4
	DQ	FLAT:?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
	DD	08H
	DD	04H
	DD	04H
	ORG $+4
	DQ	FLAT:?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
	DD	010H
	DD	08H
	DD	08H
	ORG $+4
	DQ	FLAT:?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
	DD	010H
	DD	04H
	DD	04H
	ORG $+4
	DQ	FLAT:?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
PUBLIC	??$_Refancy@PEAE$0A@@std@@YAPEAEPEAE@Z		; std::_Refancy<unsigned char *,0>
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>
PUBLIC	??$_Copy_unchecked@PEAEPEAEPEAE@std@@YAPEAEPEAE00@Z ; std::_Copy_unchecked<unsigned char *,unsigned char *,unsigned char *>
PUBLIC	??$log10@H$0A@@@YANH@Z				; log10<int,0>
PUBLIC	??$log10@I$0A@@@YANI@Z				; log10<unsigned int,0>
PUBLIC	??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &,__int64>
PUBLIC	??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V10@00@Z ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator+=
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator+=
PUBLIC	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAX_K@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::__autoclassinit2
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator+
PUBLIC	?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z ; TegraSwizzle::GetDirectImageData
PUBLIC	?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z ; TegraSwizzle::GetDirectImageData
PUBLIC	?Deswizzle@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@IIIIIIHIIHAEAV23@@Z ; TegraSwizzle::Deswizzle
PUBLIC	?GetAddrBlockLinear@TegraSwizzle@@YAIIIIIII@Z	; TegraSwizzle::GetAddrBlockLinear
PUBLIC	?GetBlockHeight@TegraSwizzle@@YAII@Z		; TegraSwizzle::GetBlockHeight
PUBLIC	?RoundUp@TegraSwizzle@@YAIII@Z			; TegraSwizzle::RoundUp
PUBLIC	?Pow2RoundUp@TegraSwizzle@@YAII@Z		; TegraSwizzle::Pow2RoundUp
PUBLIC	?DIV_ROUND_UP@TegraSwizzle@@YAIII@Z		; TegraSwizzle::DIV_ROUND_UP
PUBLIC	?Max@TegraSwizzle@@YAIII@Z			; TegraSwizzle::Max
PUBLIC	?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z ; TegraSwizzle::GetFormatInfo
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_unchecked@PEAEPEAEPEAE@std@@YAPEAEPEAE00@Z DD imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$??$_Copy_unchecked@PEAEPEAEPEAE@std@@YAPEAEPEAE00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V10@00@Z DD imagerel $LN20
	DD	imagerel $LN20+64
	DD	imagerel $unwind$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V10@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z DD imagerel $LN282
	DD	imagerel $LN282+845
	DD	imagerel $unwind$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z DD imagerel $LN49
	DD	imagerel $LN49+354
	DD	imagerel $unwind$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Deswizzle@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@IIIIIIHIIHAEAV23@@Z DD imagerel $LN171
	DD	imagerel $LN171+544
	DD	imagerel $unwind$?Deswizzle@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@IIIIIIHIIHAEAV23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetAddrBlockLinear@TegraSwizzle@@YAIIIIIII@Z DD imagerel $LN6
	DD	imagerel $LN6+130
	DD	imagerel $unwind$?GetAddrBlockLinear@TegraSwizzle@@YAIIIIIII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z DD imagerel $LN108
	DD	imagerel $LN108+446
	DD	imagerel $unwind$?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z DB 08H
	DB	0cdH, 02H
	DB	00H
	DB	','
	DB	02H
	DB	0b6H
	DB	04H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z
	DD	imagerel $ip2state$?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z DD 071211H
	DD	0166412H
	DD	0143412H
	DD	0120112H
	DD	0700bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetAddrBlockLinear@TegraSwizzle@@YAIIIIIII@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Deswizzle@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@IIIIIIHIIHAEAV23@@Z DD 0aa701H
	DD	01334a7H
	DD	0f00c7210H
	DD	0d008e00aH
	DD	07004c006H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z DB 04H
	DB	01H, 03H
	DB	02H
	DB	'\'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z
	DD	imagerel $ip2state$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z DD 0b2c19H
	DD	09681aH
	DD	0140112H
	DD	0e009f00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z
	DD	082H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z DB 0eH
	DB	0f9H, 02H
	DB	02H
	DB	','
	DB	04H
	DB	0aeH
	DB	06H
	DB	01aH
	DB	04H
	DB	0e1H, 05H
	DB	02H
	DB	'n'
	DB	08H
	DB	09aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z DB 08H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	061H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	02H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	0aaH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	081H
	DB	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z
	DD	imagerel $ip2state$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z DD 0a2719H
	DD	0210119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z
	DD	0faH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V10@00@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_unchecked@PEAEPEAEPEAE@std@@YAPEAEPEAE00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
;	COMDAT ?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 72
$T4 = 112
__$ReturnAddress$ = 160
FormatId$ = 168
?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z PROC	; TegraSwizzle::GetFormatInfo, COMDAT

; 16   : {

$LN108:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rbx, rcx
	xor	esi, esi

; 17   : 	switch (FormatId)

	movzx	edx, dx
	cmp	edx, 1285				; 00000505H
	ja	SHORT $LN12@GetFormatI
	je	SHORT $LN6@GetFormatI
	cmp	edx, 257				; 00000101H
	je	SHORT $LN9@GetFormatI
	lea	eax, DWORD PTR [rdx-514]
	test	eax, -257				; fffffeffH
	jne	SHORT $LN10@GetFormatI

; 18   : 	{
; 19   : 	case 0x202:
; 20   : 	case 0x302:
; 21   : 		return Formats.BC1_UNORM;

	movaps	xmm0, XMMWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B
	movups	XMMWORD PTR [rcx], xmm0
	movsd	xmm0, QWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+16
	movsd	QWORD PTR [rcx+16], xmm0
	jmp	$LN104@GetFormatI
$LN9@GetFormatI:

; 27   : 	case 0x101:
; 28   : 		return Formats.ASTC_8x8_UNORM;

	movups	xmm0, XMMWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+72
	movups	XMMWORD PTR [rcx], xmm0
	movsd	xmm0, QWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+88
	movsd	QWORD PTR [rcx+16], xmm0
	jmp	$LN104@GetFormatI
$LN6@GetFormatI:

; 22   : 	case 0x505:
; 23   : 		return Formats.BC3_UNORM_SRGB;

	movups	xmm0, XMMWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+24
	movups	XMMWORD PTR [rcx], xmm0
	movsd	xmm0, QWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+40
	movsd	QWORD PTR [rcx+16], xmm0
	jmp	$LN104@GetFormatI
$LN12@GetFormatI:

; 17   : 	switch (FormatId)

	mov	ecx, edx
	sub	ecx, 1538				; 00000602H
	je	$LN7@GetFormatI
	cmp	ecx, 4
	je	$LN7@GetFormatI
$LN10@GetFormatI:

; 30   : 		Logger::Warning("TegraSwizzler", "Unknown texture format " + std::to_string(FormatId));

	lea	rdi, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T1[rsp], rdi
	lea	rcx, QWORD PTR $T4[rsp]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 23
	lea	r8, OFFSET FLAT:??_C@_0BI@LLANGCPM@Unknown?5texture?5format?5@
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rsp+16], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rsp+24], rsi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T2[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T2[rsp+16], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 30   : 		Logger::Warning("TegraSwizzler", "Unknown texture format " + std::to_string(FormatId));

	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T3[rsp+16], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rsp+24], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 13
	lea	rdx, OFFSET FLAT:??_C@_0O@PMEMKMJ@TegraSwizzler@
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 30   : 		Logger::Warning("TegraSwizzler", "Unknown texture format " + std::to_string(FormatId));

	mov	rdx, rdi
	lea	rcx, QWORD PTR $T3[rsp]
	call	?Warning@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Warning
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T4[rsp+24]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN78@GetFormatI

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T4[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN90@GetFormatI

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN90@GetFormatI
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN90@GetFormatI:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN78@GetFormatI:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 31   : 		return Formats.UNSUPPORTED;

	movups	xmm0, XMMWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+120
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+136
	jmp	SHORT $LN105@GetFormatI
$LN7@GetFormatI:

; 24   : 	case 0x606:
; 25   : 	case 0x602:
; 26   : 		return Formats.BC4_UNORM;

	movaps	xmm0, XMMWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+48
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+64
$LN105@GetFormatI:

; 32   : 	}
; 33   : }

	movsd	QWORD PTR [rbx+16], xmm0
$LN104@GetFormatI:
	mov	rax, rbx
	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
$LN103@GetFormatI:
?GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z ENDP	; TegraSwizzle::GetFormatInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 72
$T4 = 112
__$ReturnAddress$ = 160
FormatId$ = 168
?dtor$0@?0??GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z@4HA PROC ; `TegraSwizzle::GetFormatInfo'::`1'::dtor$0
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z@4HA ENDP ; `TegraSwizzle::GetFormatInfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 72
$T4 = 112
__$ReturnAddress$ = 160
FormatId$ = 168
?dtor$1@?0??GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z@4HA PROC ; `TegraSwizzle::GetFormatInfo'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??GetFormatInfo@TegraSwizzle@@YA?AUFormatInfo@1@G@Z@4HA ENDP ; `TegraSwizzle::GetFormatInfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
;	COMDAT ?Max@TegraSwizzle@@YAIII@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?Max@TegraSwizzle@@YAIII@Z PROC				; TegraSwizzle::Max, COMDAT

; 37   : 	return a < b ? b : a;

	cmp	ecx, edx
	cmovb	ecx, edx
	mov	eax, ecx

; 38   : }

	ret	0
?Max@TegraSwizzle@@YAIII@Z ENDP				; TegraSwizzle::Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
;	COMDAT ?DIV_ROUND_UP@TegraSwizzle@@YAIII@Z
_TEXT	SEGMENT
n$ = 8
d$ = 16
?DIV_ROUND_UP@TegraSwizzle@@YAIII@Z PROC		; TegraSwizzle::DIV_ROUND_UP, COMDAT

; 42   : 	return (n + d - 1) / d;

	lea	eax, DWORD PTR [rdx-1]
	mov	r8d, edx
	add	eax, ecx
	xor	edx, edx
	div	r8d

; 43   : }

	ret	0
?DIV_ROUND_UP@TegraSwizzle@@YAIII@Z ENDP		; TegraSwizzle::DIV_ROUND_UP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
;	COMDAT ?Pow2RoundUp@TegraSwizzle@@YAII@Z
_TEXT	SEGMENT
x$ = 8
?Pow2RoundUp@TegraSwizzle@@YAII@Z PROC			; TegraSwizzle::Pow2RoundUp, COMDAT

; 47   : 	x -= 1;

	dec	ecx

; 48   : 	x |= x >> 1;

	mov	eax, ecx
	shr	eax, 1
	or	ecx, eax

; 49   : 	x |= x >> 2;

	mov	eax, ecx
	shr	eax, 2
	or	ecx, eax

; 50   : 	x |= x >> 4;

	mov	eax, ecx
	shr	eax, 4
	or	ecx, eax

; 51   : 	x |= x >> 8;

	mov	eax, ecx
	shr	eax, 8
	or	ecx, eax

; 52   : 	x |= x >> 16;

	mov	eax, ecx
	shr	eax, 16
	or	eax, ecx

; 53   : 	return x + 1;

	inc	eax

; 54   : }

	ret	0
?Pow2RoundUp@TegraSwizzle@@YAII@Z ENDP			; TegraSwizzle::Pow2RoundUp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
;	COMDAT ?RoundUp@TegraSwizzle@@YAIII@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
?RoundUp@TegraSwizzle@@YAIII@Z PROC			; TegraSwizzle::RoundUp, COMDAT

; 58   : 	return ((x - 1) | (y - 1)) + 1;

	lea	eax, DWORD PTR [rcx-1]
	lea	ecx, DWORD PTR [rdx-1]
	or	eax, ecx
	inc	eax

; 59   : }

	ret	0
?RoundUp@TegraSwizzle@@YAIII@Z ENDP			; TegraSwizzle::RoundUp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
;	COMDAT ?GetBlockHeight@TegraSwizzle@@YAII@Z
_TEXT	SEGMENT
Height$ = 8
?GetBlockHeight@TegraSwizzle@@YAII@Z PROC		; TegraSwizzle::GetBlockHeight, COMDAT

; 63   : 	uint32_t BlockHeight = Pow2RoundUp(Height / 8);

	shr	ecx, 3

; 47   : 	x -= 1;

	dec	ecx

; 48   : 	x |= x >> 1;

	mov	eax, ecx
	shr	eax, 1
	or	ecx, eax

; 49   : 	x |= x >> 2;

	mov	eax, ecx
	shr	eax, 2
	or	ecx, eax

; 50   : 	x |= x >> 4;

	mov	eax, ecx
	shr	eax, 4
	or	ecx, eax

; 51   : 	x |= x >> 8;

	mov	eax, ecx
	shr	eax, 8
	or	ecx, eax

; 52   : 	x |= x >> 16;

	mov	eax, ecx
	shr	eax, 16
	or	eax, ecx

; 64   : 	if (BlockHeight > 16)

	mov	ecx, 16

; 53   : 	return x + 1;

	inc	eax

; 64   : 	if (BlockHeight > 16)

	cmp	eax, ecx
	cmova	eax, ecx

; 65   : 		BlockHeight = 16;
; 66   : 
; 67   : 	return BlockHeight;
; 68   : }

	ret	0
?GetBlockHeight@TegraSwizzle@@YAII@Z ENDP		; TegraSwizzle::GetBlockHeight
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
;	COMDAT ?GetAddrBlockLinear@TegraSwizzle@@YAIIIIIII@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
Width$ = 24
BytesPerPixel$ = 32
BaseAddress$dead$ = 40
BlockHeight$ = 48
?GetAddrBlockLinear@TegraSwizzle@@YAIIIIIII@Z PROC	; TegraSwizzle::GetAddrBlockLinear, COMDAT

; 71   : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 72   : 	uint32_t ImageWidthInGobs = DIV_ROUND_UP(Width * BytesPerPixel, 64);
; 73   : 	uint32_t GOBAddress = (BaseAddress

	mov	r11d, DWORD PTR BlockHeight$[rsp]
	mov	ebx, edx
	imul	r8d, r9d
	xor	edx, edx
	mov	eax, ebx
	mov	edi, ecx
	imul	edi, r9d
	lea	r10d, DWORD PTR [r11*8]
	div	r10d

; 42   : 	return (n + d - 1) / d;

	add	r8d, 63					; 0000003fH
	shr	r8d, 6

; 72   : 	uint32_t ImageWidthInGobs = DIV_ROUND_UP(Width * BytesPerPixel, 64);
; 73   : 	uint32_t GOBAddress = (BaseAddress

	imul	r8d, eax
	mov	eax, edi
	shr	eax, 6
	shr	edx, 3
	add	r8d, eax

; 74   : 		+ (y / (8 * BlockHeight)) * 512 * BlockHeight * ImageWidthInGobs
; 75   : 		+ (x * BytesPerPixel / 64) * 512 * BlockHeight
; 76   : 		+ (y % (8 * BlockHeight) / 8) * 512);
; 77   : 
; 78   : 	x *= BytesPerPixel;
; 79   : 
; 80   : 	/* What the fuck is this...? */
; 81   : 	uint32_t Address = (GOBAddress + ((x % 64) / 32) * 256 + ((y % 8) / 2) * 64

	mov	eax, edi
	shr	eax, 5
	and	eax, 1
	imul	r8d, r11d
	add	r8d, edx
	lea	ecx, DWORD PTR [rax+r8*2]
	mov	eax, ebx
	shr	eax, 1
	and	ebx, 1
	and	eax, 3
	lea	edx, DWORD PTR [rax+rcx*4]
	mov	eax, edi
	shr	eax, 4
	and	edi, 15
	and	eax, 1
	lea	eax, DWORD PTR [rax+rdx*2]
	lea	eax, DWORD PTR [rbx+rax*2]

; 82   : 		+ ((x % 32) / 16) * 32 + (y % 2) * 16 + (x % 16));
; 83   : 
; 84   : 	return Address;
; 85   : }

	mov	rbx, QWORD PTR [rsp+8]
	shl	eax, 4
	add	eax, edi
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
?GetAddrBlockLinear@TegraSwizzle@@YAIIIIIII@Z ENDP	; TegraSwizzle::GetAddrBlockLinear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
;	COMDAT ?Deswizzle@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@IIIIIIHIIHAEAV23@@Z
_TEXT	SEGMENT
BlockHeight$1$ = 32
Pitch$1$ = 36
Height$GSCopy$2$ = 40
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 128
Width$ = 136
Height$ = 144
Depth$dead$ = 152
BlockWidth$ = 160
FormatBlockHeight$ = 168
BlockDepth$dead$ = 176
RoundPitch$dead$ = 184
BytesPerPixel$ = 192
TileMode$ = 200
SizeRange$ = 208
ImageData$ = 216
?Deswizzle@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@IIIIIIHIIHAEAV23@@Z PROC ; TegraSwizzle::Deswizzle, COMDAT

; 88   : {

$LN171:
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	edi, DWORD PTR BytesPerPixel$[rsp]

; 42   : 	return (n + d - 1) / d;

	lea	eax, DWORD PTR [rdx-1]
	add	eax, DWORD PTR BlockWidth$[rsp]
	xor	edx, edx
	div	DWORD PTR BlockWidth$[rsp]

; 88   : {

	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	r13, rcx

; 89   : 	uint32_t BlockHeight = (uint32_t)(1 << SizeRange);

	mov	ecx, DWORD PTR SizeRange$[rsp]

; 42   : 	return (n + d - 1) / d;

	mov	ebp, eax
	xor	edx, edx

; 89   : 	uint32_t BlockHeight = (uint32_t)(1 << SizeRange);

	mov	r9d, 1
	shl	r9d, cl

; 90   : 	Width = DIV_ROUND_UP(Width, BlockWidth);
; 91   : 	Height = DIV_ROUND_UP(Height, FormatBlockHeight);

	mov	r10d, edi

; 42   : 	return (n + d - 1) / d;

	mov	ecx, DWORD PTR FormatBlockHeight$[rsp]

; 90   : 	Width = DIV_ROUND_UP(Width, BlockWidth);
; 91   : 	Height = DIV_ROUND_UP(Height, FormatBlockHeight);

	imul	r10d, ebp
	mov	DWORD PTR BlockHeight$1$[rsp], r9d

; 42   : 	return (n + d - 1) / d;

	lea	eax, DWORD PTR [rcx-1]
	add	eax, r8d
	div	ecx

; 92   : 	Depth = DIV_ROUND_UP(Depth, BlockDepth);
; 93   : 
; 94   : 	uint32_t Pitch = 0;
; 95   : 	uint32_t SurfaceSize = 0;
; 96   : 	if (TileMode == 1)

	mov	ecx, DWORD PTR TileMode$[rsp]
	lea	r15d, DWORD PTR [r10-1]

; 42   : 	return (n + d - 1) / d;

	mov	DWORD PTR Height$GSCopy$2$[rsp], eax
	mov	r14d, eax

; 90   : 	Width = DIV_ROUND_UP(Width, BlockWidth);
; 91   : 	Height = DIV_ROUND_UP(Height, FormatBlockHeight);

	mov	DWORD PTR Pitch$1$[rsp], r10d

; 92   : 	Depth = DIV_ROUND_UP(Depth, BlockDepth);
; 93   : 
; 94   : 	uint32_t Pitch = 0;
; 95   : 	uint32_t SurfaceSize = 0;
; 96   : 	if (TileMode == 1)

	cmp	ecx, 1
	jne	SHORT $LN8@Deswizzle

; 58   : 	return ((x - 1) | (y - 1)) + 1;

	or	r15d, 31

; 97   : 	{
; 98   : 		Pitch = Width * BytesPerPixel;
; 99   : 		if (RoundPitch == 1)
; 100  : 			Pitch = RoundUp(Pitch, 32);
; 101  : 
; 102  : 		SurfaceSize = Pitch * Height;

	mov	r12d, eax

; 103  : 	}

	jmp	SHORT $LN167@Deswizzle
$LN8@Deswizzle:

; 58   : 	return ((x - 1) | (y - 1)) + 1;

	dec	eax

; 104  : 	else
; 105  : 	{
; 106  : 		Pitch = RoundUp(Width * BytesPerPixel, 64);
; 107  : 		SurfaceSize = Pitch * RoundUp(Height, BlockHeight * 8);

	lea	r12d, DWORD PTR [r9*8]

; 58   : 	return ((x - 1) | (y - 1)) + 1;

	dec	r12d
	or	r15d, 63				; 0000003fH
	or	r12d, eax
	inc	r12d
$LN167@Deswizzle:
	xor	eax, eax
	mov	QWORD PTR [rsp+152], rbx

; 110  : 	std::vector<unsigned char> Result(SurfaceSize);

	inc	r15d
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [r13], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r13], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 110  : 	std::vector<unsigned char> Result(SurfaceSize);

	imul	r12d, r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r13+8], rax
	mov	QWORD PTR [r13+16], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 110  : 	std::vector<unsigned char> Result(SurfaceSize);

	mov	esi, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2065 :         if (_Count != 0) {

	test	r12d, r12d
	je	SHORT $LN129@Deswizzle

; 2010 :         _Buy_raw(_Newcapacity);

	mov	edx, esi
	mov	rcx, r13
	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	rbx, QWORD PTR [r13]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8d, esi
	mov	rcx, rbx
	xor	edx, edx
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	ecx, DWORD PTR TileMode$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+r12]
	mov	r9d, DWORD PTR BlockHeight$1$[rsp]
	mov	r10d, DWORD PTR Pitch$1$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [r13+8], rax
$LN129@Deswizzle:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 112  : 	for (uint32_t y = 0; y < Height; y++)

	xor	esi, esi
	test	r14d, r14d
	je	$LN157@Deswizzle
	mov	r14, QWORD PTR ImageData$[rsp]
	mov	eax, DWORD PTR Height$GSCopy$2$[rsp]
$LL4@Deswizzle:

; 114  : 		for (uint32_t x = 0; x < Width; x++)

	xor	ebx, ebx
	test	ebp, ebp
	je	$LN2@Deswizzle
	npad	1
$LL7@Deswizzle:

; 115  : 		{
; 116  : 			uint32_t pos;
; 117  : 			uint32_t pos_;
; 118  : 
; 119  : 			if (TileMode == 1)

	mov	r8d, edi
	mov	eax, esi
	imul	r8d, ebx
	cmp	ecx, 1
	jne	SHORT $LN11@Deswizzle

; 120  : 			{
; 121  : 				pos = y * Pitch + x * BytesPerPixel;

	imul	eax, r15d

; 122  : 			}

	jmp	SHORT $LN168@Deswizzle
$LN11@Deswizzle:

; 73   : 	uint32_t GOBAddress = (BaseAddress

	xor	edx, edx
	lea	ecx, DWORD PTR [r9*8]
	div	ecx

; 42   : 	return (n + d - 1) / d;

	lea	ecx, DWORD PTR [r10+63]
	shr	ecx, 6

; 73   : 	uint32_t GOBAddress = (BaseAddress

	imul	ecx, eax
	mov	eax, r8d
	shr	eax, 6
	shr	edx, 3
	add	ecx, eax

; 74   : 		+ (y / (8 * BlockHeight)) * 512 * BlockHeight * ImageWidthInGobs
; 75   : 		+ (x * BytesPerPixel / 64) * 512 * BlockHeight
; 76   : 		+ (y % (8 * BlockHeight) / 8) * 512);
; 77   : 
; 78   : 	x *= BytesPerPixel;
; 79   : 
; 80   : 	/* What the fuck is this...? */
; 81   : 	uint32_t Address = (GOBAddress + ((x % 64) / 32) * 256 + ((y % 8) / 2) * 64

	mov	eax, r8d
	shr	eax, 5
	and	eax, 1
	imul	ecx, r9d
	add	ecx, edx
	lea	ecx, DWORD PTR [rax+rcx*2]
	mov	eax, esi
	shr	eax, 1
	and	eax, 3
	lea	edx, DWORD PTR [rax+rcx*4]
	mov	eax, r8d
	shr	eax, 4
	and	eax, 1
	lea	ecx, DWORD PTR [rax+rdx*2]
	mov	eax, esi
	and	eax, 1
	lea	eax, DWORD PTR [rax+rcx*2]
	shl	eax, 4
	and	r8d, 15
$LN168@Deswizzle:

; 129  : 
; 130  : 			if (pos + BytesPerPixel <= SurfaceSize)

	add	eax, r8d
	lea	ecx, DWORD PTR [rdi+rax]
	cmp	ecx, r12d
	ja	SHORT $LN5@Deswizzle
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR [r14]
	mov	rdx, QWORD PTR [r14+8]
	sub	rdx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 132  : 				if (ImageData.size() >= pos + BytesPerPixel)

	cmp	rdx, rcx
	jb	SHORT $LN5@Deswizzle

; 133  : 				{
; 134  : 					std::copy(ImageData.begin() + pos, ImageData.begin() + pos + BytesPerPixel, Result.begin() + pos_);

	mov	ecx, eax
	lea	rdx, QWORD PTR [r9+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdi
	sub	r8, rdx
	add	r8, r9
	add	r8, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 128  : 			pos_ = (y * Width + x) * BytesPerPixel;

	mov	ecx, ebp
	imul	ecx, esi
	add	ecx, ebx
	imul	ecx, edi

; 133  : 				{
; 134  : 					std::copy(ImageData.begin() + pos, ImageData.begin() + pos + BytesPerPixel, Result.begin() + pos_);

	add	rcx, QWORD PTR [r13]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
$LN5@Deswizzle:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 114  : 		for (uint32_t x = 0; x < Width; x++)

	mov	ecx, DWORD PTR TileMode$[rsp]
	inc	ebx
	mov	r9d, DWORD PTR BlockHeight$1$[rsp]
	mov	r10d, DWORD PTR Pitch$1$[rsp]
	cmp	ebx, ebp
	jb	$LL7@Deswizzle
	mov	eax, DWORD PTR Height$GSCopy$2$[rsp]
$LN2@Deswizzle:

; 112  : 	for (uint32_t y = 0; y < Height; y++)

	mov	ecx, DWORD PTR TileMode$[rsp]
	inc	esi
	mov	r9d, DWORD PTR BlockHeight$1$[rsp]
	mov	r10d, DWORD PTR Pitch$1$[rsp]
	cmp	esi, eax
	jb	$LL4@Deswizzle
$LN157@Deswizzle:
	mov	rbx, QWORD PTR [rsp+152]

; 135  : 				}
; 136  : 			}
; 137  : 		}
; 138  : 	}
; 139  : 
; 140  : 	return Result;
; 141  : }

	mov	rax, r13
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?Deswizzle@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@IIIIIIHIIHAEAV23@@Z ENDP ; TegraSwizzle::Deswizzle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
;	COMDAT ?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z
_TEXT	SEGMENT
$T1 = 96
Pixels$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
__$ArrayPad$ = 128
__$ReturnUdt$ = 224
Texture$ = 232
Pixels$ = 240
Format$ = 248
Width$ = 256
Height$ = 264
Depth$dead$ = 272
Target$dead$ = 280
LinearTileMode$dead$ = 288
?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z PROC ; TegraSwizzle::GetDirectImageData, COMDAT

; 144  : {

$LN49:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 160				; 000000a0H
	movaps	XMMWORD PTR [rsp+144], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movzx	r14d, r9w
	mov	rdi, r8
	mov	r15, rdx
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR Pixels$GSCopy$[rsp], r8
	xor	r12d, r12d

; 145  : 	uint32_t BlockHeight = GetBlockHeight(DIV_ROUND_UP(Height, 4));

	movzx	ebp, WORD PTR Height$[rsp]

; 42   : 	return (n + d - 1) / d;

	lea	ecx, DWORD PTR [rbp+3]

; 63   : 	uint32_t BlockHeight = Pow2RoundUp(Height / 8);

	shr	ecx, 5

; 47   : 	x -= 1;

	dec	ecx

; 48   : 	x |= x >> 1;

	mov	eax, ecx
	shr	eax, 1
	or	ecx, eax

; 49   : 	x |= x >> 2;

	mov	eax, ecx
	shr	eax, 2
	or	ecx, eax

; 50   : 	x |= x >> 4;

	mov	eax, ecx
	shr	eax, 4
	or	ecx, eax

; 51   : 	x |= x >> 8;

	mov	eax, ecx
	shr	eax, 8
	or	ecx, eax

; 52   : 	x |= x >> 16;

	mov	eax, ecx
	shr	eax, 16
	or	ecx, eax

; 53   : 	return x + 1;

	inc	ecx

; 64   : 	if (BlockHeight > 16)

	cmp	ecx, 16
	jbe	SHORT $LN11@GetDirectI

; 65   : 		BlockHeight = 16;

	lea	ecx, QWORD PTR [r12+16]
	jmp	SHORT $LN2@GetDirectI
$LN11@GetDirectI:

; 146  : 
; 147  : 	if (BlockHeight == 0) BlockHeight = 4;

	mov	eax, 4
	test	ecx, ecx
	cmove	ecx, eax
$LN2@GetDirectI:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 662  : _GENERIC_MATH1(log10)

	mov	eax, ecx
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rax
	call	log10
	movaps	xmm6, xmm0
	movsd	xmm0, QWORD PTR __real@4000000000000000
	call	log10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 149  : 	return GetDirectImageData(Texture, Pixels, Format, Width, Height, Depth, std::log10(BlockHeight) / std::log10(2), Target, LinearTileMode);

	divsd	xmm6, xmm0
	cvttsd2si rbx, xmm6
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	r8, rax
	mov	DWORD PTR [rsp+56], ebx
	mov	WORD PTR [rsp+40], bp
	movzx	eax, WORD PTR Width$[rsp]
	mov	WORD PTR [rsp+32], ax
	movzx	r9d, r14w
	mov	rdx, r15
	mov	rcx, rsi
	call	?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z ; TegraSwizzle::GetDirectImageData
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN22@GetDirectI

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN40@GetDirectI

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN37@GetDirectI

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN40@GetDirectI:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rdi], r12

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], r12

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], r12
$LN22@GetDirectI:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 149  : 	return GetDirectImageData(Texture, Pixels, Format, Width, Height, Depth, std::log10(BlockHeight) / std::log10(2), Target, LinearTileMode);

	mov	rax, rsi

; 150  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm6, XMMWORD PTR [rsp+144]
	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN37@GetDirectI:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@GetDirectI:
?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z ENDP ; TegraSwizzle::GetDirectImageData
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 96
Pixels$GSCopy$ = 120
__$ReturnUdt$GSCopy$ = 120
__$ArrayPad$ = 128
__$ReturnUdt$ = 224
Texture$ = 232
Pixels$ = 240
Format$ = 248
Width$ = 256
Height$ = 264
Depth$dead$ = 272
Target$dead$ = 280
LinearTileMode$dead$ = 288
?dtor$0@?0??GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z@4HA PROC ; `TegraSwizzle::GetDirectImageData'::`1'::dtor$0
	mov	rcx, QWORD PTR Pixels$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0??GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGH_N@Z@4HA ENDP ; `TegraSwizzle::GetDirectImageData'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
;	COMDAT ?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z
_TEXT	SEGMENT
$T2 = 96
$T3 = 96
$T4 = 136
$T5 = 168
$T6 = 184
Pixels$GSCopy$ = 216
__$ReturnUdt$GSCopy$ = 216
AlignedData$ = 224
__$ArrayPad$ = 248
__$ReturnUdt$ = 336
TexToGo$ = 344
Pixels$ = 352
TextureFormat$ = 360
TextureWidth$ = 368
TextureHeight$ = 376
TextureDepth$dead$ = 384
BlockHeightLog2$ = 392
Target$dead$ = 400
LinearTileMode$dead$ = 408
?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z PROC ; TegraSwizzle::GetDirectImageData, COMDAT

; 162  : {

$LN282:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-8]
	sub	rsp, 264				; 00000108H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r12, r8
	mov	rbx, rdx
	mov	r15, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-256], rcx
	mov	QWORD PTR Pixels$GSCopy$[rbp-256], r8
	xor	r13d, r13d

; 17   : 	switch (FormatId)

	movzx	edx, r9w
	cmp	edx, 1285				; 00000505H
	ja	SHORT $LN20@GetDirectI
	je	SHORT $LN14@GetDirectI
	cmp	edx, 257				; 00000101H
	je	SHORT $LN17@GetDirectI
	lea	eax, DWORD PTR [rdx-514]
	test	eax, -257				; fffffeffH
	jne	SHORT $LN18@GetDirectI

; 18   : 	{
; 19   : 	case 0x202:
; 20   : 	case 0x302:
; 21   : 		return Formats.BC1_UNORM;

	movaps	xmm1, XMMWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B
	movsd	xmm0, QWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+16
	jmp	$LN277@GetDirectI
$LN17@GetDirectI:

; 27   : 	case 0x101:
; 28   : 		return Formats.ASTC_8x8_UNORM;

	movups	xmm1, XMMWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+72
	movsd	xmm0, QWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+88
	jmp	$LN277@GetDirectI
$LN14@GetDirectI:

; 22   : 	case 0x505:
; 23   : 		return Formats.BC3_UNORM_SRGB;

	movups	xmm1, XMMWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+24
	movsd	xmm0, QWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+40
	jmp	$LN277@GetDirectI
$LN20@GetDirectI:

; 17   : 	switch (FormatId)

	mov	ecx, edx
	sub	ecx, 1538				; 00000602H
	je	$LN15@GetDirectI
	cmp	ecx, 4
	je	$LN15@GetDirectI
$LN18@GetDirectI:

; 30   : 		Logger::Warning("TegraSwizzler", "Unknown texture format " + std::to_string(FormatId));

	lea	rdi, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T5[rbp-256], rdi
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 23
	lea	r8, OFFSET FLAT:??_C@_0BI@LLANGCPM@Unknown?5texture?5format?5@
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rsp+24], r13

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T2[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T2[rsp+16], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 30   : 		Logger::Warning("TegraSwizzler", "Unknown texture format " + std::to_string(FormatId));

	mov	QWORD PTR [rax+16], r13
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T4[rbp-240], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rbp-232], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 13
	lea	rdx, OFFSET FLAT:??_C@_0O@PMEMKMJ@TegraSwizzler@
	lea	rcx, QWORD PTR $T4[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 30   : 		Logger::Warning("TegraSwizzler", "Unknown texture format " + std::to_string(FormatId));

	mov	rdx, rdi
	lea	rcx, QWORD PTR $T4[rbp-256]
	call	?Warning@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Warning
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T6[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN86@GetDirectI

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T6[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN98@GetDirectI

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN98@GetDirectI
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN98@GetDirectI:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN86@GetDirectI:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 31   : 		return Formats.UNSUPPORTED;

	movups	xmm1, XMMWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+120
	movsd	xmm0, QWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+136
	jmp	SHORT $LN277@GetDirectI
$LN15@GetDirectI:

; 24   : 	case 0x606:
; 25   : 	case 0x602:
; 26   : 		return Formats.BC4_UNORM;

	movaps	xmm1, XMMWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+48
	movsd	xmm0, QWORD PTR ?Formats@@3UTegraSwizzleFormats@TegraSwizzle@@B+64
$LN277@GetDirectI:

; 163  : 
; 164  : 	TegraSwizzle::FormatInfo Format = GetFormatInfo(TextureFormat);
; 165  : 	if (Format.DecompressFunction == nullptr)

	movsd	QWORD PTR $T3[rsp+16], xmm0
	mov	rax, QWORD PTR $T3[rsp+16]
	test	rax, rax
	jne	SHORT $LN2@GetDirectI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r15], r13
	mov	QWORD PTR [r15+8], r13
	mov	QWORD PTR [r15+16], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 167  : 		return std::vector<unsigned char>(0);

	jmp	$LN278@GetDirectI
$LN2@GetDirectI:

; 168  : 	}
; 169  : 	TexToGo->DecompressFunction = Format.DecompressFunction;

	mov	QWORD PTR [rbx], rax

; 182  : 
; 183  : 	uint32_t ArrayOffset = 0;
; 184  : 
; 185  : 	int32_t BlockHeightShift = 0;
; 186  : 	uint32_t Width = Max(1, TextureWidth);

	movzx	eax, WORD PTR TextureWidth$[rbp-256]

; 37   : 	return a < b ? b : a;

	mov	r14d, 1
	mov	esi, r14d
	cmp	eax, r14d
	cmova	esi, eax

; 187  : 	uint32_t Height = Max(1, TextureHeight);

	movzx	eax, WORD PTR TextureHeight$[rbp-256]

; 37   : 	return a < b ? b : a;

	cmp	eax, r14d
	cmova	r14d, eax

; 42   : 	return (n + d - 1) / d;

	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	movd	ebx, xmm0
	lea	eax, DWORD PTR [r14-1]
	add	eax, ebx
	xor	edx, edx
	div	ebx
	mov	edi, eax
	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	movd	r11d, xmm0
	lea	eax, DWORD PTR [rsi-1]
	add	eax, r11d
	xor	edx, edx
	div	r11d

; 188  : 	uint32_t Depth = Max(1, TextureDepth);
; 189  : 
; 190  : 	uint32_t Size = DIV_ROUND_UP(Width, BlockWidth) * DIV_ROUND_UP(Height, FormatBlockHeight) * BytesPerPixel;

	imul	edi, eax
	movd	r10d, xmm1
	imul	edi, r10d

; 42   : 	return (n + d - 1) / d;

	lea	eax, DWORD PTR [r14-1]
	add	eax, r11d
	xor	edx, edx
	div	r11d

; 47   : 	x -= 1;

	lea	r8d, DWORD PTR [rax-1]

; 48   : 	x |= x >> 1;

	mov	ecx, r8d
	shr	ecx, 1
	or	r8d, ecx

; 49   : 	x |= x >> 2;

	mov	ecx, r8d
	shr	ecx, 2
	or	r8d, ecx

; 50   : 	x |= x >> 4;

	mov	ecx, r8d
	shr	ecx, 4
	or	r8d, ecx

; 51   : 	x |= x >> 8;

	mov	ecx, r8d
	shr	ecx, 8
	or	r8d, ecx

; 52   : 	x |= x >> 16;

	mov	eax, r8d
	shr	eax, 16
	or	r8d, eax
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR AlignedData$[rbp-256], xmm0
	mov	QWORD PTR AlignedData$[rbp-240], rax

; 170  : 
; 171  : 	uint32_t BytesPerPixel = Format.BytesPerPixel;
; 172  : 	uint32_t BlockWidth = Format.BlockWidth;
; 173  : 	uint32_t FormatBlockHeight = Format.BlockHeight;
; 174  : 	uint32_t BlockDepth = 1;
; 175  : 
; 176  : 	uint32_t BlockHeight = GetBlockHeight(DIV_ROUND_UP(TextureHeight, FormatBlockHeight)); //4=BlockHeight of BC1
; 177  : 
; 178  : 	uint32_t DataAlignment = 512;
; 179  : 	uint32_t TileMode = LinearTileMode ? 1 : 0;
; 180  : 
; 181  : 	int32_t LinesPerBlockHeight = (1 << (int32_t)BlockHeightLog2) * 8;

	mov	r9d, DWORD PTR BlockHeightLog2$[rbp-256]
	mov	ecx, r9d
	mov	edx, 8
	shl	edx, cl

; 53   : 	return x + 1;

	lea	eax, DWORD PTR [r8+1]

; 191  : 	if (Pow2RoundUp(DIV_ROUND_UP(Height, BlockWidth)) < LinesPerBlockHeight)
; 192  : 		BlockHeightShift++;
; 193  : 
; 194  : 	uint32_t Width__ = DIV_ROUND_UP(Width, BlockWidth);
; 195  : 	uint32_t Height__ = DIV_ROUND_UP(Height, FormatBlockHeight);
; 196  : 
; 197  : 	std::vector<unsigned char> AlignedData = Deswizzle(Width, Height, Depth, BlockWidth, FormatBlockHeight, BlockDepth, Target, BytesPerPixel, TileMode, Max(0, BlockHeightLog2 - BlockHeightShift), Pixels);

	mov	ecx, r13d
	cmp	eax, edx
	setb	cl

; 37   : 	return a < b ? b : a;

	mov	eax, r13d

; 191  : 	if (Pow2RoundUp(DIV_ROUND_UP(Height, BlockWidth)) < LinesPerBlockHeight)
; 192  : 		BlockHeightShift++;
; 193  : 
; 194  : 	uint32_t Width__ = DIV_ROUND_UP(Width, BlockWidth);
; 195  : 	uint32_t Height__ = DIV_ROUND_UP(Height, FormatBlockHeight);
; 196  : 
; 197  : 	std::vector<unsigned char> AlignedData = Deswizzle(Width, Height, Depth, BlockWidth, FormatBlockHeight, BlockDepth, Target, BytesPerPixel, TileMode, Max(0, BlockHeightLog2 - BlockHeightShift), Pixels);

	sub	r9d, ecx

; 37   : 	return a < b ? b : a;

	cmovne	eax, r9d

; 191  : 	if (Pow2RoundUp(DIV_ROUND_UP(Height, BlockWidth)) < LinesPerBlockHeight)
; 192  : 		BlockHeightShift++;
; 193  : 
; 194  : 	uint32_t Width__ = DIV_ROUND_UP(Width, BlockWidth);
; 195  : 	uint32_t Height__ = DIV_ROUND_UP(Height, FormatBlockHeight);
; 196  : 
; 197  : 	std::vector<unsigned char> AlignedData = Deswizzle(Width, Height, Depth, BlockWidth, FormatBlockHeight, BlockDepth, Target, BytesPerPixel, TileMode, Max(0, BlockHeightLog2 - BlockHeightShift), Pixels);

	mov	QWORD PTR [rsp+88], r12
	mov	DWORD PTR [rsp+80], eax
	mov	DWORD PTR [rsp+72], r13d
	mov	DWORD PTR [rsp+64], r10d
	mov	DWORD PTR [rsp+40], ebx
	mov	DWORD PTR [rsp+32], r11d
	mov	r8d, r14d
	mov	edx, esi
	lea	rcx, QWORD PTR AlignedData$[rbp-256]
	call	?Deswizzle@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@IIIIIIHIIHAEAV23@@Z ; TegraSwizzle::Deswizzle
	npad	1

; 198  : 	AlignedData.resize(Size);

	mov	r8d, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rcx, QWORD PTR AlignedData$[rbp-248]
	mov	r9, rcx
	mov	rdx, QWORD PTR AlignedData$[rbp-256]
	sub	r9, rdx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	r8, r9
	jae	SHORT $LN203@GetDirectI

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rcx, QWORD PTR [rdx+rdi]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;

	jmp	SHORT $LN204@GetDirectI
$LN203@GetDirectI:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN204@GetDirectI

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR AlignedData$[rbp-240]
	sub	rax, rdx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	r8, rax
	jbe	SHORT $LN205@GetDirectI

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, r8
	lea	rcx, QWORD PTR AlignedData$[rbp-256]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	mov	rcx, QWORD PTR AlignedData$[rbp-248]
	jmp	SHORT $LN279@GetDirectI
$LN205@GetDirectI:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	r8, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rcx+r8]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rcx, rbx
$LN279@GetDirectI:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR AlignedData$[rbp-256]
$LN204@GetDirectI:
	mov	rax, QWORD PTR AlignedData$[rbp-240]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR AlignedData$[rbp-240], r13
	mov	QWORD PTR AlignedData$[rbp-248], r13
	mov	QWORD PTR AlignedData$[rbp-256], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r15], rdx
	mov	QWORD PTR [r15+8], rcx
	mov	QWORD PTR [r15+16], rax
$LN278@GetDirectI:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 200  : }

	mov	rcx, r12
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	mov	rax, r15
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 264				; 00000108H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN276@GetDirectI:
?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z ENDP ; TegraSwizzle::GetDirectImageData
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 96
$T3 = 96
$T4 = 136
$T5 = 168
$T6 = 184
Pixels$GSCopy$ = 216
__$ReturnUdt$GSCopy$ = 216
AlignedData$ = 224
__$ArrayPad$ = 248
__$ReturnUdt$ = 336
TexToGo$ = 344
Pixels$ = 352
TextureFormat$ = 360
TextureWidth$ = 368
TextureHeight$ = 376
TextureDepth$dead$ = 384
BlockHeightLog2$ = 392
Target$dead$ = 400
LinearTileMode$dead$ = 408
?dtor$0@?0??GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z@4HA PROC ; `TegraSwizzle::GetDirectImageData'::`1'::dtor$0
	mov	rcx, QWORD PTR Pixels$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0??GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z@4HA ENDP ; `TegraSwizzle::GetDirectImageData'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 96
$T3 = 96
$T4 = 136
$T5 = 168
$T6 = 184
Pixels$GSCopy$ = 216
__$ReturnUdt$GSCopy$ = 216
AlignedData$ = 224
__$ArrayPad$ = 248
__$ReturnUdt$ = 336
TexToGo$ = 344
Pixels$ = 352
TextureFormat$ = 360
TextureWidth$ = 368
TextureHeight$ = 376
TextureDepth$dead$ = 384
BlockHeightLog2$ = 392
Target$dead$ = 400
LinearTileMode$dead$ = 408
?dtor$3@?0??GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z@4HA PROC ; `TegraSwizzle::GetDirectImageData'::`1'::dtor$3
	lea	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z@4HA ENDP ; `TegraSwizzle::GetDirectImageData'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 96
$T3 = 96
$T4 = 136
$T5 = 168
$T6 = 184
Pixels$GSCopy$ = 216
__$ReturnUdt$GSCopy$ = 216
AlignedData$ = 224
__$ArrayPad$ = 248
__$ReturnUdt$ = 336
TexToGo$ = 344
Pixels$ = 352
TextureFormat$ = 360
TextureWidth$ = 368
TextureHeight$ = 376
TextureDepth$dead$ = 384
BlockHeightLog2$ = 392
Target$dead$ = 400
LinearTileMode$dead$ = 408
?dtor$4@?0??GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z@4HA PROC ; `TegraSwizzle::GetDirectImageData'::`1'::dtor$4
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z@4HA ENDP ; `TegraSwizzle::GetDirectImageData'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 96
$T3 = 96
$T4 = 136
$T5 = 168
$T6 = 184
Pixels$GSCopy$ = 216
__$ReturnUdt$GSCopy$ = 216
AlignedData$ = 224
__$ArrayPad$ = 248
__$ReturnUdt$ = 336
TexToGo$ = 344
Pixels$ = 352
TextureFormat$ = 360
TextureWidth$ = 368
TextureHeight$ = 376
TextureDepth$dead$ = 384
BlockHeightLog2$ = 392
Target$dead$ = 400
LinearTileMode$dead$ = 408
?dtor$2@?0??GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z@4HA PROC ; `TegraSwizzle::GetDirectImageData'::`1'::dtor$2
	lea	rcx, QWORD PTR AlignedData$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$2@?0??GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z@4HA ENDP ; `TegraSwizzle::GetDirectImageData'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$ = 24
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator+, COMDAT

; 126  :         _Ptr += _Off;

	mov	rcx, QWORD PTR [rcx]

; 311  :         _Vector_iterator _Tmp = *this;
; 312  :         _Tmp += _Off;
; 313  :         return _Tmp;

	mov	rax, rdx

; 126  :         _Ptr += _Off;

	add	rcx, r8
	mov	QWORD PTR [rdx], rcx

; 314  :     }

	ret	0
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator+=, COMDAT

; 126  :         _Ptr += _Off;

	add	QWORD PTR [rcx], rdx

; 306  :         _Mybase::operator+=(_Off);
; 307  :         return *this;

	mov	rax, rcx

; 308  :     }

	ret	0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator+=, COMDAT

; 125  :         _Verify_offset(_Off);
; 126  :         _Ptr += _Off;

	add	QWORD PTR [rcx], rdx

; 127  :         return *this;

	mov	rax, rcx

; 128  :     }

	ret	0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z
_TEXT	SEGMENT
this$dead$ = 8
_Off$dead$ = 16
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset, COMDAT

; 108  : #if _ITERATOR_DEBUG_LEVEL == 0
; 109  :         (void) _Off;
; 110  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 111  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 112  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 113  :         _STL_VERIFY(_Off == 0 || _Mycont, "cannot seek invalidated vector iterator");
; 114  :         if (_Off < 0) {
; 115  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 116  :         }
; 117  : 
; 118  :         if (_Off > 0) {
; 119  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 120  :         }
; 121  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 122  :     }

	ret	0
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEBAX_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V10@00@Z PROC ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >, COMDAT

; 4619 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)

$LN20:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rcx

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rsi, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	mov	r8, rsi

; 4619 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)

	mov	rbx, r9

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rcx, QWORD PTR [rsi+rbx]

; 4620 :     _Adl_verify_range(_First, _Last);
; 4621 :     const auto _UFirst = _Get_unwrapped(_First);
; 4622 :     const auto _ULast  = _Get_unwrapped(_Last);
; 4623 :     const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 4624 :     _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _UDest));
; 4625 :     return _Dest;

	mov	rax, rdi

; 4626 : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rdi], rcx
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V10@00@Z ENDP ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z
_TEXT	SEGMENT
_It$ = 8
_Off$dead$ = 16
??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z PROC ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &,__int64>, COMDAT

; 1222 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1223 :         return _It + 0;
; 1224 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
; 1225 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1226 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1227 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1228 :         const auto _COff = static_cast<_CDiff>(_Off);
; 1229 : 
; 1230 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1231 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1232 :             "integer overflow");
; 1233 :         (void) _COff;
; 1234 : 
; 1235 :         _It._Verify_offset(static_cast<_IDiff>(_Off));
; 1236 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 1237 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1238 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1239 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1240 :     } else {
; 1241 :         // pass through iterator that doesn't participate in checking
; 1242 :         return static_cast<_Iter&&>(_It);
; 1243 :     }
; 1244 : }

	ret	0
??$_Get_unwrapped_n@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@_J@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@_J@Z ENDP ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > > &,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
;	COMDAT ??$log10@I$0A@@@YANI@Z
_TEXT	SEGMENT
_Left$ = 8
??$log10@I$0A@@@YANI@Z PROC				; log10<unsigned int,0>, COMDAT

; 662  : _GENERIC_MATH1(log10)

	mov	eax, ecx
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rax
	jmp	log10
??$log10@I$0A@@@YANI@Z ENDP				; log10<unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
;	COMDAT ??$log10@H$0A@@@YANH@Z
_TEXT	SEGMENT
_Left$dead$ = 8
??$log10@H$0A@@@YANH@Z PROC				; log10<int,0>, COMDAT

; 662  : _GENERIC_MATH1(log10)

	movsd	xmm0, QWORD PTR __real@4000000000000000
	jmp	log10
??$log10@H$0A@@@YANH@Z ENDP				; log10<int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_unchecked@PEAEPEAEPEAE@std@@YAPEAEPEAE00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_unchecked@PEAEPEAEPEAE@std@@YAPEAEPEAE00@Z PROC ; std::_Copy_unchecked<unsigned char *,unsigned char *,unsigned char *>, COMDAT

; 4589 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {

$LN16:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4590 :     // copy [_First, _Last) to [_Dest, ...)
; 4591 :     // note: _Copy_unchecked has callers other than the copy family
; 4592 :     if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {
; 4593 : #if _HAS_CXX20
; 4594 :         if (!_STD is_constant_evaluated())
; 4595 : #endif // _HAS_CXX20
; 4596 :         {
; 4597 : #ifdef __cpp_lib_concepts
; 4598 :             if constexpr (is_same_v<_InIt, _Sent>)
; 4599 : #endif // __cpp_lib_concepts
; 4600 :             {
; 4601 :                 return _Copy_memmove(_First, _Last, _Dest);
; 4602 :             }
; 4603 : #ifdef __cpp_lib_concepts
; 4604 :             else {
; 4605 :                 return _Copy_memmove_n(_First, static_cast<size_t>(_Last - _First), _Dest);
; 4606 :             }
; 4607 : #endif // __cpp_lib_concepts
; 4608 :         }
; 4609 :     }
; 4610 : 
; 4611 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4612 :         *_Dest = *_First;
; 4613 :     }
; 4614 : 
; 4615 :     return _Dest;
; 4616 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_unchecked@PEAEPEAEPEAE@std@@YAPEAEPEAE00@Z ENDP ; std::_Copy_unchecked<unsigned char *,unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>, COMDAT

; 1256 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1257 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1258 :     } else {
; 1259 :         _It = _STD forward<_UIter>(_UIt);
; 1260 :     }
; 1261 : }

	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PEAE@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@$$QEAPEAE@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z
_TEXT	SEGMENT
this$ = 8
_It$ = 16
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to, COMDAT

; 218  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

	mov	QWORD PTR [rcx], rdx

; 219  :     }

	ret	0
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QEAAXPEBE@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Refancy@PEAE$0A@@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEAE$0A@@std@@YAPEAEPEAE@Z PROC		; std::_Refancy<unsigned char *,0>, COMDAT

; 297  :     return _Ptr;

	mov	rax, rcx

; 298  : }

	ret	0
??$_Refancy@PEAE$0A@@std@@YAPEAEPEAE@Z ENDP		; std::_Refancy<unsigned char *,0>
_TEXT	ENDS
END
