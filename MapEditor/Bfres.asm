; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_04KPICECCB@Area@				; `string'
PUBLIC	??_C@_06CFGHAFBF@?4bfres@			; `string'
PUBLIC	??_C@_0P@PDPHHJCD@Deleted?5models@		; `string'
PUBLIC	??_C@_0N@DOLLKCOO@BfresLibrary@			; `string'
PUBLIC	??_C@_0BB@PBGFDDAA@Deleted?5textures@		; `string'
PUBLIC	??_C@_0BB@OOKFAFMK@GLTextureLibrary@		; `string'
PUBLIC	??_C@_0BA@DMKNGAPB@Mt_DefaultModel@		; `string'
PUBLIC	??_C@_0BL@PJEMKFHB@Wrong?5magic?0?5expected?5FRES@ ; `string'
PUBLIC	??_C@_05JBOHDMDP@Bfres@				; `string'
PUBLIC	??_C@_0BL@CHFNEMLJ@File?5is?5not?5a?5switch?5model@ ; `string'
PUBLIC	??_C@_0CD@FODENHEF@Wrong?5version?0?5expected?5v10?0?5go@ ; `string'
PUBLIC	??_C@_0CD@ECKIPNII@Only?5little?5endian?5supported?0?5g@ ; `string'
PUBLIC	??_C@_0L@DMHOGPOL@WaterPlane@			; `string'
PUBLIC	??_C@_03NLIGKIPD@_a0@				; `string'
PUBLIC	??_C@_0BG@CFBMLDHA@TerraWater01_Alb?4txtg@	; `string'
PUBLIC	??_C@_02BLLIBFIG@_a@				; `string'
PUBLIC	??_C@_05KIAGMJIK@?4txtg@			; `string'
PUBLIC	??_C@_0BC@NKOCGIM@Unknown?5face?5type@		; `string'
PUBLIC	??_C@_0BF@BGOJHMKC@Could?5not?5open?5file?5@	; `string'
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Min_buckets
EXTRN	__imp_fmax:PROC
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ??_C@_0BF@BGOJHMKC@Could?5not?5open?5file?5@
CONST	SEGMENT
??_C@_0BF@BGOJHMKC@Could?5not?5open?5file?5@ DB 'Could not open file ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NKOCGIM@Unknown?5face?5type@
CONST	SEGMENT
??_C@_0BC@NKOCGIM@Unknown?5face?5type@ DB 'Unknown face type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KIAGMJIK@?4txtg@
CONST	SEGMENT
??_C@_05KIAGMJIK@?4txtg@ DB '.txtg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BLLIBFIG@_a@
CONST	SEGMENT
??_C@_02BLLIBFIG@_a@ DB '_a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CFBMLDHA@TerraWater01_Alb?4txtg@
CONST	SEGMENT
??_C@_0BG@CFBMLDHA@TerraWater01_Alb?4txtg@ DB 'TerraWater01_Alb.txtg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NLIGKIPD@_a0@
CONST	SEGMENT
??_C@_03NLIGKIPD@_a0@ DB '_a0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMHOGPOL@WaterPlane@
CONST	SEGMENT
??_C@_0L@DMHOGPOL@WaterPlane@ DB 'WaterPlane', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ECKIPNII@Only?5little?5endian?5supported?0?5g@
CONST	SEGMENT
??_C@_0CD@ECKIPNII@Only?5little?5endian?5supported?0?5g@ DB 'Only little '
	DB	'endian supported, got ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FODENHEF@Wrong?5version?0?5expected?5v10?0?5go@
CONST	SEGMENT
??_C@_0CD@FODENHEF@Wrong?5version?0?5expected?5v10?0?5go@ DB 'Wrong versi'
	DB	'on, expected v10, got v', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CHFNEMLJ@File?5is?5not?5a?5switch?5model@
CONST	SEGMENT
??_C@_0BL@CHFNEMLJ@File?5is?5not?5a?5switch?5model@ DB 'File is not a swi'
	DB	'tch model', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05JBOHDMDP@Bfres@
CONST	SEGMENT
??_C@_05JBOHDMDP@Bfres@ DB 'Bfres', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PJEMKFHB@Wrong?5magic?0?5expected?5FRES@
CONST	SEGMENT
??_C@_0BL@PJEMKFHB@Wrong?5magic?0?5expected?5FRES@ DB 'Wrong magic, expec'
	DB	'ted FRES', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMKNGAPB@Mt_DefaultModel@
CONST	SEGMENT
??_C@_0BA@DMKNGAPB@Mt_DefaultModel@ DB 'Mt_DefaultModel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OOKFAFMK@GLTextureLibrary@
CONST	SEGMENT
??_C@_0BB@OOKFAFMK@GLTextureLibrary@ DB 'GLTextureLibrary', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PBGFDDAA@Deleted?5textures@
CONST	SEGMENT
??_C@_0BB@PBGFDDAA@Deleted?5textures@ DB 'Deleted textures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DOLLKCOO@BfresLibrary@
CONST	SEGMENT
??_C@_0N@DOLLKCOO@BfresLibrary@ DB 'BfresLibrary', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PDPHHJCD@Deleted?5models@
CONST	SEGMENT
??_C@_0P@PDPHHJCD@Deleted?5models@ DB 'Deleted models', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CFGHAFBF@?4bfres@
CONST	SEGMENT
??_C@_06CFGHAFBF@?4bfres@ DB '.bfres', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KPICECCB@Area@
CONST	SEGMENT
??_C@_04KPICECCB@Area@ DB 'Area', 00H			; `string'
PUBLIC	??$forward@PEAPEAVTexture@@@std@@YA$$QEAPEAPEAVTexture@@AEAPEAPEAV1@@Z ; std::forward<Texture * *>
PUBLIC	??$forward@PEAUBfresTexture@BfresFile@@@std@@YA$$QEAPEAUBfresTexture@BfresFile@@AEAPEAU12@@Z ; std::forward<BfresFile::BfresTexture *>
PUBLIC	??$forward@PEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAPEAV?$vector@IV?$allocator@I@std@@@0@AEAPEAV10@@Z ; std::forward<std::vector<unsigned int,std::allocator<unsigned int> > *>
PUBLIC	??$forward@PEAVMesh@@@std@@YA$$QEAPEAVMesh@@AEAPEAV1@@Z ; std::forward<Mesh *>
PUBLIC	??$forward@PEAULOD@BfresFile@@@std@@YA$$QEAPEAULOD@BfresFile@@AEAPEAU12@@Z ; std::forward<BfresFile::LOD *>
PUBLIC	??$forward@PEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAPEAV?$vector@MV?$allocator@M@std@@@0@AEAPEAV10@@Z ; std::forward<std::vector<float,std::allocator<float> > *>
PUBLIC	??$forward@PEAUMaterial@BfresFile@@@std@@YA$$QEAPEAUMaterial@BfresFile@@AEAPEAU12@@Z ; std::forward<BfresFile::Material *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@std@@QEAA@PEAPEAVTexture@@00@Z ; std::_Vector_val<std::_Simple_types<Texture *> >::_Vector_val<std::_Simple_types<Texture *> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@std@@QEAA@PEAUBfresTexture@BfresFile@@00@Z ; std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@IV?$allocator@I@std@@@1@00@Z ; std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@std@@QEAA@PEAVMesh@@00@Z ; std::_Vector_val<std::_Simple_types<Mesh> >::_Vector_val<std::_Simple_types<Mesh> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@std@@QEAA@PEAULOD@BfresFile@@00@Z ; std::_Vector_val<std::_Simple_types<BfresFile::LOD> >::_Vector_val<std::_Simple_types<BfresFile::LOD> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@MV?$allocator@M@std@@@1@00@Z ; std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@std@@QEAA@PEAUMaterial@BfresFile@@00@Z ; std::_Vector_val<std::_Simple_types<BfresFile::Material> >::_Vector_val<std::_Simple_types<BfresFile::Material> >
PUBLIC	??$?0V?$allocator@PEAVTexture@@@std@@PEAPEAVTexture@@PEAPEAV2@PEAPEAV2@@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@PEAVTexture@@@1@$$QEAPEAPEAVTexture@@22@Z ; std::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1>::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1><std::allocator<Texture *>,Texture * *,Texture * *,Texture * *>
PUBLIC	??$exchange@PEAPEAVTexture@@$$T@std@@YAPEAPEAVTexture@@AEAPEAPEAV1@$$QEA$$T@Z ; std::exchange<Texture * *,std::nullptr_t>
PUBLIC	??$?0V?$allocator@UBfresTexture@BfresFile@@@std@@PEAUBfresTexture@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UBfresTexture@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UBfresTexture@BfresFile@@@1@$$QEAPEAUBfresTexture@BfresFile@@22@Z ; std::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1>::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1><std::allocator<BfresFile::BfresTexture>,BfresFile::BfresTexture *,BfresFile::BfresTexture *,BfresFile::BfresTexture *>
PUBLIC	??$exchange@PEAUBfresTexture@BfresFile@@$$T@std@@YAPEAUBfresTexture@BfresFile@@AEAPEAU12@$$QEA$$T@Z ; std::exchange<BfresFile::BfresTexture *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UBfresTexture@BfresFile@@@0@AEAV10@@Z ; std::move<std::allocator<BfresFile::BfresTexture> &>
PUBLIC	??$?0V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@PEAV?$vector@IV?$allocator@I@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@$$QEAPEAV?$vector@IV?$allocator@I@std@@@1@22@Z ; std::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1>::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1><std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::vector<unsigned int,std::allocator<unsigned int> > *,std::vector<unsigned int,std::allocator<unsigned int> > *,std::vector<unsigned int,std::allocator<unsigned int> > *>
PUBLIC	??$exchange@PEAV?$vector@IV?$allocator@I@std@@@std@@$$T@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::vector<unsigned int,std::allocator<unsigned int> > *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@AEAV10@@Z ; std::move<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > &>
PUBLIC	??$?0V?$allocator@VMesh@@@std@@PEAVMesh@@PEAV2@PEAV2@@?$_Compressed_pair@V?$allocator@VMesh@@@std@@V?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VMesh@@@1@$$QEAPEAVMesh@@22@Z ; std::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1>::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1><std::allocator<Mesh>,Mesh *,Mesh *,Mesh *>
PUBLIC	??$exchange@PEAVMesh@@$$T@std@@YAPEAVMesh@@AEAPEAV1@$$QEA$$T@Z ; std::exchange<Mesh *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@VMesh@@@std@@@std@@YA$$QEAV?$allocator@VMesh@@@0@AEAV10@@Z ; std::move<std::allocator<Mesh> &>
PUBLIC	??$?0V?$allocator@ULOD@BfresFile@@@std@@PEAULOD@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@ULOD@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@ULOD@BfresFile@@@1@$$QEAPEAULOD@BfresFile@@22@Z ; std::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1>::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1><std::allocator<BfresFile::LOD>,BfresFile::LOD *,BfresFile::LOD *,BfresFile::LOD *>
PUBLIC	??$exchange@PEAULOD@BfresFile@@$$T@std@@YAPEAULOD@BfresFile@@AEAPEAU12@$$QEA$$T@Z ; std::exchange<BfresFile::LOD *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@ULOD@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@ULOD@BfresFile@@@0@AEAV10@@Z ; std::move<std::allocator<BfresFile::LOD> &>
PUBLIC	??$?0V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@PEAV?$vector@MV?$allocator@M@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@$$QEAPEAV?$vector@MV?$allocator@M@std@@@1@22@Z ; std::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1>::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1><std::allocator<std::vector<float,std::allocator<float> > >,std::vector<float,std::allocator<float> > *,std::vector<float,std::allocator<float> > *,std::vector<float,std::allocator<float> > *>
PUBLIC	??$exchange@PEAV?$vector@MV?$allocator@M@std@@@std@@$$T@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::vector<float,std::allocator<float> > *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@AEAV10@@Z ; std::move<std::allocator<std::vector<float,std::allocator<float> > > &>
PUBLIC	??$?0V?$allocator@UMaterial@BfresFile@@@std@@PEAUMaterial@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UMaterial@BfresFile@@@1@$$QEAPEAUMaterial@BfresFile@@22@Z ; std::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1>::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1><std::allocator<BfresFile::Material>,BfresFile::Material *,BfresFile::Material *,BfresFile::Material *>
PUBLIC	??$exchange@PEAUMaterial@BfresFile@@$$T@std@@YAPEAUMaterial@BfresFile@@AEAPEAU12@$$QEA$$T@Z ; std::exchange<BfresFile::Material *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@UMaterial@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UMaterial@BfresFile@@@0@AEAV10@@Z ; std::move<std::allocator<BfresFile::Material> &>
PUBLIC	??$move@AEAV?$tuple@AEBQEAVTextureToGo@@@std@@@std@@YA$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@AEAV10@@Z ; std::move<std::tuple<TextureToGo * const &> &>
PUBLIC	??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<Texture *,std::allocator<Texture *> >::vector<Texture *,std::allocator<Texture *> >
PUBLIC	??0?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >
PUBLIC	??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	??0?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<Mesh,std::allocator<Mesh> >::vector<Mesh,std::allocator<Mesh> >
PUBLIC	??0?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >
PUBLIC	??0?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >
PUBLIC	??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::vector<BfresFile::Material,std::allocator<BfresFile::Material> >
PUBLIC	??0BfresTexture@BfresFile@@QEAA@$$QEAU01@@Z	; BfresFile::BfresTexture::BfresTexture
PUBLIC	??0Mesh@@QEAA@$$QEAV0@@Z			; Mesh::Mesh
PUBLIC	??0LOD@BfresFile@@QEAA@$$QEAU01@@Z		; BfresFile::LOD::LOD
PUBLIC	??0Material@BfresFile@@QEAA@$$QEAU01@@Z		; BfresFile::Material::Material
PUBLIC	??0Model@BfresFile@@QEAA@$$QEAU01@@Z		; BfresFile::Model::Model
PUBLIC	??$construct_at@MM$0A@@std@@YAPEAMQEAM$$QEAM@Z	; std::construct_at<float,float,0>
PUBLIC	??$construct_at@UBfresTexture@BfresFile@@U12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@$$QEAU12@@Z ; std::construct_at<BfresFile::BfresTexture,BfresFile::BfresTexture,0>
PUBLIC	??$construct_at@VMesh@@V1@$0A@@std@@YAPEAVMesh@@QEAV1@$$QEAV1@@Z ; std::construct_at<Mesh,Mesh,0>
PUBLIC	??$construct_at@ULOD@BfresFile@@U12@$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@$$QEAU12@@Z ; std::construct_at<BfresFile::LOD,BfresFile::LOD,0>
PUBLIC	??$construct_at@UMaterial@BfresFile@@U12@$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@$$QEAU12@@Z ; std::construct_at<BfresFile::Material,BfresFile::Material,0>
PUBLIC	??$construct_at@UModel@BfresFile@@U12@$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@$$QEAU12@@Z ; std::construct_at<BfresFile::Model,BfresFile::Model,0>
PUBLIC	??$construct_at@USkeletonBone@BfresFile@@U12@$0A@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@$$QEAU12@@Z ; std::construct_at<BfresFile::SkeletonBone,BfresFile::SkeletonBone,0>
PUBLIC	??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>
PUBLIC	??$_Tuple_get@$0A@AEBQEAVTextureToGo@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@@Z ; std::_Tuple_get<0,TextureToGo * const &>
PUBLIC	??$?0V?$tuple@AEBQEAVTextureToGo@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@AEAV?$tuple@AEBQEAVTextureToGo@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture><std::tuple<TextureToGo * const &>,std::tuple<>,0>
PUBLIC	??0VertexBufferAttribute@BfresFile@@QEAA@XZ	; BfresFile::VertexBufferAttribute::VertexBufferAttribute
PUBLIC	??0VertexBuffer@BfresFile@@QEAA@XZ		; BfresFile::VertexBuffer::VertexBuffer
PUBLIC	??0TextureToGo@@QEAA@$$QEAV0@@Z			; TextureToGo::TextureToGo
PUBLIC	??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@$$QEAU01@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>
PUBLIC	??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@$$QEAU01@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>
PUBLIC	??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z	; std::construct_at<unsigned char,unsigned char const &,0>
PUBLIC	??$construct_at@M$$V$0A@@std@@YAPEAMQEAM@Z	; std::construct_at<float,0>
PUBLIC	??$construct@MM@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM$$QEAM@Z ; std::_Default_allocator_traits<std::allocator<float> >::construct<float,float>
PUBLIC	??$construct_at@PEAVTexture@@AEBQEAV1@$0A@@std@@YAPEAPEAVTexture@@QEAPEAV1@AEBQEAV1@@Z ; std::construct_at<Texture *,Texture * const &,0>
PUBLIC	??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z ; std::construct_at<BfresFile::BfresTexture,0>
PUBLIC	??$construct@UBfresTexture@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture,BfresFile::BfresTexture>
PUBLIC	??$forward@UBfresTexture@BfresFile@@@std@@YA$$QEAUBfresTexture@BfresFile@@AEAU12@@Z ; std::forward<BfresFile::BfresTexture>
PUBLIC	??$construct_at@V?$vector@IV?$allocator@I@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@@Z ; std::construct_at<std::vector<unsigned int,std::allocator<unsigned int> >,0>
PUBLIC	??$construct_at@VMesh@@$$V$0A@@std@@YAPEAVMesh@@QEAV1@@Z ; std::construct_at<Mesh,0>
PUBLIC	??$construct@VMesh@@V1@@?$_Default_allocator_traits@V?$allocator@VMesh@@@std@@@std@@SAXAEAV?$allocator@VMesh@@@1@QEAVMesh@@$$QEAV3@@Z ; std::_Default_allocator_traits<std::allocator<Mesh> >::construct<Mesh,Mesh>
PUBLIC	??$forward@VMesh@@@std@@YA$$QEAVMesh@@AEAV1@@Z	; std::forward<Mesh>
PUBLIC	??$construct_at@ULOD@BfresFile@@$$V$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@@Z ; std::construct_at<BfresFile::LOD,0>
PUBLIC	??$construct@ULOD@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::LOD> >::construct<BfresFile::LOD,BfresFile::LOD>
PUBLIC	??$forward@ULOD@BfresFile@@@std@@YA$$QEAULOD@BfresFile@@AEAU12@@Z ; std::forward<BfresFile::LOD>
PUBLIC	??$construct_at@V?$vector@MV?$allocator@M@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@@Z ; std::construct_at<std::vector<float,std::allocator<float> >,0>
PUBLIC	??$construct_at@UMaterial@BfresFile@@$$V$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@@Z ; std::construct_at<BfresFile::Material,0>
PUBLIC	??$construct@UMaterial@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::Material> >::construct<BfresFile::Material,BfresFile::Material>
PUBLIC	??$forward@UMaterial@BfresFile@@@std@@YA$$QEAUMaterial@BfresFile@@AEAU12@@Z ; std::forward<BfresFile::Material>
PUBLIC	??$construct_at@UModel@BfresFile@@$$V$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@@Z ; std::construct_at<BfresFile::Model,0>
PUBLIC	??$construct@UModel@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::Model> >::construct<BfresFile::Model,BfresFile::Model>
PUBLIC	??$forward@UModel@BfresFile@@@std@@YA$$QEAUModel@BfresFile@@AEAU12@@Z ; std::forward<BfresFile::Model>
PUBLIC	??$construct_at@USkeletonBone@BfresFile@@$$V$0A@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@@Z ; std::construct_at<BfresFile::SkeletonBone,0>
PUBLIC	??$construct@USkeletonBone@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@SAXAEAV?$allocator@USkeletonBone@BfresFile@@@1@QEAUSkeletonBone@BfresFile@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::SkeletonBone> >::construct<BfresFile::SkeletonBone,BfresFile::SkeletonBone>
PUBLIC	??$forward@USkeletonBone@BfresFile@@@std@@YA$$QEAUSkeletonBone@BfresFile@@AEAU12@@Z ; std::forward<BfresFile::SkeletonBone>
PUBLIC	??$construct_at@G$$V$0A@@std@@YAPEAGQEAG@Z	; std::construct_at<unsigned short,0>
PUBLIC	??$?0AEBQEAVTextureToGo@@@?$_Tuple_val@AEBQEAVTextureToGo@@@std@@QEAA@AEBQEAVTextureToGo@@@Z ; std::_Tuple_val<TextureToGo * const &>::_Tuple_val<TextureToGo * const &><TextureToGo * const &>
PUBLIC	??$construct_at@UVertexBufferSize@BfresFile@@$$V$0A@@std@@YAPEAUVertexBufferSize@BfresFile@@QEAU12@@Z ; std::construct_at<BfresFile::VertexBufferSize,0>
PUBLIC	??$construct_at@UVertexBufferAttribute@BfresFile@@$$V$0A@@std@@YAPEAUVertexBufferAttribute@BfresFile@@QEAU12@@Z ; std::construct_at<BfresFile::VertexBufferAttribute,0>
PUBLIC	??$construct_at@UVertexBuffer@BfresFile@@$$V$0A@@std@@YAPEAUVertexBuffer@BfresFile@@QEAU12@@Z ; std::construct_at<BfresFile::VertexBuffer,0>
PUBLIC	??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &,0>
PUBLIC	??$addressof@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *>
PUBLIC	??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@$$QEAU10@@Z ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,0>
PUBLIC	??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@$$QEAU10@@Z ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,0>
PUBLIC	??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$?0AEBQEAVTextureToGo@@$$Z$$V@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@Z ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture><TextureToGo * const &>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@PEAM00@Z ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAA@PEAI00@Z ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
PUBLIC	??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAAPEAXI@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::`scalar deleting destructor'
PUBLIC	??0?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@$$QEAU01@@Z ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture>
PUBLIC	??0?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@$$QEAV01@@Z ; std::tuple<TextureToGo * const &>::tuple<TextureToGo * const &>
PUBLIC	??$?0V?$allocator@M@std@@PEAMPEAMPEAM@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@M@1@$$QEAPEAM22@Z ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float>,float *,float *,float *>
PUBLIC	??$exchange@PEAM$$T@std@@YAPEAMAEAPEAM$$QEA$$T@Z ; std::exchange<float *,std::nullptr_t>
PUBLIC	??$?0V?$allocator@I@std@@PEAIPEAIPEAI@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@I@1@$$QEAPEAI22@Z ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int>,unsigned int *,unsigned int *,unsigned int *>
PUBLIC	??$exchange@PEAI$$T@std@@YAPEAIAEAPEAI$$QEA$$T@Z ; std::exchange<unsigned int *,std::nullptr_t>
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > const >
PUBLIC	??$_Fnv1a_append_value@PEAVTextureToGo@@@std@@YA_K_KAEBQEAVTextureToGo@@@Z ; std::_Fnv1a_append_value<TextureToGo *>
PUBLIC	??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@@Z ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
PUBLIC	??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &,0>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >
PUBLIC	??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
PUBLIC	??$forward@AEBE@std@@YAAEBEAEBE@Z		; std::forward<unsigned char const &>
PUBLIC	??$construct@M$$V@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM@Z ; std::_Default_allocator_traits<std::allocator<float> >::construct<float>
PUBLIC	??$_Emplace_back@M@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAX$$QEAM@Z ; std::_Uninitialized_backout_al<std::allocator<float> >::_Emplace_back<float>
PUBLIC	??$construct@PEAVTexture@@AEBQEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVTexture@@@std@@@std@@SAXAEAV?$allocator@PEAVTexture@@@1@QEAPEAVTexture@@AEBQEAV3@@Z ; std::_Default_allocator_traits<std::allocator<Texture *> >::construct<Texture *,Texture * const &>
PUBLIC	??$forward@AEBQEAVTexture@@@std@@YAAEBQEAVTexture@@AEBQEAV1@@Z ; std::forward<Texture * const &>
PUBLIC	??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z ; std::construct_at<BfresFile::BfresTexture,BfresFile::BfresTexture const &,0>
PUBLIC	??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture>
PUBLIC	??$_Emplace_back@UBfresTexture@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX$$QEAUBfresTexture@BfresFile@@@Z ; std::_Uninitialized_backout_al<std::allocator<BfresFile::BfresTexture> >::_Emplace_back<BfresFile::BfresTexture>
PUBLIC	??$move@AEAUBfresTexture@BfresFile@@@std@@YA$$QEAUBfresTexture@BfresFile@@AEAU12@@Z ; std::move<BfresFile::BfresTexture &>
PUBLIC	??$construct_at@V?$vector@IV?$allocator@I@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@$$QEAV10@@Z ; std::construct_at<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> >,0>
PUBLIC	??$construct@V?$vector@IV?$allocator@I@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@QEAV?$vector@IV?$allocator@I@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::construct<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Emplace_back@V?$vector@IV?$allocator@I@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@IV?$allocator@I@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_back<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$construct@VMesh@@$$V@?$_Default_allocator_traits@V?$allocator@VMesh@@@std@@@std@@SAXAEAV?$allocator@VMesh@@@1@QEAVMesh@@@Z ; std::_Default_allocator_traits<std::allocator<Mesh> >::construct<Mesh>
PUBLIC	??$_Emplace_back@VMesh@@@?$_Uninitialized_backout_al@V?$allocator@VMesh@@@std@@@std@@QEAAX$$QEAVMesh@@@Z ; std::_Uninitialized_backout_al<std::allocator<Mesh> >::_Emplace_back<Mesh>
PUBLIC	??$move@AEAVMesh@@@std@@YA$$QEAVMesh@@AEAV1@@Z	; std::move<Mesh &>
PUBLIC	??$construct_at@ULOD@BfresFile@@AEBU12@$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@AEBU12@@Z ; std::construct_at<BfresFile::LOD,BfresFile::LOD const &,0>
PUBLIC	??$construct@ULOD@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::LOD> >::construct<BfresFile::LOD>
PUBLIC	??$_Emplace_back@ULOD@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX$$QEAULOD@BfresFile@@@Z ; std::_Uninitialized_backout_al<std::allocator<BfresFile::LOD> >::_Emplace_back<BfresFile::LOD>
PUBLIC	??$move@AEAULOD@BfresFile@@@std@@YA$$QEAULOD@BfresFile@@AEAU12@@Z ; std::move<BfresFile::LOD &>
PUBLIC	??$construct_at@V?$vector@MV?$allocator@M@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@$$QEAV10@@Z ; std::construct_at<std::vector<float,std::allocator<float> >,std::vector<float,std::allocator<float> >,0>
PUBLIC	??$construct@V?$vector@MV?$allocator@M@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@QEAV?$vector@MV?$allocator@M@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<float,std::allocator<float> > > >::construct<std::vector<float,std::allocator<float> > >
PUBLIC	??$_Emplace_back@V?$vector@MV?$allocator@M@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@MV?$allocator@M@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_back<std::vector<float,std::allocator<float> > >
PUBLIC	??$construct_at@UMaterial@BfresFile@@AEBU12@$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@AEBU12@@Z ; std::construct_at<BfresFile::Material,BfresFile::Material const &,0>
PUBLIC	??$construct@UMaterial@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::Material> >::construct<BfresFile::Material>
PUBLIC	??$_Emplace_back@UMaterial@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX$$QEAUMaterial@BfresFile@@@Z ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Material> >::_Emplace_back<BfresFile::Material>
PUBLIC	??$move@AEAUMaterial@BfresFile@@@std@@YA$$QEAUMaterial@BfresFile@@AEAU12@@Z ; std::move<BfresFile::Material &>
PUBLIC	??$construct_at@UModel@BfresFile@@AEBU12@$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@AEBU12@@Z ; std::construct_at<BfresFile::Model,BfresFile::Model const &,0>
PUBLIC	??$construct@UModel@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::Model> >::construct<BfresFile::Model>
PUBLIC	??$_Emplace_back@UModel@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX$$QEAUModel@BfresFile@@@Z ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Model> >::_Emplace_back<BfresFile::Model>
PUBLIC	??$move@AEAUModel@BfresFile@@@std@@YA$$QEAUModel@BfresFile@@AEAU12@@Z ; std::move<BfresFile::Model &>
PUBLIC	??0SkeletonBone@BfresFile@@QEAA@XZ		; BfresFile::SkeletonBone::SkeletonBone
PUBLIC	??$construct@USkeletonBone@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@SAXAEAV?$allocator@USkeletonBone@BfresFile@@@1@QEAUSkeletonBone@BfresFile@@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::SkeletonBone> >::construct<BfresFile::SkeletonBone>
PUBLIC	??$_Emplace_back@USkeletonBone@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX$$QEAUSkeletonBone@BfresFile@@@Z ; std::_Uninitialized_backout_al<std::allocator<BfresFile::SkeletonBone> >::_Emplace_back<BfresFile::SkeletonBone>
PUBLIC	??$move@AEAUSkeletonBone@BfresFile@@@std@@YA$$QEAUSkeletonBone@BfresFile@@AEAU12@@Z ; std::move<BfresFile::SkeletonBone &>
PUBLIC	??$construct@G$$V@?$_Default_allocator_traits@V?$allocator@G@std@@@std@@SAXAEAV?$allocator@G@1@QEAG@Z ; std::_Default_allocator_traits<std::allocator<unsigned short> >::construct<unsigned short>
PUBLIC	??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>
PUBLIC	??$construct_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@U12@$0A@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@QEAU10@$$QEAU10@@Z ; std::construct_at<std::pair<TextureToGo * const,Texture>,std::pair<TextureToGo * const,Texture>,0>
PUBLIC	??$construct_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBQEAVTextureToGo@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@$$QEAV?$tuple@$$V@0@@Z ; std::construct_at<std::pair<TextureToGo * const,Texture>,std::piecewise_construct_t const &,std::tuple<TextureToGo * const &>,std::tuple<>,0>
PUBLIC	??$?0U_Exact_args_t@std@@AEBQEAVTextureToGo@@$$V$0A@@?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@U_Exact_args_t@1@AEBQEAVTextureToGo@@@Z ; std::tuple<TextureToGo * const &>::tuple<TextureToGo * const &><std::_Exact_args_t,TextureToGo * const &,0>
PUBLIC	??$_Emplace_back@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_back<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$construct_at@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@$0A@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@$$QEAU10@@Z ; std::construct_at<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0>
PUBLIC	??$addressof@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$construct@UVertexBufferSize@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferSize@BfresFile@@@1@QEAUVertexBufferSize@BfresFile@@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferSize> >::construct<BfresFile::VertexBufferSize>
PUBLIC	??$_Unfancy@UVertexBufferSize@BfresFile@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@@Z ; std::_Unfancy<BfresFile::VertexBufferSize>
PUBLIC	??$construct@UVertexBufferAttribute@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@QEAUVertexBufferAttribute@BfresFile@@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferAttribute> >::construct<BfresFile::VertexBufferAttribute>
PUBLIC	??$construct@UVertexBuffer@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBuffer@BfresFile@@@1@QEAUVertexBuffer@BfresFile@@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBuffer> >::construct<BfresFile::VertexBuffer>
PUBLIC	??$forward@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *>
PUBLIC	??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &>
PUBLIC	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &>
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@$$QEAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
PUBLIC	??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@$$QEAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >::allocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>,1>::_Get_first
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Allocate
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Getcomp
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Get_scary
PUBLIC	??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Release
PUBLIC	??_G?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAAPEAXI@Z ; std::pair<TextureToGo * const,Texture>::`scalar deleting destructor'
PUBLIC	??_G?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
PUBLIC	??_GVertexBufferAttribute@BfresFile@@QEAAPEAXI@Z ; BfresFile::VertexBufferAttribute::`scalar deleting destructor'
PUBLIC	??_GVertexBuffer@BfresFile@@QEAAPEAXI@Z		; BfresFile::VertexBuffer::`scalar deleting destructor'
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit2
PUBLIC	??0?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAU01@@Z ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Hash_representation@PEAVTextureToGo@@@std@@YA_KAEBQEAVTextureToGo@@@Z ; std::_Hash_representation<TextureToGo *>
PUBLIC	??$exchange@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::nullptr_t>
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
PUBLIC	??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
PUBLIC	??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *>
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * const &,0>
PUBLIC	??$forward@AEBQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * const &>
PUBLIC	??$destroy_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YAXQEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z ; std::destroy_at<std::pair<TextureToGo * const,Texture> >
PUBLIC	??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * const &,0>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &>
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &>
PUBLIC	??$destroy_at@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::destroy_at<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1VertexBufferAttribute@BfresFile@@QEAA@XZ	; BfresFile::VertexBufferAttribute::~VertexBufferAttribute
PUBLIC	??$destroy_at@UVertexBufferAttribute@BfresFile@@@std@@YAXQEAUVertexBufferAttribute@BfresFile@@@Z ; std::destroy_at<BfresFile::VertexBufferAttribute>
PUBLIC	??1VertexBuffer@BfresFile@@QEAA@XZ		; BfresFile::VertexBuffer::~VertexBuffer
PUBLIC	??$destroy_at@UVertexBuffer@BfresFile@@@std@@YAXQEAUVertexBuffer@BfresFile@@@Z ; std::destroy_at<BfresFile::VertexBuffer>
PUBLIC	??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z ; std::_Copy_memmove<unsigned char const *,unsigned char *>
PUBLIC	??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<float> >::_Emplace_back<>
PUBLIC	??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z		; std::_Zero_range<float *>
PUBLIC	??$_Uninitialized_move@PEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z ; std::_Uninitialized_move<float *,std::allocator<float> >
PUBLIC	??$_Get_unwrapped@AEBQEAM@std@@YA?A_TAEBQEAM@Z	; std::_Get_unwrapped<float * const &>
PUBLIC	??$_Emplace_back@AEBQEAVTexture@@@?$_Uninitialized_backout_al@V?$allocator@PEAVTexture@@@std@@@std@@QEAAXAEBQEAVTexture@@@Z ; std::_Uninitialized_backout_al<std::allocator<Texture *> >::_Emplace_back<Texture * const &>
PUBLIC	??$_Copy_memmove@PEBQEAVTexture@@PEAPEAV1@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@@Z ; std::_Copy_memmove<Texture * const *,Texture * *>
PUBLIC	??$to_address@QEAVTexture@@@std@@YAPEBQEAVTexture@@QEBQEAV1@@Z ; std::to_address<Texture * const>
PUBLIC	??$move@AEAPEBQEAVTexture@@@std@@YA$$QEAPEBQEAVTexture@@AEAPEBQEAV1@@Z ; std::move<Texture * const * &>
PUBLIC	??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture,BfresFile::BfresTexture const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::BfresTexture> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::BfresTexture *,std::allocator<BfresFile::BfresTexture> >
PUBLIC	??$_Get_unwrapped@AEBQEAUBfresTexture@BfresFile@@@std@@YA?A_TAEBQEAUBfresTexture@BfresFile@@@Z ; std::_Get_unwrapped<BfresFile::BfresTexture * const &>
PUBLIC	??$construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@QEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::construct<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Construct_in_place@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXAEAV?$vector@IV?$allocator@I@std@@@0@$$QEAV10@@Z ; std::_Construct_in_place<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAV?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<unsigned int,std::allocator<unsigned int> > *,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@IV?$allocator@I@std@@@0@@Z ; std::_Get_unwrapped<std::vector<unsigned int,std::allocator<unsigned int> > * const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@VMesh@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<Mesh> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z ; std::_Uninitialized_move<Mesh *,std::allocator<Mesh> >
PUBLIC	??$_Get_unwrapped@AEBQEAVMesh@@@std@@YA?A_TAEBQEAVMesh@@@Z ; std::_Get_unwrapped<Mesh * const &>
PUBLIC	??$construct@ULOD@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::LOD> >::construct<BfresFile::LOD,BfresFile::LOD const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::LOD> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::LOD *,std::allocator<BfresFile::LOD> >
PUBLIC	??$_Get_unwrapped@AEBQEAULOD@BfresFile@@@std@@YA?A_TAEBQEAULOD@BfresFile@@@Z ; std::_Get_unwrapped<BfresFile::LOD * const &>
PUBLIC	??$construct@V?$vector@MV?$allocator@M@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@QEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<float,std::allocator<float> > > >::construct<std::vector<float,std::allocator<float> >,std::vector<float,std::allocator<float> > >
PUBLIC	??$_Construct_in_place@V?$vector@MV?$allocator@M@std@@@std@@V12@@std@@YAXAEAV?$vector@MV?$allocator@M@std@@@0@$$QEAV10@@Z ; std::_Construct_in_place<std::vector<float,std::allocator<float> >,std::vector<float,std::allocator<float> > >
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAV?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<float,std::allocator<float> > *,std::allocator<std::vector<float,std::allocator<float> > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@MV?$allocator@M@std@@@0@@Z ; std::_Get_unwrapped<std::vector<float,std::allocator<float> > * const &>
PUBLIC	??$construct@UMaterial@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::Material> >::construct<BfresFile::Material,BfresFile::Material const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Material> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::Material *,std::allocator<BfresFile::Material> >
PUBLIC	??$_Get_unwrapped@AEBQEAUMaterial@BfresFile@@@std@@YA?A_TAEBQEAUMaterial@BfresFile@@@Z ; std::_Get_unwrapped<BfresFile::Material * const &>
PUBLIC	??$construct@UModel@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::Model> >::construct<BfresFile::Model,BfresFile::Model const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Model> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::Model *,std::allocator<BfresFile::Model> >
PUBLIC	??$_Get_unwrapped@AEBQEAUModel@BfresFile@@@std@@YA?A_TAEBQEAUModel@BfresFile@@@Z ; std::_Get_unwrapped<BfresFile::Model * const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::SkeletonBone> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUSkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::SkeletonBone *,std::allocator<BfresFile::SkeletonBone> >
PUBLIC	??$_Get_unwrapped@AEBQEAUSkeletonBone@BfresFile@@@std@@YA?A_TAEBQEAUSkeletonBone@BfresFile@@@Z ; std::_Get_unwrapped<BfresFile::SkeletonBone * const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@G@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned short> >::_Emplace_back<>
PUBLIC	??$_Zero_range@PEAG@std@@YAPEAGQEAG0@Z		; std::_Zero_range<unsigned short *>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
PUBLIC	??$exchange@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@AEAPEAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * &>
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >
PUBLIC	??$construct@U?$pair@QEAVTextureToGo@@VTexture@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@$$QEAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::construct<std::pair<TextureToGo * const,Texture>,std::pair<TextureToGo * const,Texture> >
PUBLIC	??$forward@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *>
PUBLIC	??$construct@U?$pair@QEAVTextureToGo@@VTexture@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBQEAVTextureToGo@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::construct<std::pair<TextureToGo * const,Texture>,std::piecewise_construct_t const &,std::tuple<TextureToGo * const &>,std::tuple<> >
PUBLIC	??$forward@V?$tuple@AEBQEAVTextureToGo@@@std@@@std@@YA$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@AEAV10@@Z ; std::forward<std::tuple<TextureToGo * const &> >
PUBLIC	??$?0AEBQEAVTextureToGo@@$0A@@?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@AEBQEAVTextureToGo@@@Z ; std::tuple<TextureToGo * const &>::tuple<TextureToGo * const &><TextureToGo * const &,0>
PUBLIC	??$_Uninitialized_move@PEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$_Get_unwrapped@AEBQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_TAEBQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Get_unwrapped<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > * const &>
PUBLIC	??$construct@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::construct<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Construct_in_place@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@@std@@YAXAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU10@@Z ; std::_Construct_in_place<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::_Emplace_back<>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::_Emplace_back<>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::_Emplace_back<>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > > >
PUBLIC	??$?0PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool,0>
PUBLIC	??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &,bool,0>
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
PUBLIC	??$forward@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
PUBLIC	??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$forward@PEAM@std@@YA$$QEAPEAMAEAPEAM@Z	; std::forward<float *>
PUBLIC	??$forward@PEAI@std@@YA$$QEAPEAIAEAPEAI@Z	; std::forward<unsigned int *>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > > >
PUBLIC	??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * &,bool,0>
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >
PUBLIC	??$forward@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@AEAU10@@Z ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >
PUBLIC	??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > ><std::pair<TextureToGo * const,Texture> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::max_size
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
PUBLIC	?_Do_hash@?$hash@PEAVTextureToGo@@@std@@SA_KAEBQEAVTextureToGo@@@Z ; std::hash<TextureToGo *>::_Do_hash
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::max_size
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Rrotate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
PUBLIC	?capacity@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::capacity
PUBLIC	?_Getal@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
PUBLIC	?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z ; std::vector<float,std::allocator<float> >::_Change_array
PUBLIC	?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Change_array
PUBLIC	?_Change_array@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAXQEAV?$vector@IV?$allocator@I@std@@@2@_K1@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Change_array
PUBLIC	?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z ; std::vector<Mesh,std::allocator<Mesh> >::_Change_array
PUBLIC	?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Change_array
PUBLIC	?_Change_array@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXQEAV?$vector@MV?$allocator@M@std@@@2@_K1@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Change_array
PUBLIC	?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Change_array
PUBLIC	?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Change_array
PUBLIC	?_Change_array@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXQEAUSkeletonBone@BfresFile@@_K1@Z ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Change_array
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::deallocate
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAA@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >
PUBLIC	??R?$_Conditionally_enabled_hash@PEAVTextureToGo@@$00@std@@QEBA_KAEBQEAVTextureToGo@@@Z ; std::_Conditionally_enabled_hash<TextureToGo *,1>::operator()
PUBLIC	??R?$equal_to@PEAVTextureToGo@@@std@@QEBA_NAEBQEAVTextureToGo@@0@Z ; std::equal_to<TextureToGo *>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@std@@QEBAAEBU?$equal_to@PEAVTextureToGo@@@2@XZ ; std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@PEAVTextureToGo@@@std@@V?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@PEAVTextureToGo@@@2@XZ ; std::_Compressed_pair<std::hash<TextureToGo *>,std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>,1>::_Get_first
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Check_grow_by_1
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Getal
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Insert_node
PUBLIC	?allocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z ; std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate
PUBLIC	?max_size@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
PUBLIC	?_Calculate_growth@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Change_array
PUBLIC	?_Xlength@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAXPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@0@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_range
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_Allocate
PUBLIC	?_Extract@?$_In_place_key_extract_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@@Z ; std::_In_place_key_extract_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >::_Extract
PUBLIC	?_Extract@?$_In_place_key_extract_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@2@@Z ; std::_In_place_key_extract_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >::_Extract
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Release
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@PEAUVertexBuffer@BfresFile@@AEAV?$allocator@UVertexBuffer@BfresFile@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::~_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAPEAUVertexBuffer@BfresFile@@XZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@PEAUVertexBufferAttribute@BfresFile@@AEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::~_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@PEAUVertexBufferSize@BfresFile@@AEAV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::~_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferSize@BfresFile@@XZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::__autoclassinit2
PUBLIC	??$?RPEAVTextureToGo@@PEAV0@@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBA_NAEBQEAVTextureToGo@@0@Z ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::operator()<TextureToGo *,TextureToGo *>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > const >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * const &>
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::nullptr_t>
PUBLIC	??$destroy@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::destroy<std::pair<TextureToGo * const,Texture> >
PUBLIC	??$addressof@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z ; std::addressof<std::pair<TextureToGo * const,Texture> >
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &,0>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *>
PUBLIC	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * const &>
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *>
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<TextureToGo * const,Texture>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1><std::allocator<std::pair<TextureToGo * const,Texture> > const &>
PUBLIC	??$forward@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<TextureToGo * const,Texture> > const &>
PUBLIC	??$destroy@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::destroy<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Unfancy@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@PEAU10@@Z ; std::_Unfancy<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$destroy@UVertexBufferAttribute@BfresFile@@@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@QEAUVertexBufferAttribute@BfresFile@@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferAttribute> >::destroy<BfresFile::VertexBufferAttribute>
PUBLIC	??$_Unfancy@UVertexBufferAttribute@BfresFile@@@std@@YAPEAUVertexBufferAttribute@BfresFile@@PEAU12@@Z ; std::_Unfancy<BfresFile::VertexBufferAttribute>
PUBLIC	??$destroy@UVertexBuffer@BfresFile@@@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBuffer@BfresFile@@@1@QEAUVertexBuffer@BfresFile@@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBuffer> >::destroy<BfresFile::VertexBuffer>
PUBLIC	??$_Unfancy@UVertexBuffer@BfresFile@@@std@@YAPEAUVertexBuffer@BfresFile@@PEAU12@@Z ; std::_Unfancy<BfresFile::VertexBuffer>
PUBLIC	??$_Copy_n_unchecked4@PEBE_KPEAE@std@@YAPEAEPEBE_KPEAE@Z ; std::_Copy_n_unchecked4<unsigned char const *,unsigned __int64,unsigned char *>
PUBLIC	??$_Copy_memmove_n@PEBEPEAE@std@@YAPEAEPEBE_KPEAE@Z ; std::_Copy_memmove_n<unsigned char const *,unsigned char *>
PUBLIC	??$_Uninitialized_copy_n@PEBEV?$allocator@E@std@@@std@@YAPEAEPEBE_KPEAEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_copy_n<unsigned char const *,std::allocator<unsigned char> >
PUBLIC	??$_Get_unwrapped@PEBE@std@@YA?A_T$$QEAPEBE@Z	; std::_Get_unwrapped<unsigned char const *>
PUBLIC	??$forward@AEBV?$allocator@M@std@@@std@@YAAEBV?$allocator@M@0@AEBV10@@Z ; std::forward<std::allocator<float> const &>
PUBLIC	??$move@AEAV?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z ; std::move<std::allocator<float> &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<float> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<float,std::allocator<float> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$move@AEAV?$allocator@I@std@@@std@@YA$$QEAV?$allocator@I@0@AEAV10@@Z ; std::move<std::allocator<unsigned int> &>
PUBLIC	??$_To_address@PEBQEAVTexture@@@std@@YA?A_PAEBQEBQEAVTexture@@@Z ; std::_To_address<Texture * const *>
PUBLIC	??$_Uninitialized_copy@PEBQEAVTexture@@PEBQEAV1@V?$allocator@PEAVTexture@@@std@@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@AEAV?$allocator@PEAVTexture@@@0@@Z ; std::_Uninitialized_copy<Texture * const *,Texture * const *,std::allocator<Texture *> >
PUBLIC	??$_Unwrap_sent@PEBQEAVTexture@@PEBQEAV1@@ranges@std@@YA?A_T$$QEAPEBQEAVTexture@@@Z ; std::ranges::_Unwrap_sent<Texture * const *,Texture * const *>
PUBLIC	??$_Unwrap_iter@PEBQEAVTexture@@PEBQEAV1@@ranges@std@@YA?A_T$$QEAPEBQEAVTexture@@@Z ; std::ranges::_Unwrap_iter<Texture * const *,Texture * const *>
PUBLIC	??$forward@PEBQEAVTexture@@@std@@YA$$QEAPEBQEAVTexture@@AEAPEBQEAV1@@Z ; std::forward<Texture * const *>
PUBLIC	??$forward@AEBV?$allocator@PEAVTexture@@@std@@@std@@YAAEBV?$allocator@PEAVTexture@@@0@AEBV10@@Z ; std::forward<std::allocator<Texture *> const &>
PUBLIC	??$move@AEAV?$allocator@PEAVTexture@@@std@@@std@@YA$$QEAV?$allocator@PEAVTexture@@@0@AEAV10@@Z ; std::move<std::allocator<Texture *> &>
PUBLIC	??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_back_with_unused_capacity<BfresFile::BfresTexture const &>
PUBLIC	??$forward@AEBUBfresTexture@BfresFile@@@std@@YAAEBUBfresTexture@BfresFile@@AEBU12@@Z ; std::forward<BfresFile::BfresTexture const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::BfresTexture> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_reallocate<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAAEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV21@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_back_with_unused_capacity<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$forward@V?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z ; std::forward<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@PEAV1@_KAEAV?$allocator@VMesh@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<Mesh> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<Mesh,std::allocator<Mesh> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_reallocate<BfresFile::LOD const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_back_with_unused_capacity<BfresFile::LOD const &>
PUBLIC	??$forward@AEBULOD@BfresFile@@@std@@YAAEBULOD@BfresFile@@AEBU12@@Z ; std::forward<BfresFile::LOD const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@PEAU12@_KAEAV?$allocator@ULOD@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::LOD> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_reallocate<std::vector<float,std::allocator<float> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAAEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV21@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_back_with_unused_capacity<std::vector<float,std::allocator<float> > >
PUBLIC	??$forward@V?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z ; std::forward<std::vector<float,std::allocator<float> > >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<float,std::allocator<float> > > >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$forward@AEBV?$allocator@UMaterial@BfresFile@@@std@@@std@@YAAEBV?$allocator@UMaterial@BfresFile@@@0@AEBV10@@Z ; std::forward<std::allocator<BfresFile::Material> const &>
PUBLIC	??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_reallocate<BfresFile::Material const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_back_with_unused_capacity<BfresFile::Material const &>
PUBLIC	??$forward@AEBUMaterial@BfresFile@@@std@@YAAEBUMaterial@BfresFile@@AEBU12@@Z ; std::forward<BfresFile::Material const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@PEAU12@_KAEAV?$allocator@UMaterial@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Material> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$forward@PEAUModel@BfresFile@@@std@@YA$$QEAPEAUModel@BfresFile@@AEAPEAU12@@Z ; std::forward<BfresFile::Model *>
PUBLIC	??$forward@V?$allocator@UModel@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UModel@BfresFile@@@0@AEAV10@@Z ; std::forward<std::allocator<BfresFile::Model> >
PUBLIC	??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_reallocate<BfresFile::Model const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_back_with_unused_capacity<BfresFile::Model const &>
PUBLIC	??$forward@AEBUModel@BfresFile@@@std@@YAAEBUModel@BfresFile@@AEBU12@@Z ; std::forward<BfresFile::Model const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@PEAU12@_KAEAV?$allocator@UModel@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Model> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$forward@PEAUSkeletonBone@BfresFile@@@std@@YA$$QEAPEAUSkeletonBone@BfresFile@@AEAPEAU12@@Z ; std::forward<BfresFile::SkeletonBone *>
PUBLIC	??$forward@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@USkeletonBone@BfresFile@@@0@AEAV10@@Z ; std::forward<std::allocator<BfresFile::SkeletonBone> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@PEAU12@_KAEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::SkeletonBone> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@G@std@@@std@@YAPEAGPEAG_KAEAV?$allocator@G@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned short> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
PUBLIC	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,bool,0>
PUBLIC	??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > ><std::pair<TextureToGo * const,Texture> >
PUBLIC	??$forward@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YA$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z ; std::forward<std::pair<TextureToGo * const,Texture> >
PUBLIC	??$?0PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool>::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool><std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool,0>
PUBLIC	??$?0AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool>::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool><std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &,bool,0>
PUBLIC	??$_Kfn@QEAVTextureToGo@@VTexture@@@?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@SAAEBQEAVTextureToGo@@AEBU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z ; std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0>::_Kfn<TextureToGo * const,Texture>
PUBLIC	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > ><std::piecewise_construct_t const &,std::tuple<TextureToGo * const &>,std::tuple<> >
PUBLIC	??$forward_as_tuple@AEBQEAVTextureToGo@@@std@@YA?AV?$tuple@AEBQEAVTextureToGo@@@0@AEBQEAVTextureToGo@@@Z ; std::forward_as_tuple<TextureToGo * const &>
PUBLIC	??$forward@AEBQEAVTextureToGo@@@std@@YAAEBQEAVTextureToGo@@AEBQEAV1@@Z ; std::forward<TextureToGo * const &>
PUBLIC	??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_reallocate<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Emplace_back_with_unused_capacity@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU21@@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_back_with_unused_capacity<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$forward@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::forward<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::VertexBufferSize> >
PUBLIC	??$forward@AEBV?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBufferSize@BfresFile@@@0@AEBV10@@Z ; std::forward<std::allocator<BfresFile::VertexBufferSize> const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAPEAUVertexBufferAttribute@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::VertexBufferAttribute> >
PUBLIC	??$forward@AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@0@AEBV10@@Z ; std::forward<std::allocator<BfresFile::VertexBufferAttribute> const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAPEAUVertexBuffer@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::VertexBuffer> >
PUBLIC	??$forward@AEBV?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBuffer@BfresFile@@@0@AEBV10@@Z ; std::forward<std::allocator<BfresFile::VertexBuffer> const &>
PUBLIC	??$forward@AEAY03$$CBD@std@@YAAEAY03$$CBDAEAY03$$CBD@Z ; std::forward<char const (&)[4]>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@AEB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@1@AEB_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >,bool const &,0>
PUBLIC	??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
PUBLIC	??$move@AEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z ; std::move<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> &>
PUBLIC	??$forward@AEAVTextureToGo@@@std@@YAAEAVTextureToGo@@AEAV1@@Z ; std::forward<TextureToGo &>
PUBLIC	??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z ; std::vector<float,std::allocator<float> >::_Construct_n<float *,float *>
PUBLIC	??$distance@PEAM@std@@YA_JPEAM0@Z		; std::distance<float *>
PUBLIC	??$_Adl_verify_range@PEAMPEAM@std@@YAXAEBQEAM0@Z ; std::_Adl_verify_range<float *,float *>
PUBLIC	??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n<unsigned int *,unsigned int *>
PUBLIC	??$distance@PEAI@std@@YA_JPEAI0@Z		; std::distance<unsigned int *>
PUBLIC	??$_Adl_verify_range@PEAIPEAI@std@@YAXAEBQEAI0@Z ; std::_Adl_verify_range<unsigned int *,unsigned int *>
PUBLIC	??$forward@PEAVTextureToGo@@@std@@YA$$QEAPEAVTextureToGo@@AEAPEAV1@@Z ; std::forward<TextureToGo *>
PUBLIC	??$forward@VTexture@@@std@@YA$$QEAVTexture@@AEAV1@@Z ; std::forward<Texture>
PUBLIC	??$forward@AEAPEAVTextureToGo@@@std@@YAAEAPEAVTextureToGo@@AEAPEAV1@@Z ; std::forward<TextureToGo * &>
PUBLIC	??$_Find_last@PEAVTextureToGo@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBQEAVTextureToGo@@_K@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Find_last<TextureToGo *>
PUBLIC	??$?RPEAVTextureToGo@@@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBA_KAEBQEAVTextureToGo@@@Z ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::operator()<TextureToGo *>
PUBLIC	??$forward@AEAY07$$CBD@std@@YAAEAY07$$CBDAEAY07$$CBD@Z ; std::forward<char const (&)[8]>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@AEB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@1@AEB_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,bool const &,0>
PUBLIC	??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >
PUBLIC	??$move@AEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@AEAU10@@Z ; std::move<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> &>
PUBLIC	??$forward@VBfresFile@@@std@@YA$$QEAVBfresFile@@AEAV1@@Z ; std::forward<BfresFile>
PUBLIC	??$forward@AEAY04$$CBD@std@@YAAEAY04$$CBDAEAY04$$CBD@Z ; std::forward<char const (&)[5]>
PUBLIC	??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> ><std::pair<TextureToGo * const,Texture> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1><>
PUBLIC	??$?0M@?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>::_Compressed_pair<std::equal_to<TextureToGo *>,float,1><float>
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_Orphan_non_end
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@2@QEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::clear
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Unchecked_erase
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBAAEBMXZ ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::_Get_max_bucket_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1>::_Get_first
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::clear
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBuffer@BfresFile@@@2@XZ ; std::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::max_size
PUBLIC	?_Getal@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Getal
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_Unchecked_splice
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KAEBQEAVTextureToGo@@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::bucket
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Min_load_factor_buckets
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Max_bucket_size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::max_size
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator--
PUBLIC	?allocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAPEAUVertexBufferSize@BfresFile@@_K@Z ; std::allocator<BfresFile::VertexBufferSize>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferSize> >::max_size
PUBLIC	?_Getal@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Getal
PUBLIC	?allocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@_K@Z ; std::allocator<BfresFile::VertexBufferAttribute>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferAttribute> >::max_size
PUBLIC	?_Getal@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Getal
PUBLIC	?allocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAPEAUVertexBuffer@BfresFile@@_K@Z ; std::allocator<BfresFile::VertexBuffer>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBuffer@BfresFile@@@2@@Z ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBuffer> >::max_size
PUBLIC	?_Getal@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBuffer@BfresFile@@@2@XZ ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Getal
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >::deallocate
PUBLIC	?max_size@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::max_size
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::bucket_count
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::max_load_factor
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Forced_rehash
PUBLIC	?max_size@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEBA_KXZ ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::max_size
PUBLIC	?_Buy_raw@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Xlength
PUBLIC	?max_size@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEBA_KXZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::max_size
PUBLIC	?_Buy_raw@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Xlength
PUBLIC	?max_size@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEBA_KXZ ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::max_size
PUBLIC	?_Buy_raw@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Xlength
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >
PUBLIC	?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@AEBAXPEAM0@Z ; std::vector<float,std::allocator<float> >::_Orphan_range
PUBLIC	??0?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAA@XZ ; std::allocator<glm::mat<4,4,float,0> >::allocator<glm::mat<4,4,float,0> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >
PUBLIC	??0?$allocator@UBfresTexture@BfresFile@@@std@@QEAA@XZ ; std::allocator<BfresFile::BfresTexture>::allocator<BfresFile::BfresTexture>
PUBLIC	?_Orphan_range@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEBAXPEAUBfresTexture@BfresFile@@0@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Orphan_range
PUBLIC	??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	?_Orphan_range@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEBAXPEAV?$vector@IV?$allocator@I@std@@@2@0@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Orphan_range
PUBLIC	??0?$allocator@VMesh@@@std@@QEAA@XZ		; std::allocator<Mesh>::allocator<Mesh>
PUBLIC	?_Orphan_range@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEBAXPEAVMesh@@0@Z ; std::vector<Mesh,std::allocator<Mesh> >::_Orphan_range
PUBLIC	??0?$allocator@ULOD@BfresFile@@@std@@QEAA@XZ	; std::allocator<BfresFile::LOD>::allocator<BfresFile::LOD>
PUBLIC	?_Orphan_range@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEBAXPEAULOD@BfresFile@@0@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Orphan_range
PUBLIC	??0?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::vector<float,std::allocator<float> > >::allocator<std::vector<float,std::allocator<float> > >
PUBLIC	?_Orphan_range@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEBAXPEAV?$vector@MV?$allocator@M@std@@@2@0@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Orphan_range
PUBLIC	?_Orphan_range@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEBAXPEAUMaterial@BfresFile@@0@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Orphan_range
PUBLIC	?_Orphan_range@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEBAXPEAUModel@BfresFile@@0@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UModel@BfresFile@@@std@@@std@@QEAA@PEAUModel@BfresFile@@00@Z ; std::_Vector_val<std::_Simple_types<BfresFile::Model> >::_Vector_val<std::_Simple_types<BfresFile::Model> >
PUBLIC	?_Orphan_range@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEBAXPEAUSkeletonBone@BfresFile@@0@Z ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@USkeletonBone@BfresFile@@@std@@@std@@QEAA@PEAUSkeletonBone@BfresFile@@00@Z ; std::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::deallocate
PUBLIC	?_Make_iter@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Make_iter
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Rehash_for_1
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Get_scary
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,std::_Iterator_base0>
PUBLIC	??0?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >
PUBLIC	?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >
PUBLIC	?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >
PUBLIC	??1?$_Tidy_guard@V?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> > >::~_Tidy_guard<std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> > >
PUBLIC	??1?$_Tidy_guard@V?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> > >::~_Tidy_guard<std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> > >
PUBLIC	??1?$_Tidy_guard@V?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> > >::~_Tidy_guard<std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_Release
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
PUBLIC	?_Extract@?$_In_place_key_extract_map@PEAVTextureToGo@@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@SAAEBQEAVTextureToGo@@AEBU?$pair@QEAVTextureToGo@@VTexture@@@2@@Z ; std::_In_place_key_extract_map<TextureToGo *,std::pair<TextureToGo * const,Texture> >::_Extract
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::_Release
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &>
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1><std::allocator<std::pair<TextureToGo * const,Texture> > const &>
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > * const &>
PUBLIC	??$_Destroy_range@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAXPEAU?$mat@$03$03M$0A@@glm@@QEAU12@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z ; std::_Destroy_range<std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	??$?0AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@PEAVTextureToGo@@@std@@V?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<TextureToGo *>,std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>,1>::_Compressed_pair<std::hash<TextureToGo *>,std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>,1><std::_Zero_then_variadic_args_t,float>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<TextureToGo * const,Texture>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<TextureToGo * const,Texture>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > ><std::allocator<std::pair<TextureToGo * const,Texture> > const &,0>
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$_Destroy_range@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAXPEAUVertexBufferSize@BfresFile@@QEAU12@AEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::VertexBufferSize> >
PUBLIC	??$_Destroy_range@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAXPEAUVertexBufferAttribute@BfresFile@@QEAU12@AEAV?$allocator@UVertexBufferAttribute@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::VertexBufferAttribute> >
PUBLIC	??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::VertexBuffer> >
PUBLIC	??$_Assign_counted_range@PEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEBE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char const *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><>
PUBLIC	??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Construct_n<>
PUBLIC	??$?0AEBV?$allocator@M@std@@$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@M@1@@Z ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float> const &>
PUBLIC	??$_Pocma@V?$allocator@M@std@@@std@@YAXAEAV?$allocator@M@0@0@Z ; std::_Pocma<std::allocator<float> >
PUBLIC	??$addressof@V?$vector@MV?$allocator@M@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z ; std::addressof<std::vector<float,std::allocator<float> > >
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<float,std::allocator<float> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Pocma@V?$allocator@I@std@@@std@@YAXAEAV?$allocator@I@0@0@Z ; std::_Pocma<std::allocator<unsigned int> >
PUBLIC	??$addressof@V?$vector@IV?$allocator@I@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z ; std::addressof<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1>::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1><>
PUBLIC	??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z ; std::vector<Texture *,std::allocator<Texture *> >::_Construct_n<Texture * const *,Texture * const *>
PUBLIC	??$?0AEBV?$allocator@PEAVTexture@@@std@@$$V@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEAVTexture@@@1@@Z ; std::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1>::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1><std::allocator<Texture *> const &>
PUBLIC	??$_Pocma@V?$allocator@PEAVTexture@@@std@@@std@@YAXAEAV?$allocator@PEAVTexture@@@0@0@Z ; std::_Pocma<std::allocator<Texture *> >
PUBLIC	??$addressof@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@@std@@YAPEAV?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@0@AEAV10@@Z ; std::addressof<std::vector<Texture *,std::allocator<Texture *> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UBfresTexture@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1>::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1><>
PUBLIC	??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_one_at_back<BfresFile::BfresTexture const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1>::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1><>
PUBLIC	??$_Emplace_one_at_back@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAAEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV21@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_one_at_back<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$move@AEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z ; std::move<std::vector<unsigned int,std::allocator<unsigned int> > &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@VMesh@@@std@@V?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1>::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1><>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<Mesh,std::allocator<Mesh> >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@ULOD@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1>::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1><>
PUBLIC	??$_Emplace_one_at_back@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_one_at_back<BfresFile::LOD const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1>::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1><>
PUBLIC	??$_Emplace_one_at_back@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAAEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV21@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_one_at_back<std::vector<float,std::allocator<float> > >
PUBLIC	??$move@AEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z ; std::move<std::vector<float,std::allocator<float> > &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1>::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1><>
PUBLIC	??$_Construct_n@$$V@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Construct_n<>
PUBLIC	??$?0AEBV?$allocator@UMaterial@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UMaterial@BfresFile@@@1@@Z ; std::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1>::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1><std::allocator<BfresFile::Material> const &>
PUBLIC	??$_Emplace_one_at_back@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_one_at_back<BfresFile::Material const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0V?$allocator@UModel@BfresFile@@@std@@PEAUModel@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UModel@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UModel@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UModel@BfresFile@@@1@$$QEAPEAUModel@BfresFile@@22@Z ; std::_Compressed_pair<std::allocator<BfresFile::Model>,std::_Vector_val<std::_Simple_types<BfresFile::Model> >,1>::_Compressed_pair<std::allocator<BfresFile::Model>,std::_Vector_val<std::_Simple_types<BfresFile::Model> >,1><std::allocator<BfresFile::Model>,BfresFile::Model *,BfresFile::Model *,BfresFile::Model *>
PUBLIC	??$exchange@PEAUModel@BfresFile@@$$T@std@@YAPEAUModel@BfresFile@@AEAPEAU12@$$QEA$$T@Z ; std::exchange<BfresFile::Model *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@UModel@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UModel@BfresFile@@@0@AEAV10@@Z ; std::move<std::allocator<BfresFile::Model> &>
PUBLIC	??$_Emplace_one_at_back@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_one_at_back<BfresFile::Model const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0V?$allocator@USkeletonBone@BfresFile@@@std@@PEAUSkeletonBone@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@USkeletonBone@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@USkeletonBone@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@USkeletonBone@BfresFile@@@1@$$QEAPEAUSkeletonBone@BfresFile@@22@Z ; std::_Compressed_pair<std::allocator<BfresFile::SkeletonBone>,std::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >,1>::_Compressed_pair<std::allocator<BfresFile::SkeletonBone>,std::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >,1><std::allocator<BfresFile::SkeletonBone>,BfresFile::SkeletonBone *,BfresFile::SkeletonBone *,BfresFile::SkeletonBone *>
PUBLIC	??$exchange@PEAUSkeletonBone@BfresFile@@$$T@std@@YAPEAUSkeletonBone@BfresFile@@AEAPEAU12@$$QEA$$T@Z ; std::exchange<BfresFile::SkeletonBone *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@USkeletonBone@BfresFile@@@0@AEAV10@@Z ; std::move<std::allocator<BfresFile::SkeletonBone> &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Unfancy_maybe_null@G@std@@YAPEAGPEAG@Z	; std::_Unfancy_maybe_null<unsigned short>
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
PUBLIC	??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::emplace<std::pair<TextureToGo * const,Texture> >
PUBLIC	??$move@AEAU?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YA$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z ; std::move<std::pair<TextureToGo * const,Texture> &>
PUBLIC	??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Try_emplace<TextureToGo * const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><>
PUBLIC	??$_Emplace_one_at_back@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU21@@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_one_at_back<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$move@AEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ; std::move<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Construct_n<>
PUBLIC	??$?0AEBV?$allocator@UVertexBufferSize@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1>::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1><std::allocator<BfresFile::VertexBufferSize> const &>
PUBLIC	??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Construct_n<>
PUBLIC	??$?0AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1>::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1><std::allocator<BfresFile::VertexBufferAttribute> const &>
PUBLIC	??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Construct_n<>
PUBLIC	??$?0AEBV?$allocator@UVertexBuffer@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBuffer@BfresFile@@@1@@Z ; std::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1>::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1><std::allocator<BfresFile::VertexBuffer> const &>
PUBLIC	??$?0AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><TextureToGo * &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
PUBLIC	??$?0PEAVTextureToGo@@AEAY03$$CBD$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAPEAVTextureToGo@@AEAY03$$CBD@Z ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><TextureToGo *,char const (&)[4],0>
PUBLIC	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::insert<0,0>
PUBLIC	??0TextureToGo@@QEAA@AEBV0@@Z			; TextureToGo::TextureToGo
PUBLIC	??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,TextureToGo &,0>
PUBLIC	??$end@M$0BA@@std@@YAPEAMAEAY0BA@M@Z		; std::end<float,16>
PUBLIC	??$begin@M$0BA@@std@@YAPEAMAEAY0BA@M@Z		; std::begin<float,16>
PUBLIC	??$_Get_unwrapped@AEAPEAM@std@@YA?A_TAEAPEAM@Z	; std::_Get_unwrapped<float * &>
PUBLIC	??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> ><float *,0>
PUBLIC	??$end@M$0BI@@std@@YAPEAMAEAY0BI@M@Z		; std::end<float,24>
PUBLIC	??$begin@M$0BI@@std@@YAPEAMAEAY0BI@M@Z		; std::begin<float,24>
PUBLIC	??$_Get_unwrapped@AEAPEAI@std@@YA?A_TAEAPEAI@Z	; std::_Get_unwrapped<unsigned int * &>
PUBLIC	??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> ><unsigned int *,0>
PUBLIC	??$end@I$0CE@@std@@YAPEAIAEAY0CE@I@Z		; std::end<unsigned int,36>
PUBLIC	??$begin@I$0CE@@std@@YAPEAIAEAY0CE@I@Z		; std::begin<unsigned int,36>
PUBLIC	??$fmax@MN$0A@@@YANMN@Z				; fmax<float,double,0>
PUBLIC	??$pow@MH$0A@@@YANMH@Z				; pow<float,int,0>
PUBLIC	??$get@$00QEAVTextureToGo@@VTexture@@@std@@YAAEAVTexture@@AEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z ; std::get<1,TextureToGo * const,Texture>
PUBLIC	??$get@$0A@QEAVTextureToGo@@VTexture@@@std@@YAAEBQEAVTextureToGo@@AEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z ; std::get<0,TextureToGo * const,Texture>
PUBLIC	??0Texture@@QEAA@$$QEAV0@@Z			; Texture::Texture
PUBLIC	??$?0AEAPEAVTextureToGo@@VTexture@@$0A@@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@AEAPEAVTextureToGo@@$$QEAVTexture@@@Z ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture><TextureToGo * &,Texture,0>
PUBLIC	??$count@X@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KAEBQEAVTextureToGo@@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::count<void>
PUBLIC	??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAVBfresFile@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,BfresFile,0>
PUBLIC	??$?0AEAY07$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY07$$CBD$$QEAVBfresFile@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><char const (&)[8],BfresFile,0>
PUBLIC	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::insert<0,0>
PUBLIC	??$?0AEAY04$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY04$$CBD$$QEAVBfresFile@@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><char const (&)[5],BfresFile,0>
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >::allocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Get_first
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEAAAEAMXZ ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::_Get_max_bucket_size
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1>::_Get_first
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >::allocate
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBuffer@BfresFile@@@2@XZ ; std::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAXQEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::allocator<glm::mat<4,4,float,0> >::deallocate
PUBLIC	?_Getal@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Getal
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	??0?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@@Z ; std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0>::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0>
PUBLIC	??0?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >
PUBLIC	?_Getal@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Getal
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >::deallocate
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Assign_grow
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1>::_Get_first
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>
PUBLIC	?deallocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z ; std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
PUBLIC	?_Getal@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
PUBLIC	?deallocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAXQEAUVertexBufferSize@BfresFile@@_K@Z ; std::allocator<BfresFile::VertexBufferSize>::deallocate
PUBLIC	?_Getal@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Getal
PUBLIC	?deallocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAXQEAUVertexBufferAttribute@BfresFile@@_K@Z ; std::allocator<BfresFile::VertexBufferAttribute>::deallocate
PUBLIC	?_Getal@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Getal
PUBLIC	?deallocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAXQEAUVertexBuffer@BfresFile@@_K@Z ; std::allocator<BfresFile::VertexBuffer>::deallocate
PUBLIC	?_Getal@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBuffer@BfresFile@@@2@XZ ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Getal
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >
PUBLIC	?_Xrange@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xrange
PUBLIC	?_Take_contents@?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAAXAEAV12@@Z ; std::_Vector_val<std::_Simple_types<float> >::_Take_contents
PUBLIC	?_Take_contents@?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAAXAEAV12@@Z ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Take_contents
PUBLIC	?_Take_contents@?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@std@@QEAAXAEAV12@@Z ; std::_Vector_val<std::_Simple_types<Texture *> >::_Take_contents
PUBLIC	?_Tidy@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Tidy
PUBLIC	?begin@?$initializer_list@E@std@@QEBAPEBEXZ	; std::initializer_list<unsigned char>::begin
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >
PUBLIC	??0?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEAA@XZ ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >
PUBLIC	??0?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<TextureToGo * const,Texture> >::allocator<std::pair<TextureToGo * const,Texture> >
PUBLIC	?_Unchecked_begin@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Unchecked_end
PUBLIC	?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Tidy
PUBLIC	??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Tidy
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@QEAVTextureToGo@@VTexture@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator++
PUBLIC	?begin@?$initializer_list@PEAVTexture@@@std@@QEBAPEBQEAVTexture@@XZ ; std::initializer_list<Texture *>::begin
PUBLIC	?end@?$initializer_list@PEAVTexture@@@std@@QEBAPEBQEAVTexture@@XZ ; std::initializer_list<Texture *>::end
PUBLIC	?size@?$initializer_list@PEAVTexture@@@std@@QEBA_KXZ ; std::initializer_list<Texture *>::size
PUBLIC	?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
PUBLIC	?_Tidy@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Tidy
PUBLIC	?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Tidy
PUBLIC	?_Tidy@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Tidy
PUBLIC	?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::pop_back
PUBLIC	?size@?$initializer_list@E@std@@QEBA_KXZ	; std::initializer_list<unsigned char>::size
PUBLIC	??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@V?$initializer_list@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
PUBLIC	??0?$allocator@M@std@@QEAA@XZ			; std::allocator<float>::allocator<float>
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<float,std::allocator<float> >::operator=
PUBLIC	?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z ; std::vector<float,std::allocator<float> >::resize
PUBLIC	?empty@?$vector@MV?$allocator@M@std@@@std@@QEBA_NXZ ; std::vector<float,std::allocator<float> >::empty
PUBLIC	?size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ ; std::vector<float,std::allocator<float> >::size
PUBLIC	??A?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z ; std::vector<float,std::allocator<float> >::operator[]
PUBLIC	?at@?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z ; std::vector<float,std::allocator<float> >::at
PUBLIC	??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
PUBLIC	?clear@?$vector@IV?$allocator@I@std@@@std@@QEAAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::clear
PUBLIC	??0?$allocator@PEAVTexture@@@std@@QEAA@XZ	; std::allocator<Texture *>::allocator<Texture *>
PUBLIC	??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@XZ ; std::vector<Texture *,std::allocator<Texture *> >::vector<Texture *,std::allocator<Texture *> >
PUBLIC	??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z ; std::vector<Texture *,std::allocator<Texture *> >::vector<Texture *,std::allocator<Texture *> >
PUBLIC	??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<Texture *,std::allocator<Texture *> >::operator=
PUBLIC	??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::~vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	??0?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >
PUBLIC	?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::push_back
PUBLIC	?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::resize
PUBLIC	?empty@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEBA_NXZ ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::empty
PUBLIC	?size@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEBA_KXZ ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::size
PUBLIC	??A?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAAEAUBfresTexture@BfresFile@@_K@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::operator[]
PUBLIC	??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
PUBLIC	?push_back@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@IV?$allocator@I@std@@@2@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::push_back
PUBLIC	?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::resize
PUBLIC	?size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::size
PUBLIC	??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAAEAV?$vector@IV?$allocator@I@std@@@1@_K@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator[]
PUBLIC	??0?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAA@XZ ; std::vector<Mesh,std::allocator<Mesh> >::vector<Mesh,std::allocator<Mesh> >
PUBLIC	?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z ; std::vector<Mesh,std::allocator<Mesh> >::resize
PUBLIC	?clear@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAXXZ ; std::vector<Mesh,std::allocator<Mesh> >::clear
PUBLIC	??A?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAAEAVMesh@@_K@Z ; std::vector<Mesh,std::allocator<Mesh> >::operator[]
PUBLIC	??0?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >
PUBLIC	?push_back@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAXAEBULOD@BfresFile@@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::push_back
PUBLIC	?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::resize
PUBLIC	?_Unchecked_begin@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAPEAULOD@BfresFile@@XZ ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAPEAULOD@BfresFile@@XZ ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Unchecked_end
PUBLIC	??0?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >
PUBLIC	?push_back@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@MV?$allocator@M@std@@@2@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::push_back
PUBLIC	?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::resize
PUBLIC	?size@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::size
PUBLIC	??A?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAAEAV?$vector@MV?$allocator@M@std@@@1@_K@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::operator[]
PUBLIC	??0?$allocator@UMaterial@BfresFile@@@std@@QEAA@XZ ; std::allocator<BfresFile::Material>::allocator<BfresFile::Material>
PUBLIC	??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::vector<BfresFile::Material,std::allocator<BfresFile::Material> >
PUBLIC	??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UMaterial@BfresFile@@@1@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::vector<BfresFile::Material,std::allocator<BfresFile::Material> >
PUBLIC	?push_back@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAXAEBUMaterial@BfresFile@@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::push_back
PUBLIC	?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::resize
PUBLIC	??A?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAAEAUMaterial@BfresFile@@_K@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::operator[]
PUBLIC	??0?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::vector<BfresFile::Model,std::allocator<BfresFile::Model> >
PUBLIC	?push_back@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAXAEBUModel@BfresFile@@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::push_back
PUBLIC	?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::resize
PUBLIC	?_Unchecked_begin@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAPEAUModel@BfresFile@@XZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAPEAUModel@BfresFile@@XZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Unchecked_end
PUBLIC	?size@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEBA_KXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::size
PUBLIC	??0?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >
PUBLIC	?resize@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::resize
PUBLIC	??A?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAAEAUSkeletonBone@BfresFile@@_K@Z ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::operator[]
PUBLIC	?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::resize
PUBLIC	?data@?$vector@GV?$allocator@G@std@@@std@@QEAAPEAGXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::data
PUBLIC	??0?$initializer_list@E@std@@QEAA@PEBE0@Z	; std::initializer_list<unsigned char>::initializer_list<unsigned char>
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >
PUBLIC	?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::count
PUBLIC	??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >
PUBLIC	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::operator[]
PUBLIC	??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::~list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Unchecked_end
PUBLIC	?insert@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@2@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::insert
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >
PUBLIC	??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >
PUBLIC	??A?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAAAEAVTexture@@AEBQEAVTextureToGo@@@Z ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::operator[]
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator==
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@QEAVTextureToGo@@VTexture@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::operator++
PUBLIC	??0?$initializer_list@PEAVTexture@@@std@@QEAA@PEBQEAVTexture@@0@Z ; std::initializer_list<Texture *>::initializer_list<Texture *>
PUBLIC	??0?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?push_back@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::push_back
PUBLIC	?size@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::size
PUBLIC	??A?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@_K@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
PUBLIC	??0?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAA@XZ ; std::allocator<BfresFile::VertexBufferSize>::allocator<BfresFile::VertexBufferSize>
PUBLIC	??0?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >
PUBLIC	??1?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::~vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >
PUBLIC	??A?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAAEAUVertexBufferSize@BfresFile@@_K@Z ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::operator[]
PUBLIC	??0?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAA@XZ ; std::allocator<BfresFile::VertexBufferAttribute>::allocator<BfresFile::VertexBufferAttribute>
PUBLIC	??0?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >
PUBLIC	??1?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::~vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >
PUBLIC	?_Unchecked_begin@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Unchecked_end
PUBLIC	??A?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAAEAUVertexBufferAttribute@BfresFile@@_K@Z ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::operator[]
PUBLIC	??0?$allocator@UVertexBuffer@BfresFile@@@std@@QEAA@XZ ; std::allocator<BfresFile::VertexBuffer>::allocator<BfresFile::VertexBuffer>
PUBLIC	??0?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBuffer@BfresFile@@@1@@Z ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >
PUBLIC	??1?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::~vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >
PUBLIC	??A?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAAEAUVertexBuffer@BfresFile@@_K@Z ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::operator[]
PUBLIC	?Delete@BfresFile@@QEAAXXZ			; BfresFile::Delete
PUBLIC	??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BfresFile::BfresFile
PUBLIC	?__autoclassinit2@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::__autoclassinit2
PUBLIC	??1?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?__autoclassinit2@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::__autoclassinit2
PUBLIC	??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z ; BfresFile::BfresFile
PUBLIC	?IsDefaultModel@BfresFile@@QEAAAEA_NXZ		; BfresFile::IsDefaultModel
PUBLIC	?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z ; BfresFile::ReadString
PUBLIC	?CombineToUInt16@BfresFile@@AEAAGEE@Z		; BfresFile::CombineToUInt16
PUBLIC	?UInt32ToFloat@BfresFile@@AEAAMEEEE@Z		; BfresFile::UInt32ToFloat
PUBLIC	?ShortToFloat@BfresFile@@AEAAMEE@Z		; BfresFile::ShortToFloat
PUBLIC	?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z ; BfresFile::CreateDefaultAreaModel
PUBLIC	??0BfresFile@@QEAA@$$QEAV0@@Z			; BfresFile::BfresFile
PUBLIC	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>
PUBLIC	?__autoclassinit2@TextureToGo@@QEAAX_K@Z	; TextureToGo::__autoclassinit2
PUBLIC	??1TextureToGo@@QEAA@XZ				; TextureToGo::~TextureToGo
PUBLIC	??0BfresTexture@BfresFile@@QEAA@XZ		; BfresFile::BfresTexture::BfresTexture
PUBLIC	?__autoclassinit2@BfresFile@@QEAAX_K@Z		; BfresFile::__autoclassinit2
PUBLIC	??0Material@BfresFile@@QEAA@XZ			; BfresFile::Material::Material
PUBLIC	??0LOD@BfresFile@@QEAA@XZ			; BfresFile::LOD::LOD
PUBLIC	??0Model@BfresFile@@QEAA@XZ			; BfresFile::Model::Model
PUBLIC	?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z ; BfresFile::CreateDefaultModel
PUBLIC	??4Mesh@@QEAAAEAV0@$$QEAV0@@Z			; Mesh::operator=
PUBLIC	?__autoclassinit2@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z ; std::vector<float,std::allocator<float> >::__autoclassinit2
PUBLIC	?CreateOpenGLObjects@BfresFile@@QEAAXXZ		; BfresFile::CreateOpenGLObjects
PUBLIC	?GenerateBoundingBox@BfresFile@@AEAAXXZ		; BfresFile::GenerateBoundingBox
PUBLIC	?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::__autoclassinit2
PUBLIC	?Cleanup@GLTextureLibrary@@YAXXZ		; GLTextureLibrary::Cleanup
PUBLIC	??1?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@XZ ; std::pair<TextureToGo * const,Texture>::~pair<TextureToGo * const,Texture>
PUBLIC	??1Texture@@QEAA@XZ				; Texture::~Texture
PUBLIC	?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; GLTextureLibrary::GetTexture
PUBLIC	?IsTextureLoaded@GLTextureLibrary@@YA_NPEAVTextureToGo@@@Z ; GLTextureLibrary::IsTextureLoaded
PUBLIC	??1?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::~_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >
PUBLIC	??1?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::~unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >
PUBLIC	?__autoclassinit2@?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAAX_K@Z ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::__autoclassinit2
PUBLIC	?Cleanup@BfresLibrary@@YAXXZ			; BfresLibrary::Cleanup
PUBLIC	?IsModelLoaded@BfresLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BfresLibrary::IsModelLoaded
PUBLIC	?Initialize@BfresLibrary@@YAXXZ			; BfresLibrary::Initialize
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >
PUBLIC	?__autoclassinit2@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAX_K@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::__autoclassinit2
PUBLIC	??0Mesh@@QEAA@XZ				; Mesh::Mesh
PUBLIC	??0Texture@@QEAA@XZ				; Texture::Texture
PUBLIC	??0TextureToGo@@QEAA@XZ				; TextureToGo::TextureToGo
PUBLIC	??0EBO@@QEAA@XZ					; EBO::EBO
PUBLIC	??0VAO@@QEAA@XZ					; VAO::VAO
PUBLIC	??0VBO@@QEAA@XZ					; VBO::VBO
PUBLIC	?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BfresLibrary::GetModel
PUBLIC	?GetModels@BfresFile@@QEAAAEAV?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@XZ ; BfresFile::GetModels
PUBLIC	?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures
PUBLIC	?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A DB 040H DUP (?) ; GLTextureLibrary::Textures
?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A DB 010H DUP (?) ; BfresLibrary::Models
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Mesh@@QEAA@$$QEAV0@@Z DD imagerel $LN41
	DD	imagerel $LN41+167
	DD	imagerel $unwind$??0Mesh@@QEAA@$$QEAV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0LOD@BfresFile@@QEAA@$$QEAU01@@Z DD imagerel $LN53
	DD	imagerel $LN53+163
	DD	imagerel $unwind$??0LOD@BfresFile@@QEAA@$$QEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Model@BfresFile@@QEAA@$$QEAU01@@Z DD imagerel $LN53
	DD	imagerel $LN53+171
	DD	imagerel $unwind$??0Model@BfresFile@@QEAA@$$QEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@VMesh@@V1@$0A@@std@@YAPEAVMesh@@QEAV1@$$QEAV1@@Z DD imagerel $LN44
	DD	imagerel $LN44+167
	DD	imagerel $unwind$??$construct_at@VMesh@@V1@$0A@@std@@YAPEAVMesh@@QEAV1@$$QEAV1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@ULOD@BfresFile@@U12@$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@$$QEAU12@@Z DD imagerel $LN56
	DD	imagerel $LN56+163
	DD	imagerel $unwind$??$construct_at@ULOD@BfresFile@@U12@$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@$$QEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UModel@BfresFile@@U12@$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@$$QEAU12@@Z DD imagerel $LN56
	DD	imagerel $LN56+171
	DD	imagerel $unwind$??$construct_at@UModel@BfresFile@@U12@$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@$$QEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD imagerel $LN7
	DD	imagerel $LN7+41
	DD	imagerel $unwind$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@$$QEAU01@@Z DD imagerel $LN22
	DD	imagerel $LN22+134
	DD	imagerel $unwind$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@$$QEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@$$QEAU01@@Z DD imagerel $LN7
	DD	imagerel $LN7+48
	DD	imagerel $unwind$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@$$QEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z DD imagerel $LN27
	DD	imagerel $LN27+82
	DD	imagerel $unwind$??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@$$QEAU10@@Z DD imagerel $LN24
	DD	imagerel $LN24+134
	DD	imagerel $unwind$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@$$QEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@$$QEAU10@@Z DD imagerel $LN9
	DD	imagerel $LN9+48
	DD	imagerel $unwind$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@$$QEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z DD imagerel $LN10
	DD	imagerel $LN10+41
	DD	imagerel $unwind$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z DD imagerel $LN9
	DD	imagerel $LN9+69
	DD	imagerel $unwind$??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z DD imagerel $LN29
	DD	imagerel $LN29+78
	DD	imagerel $unwind$??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@VMesh@@@?$_Uninitialized_backout_al@V?$allocator@VMesh@@@std@@@std@@QEAAX$$QEAVMesh@@@Z DD imagerel $LN48
	DD	imagerel $LN48+183
	DD	imagerel $unwind$??$_Emplace_back@VMesh@@@?$_Uninitialized_backout_al@V?$allocator@VMesh@@@std@@@std@@QEAAX$$QEAVMesh@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@ULOD@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX$$QEAULOD@BfresFile@@@Z DD imagerel $LN60
	DD	imagerel $LN60+179
	DD	imagerel $unwind$??$_Emplace_back@ULOD@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX$$QEAULOD@BfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@UModel@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX$$QEAUModel@BfresFile@@@Z DD imagerel $LN60
	DD	imagerel $LN60+187
	DD	imagerel $unwind$??$_Emplace_back@UModel@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX$$QEAUModel@BfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z DD imagerel $LN14
	DD	imagerel $LN14+46
	DD	imagerel $unwind$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@$$QEAU31@@Z DD imagerel $LN26
	DD	imagerel $LN26+137
	DD	imagerel $unwind$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@$$QEAU31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@$$QEAU31@@Z DD imagerel $LN11
	DD	imagerel $LN11+50
	DD	imagerel $unwind$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@$$QEAU31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN33
	DD	imagerel $LN33+37
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DD imagerel $LN40
	DD	imagerel $LN40+43
	DD	imagerel $unwind$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+51
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAAPEAXI@Z DD imagerel $LN15
	DD	imagerel $LN15+27
	DD	imagerel $unwind$??_G?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+27
	DD	imagerel $unwind$??_G?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GVertexBufferAttribute@BfresFile@@QEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+23
	DD	imagerel $unwind$??_GVertexBufferAttribute@BfresFile@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GVertexBuffer@BfresFile@@QEAAPEAXI@Z DD imagerel $LN41
	DD	imagerel $LN41+93
	DD	imagerel $unwind$??_GVertexBuffer@BfresFile@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1VertexBuffer@BfresFile@@QEAA@XZ DD imagerel $LN36
	DD	imagerel $LN36+90
	DD	imagerel $unwind$??1VertexBuffer@BfresFile@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@UVertexBuffer@BfresFile@@@std@@YAXQEAUVertexBuffer@BfresFile@@@Z DD imagerel $LN44
	DD	imagerel $LN44+90
	DD	imagerel $unwind$??$destroy_at@UVertexBuffer@BfresFile@@@std@@YAXQEAUVertexBuffer@BfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+52
	DD	imagerel $unwind$??$_Uninitialized_move@PEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEBQEAVTexture@@PEAPEAV1@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEBQEAVTexture@@PEAPEAV1@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z DD imagerel $LN11
	DD	imagerel $LN11+71
	DD	imagerel $unwind$??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+88
	DD	imagerel $unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z DD imagerel $LN99
	DD	imagerel $LN99+22
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z DD imagerel $LN99+22
	DD	imagerel $LN99+172
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z DD imagerel $LN99+172
	DD	imagerel $LN99+180
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z DD imagerel $LN39
	DD	imagerel $LN39+103
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z DD imagerel $LN84
	DD	imagerel $LN84+22
	DD	imagerel $unwind$??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z DD imagerel $LN84+22
	DD	imagerel $LN84+230
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z DD imagerel $LN84+230
	DD	imagerel $LN84+238
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z DD imagerel $LN96
	DD	imagerel $LN96+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z DD imagerel $LN96+20
	DD	imagerel $LN96+225
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z DD imagerel $LN96+225
	DD	imagerel $LN96+230
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z DD imagerel $LN39
	DD	imagerel $LN39+103
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z DD imagerel $LN107
	DD	imagerel $LN107+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z DD imagerel $LN107+20
	DD	imagerel $LN107+171
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z DD imagerel $LN107+171
	DD	imagerel $LN107+176
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z DD imagerel $LN107
	DD	imagerel $LN107+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z DD imagerel $LN107+20
	DD	imagerel $LN107+234
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z DD imagerel $LN107+234
	DD	imagerel $LN107+239
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUSkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+78
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUSkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAG@std@@YAPEAGQEAG0@Z DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$??$_Zero_range@PEAG@std@@YAPEAGQEAG0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN74
	DD	imagerel $LN74+94
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN16
	DD	imagerel $LN16+46
	DD	imagerel $unwind$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DD imagerel $LN73
	DD	imagerel $LN73+226
	DD	imagerel $unwind$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN11
	DD	imagerel $LN11+40
	DD	imagerel $unwind$??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN20
	DD	imagerel $LN20+131
	DD	imagerel $unwind$??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DD imagerel $LN54
	DD	imagerel $LN54+134
	DD	imagerel $unwind$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+136
	DD	imagerel $unwind$?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z DD imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z DD imagerel $LN47+39
	DD	imagerel $LN47+98
	DD	imagerel $chain$0$?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z DD imagerel $LN47+98
	DD	imagerel $LN47+179
	DD	imagerel $chain$1$?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAXQEAV?$vector@IV?$allocator@I@std@@@2@_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+180
	DD	imagerel $unwind$?_Change_array@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAXQEAV?$vector@IV?$allocator@I@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z DD imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z DD imagerel $LN47+39
	DD	imagerel $LN47+120
	DD	imagerel $chain$0$?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z DD imagerel $LN47+120
	DD	imagerel $LN47+209
	DD	imagerel $chain$1$?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z DD imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z DD imagerel $LN47+39
	DD	imagerel $LN47+120
	DD	imagerel $chain$0$?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z DD imagerel $LN47+120
	DD	imagerel $LN47+209
	DD	imagerel $chain$1$?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXQEAV?$vector@MV?$allocator@M@std@@@2@_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+180
	DD	imagerel $unwind$?_Change_array@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXQEAV?$vector@MV?$allocator@M@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z DD imagerel $LN55
	DD	imagerel $LN55+39
	DD	imagerel $unwind$?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z DD imagerel $LN55+39
	DD	imagerel $LN55+107
	DD	imagerel $chain$0$?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z DD imagerel $LN55+107
	DD	imagerel $LN55+188
	DD	imagerel $chain$1$?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z DD imagerel $LN58
	DD	imagerel $LN58+43
	DD	imagerel $unwind$?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z DD imagerel $LN58+43
	DD	imagerel $LN58+154
	DD	imagerel $chain$0$?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z DD imagerel $LN58+154
	DD	imagerel $LN58+235
	DD	imagerel $chain$1$?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXQEAUSkeletonBone@BfresFile@@_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+160
	DD	imagerel $unwind$?_Change_array@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXQEAUSkeletonBone@BfresFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+34
	DD	imagerel $unwind$?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+116
	DD	imagerel $unwind$?allocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z DD imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z DD imagerel $LN53+40
	DD	imagerel $LN53+122
	DD	imagerel $chain$0$?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z DD imagerel $LN53+122
	DD	imagerel $LN53+206
	DD	imagerel $chain$1$?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN33
	DD	imagerel $LN33+37
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN43
	DD	imagerel $LN43+57
	DD	imagerel $unwind$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN65
	DD	imagerel $LN65+36
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@UVertexBuffer@BfresFile@@@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBuffer@BfresFile@@@1@QEAUVertexBuffer@BfresFile@@@Z DD imagerel $LN47
	DD	imagerel $LN47+90
	DD	imagerel $unwind$??$destroy@UVertexBuffer@BfresFile@@@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBuffer@BfresFile@@@1@QEAUVertexBuffer@BfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEBE_KPEAE@std@@YAPEAEPEBE_KPEAE@Z DD imagerel $LN16
	DD	imagerel $LN16+45
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEBE_KPEAE@std@@YAPEAEPEBE_KPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_n@PEBEPEAE@std@@YAPEAEPEBE_KPEAE@Z DD imagerel $LN6
	DD	imagerel $LN6+45
	DD	imagerel $unwind$??$_Copy_memmove_n@PEBEPEAE@std@@YAPEAEPEBE_KPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEBEV?$allocator@E@std@@@std@@YAPEAEPEBE_KPEAEAEAV?$allocator@E@0@@Z DD imagerel $LN25
	DD	imagerel $LN25+45
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEBEV?$allocator@E@std@@@std@@YAPEAEPEBE_KPEAEAEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+46
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN69
	DD	imagerel $LN69+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN69+33
	DD	imagerel $LN69+181
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN69+181
	DD	imagerel $LN69+187
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEBQEAVTexture@@PEBQEAV1@V?$allocator@PEAVTexture@@@std@@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@AEAV?$allocator@PEAVTexture@@@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+52
	DD	imagerel $unwind$??$_Uninitialized_copy@PEBQEAVTexture@@PEBQEAV1@V?$allocator@PEAVTexture@@@std@@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@AEAV?$allocator@PEAVTexture@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z DD imagerel $LN30
	DD	imagerel $LN30+284
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$2@?0???$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z@4HA DD imagerel ?catch$2@?0???$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z@4HA
	DD	imagerel ?catch$2@?0???$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z@4HA+52
	DD	imagerel $unwind$?catch$2@?0???$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z DD imagerel $LN13
	DD	imagerel $LN13+92
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z DD imagerel $LN66
	DD	imagerel $LN66+193
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN19
	DD	imagerel $LN19+201
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA DD imagerel ?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA+49
	DD	imagerel $unwind$?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN41
	DD	imagerel $LN41+127
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN41+127
	DD	imagerel $LN41+312
	DD	imagerel $chain$0$??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN41+312
	DD	imagerel $LN41+318
	DD	imagerel $chain$1$??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z DD imagerel $LN33
	DD	imagerel $LN33+57
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN51
	DD	imagerel $LN51+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN51+34
	DD	imagerel $LN51+144
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN51+144
	DD	imagerel $LN51+234
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN51+234
	DD	imagerel $LN51+240
	DD	imagerel $chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN208
	DD	imagerel $LN208+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN208+34
	DD	imagerel $LN208+418
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN208+418
	DD	imagerel $LN208+489
	DD	imagerel $chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN208+489
	DD	imagerel $LN208+575
	DD	imagerel $chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN208+575
	DD	imagerel $LN208+582
	DD	imagerel $chain$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN208+582
	DD	imagerel $LN208+588
	DD	imagerel $chain$7$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z DD imagerel $LN26
	DD	imagerel $LN26+311
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z@4HA+52
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z DD imagerel $LN8
	DD	imagerel $LN8+36
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+50
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+50
	DD	imagerel $LN21+208
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+208
	DD	imagerel $LN21+214
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN41
	DD	imagerel $LN41+127
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN41+127
	DD	imagerel $LN41+312
	DD	imagerel $chain$0$??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN41+312
	DD	imagerel $LN41+318
	DD	imagerel $chain$1$??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z DD imagerel $LN33
	DD	imagerel $LN33+57
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN51
	DD	imagerel $LN51+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN51+34
	DD	imagerel $LN51+144
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN51+144
	DD	imagerel $LN51+234
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN51+234
	DD	imagerel $LN51+240
	DD	imagerel $chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z DD imagerel $LN26
	DD	imagerel $LN26+260
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z@4HA+52
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z DD imagerel $LN8
	DD	imagerel $LN8+36
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+41
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+41
	DD	imagerel $LN21+189
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+189
	DD	imagerel $LN21+195
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z DD imagerel $LN26
	DD	imagerel $LN26+300
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z@4HA+52
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z DD imagerel $LN8
	DD	imagerel $LN8+36
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+40
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+40
	DD	imagerel $LN21+204
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN21+204
	DD	imagerel $LN21+210
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN98
	DD	imagerel $LN98+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN98+33
	DD	imagerel $LN98+41
	DD	imagerel $chain$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN98+41
	DD	imagerel $LN98+147
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN98+147
	DD	imagerel $LN98+349
	DD	imagerel $chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN98+349
	DD	imagerel $LN98+356
	DD	imagerel $chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN98+356
	DD	imagerel $LN98+362
	DD	imagerel $chain$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@G@std@@@std@@YAPEAGPEAG_KAEAV?$allocator@G@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+42
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@G@std@@@std@@YAPEAGPEAG_KAEAV?$allocator@G@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN65
	DD	imagerel $LN65+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN65+33
	DD	imagerel $LN65+174
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN65+174
	DD	imagerel $LN65+180
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z DD imagerel $LN85
	DD	imagerel $LN85+26
	DD	imagerel $unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z DD imagerel $LN85+26
	DD	imagerel $LN85+151
	DD	imagerel $chain$2$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z DD imagerel $LN85+151
	DD	imagerel $LN85+161
	DD	imagerel $chain$3$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN59
	DD	imagerel $LN59+143
	DD	imagerel $unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z DD imagerel $LN86
	DD	imagerel $LN86+141
	DD	imagerel $unwind$??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN65
	DD	imagerel $LN65+105
	DD	imagerel $unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z DD imagerel $LN156
	DD	imagerel $LN156+106
	DD	imagerel $unwind$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z DD imagerel $LN156+106
	DD	imagerel $LN156+543
	DD	imagerel $chain$2$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z DD imagerel $LN156+543
	DD	imagerel $LN156+550
	DD	imagerel $chain$4$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z DD imagerel $LN156+550
	DD	imagerel $LN156+556
	DD	imagerel $chain$5$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z DD imagerel $LN156+556
	DD	imagerel $LN156+562
	DD	imagerel $chain$6$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z DD imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z DD imagerel $LN26+14
	DD	imagerel $LN26+52
	DD	imagerel $chain$0$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z DD imagerel $LN26+52
	DD	imagerel $LN26+61
	DD	imagerel $chain$1$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAPEAUVertexBuffer@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z DD imagerel $LN36
	DD	imagerel $LN36+94
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAPEAUVertexBuffer@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DD imagerel $LN147
	DD	imagerel $LN147+402
	DD	imagerel $unwind$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z DD imagerel $LN45
	DD	imagerel $LN45+42
	DD	imagerel $unwind$??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z DD imagerel $LN45+42
	DD	imagerel $LN45+117
	DD	imagerel $chain$0$??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z DD imagerel $LN45+117
	DD	imagerel $LN45+124
	DD	imagerel $chain$1$??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z DD imagerel $LN41
	DD	imagerel $LN41+42
	DD	imagerel $unwind$??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z DD imagerel $LN41+42
	DD	imagerel $LN41+117
	DD	imagerel $chain$0$??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z DD imagerel $LN41+117
	DD	imagerel $LN41+124
	DD	imagerel $chain$1$??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DD imagerel $LN146
	DD	imagerel $LN146+318
	DD	imagerel $unwind$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN68
	DD	imagerel $LN68+64
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN79
	DD	imagerel $LN79+35
	DD	imagerel $unwind$?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN79+35
	DD	imagerel $LN79+86
	DD	imagerel $chain$0$?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN79+86
	DD	imagerel $LN79+118
	DD	imagerel $chain$1$?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN248
	DD	imagerel $LN248+44
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN248+44
	DD	imagerel $LN248+608
	DD	imagerel $chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN248+608
	DD	imagerel $LN248+621
	DD	imagerel $chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN94
	DD	imagerel $LN94+62
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN94+62
	DD	imagerel $LN94+86
	DD	imagerel $chain$0$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN94+86
	DD	imagerel $LN94+134
	DD	imagerel $chain$1$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN94+134
	DD	imagerel $LN94+189
	DD	imagerel $chain$2$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN94+189
	DD	imagerel $LN94+195
	DD	imagerel $chain$3$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN10
	DD	imagerel $LN10+103
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAPEAUVertexBufferSize@BfresFile@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAPEAUVertexBufferSize@BfresFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+116
	DD	imagerel $unwind$?allocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAPEAUVertexBuffer@BfresFile@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+116
	DD	imagerel $unwind$?allocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAPEAUVertexBuffer@BfresFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN21
	DD	imagerel $LN21+166
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN151
	DD	imagerel $LN151+136
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN151+136
	DD	imagerel $LN151+466
	DD	imagerel $chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN151+466
	DD	imagerel $LN151+477
	DD	imagerel $chain$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+136
	DD	imagerel $unwind$?_Buy_raw@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+140
	DD	imagerel $unwind$?_Buy_raw@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+140
	DD	imagerel $unwind$?_Buy_raw@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN6
	DD	imagerel $LN6+42
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN23
	DD	imagerel $LN23+170
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45
	DD	imagerel $LN45+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+24
	DD	imagerel $LN45+131
	DD	imagerel $chain$0$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+131
	DD	imagerel $LN45+137
	DD	imagerel $chain$1$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+137
	DD	imagerel $LN45+143
	DD	imagerel $chain$2$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45
	DD	imagerel $LN45+28
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+28
	DD	imagerel $LN45+135
	DD	imagerel $chain$0$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+135
	DD	imagerel $LN45+141
	DD	imagerel $chain$1$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+141
	DD	imagerel $LN45+147
	DD	imagerel $chain$2$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45
	DD	imagerel $LN45+28
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+28
	DD	imagerel $LN45+135
	DD	imagerel $chain$0$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+135
	DD	imagerel $LN45+141
	DD	imagerel $chain$1$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+141
	DD	imagerel $LN45+147
	DD	imagerel $chain$2$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN48
	DD	imagerel $LN48+57
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z DD imagerel $LN29
	DD	imagerel $LN29+36
	DD	imagerel $unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21+62
	DD	imagerel $LN21+98
	DD	imagerel $chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21+98
	DD	imagerel $LN21+132
	DD	imagerel $chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN76
	DD	imagerel $LN76+25
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN76+25
	DD	imagerel $LN76+70
	DD	imagerel $chain$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN76+70
	DD	imagerel $LN76+76
	DD	imagerel $chain$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+50
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAXPEAUVertexBufferAttribute@BfresFile@@QEAU12@AEAV?$allocator@UVertexBufferAttribute@BfresFile@@@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+49
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAXPEAUVertexBufferAttribute@BfresFile@@QEAU12@AEAV?$allocator@UVertexBufferAttribute@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z DD imagerel $LN62
	DD	imagerel $LN62+10
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z DD imagerel $LN62+10
	DD	imagerel $LN62+124
	DD	imagerel $chain$1$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z DD imagerel $LN62+124
	DD	imagerel $LN62+125
	DD	imagerel $chain$2$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z DD imagerel $LN62+125
	DD	imagerel $LN62+132
	DD	imagerel $chain$3$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEBE_K@Z DD imagerel $LN83
	DD	imagerel $LN83+161
	DD	imagerel $unwind$??$_Assign_counted_range@PEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEBE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD imagerel $LN45
	DD	imagerel $LN45+36
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD imagerel $LN45+36
	DD	imagerel $LN45+104
	DD	imagerel $chain$0$??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD imagerel $LN45+104
	DD	imagerel $LN45+111
	DD	imagerel $chain$1$??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN36
	DD	imagerel $LN36+93
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN36+93
	DD	imagerel $LN36+132
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN36+132
	DD	imagerel $LN36+143
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z DD imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z DD imagerel $LN39+37
	DD	imagerel $LN39+95
	DD	imagerel $chain$0$??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z DD imagerel $LN39+95
	DD	imagerel $LN39+102
	DD	imagerel $chain$1$??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z DD imagerel $LN16
	DD	imagerel $LN16+124
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+51
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+51
	DD	imagerel $LN28+107
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+107
	DD	imagerel $LN28+190
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN41
	DD	imagerel $LN41+53
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN41+53
	DD	imagerel $LN41+93
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN41+93
	DD	imagerel $LN41+191
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+50
	DD	imagerel $LN28+123
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+123
	DD	imagerel $LN28+191
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z DD imagerel $LN12
	DD	imagerel $LN12+61
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+50
	DD	imagerel $LN28+123
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+123
	DD	imagerel $LN28+191
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN41
	DD	imagerel $LN41+53
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN41+53
	DD	imagerel $LN41+93
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN41+93
	DD	imagerel $LN41+191
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@$$V@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN21
	DD	imagerel $LN21+94
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z DD imagerel $LN12
	DD	imagerel $LN12+61
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN36
	DD	imagerel $LN36+51
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN36+51
	DD	imagerel $LN36+116
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN36+116
	DD	imagerel $LN36+196
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z DD imagerel $LN12
	DD	imagerel $LN12+61
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN39
	DD	imagerel $LN39+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN39+50
	DD	imagerel $LN39+67
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN39+67
	DD	imagerel $LN39+133
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN39+133
	DD	imagerel $LN39+154
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN39+154
	DD	imagerel $LN39+222
	DD	imagerel $chain$3$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN8
	DD	imagerel $LN8+113
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN36
	DD	imagerel $LN36+91
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN36+91
	DD	imagerel $LN36+126
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN36+126
	DD	imagerel $LN36+137
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z DD imagerel $LN49
	DD	imagerel $LN49+39
	DD	imagerel $unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN159
	DD	imagerel $LN159+323
	DD	imagerel $unwind$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z DD imagerel $LN238
	DD	imagerel $LN238+609
	DD	imagerel $unwind$??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z DD imagerel $LN209
	DD	imagerel $LN209+574
	DD	imagerel $unwind$??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83
	DD	imagerel $LN83+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+40
	DD	imagerel $LN83+202
	DD	imagerel $chain$3$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+202
	DD	imagerel $LN83+203
	DD	imagerel $chain$4$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+203
	DD	imagerel $LN83+209
	DD	imagerel $chain$5$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+209
	DD	imagerel $LN83+215
	DD	imagerel $chain$6$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN122
	DD	imagerel $LN122+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN122+40
	DD	imagerel $LN122+241
	DD	imagerel $chain$3$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN122+241
	DD	imagerel $LN122+242
	DD	imagerel $chain$4$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN122+242
	DD	imagerel $LN122+248
	DD	imagerel $chain$5$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN122+248
	DD	imagerel $LN122+254
	DD	imagerel $chain$6$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN95
	DD	imagerel $LN95+41
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN95+41
	DD	imagerel $LN95+297
	DD	imagerel $chain$4$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN95+297
	DD	imagerel $LN95+298
	DD	imagerel $chain$5$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN95+298
	DD	imagerel $LN95+304
	DD	imagerel $chain$6$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN95+304
	DD	imagerel $LN95+310
	DD	imagerel $chain$7$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??$?0AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAVTextureToGo@@AEAY03$$CBD$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAPEAVTextureToGo@@AEAY03$$CBD@Z DD imagerel $LN18
	DD	imagerel $LN18+60
	DD	imagerel $unwind$??$?0PEAVTextureToGo@@AEAY03$$CBD$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAPEAVTextureToGo@@AEAY03$$CBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DD imagerel $LN157
	DD	imagerel $LN157+401
	DD	imagerel $unwind$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0TextureToGo@@QEAA@AEBV0@@Z DD imagerel $LN6
	DD	imagerel $LN6+102
	DD	imagerel $unwind$??0TextureToGo@@QEAA@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z DD imagerel $LN7
	DD	imagerel $LN7+54
	DD	imagerel $unwind$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z DD imagerel $LN53
	DD	imagerel $LN53+65
	DD	imagerel $unwind$??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z DD imagerel $LN53+65
	DD	imagerel $LN53+120
	DD	imagerel $chain$0$??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z DD imagerel $LN53+120
	DD	imagerel $LN53+139
	DD	imagerel $chain$1$??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z DD imagerel $LN49
	DD	imagerel $LN49+65
	DD	imagerel $unwind$??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z DD imagerel $LN49+65
	DD	imagerel $LN49+120
	DD	imagerel $chain$0$??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z DD imagerel $LN49+120
	DD	imagerel $LN49+139
	DD	imagerel $chain$1$??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAVBfresFile@@@Z DD imagerel $LN7
	DD	imagerel $LN7+47
	DD	imagerel $unwind$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAVBfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAY07$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY07$$CBD$$QEAVBfresFile@@@Z DD imagerel $LN19
	DD	imagerel $LN19+74
	DD	imagerel $unwind$??$?0AEAY07$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY07$$CBD$$QEAVBfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DD imagerel $LN156
	DD	imagerel $LN156+317
	DD	imagerel $unwind$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAY04$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY04$$CBD$$QEAVBfresFile@@@Z DD imagerel $LN19
	DD	imagerel $LN19+74
	DD	imagerel $unwind$??$?0AEAY04$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY04$$CBD$$QEAVBfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN33
	DD	imagerel $LN33+35
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAXQEAU?$mat@$03$03M$0A@@glm@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+66
	DD	imagerel $unwind$?deallocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAXQEAU?$mat@$03$03M$0A@@glm@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN32
	DD	imagerel $LN32+43
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z DD imagerel $LN41
	DD	imagerel $LN41+45
	DD	imagerel $unwind$??0?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z DD imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z DD imagerel $LN88+54
	DD	imagerel $LN88+270
	DD	imagerel $chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z DD imagerel $LN88+270
	DD	imagerel $LN88+277
	DD	imagerel $chain$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z DD imagerel $LN88+277
	DD	imagerel $LN88+301
	DD	imagerel $chain$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z DD imagerel $LN88+301
	DD	imagerel $LN88+307
	DD	imagerel $chain$5$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAXQEAUVertexBufferSize@BfresFile@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAXQEAUVertexBufferSize@BfresFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAXQEAUVertexBufferAttribute@BfresFile@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAXQEAUVertexBufferAttribute@BfresFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAXQEAUVertexBuffer@BfresFile@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAXQEAUVertexBuffer@BfresFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xrange@?$vector@MV?$allocator@M@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xrange@?$vector@MV?$allocator@M@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+92
	DD	imagerel $unwind$?_Tidy@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD imagerel $LN42
	DD	imagerel $LN42+61
	DD	imagerel $unwind$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN122
	DD	imagerel $LN122+35
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN122+35
	DD	imagerel $LN122+86
	DD	imagerel $chain$0$?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN122+86
	DD	imagerel $LN122+109
	DD	imagerel $chain$1$?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z DD imagerel $LN60
	DD	imagerel $LN60+160
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN32
	DD	imagerel $LN32+92
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN53
	DD	imagerel $LN53+21
	DD	imagerel $unwind$?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN53+21
	DD	imagerel $LN53+103
	DD	imagerel $chain$0$?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN53+103
	DD	imagerel $LN53+163
	DD	imagerel $chain$1$?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+92
	DD	imagerel $unwind$?_Tidy@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ DD imagerel $LN53
	DD	imagerel $LN53+21
	DD	imagerel $unwind$?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ DD imagerel $LN53+21
	DD	imagerel $LN53+102
	DD	imagerel $chain$0$?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ DD imagerel $LN53+102
	DD	imagerel $LN53+162
	DD	imagerel $chain$1$?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+126
	DD	imagerel $unwind$?_Tidy@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@V?$initializer_list@E@1@@Z DD imagerel $LN88
	DD	imagerel $LN88+191
	DD	imagerel $unwind$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@V?$initializer_list@E@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z DD imagerel $LN51
	DD	imagerel $LN51+49
	DD	imagerel $unwind$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z DD imagerel $LN51+49
	DD	imagerel $LN51+107
	DD	imagerel $chain$0$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z DD imagerel $LN51+107
	DD	imagerel $LN51+127
	DD	imagerel $chain$1$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+24
	DD	imagerel $LN39+134
	DD	imagerel $chain$0$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+134
	DD	imagerel $LN39+148
	DD	imagerel $chain$1$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+148
	DD	imagerel $LN39+155
	DD	imagerel $chain$2$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z DD imagerel $LN38
	DD	imagerel $LN38+93
	DD	imagerel $unwind$?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z DD imagerel $LN38+93
	DD	imagerel $LN38+132
	DD	imagerel $chain$0$?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z DD imagerel $LN38+132
	DD	imagerel $LN38+143
	DD	imagerel $chain$1$?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?at@?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$?at@?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+24
	DD	imagerel $LN39+134
	DD	imagerel $chain$0$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+134
	DD	imagerel $LN39+148
	DD	imagerel $chain$1$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+148
	DD	imagerel $LN39+155
	DD	imagerel $chain$2$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z DD imagerel $LN47
	DD	imagerel $LN47+69
	DD	imagerel $unwind$??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z DD imagerel $LN47+69
	DD	imagerel $LN47+109
	DD	imagerel $chain$0$??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z DD imagerel $LN47+109
	DD	imagerel $LN47+132
	DD	imagerel $chain$1$??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+24
	DD	imagerel $LN39+134
	DD	imagerel $chain$0$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+134
	DD	imagerel $LN39+148
	DD	imagerel $chain$1$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN39+148
	DD	imagerel $LN39+155
	DD	imagerel $chain$2$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+92
	DD	imagerel $unwind$??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z DD imagerel $LN18
	DD	imagerel $LN18+117
	DD	imagerel $unwind$?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30
	DD	imagerel $LN30+51
	DD	imagerel $unwind$?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+51
	DD	imagerel $LN30+107
	DD	imagerel $chain$0$?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+107
	DD	imagerel $LN30+190
	DD	imagerel $chain$1$?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN43
	DD	imagerel $LN43+53
	DD	imagerel $unwind$?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN43+53
	DD	imagerel $LN43+93
	DD	imagerel $chain$0$?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN43+93
	DD	imagerel $LN43+191
	DD	imagerel $chain$1$?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+50
	DD	imagerel $LN30+123
	DD	imagerel $chain$1$?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+123
	DD	imagerel $LN30+191
	DD	imagerel $chain$2$?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAXXZ DD imagerel $LN24
	DD	imagerel $LN24+72
	DD	imagerel $unwind$?clear@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAXAEBULOD@BfresFile@@@Z DD imagerel $LN14
	DD	imagerel $LN14+54
	DD	imagerel $unwind$?push_back@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAXAEBULOD@BfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+50
	DD	imagerel $LN30+123
	DD	imagerel $chain$1$?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+123
	DD	imagerel $LN30+191
	DD	imagerel $chain$2$?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN43
	DD	imagerel $LN43+53
	DD	imagerel $unwind$?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN43+53
	DD	imagerel $LN43+93
	DD	imagerel $chain$0$?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN43+93
	DD	imagerel $LN43+191
	DD	imagerel $chain$1$?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UMaterial@BfresFile@@@1@@Z DD imagerel $LN97
	DD	imagerel $LN97+184
	DD	imagerel $unwind$??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UMaterial@BfresFile@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAXAEBUMaterial@BfresFile@@@Z DD imagerel $LN14
	DD	imagerel $LN14+54
	DD	imagerel $unwind$?push_back@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAXAEBUMaterial@BfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN38
	DD	imagerel $LN38+51
	DD	imagerel $unwind$?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN38+51
	DD	imagerel $LN38+116
	DD	imagerel $chain$0$?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN38+116
	DD	imagerel $LN38+196
	DD	imagerel $chain$1$?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAXAEBUModel@BfresFile@@@Z DD imagerel $LN14
	DD	imagerel $LN14+54
	DD	imagerel $unwind$?push_back@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAXAEBUModel@BfresFile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN41
	DD	imagerel $LN41+50
	DD	imagerel $unwind$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN41+50
	DD	imagerel $LN41+67
	DD	imagerel $chain$0$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN41+67
	DD	imagerel $LN41+133
	DD	imagerel $chain$1$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN41+133
	DD	imagerel $LN41+154
	DD	imagerel $chain$2$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN41+154
	DD	imagerel $LN41+222
	DD	imagerel $chain$3$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN10
	DD	imagerel $LN10+113
	DD	imagerel $unwind$?resize@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z DD imagerel $LN38
	DD	imagerel $LN38+91
	DD	imagerel $unwind$?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z DD imagerel $LN38+91
	DD	imagerel $LN38+126
	DD	imagerel $chain$0$?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z DD imagerel $LN38+126
	DD	imagerel $LN38+137
	DD	imagerel $chain$1$?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN52
	DD	imagerel $LN52+42
	DD	imagerel $unwind$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel $LN30
	DD	imagerel $LN30+130
	DD	imagerel $unwind$?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN46
	DD	imagerel $LN46+72
	DD	imagerel $unwind$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN161
	DD	imagerel $LN161+315
	DD	imagerel $unwind$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN125
	DD	imagerel $LN125+35
	DD	imagerel $unwind$??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN125+35
	DD	imagerel $LN125+86
	DD	imagerel $chain$0$??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN125+86
	DD	imagerel $LN125+109
	DD	imagerel $chain$1$??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?insert@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN35
	DD	imagerel $LN35+92
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ DD imagerel $LN70
	DD	imagerel $LN70+162
	DD	imagerel $unwind$??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAAAEAVTexture@@AEBQEAVTextureToGo@@@Z DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$??A?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAAAEAVTexture@@AEBQEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN56
	DD	imagerel $LN56+21
	DD	imagerel $unwind$??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN56+21
	DD	imagerel $LN56+103
	DD	imagerel $chain$0$??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN56+103
	DD	imagerel $LN56+163
	DD	imagerel $chain$1$??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z DD imagerel $LN84
	DD	imagerel $LN84+210
	DD	imagerel $unwind$??0?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+92
	DD	imagerel $unwind$??1?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z DD imagerel $LN125
	DD	imagerel $LN125+265
	DD	imagerel $unwind$??0?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBuffer@BfresFile@@@1@@Z DD imagerel $LN9
	DD	imagerel $LN9+36
	DD	imagerel $unwind$??0?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBuffer@BfresFile@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Delete@BfresFile@@QEAAXXZ DD imagerel $LN42
	DD	imagerel $LN42+19
	DD	imagerel $unwind$?Delete@BfresFile@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?Delete@BfresFile@@QEAAXXZ DD imagerel $LN42+19
	DD	imagerel $LN42+40
	DD	imagerel $chain$0$?Delete@BfresFile@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?Delete@BfresFile@@QEAAXXZ DD imagerel $LN42+40
	DD	imagerel $LN42+221
	DD	imagerel $chain$3$?Delete@BfresFile@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?Delete@BfresFile@@QEAAXXZ DD imagerel $LN42+221
	DD	imagerel $LN42+226
	DD	imagerel $chain$4$?Delete@BfresFile@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?Delete@BfresFile@@QEAAXXZ DD imagerel $LN42+226
	DD	imagerel $LN42+232
	DD	imagerel $chain$5$?Delete@BfresFile@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN273
	DD	imagerel $LN273+1133
	DD	imagerel $unwind$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEBA@HAEAV?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@3@AEAM33@Z DD imagerel ??R<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEBA@HAEAV?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@3@AEAM33@Z
	DD	imagerel ??R<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEBA@HAEAV?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@3@AEAM33@Z+942
	DD	imagerel $unwind$??R<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEBA@HAEAV?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@3@AEAM33@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z DD imagerel $LN2913
	DD	imagerel $LN2913+12238
	DD	imagerel $unwind$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z DD imagerel $LN72
	DD	imagerel $LN72+288
	DD	imagerel $unwind$?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z@4HA DD imagerel ?dtor$0@?0??ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z@4HA
	DD	imagerel ?dtor$0@?0??ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z DD imagerel $LN649
	DD	imagerel $LN649+2391
	DD	imagerel $unwind$?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA DD imagerel ?dtor$1@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA
	DD	imagerel ?dtor$1@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0BfresFile@@QEAA@$$QEAV0@@Z DD imagerel $LN77
	DD	imagerel $LN77+188
	DD	imagerel $unwind$??0BfresFile@@QEAA@$$QEAV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ DD imagerel $LN43
	DD	imagerel $LN43+97
	DD	imagerel $unwind$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1TextureToGo@@QEAA@XZ DD imagerel $LN36
	DD	imagerel $LN36+90
	DD	imagerel $unwind$??1TextureToGo@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0BfresTexture@BfresFile@@QEAA@XZ DD imagerel $LN25
	DD	imagerel $LN25+70
	DD	imagerel $unwind$??0BfresTexture@BfresFile@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z DD imagerel $LN649
	DD	imagerel $LN649+2376
	DD	imagerel $unwind$?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA DD imagerel ?dtor$1@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA
	DD	imagerel ?dtor$1@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4Mesh@@QEAAAEAV0@$$QEAV0@@Z DD imagerel $LN40
	DD	imagerel $LN40+217
	DD	imagerel $unwind$??4Mesh@@QEAAAEAV0@$$QEAV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateOpenGLObjects@BfresFile@@QEAAXXZ DD imagerel $LN480
	DD	imagerel $LN480+2137
	DD	imagerel $unwind$?CreateOpenGLObjects@BfresFile@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenerateBoundingBox@BfresFile@@AEAAXXZ DD imagerel $LN64
	DD	imagerel $LN64+58
	DD	imagerel $unwind$?GenerateBoundingBox@BfresFile@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?GenerateBoundingBox@BfresFile@@AEAAXXZ DD imagerel $LN64+58
	DD	imagerel $LN64+378
	DD	imagerel $chain$5$?GenerateBoundingBox@BfresFile@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?GenerateBoundingBox@BfresFile@@AEAAXXZ DD imagerel $LN64+378
	DD	imagerel $LN64+390
	DD	imagerel $chain$6$?GenerateBoundingBox@BfresFile@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Cleanup@GLTextureLibrary@@YAXXZ DD imagerel $LN70
	DD	imagerel $LN70+179
	DD	imagerel $unwind$?Cleanup@GLTextureLibrary@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD imagerel $LN125
	DD	imagerel $LN125+509
	DD	imagerel $unwind$?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN38
	DD	imagerel $LN38+102
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FTextures@GLTextureLibrary@@YAXXZ DD imagerel ??__FTextures@GLTextureLibrary@@YAXXZ
	DD	imagerel ??__FTextures@GLTextureLibrary@@YAXXZ+113
	DD	imagerel $unwind$??__FTextures@GLTextureLibrary@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ETextures@GLTextureLibrary@@YAXXZ DD imagerel ??__ETextures@GLTextureLibrary@@YAXXZ
	DD	imagerel ??__ETextures@GLTextureLibrary@@YAXXZ+119
	DD	imagerel $unwind$??__ETextures@GLTextureLibrary@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Cleanup@BfresLibrary@@YAXXZ DD imagerel $LN75
	DD	imagerel $LN75+230
	DD	imagerel $unwind$?Cleanup@BfresLibrary@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsModelLoaded@BfresLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN8
	DD	imagerel $LN8+49
	DD	imagerel $unwind$?IsModelLoaded@BfresLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@BfresLibrary@@YAXXZ DD imagerel $LN127
	DD	imagerel $LN127+516
	DD	imagerel $unwind$?Initialize@BfresLibrary@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN55
	DD	imagerel $LN55+42
	DD	imagerel $unwind$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FModels@BfresLibrary@@YAXXZ DD imagerel ??__FModels@BfresLibrary@@YAXXZ
	DD	imagerel ??__FModels@BfresLibrary@@YAXXZ+55
	DD	imagerel $unwind$??__FModels@BfresLibrary@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EModels@BfresLibrary@@YAXXZ DD imagerel ??__EModels@BfresLibrary@@YAXXZ
	DD	imagerel ??__EModels@BfresLibrary@@YAXXZ+54
	DD	imagerel $unwind$??__EModels@BfresLibrary@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN228
	DD	imagerel $LN228+648
	DD	imagerel $unwind$?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 012H
	DB	08eH
	DB	02H
	DB	'5', 02H
	DB	04H
	DB	'2'
	DB	06H
	DB	01eH
	DB	04H
	DB	0bdH, 03H
	DB	08H
	DB	'8'
	DB	0aH
	DB	014H
	DB	0cH
	DB	094H
	DB	00H
	DB	'B'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0cH
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	06H
	DB	03aH
	DD	imagerel ??1BfresFile@@QEAA@XZ
	DB	0c1H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@XZ
	DB	081H
	DB	02H
	DB	0aaH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	0a0H
	DB	0daH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	0a0H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0b3219H
	DD	03e6421H
	DD	03d3421H
	DD	0360121H
	DD	0e010f012H
	DD	0700cc00eH
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	01aaH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EModels@BfresLibrary@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FModels@BfresLibrary@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Initialize@BfresLibrary@@YAXXZ DB 010H
	DB	'v'
	DB	00H
	DB	'h'
	DB	02H
	DB	'f'
	DB	04H
	DB	01eH
	DB	02H
	DB	0eaH
	DB	00H
	DB	'h'
	DB	02H
	DB	'f'
	DB	04H
	DB	01eH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Initialize@BfresLibrary@@YAXXZ DB 04H
	DB	0aH
	DD	imagerel ??1BfresFile@@QEAA@XZ
	DB	01H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@XZ
	DB	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Initialize@BfresLibrary@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?Initialize@BfresLibrary@@YAXXZ
	DD	imagerel $ip2state$?Initialize@BfresLibrary@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@BfresLibrary@@YAXXZ DD 071711H
	DD	0327417H
	DD	0313417H
	DD	02e0117H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Initialize@BfresLibrary@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsModelLoaded@BfresLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Cleanup@BfresLibrary@@YAXXZ DB 06H
	DB	'4'
	DB	00H
	DB	'=', 02H
	DB	02H
	DB	'P'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Cleanup@BfresLibrary@@YAXXZ DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Cleanup@BfresLibrary@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?Cleanup@BfresLibrary@@YAXXZ
	DD	imagerel $ip2state$?Cleanup@BfresLibrary@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Cleanup@BfresLibrary@@YAXXZ DD 020611H
	DD	03002b206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Cleanup@BfresLibrary@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__ETextures@GLTextureLibrary@@YAXXZ DB 04H
	DB	012H
	DB	00H
	DB	0b0H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__ETextures@GLTextureLibrary@@YAXXZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0???__ETextures@GLTextureLibrary@@YAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???__ETextures@GLTextureLibrary@@YAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??__ETextures@GLTextureLibrary@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??__ETextures@GLTextureLibrary@@YAXXZ
	DD	imagerel $ip2state$??__ETextures@GLTextureLibrary@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ETextures@GLTextureLibrary@@YAXXZ DD 010411H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??__ETextures@GLTextureLibrary@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FTextures@GLTextureLibrary@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DB 0aH
	DB	09dH, 04H
	DB	02H
	DB	'@'
	DB	04H
	DB	0a8H
	DB	06H
	DB	'V'
	DB	02H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	03H
	DB	03aH
	DD	imagerel ??1Texture@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@XZ
	DB	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	imagerel $ip2state$?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 072119H
	DD	024340fH
	DD	01e010fH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	0eaH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Cleanup@GLTextureLibrary@@YAXXZ DB 06H
	DB	'R'
	DB	00H
	DB	08aH
	DB	02H
	DB	'P'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Cleanup@GLTextureLibrary@@YAXXZ DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Cleanup@GLTextureLibrary@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?Cleanup@GLTextureLibrary@@YAXXZ
	DD	imagerel $ip2state$?Cleanup@GLTextureLibrary@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Cleanup@GLTextureLibrary@@YAXXZ DD 040a11H
	DD	010340aH
	DD	07006b20aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Cleanup@GLTextureLibrary@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?GenerateBoundingBox@BfresFile@@AEAAXXZ DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+58
	DD	imagerel $unwind$?GenerateBoundingBox@BfresFile@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?GenerateBoundingBox@BfresFile@@AEAAXXZ DD 0c1c21H
	DD	02781cH
	DD	036817H
	DD	08e412H
	DD	010640cH
	DD	0f5408H
	DD	0e3404H
	DD	imagerel $LN64
	DD	imagerel $LN64+58
	DD	imagerel $unwind$?GenerateBoundingBox@BfresFile@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenerateBoundingBox@BfresFile@@AEAAXXZ DD 050e01H
	DD	0f00a820eH
	DD	0c006d008H
	DD	07004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?CreateOpenGLObjects@BfresFile@@QEAAXXZ DB 0eH
	DB	01H, 05H
	DB	00H
	DB	0ddH, 03H
	DB	02H
	DB	'}', 04H
	DB	04H
	DB	0c4H
	DB	02H
	DB	0b1H, 08H
	DB	00H
	DB	0a5H, 09H
	DB	02H
	DB	0cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?CreateOpenGLObjects@BfresFile@@QEAAXXZ DB 04H
	DB	0aH
	DD	imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DB	0c1H
	DB	04H
	DB	03cH
	DD	imagerel ??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?CreateOpenGLObjects@BfresFile@@QEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?CreateOpenGLObjects@BfresFile@@QEAAXXZ
	DD	imagerel $ip2state$?CreateOpenGLObjects@BfresFile@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateOpenGLObjects@BfresFile@@QEAAXXZ DD 0113a19H
	DD	015782cH
	DD	0166828H
	DD	0377424H
	DD	0366424H
	DD	0353424H
	DD	02e0124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?CreateOpenGLObjects@BfresFile@@QEAAXXZ
	DD	014aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4Mesh@@QEAAAEAV0@$$QEAV0@@Z DD 081201H
	DD	0b5412H
	DD	0a3412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z DB ' '
	DB	0d8H
	DB	04H
	DB	0a5H, 0aH
	DB	08H
	DB	0f4H
	DB	0aH
	DB	0c8H
	DB	08H
	DB	0eeH
	DB	0cH
	DB	'A', 02H
	DB	0eH
	DB	'V'
	DB	010H
	DB	016H
	DB	012H
	DB	'U', 03H
	DB	014H
	DB	0aaH
	DB	016H
	DB	094H
	DB	018H
	DB	01eH
	DB	014H
	DB	'E', 02H
	DB	01aH
	DB	01cH
	DB	014H
	DB	'A', 03H
	DB	012H
	DB	015H, 04H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z DB 01aH
	DB	0eH
	DD	imagerel ?dtor$1@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA
	DB	02cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	04H
	DB	03aH
	DD	imagerel ??1Model@BfresFile@@QEAA@XZ
	DB	081H
	DB	06H
	DB	03aH
	DD	imagerel ??1LOD@BfresFile@@QEAA@XZ
	DB	041H
	DB	08H
	DB	03aH
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	060H
	DB	06aH
	DD	imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DB	0a0H
	DB	09aH
	DD	imagerel ??1Material@BfresFile@@QEAA@XZ
	DB	081H
	DB	05H
	DB	03eH
	DD	imagerel ?dtor$21@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA
	DB	062H
	DD	imagerel ??1BfresTexture@BfresFile@@QEAA@XZ
	DB	081H
	DB	03H
	DB	03aH
	DD	imagerel ??1TextureToGo@@QEAA@XZ
	DB	0a1H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	072H
	DD	imagerel ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	0aeH
	DD	imagerel ?dtor$27@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z DB 028H
	DD	imagerel $stateUnwindMap$?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z
	DD	imagerel $ip2state$?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z DD 0b3019H
	DD	080341fH
	DD	076011fH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z
	DD	03a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0BfresTexture@BfresFile@@QEAA@XZ DB 02H
	DB	'n'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0BfresTexture@BfresFile@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0BfresTexture@BfresFile@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0BfresTexture@BfresFile@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0BfresTexture@BfresFile@@QEAA@XZ
	DD	imagerel $ip2state$??0BfresTexture@BfresFile@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0BfresTexture@BfresFile@@QEAA@XZ DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0BfresTexture@BfresFile@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1TextureToGo@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0BfresFile@@QEAA@$$QEAV0@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z DB ' '
	DB	0d8H
	DB	04H
	DB	0e1H, 0aH
	DB	08H
	DB	0f4H
	DB	0aH
	DB	0c8H
	DB	08H
	DB	0eeH
	DB	0cH
	DB	'A', 02H
	DB	0eH
	DB	'V'
	DB	010H
	DB	016H
	DB	012H
	DB	'U', 03H
	DB	014H
	DB	0aaH
	DB	016H
	DB	094H
	DB	018H
	DB	01eH
	DB	014H
	DB	'E', 02H
	DB	01aH
	DB	01cH
	DB	014H
	DB	'A', 03H
	DB	012H
	DB	015H, 04H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z DB 01aH
	DB	0eH
	DD	imagerel ?dtor$1@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA
	DB	02cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	04H
	DB	03aH
	DD	imagerel ??1Model@BfresFile@@QEAA@XZ
	DB	081H
	DB	06H
	DB	03aH
	DD	imagerel ??1LOD@BfresFile@@QEAA@XZ
	DB	041H
	DB	08H
	DB	03aH
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	060H
	DB	06aH
	DD	imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DB	0a0H
	DB	09aH
	DD	imagerel ??1Material@BfresFile@@QEAA@XZ
	DB	081H
	DB	05H
	DB	03eH
	DD	imagerel ?dtor$21@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA
	DB	062H
	DD	imagerel ??1BfresTexture@BfresFile@@QEAA@XZ
	DB	081H
	DB	03H
	DB	03aH
	DD	imagerel ??1TextureToGo@@QEAA@XZ
	DB	0a1H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	072H
	DD	imagerel ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	0aeH
	DD	imagerel ?dtor$27@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z DB 028H
	DD	imagerel $stateUnwindMap$?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z
	DD	imagerel $ip2state$?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z DD 0b3019H
	DD	080341fH
	DD	076011fH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z
	DD	03a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z DB 02H
	DB	'=', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z DB 028H
	DD	imagerel $stateUnwindMap$?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z
	DD	imagerel $ip2state$?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z DD 060f11H
	DD	0b640fH
	DD	08340fH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z DB 'v'
	DB	0e9H, 02H
	DB	0aH
	DB	0ceH
	DB	0cH
	DB	','
	DB	0eH
	DB	018H
	DB	0cH
	DB	'|'
	DB	0eH
	DB	'9', 02H
	DB	0cH
	DB	'.'
	DB	'&'
	DB	','
	DB	'('
	DB	018H
	DB	'&'
	DB	089H, 02H
	DB	0cH
	DB	0c1H, 05H
	DB	'*'
	DB	01H, 05H
	DB	','
	DB	084H
	DB	'.'
	DB	'H'
	DB	'0'
	DB	'('
	DB	'.'
	DB	0bcH
	DB	'2'
	DB	09cH
	DB	'4'
	DB	0f9H, 04H
	DB	'6'
	DB	0c2H
	DB	'4'
	DB	'('
	DB	'8'
	DB	0c2H
	DB	'4'
	DB	0dH, 02H
	DB	'.'
	DB	05H, 02H
	DB	':'
	DB	0caH
	DB	'<'
	DB	'I', 02H
	DB	'.'
	DB	0cdH, 02H
	DB	'>'
	DB	0b0H
	DB	'@'
	DB	0fcH
	DB	'B'
	DB	'X'
	DB	'D'
	DB	091H, 02H
	DB	'F'
	DB	'"'
	DB	'D'
	DB	'l'
	DB	'@'
	DB	0e1H, 09H
	DB	'*'
	DB	081H, 04H
	DB	'H'
	DB	0a9H, 013H
	DB	'J'
	DB	'H'
	DB	'H'
	DB	0d1H, 02H
	DB	'*'
	DB	0b5H, 0dH
	DB	'L'
	DB	098H
	DB	'N'
	DB	0f8H
	DB	'P'
	DB	0c9H, 0bH
	DB	'R'
	DB	0e9H, '8'
	DB	'P'
	DB	'E', 06H
	DB	0cH
	DB	086H
	DB	010H
	DB	'"'
	DB	012H
	DB	'$'
	DB	014H
	DB	' '
	DB	016H
	DB	'.'
	DB	018H
	DB	'.'
	DB	01aH
	DB	'&'
	DB	01cH
	DB	'.'
	DB	01eH
	DB	'&'
	DB	' '
	DB	'.'
	DB	'"'
	DB	'*'
	DB	'$'
	DB	'('
	DB	'"'
	DB	018H
	DB	' '
	DB	085H, 02H
	DB	00H
	DB	'r'
	DB	'D'
	DB	0cH
	DB	'4'
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z DB 052H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	01H
	DB	015H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	015H
	DB	03cH
	DD	imagerel ??1?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAA@XZ
	DB	081H
	DB	06H
	DB	03eH
	DD	imagerel ?dtor$3@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA
	DB	02cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	02H
	DB	062H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	012H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	08H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	09H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	09H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	0aH
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	0aH
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	0bH
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	0bH
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	0cH
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	0cH
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	02H
	DB	095H
	DB	05H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	011H
	DB	044H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	02H
	DB	085H
	DB	06H
	DD	imagerel ??1?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@XZ
	DB	0a1H
	DB	018H
	DB	042H
	DD	imagerel ??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
	DB	0c1H
	DB	015H
	DB	03aH
	DD	imagerel ??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
	DB	021H
	DB	016H
	DB	03aH
	DD	imagerel ??1?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	0c1H
	DB	07H
	DB	072H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	01aH
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	019H
	DB	03aH
	DD	imagerel ??1?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	041H
	DB	04H
	DB	072H
	DD	imagerel ??1?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	0e1H
	DB	04H
	DB	0adH
	DB	02H
	DD	imagerel ?dtor$82@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA
	DB	05H
	DB	03H
	DD	imagerel ??1BfresTexture@BfresFile@@QEAA@XZ
	DB	01H
	DB	013H
	DB	085H
	DB	03H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	019H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	018H
	DB	03eH
	DD	imagerel ?dtor$53@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA
	DB	062H
	DD	imagerel ??1BfresTexture@BfresFile@@QEAA@XZ
	DB	01H
	DB	014H
	DB	03eH
	DD	imagerel ?dtor$57@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA
	DB	075H
	DB	06H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	016H
	DB	044H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
	DB	065H
	DB	07H
	DD	imagerel ??1?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ
	DB	0c1H
	DB	017H
	DB	042H
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	061H
	DB	017H
	DB	03aH
	DD	imagerel ??1?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ
	DB	01H
	DB	017H
	DB	03aH
	DD	imagerel ??1?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ
	DB	061H
	DB	015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z
	DD	imagerel $ip2state$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z DD 0154b19H
	DD	06ea83aH
	DD	06f9832H
	DD	070882dH
	DD	0717828H
	DD	0726824H
	DD	0f13420H
	DD	0e60120H
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z
	DD	06daH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEBA@HAEAV?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@3@AEAM33@Z DD 020b901H
	DD	04f8b9H
	DD	05e8b3H
	DD	06d8adH
	DD	07c896H
	DD	08b890H
	DD	09a887H
	DD	0a987eH
	DD	0b8875H
	DD	0c786cH
	DD	0d6864H
	DD	01c7454H
	DD	023644cH
	DD	0225441H
	DD	0203431H
	DD	01d010bH
	DD	0e002f004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 01aH
	DB	015H, 02H
	DB	08H
	DB	'\'
	DB	0aH
	DB	0deH
	DB	0cH
	DB	0bdH, 02H
	DB	0eH
	DB	015H, 04H
	DB	010H
	DB	01aH
	DB	0eH
	DB	'"'
	DB	0cH
	DB	08dH, 02H
	DB	012H
	DB	'd'
	DB	0cH
	DB	'$'
	DB	0aH
	DB	0a8H
	DB	00H
	DB	'@'
	DB	0cH
	DB	'$'
	DB	0eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 012H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	02H
	DB	03cH
	DD	imagerel ??1?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAA@XZ
	DB	0e0H
	DB	036H
	DD	imagerel ?dtor$2@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02aH
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	0c1H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	01H
	DB	07H
	DB	03cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	080H
	DB	0a4H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0d0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0b3019H
	DD	04a341fH
	DD	040011fH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	01faH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?Delete@BfresFile@@QEAAXXZ DD 021H
	DD	imagerel $LN42
	DD	imagerel $LN42+19
	DD	imagerel $unwind$?Delete@BfresFile@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?Delete@BfresFile@@QEAAXXZ DD 021H
	DD	imagerel $LN42+19
	DD	imagerel $LN42+40
	DD	imagerel $chain$0$?Delete@BfresFile@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?Delete@BfresFile@@QEAAXXZ DD 060f21H
	DD	09e40fH
	DD	08740aH
	DD	076405H
	DD	imagerel $LN42+19
	DD	imagerel $LN42+40
	DD	imagerel $chain$0$?Delete@BfresFile@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?Delete@BfresFile@@QEAAXXZ DD 020521H
	DD	065405H
	DD	imagerel $LN42
	DD	imagerel $LN42+19
	DD	imagerel $unwind$?Delete@BfresFile@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Delete@BfresFile@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBuffer@BfresFile@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z DD 081201H
	DD	0b5412H
	DD	0a3412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z DD 081201H
	DD	0b5412H
	DD	0a3412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN56
	DD	imagerel $LN56+21
	DD	imagerel $unwind$??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD 020521H
	DD	077405H
	DD	imagerel $LN56
	DD	imagerel $LN56+21
	DD	imagerel $unwind$??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAAAEAVTexture@@AEBQEAVTextureToGo@@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ DB 04H
	DB	'v'
	DB	00H
	DB	0b0H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0???0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ DD 020a11H
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@2@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN125
	DD	imagerel $LN125+35
	DD	imagerel $unwind$??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ DD 020521H
	DD	073405H
	DD	imagerel $LN125
	DD	imagerel $LN125+35
	DD	imagerel $unwind$??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DB	0edH, 02H
	DB	02H
	DB	'8'
	DB	04H
	DB	014H
	DB	06H
	DB	0a8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0a1811H
	DD	0106418H
	DD	0f5418H
	DD	0e3418H
	DD	0f0149218H
	DD	07010e012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+91
	DD	imagerel $unwind$?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z DD 020521H
	DD	083405H
	DD	imagerel $LN38
	DD	imagerel $LN38+91
	DD	imagerel $unwind$?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+50
	DD	imagerel $unwind$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN41+50
	DD	imagerel $LN41+67
	DD	imagerel $chain$0$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN41+50
	DD	imagerel $LN41+67
	DD	imagerel $chain$0$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z DD 020521H
	DD	077405H
	DD	imagerel $LN41
	DD	imagerel $LN41+50
	DD	imagerel $unwind$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z DD 040b01H
	DD	08640bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAXAEBUModel@BfresFile@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+51
	DD	imagerel $unwind$?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN38
	DD	imagerel $LN38+51
	DD	imagerel $unwind$?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z DD 061001H
	DD	087410H
	DD	076410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAXAEBUMaterial@BfresFile@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UMaterial@BfresFile@@@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+53
	DD	imagerel $unwind$?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z DD 020521H
	DD	087405H
	DD	imagerel $LN43
	DD	imagerel $LN43+53
	DD	imagerel $unwind$?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAXAEBULOD@BfresFile@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAXXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+53
	DD	imagerel $unwind$?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z DD 020521H
	DD	087405H
	DD	imagerel $LN43
	DD	imagerel $LN43+53
	DD	imagerel $unwind$?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+51
	DD	imagerel $unwind$?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+51
	DD	imagerel $unwind$?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z DD 061001H
	DD	087410H
	DD	076410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z DB 04H
	DB	'd'
	DB	00H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z
	DD	imagerel $ip2state$?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z DD 060f11H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020021H
	DD	086400H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020521H
	DD	086405H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+69
	DD	imagerel $unwind$??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z DD 020521H
	DD	0a3405H
	DD	imagerel $LN47
	DD	imagerel $LN47+69
	DD	imagerel $unwind$??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z DD 060d01H
	DD	0b540dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020021H
	DD	086400H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020521H
	DD	086405H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?at@?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+93
	DD	imagerel $unwind$?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z DD 020521H
	DD	083405H
	DD	imagerel $LN38
	DD	imagerel $LN38+93
	DD	imagerel $unwind$?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020021H
	DD	086400H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020521H
	DD	086405H
	DD	imagerel $LN39
	DD	imagerel $LN39+24
	DD	imagerel $unwind$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+49
	DD	imagerel $unwind$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z DD 020521H
	DD	087405H
	DD	imagerel $LN51
	DD	imagerel $LN51+49
	DD	imagerel $unwind$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@V?$initializer_list@E@1@@Z DD 086301H
	DD	0a5463H
	DD	0b340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+21
	DD	imagerel $unwind$?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ DD 020521H
	DD	077405H
	DD	imagerel $LN53
	DD	imagerel $LN53+21
	DD	imagerel $unwind$?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+21
	DD	imagerel $unwind$?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD 020521H
	DD	077405H
	DD	imagerel $LN53
	DD	imagerel $LN53+21
	DD	imagerel $unwind$?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z DB 04H
	DB	'r'
	DB	00H
	DB	0b0H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z DD 020a11H
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN122
	DD	imagerel $LN122+35
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ DD 020521H
	DD	073405H
	DD	imagerel $LN122
	DD	imagerel $LN122+35
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xrange@?$vector@MV?$allocator@M@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAXQEAUVertexBuffer@BfresFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAXQEAUVertexBufferAttribute@BfresFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAXQEAUVertexBufferSize@BfresFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z DD 040021H
	DD	047400H
	DD	0b6400H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z DD 040021H
	DD	047400H
	DD	0b6400H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z DD 040a21H
	DD	04740aH
	DD	0b6405H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z DD 030c01H
	DD	0e008420cH
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAXQEAU?$mat@$03$03M$0A@@glm@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAY04$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY04$$CBD$$QEAVBfresFile@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DB 06H
	DB	0f9H, 02H
	DB	02H
	DB	'('
	DB	04H
	DB	0caH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
	DD	imagerel $ip2state$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DD 0a1611H
	DD	0135416H
	DD	0103416H
	DD	0f0129216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAY07$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY07$$CBD$$QEAVBfresFile@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAVBfresFile@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z DD 021H
	DD	imagerel $LN49
	DD	imagerel $LN49+65
	DD	imagerel $unwind$??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z DD 020521H
	DD	043405H
	DD	imagerel $LN49
	DD	imagerel $LN49+65
	DD	imagerel $unwind$??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z DD 050a01H
	DD	0e006420aH
	DD	060037004H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+65
	DD	imagerel $unwind$??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z DD 020521H
	DD	043405H
	DD	imagerel $LN53
	DD	imagerel $LN53+65
	DD	imagerel $unwind$??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z DD 050a01H
	DD	0e006420aH
	DD	060037004H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z DB 04H
	DB	'*'
	DB	00H
	DB	01aH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z
	DD	imagerel $ip2state$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0TextureToGo@@QEAA@AEBV0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DB 06H
	DB	0f9H, 02H
	DB	02H
	DB	'('
	DB	04H
	DB	0e5H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
	DD	imagerel $ip2state$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DD 0a1611H
	DD	0135416H
	DD	0103416H
	DD	0f0129216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAVTextureToGo@@AEAY03$$CBD$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAPEAVTextureToGo@@AEAY03$$CBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN95
	DD	imagerel $LN95+41
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD 0a0021H
	DD	04f400H
	DD	05c400H
	DD	066400H
	DD	0d5400H
	DD	0c3400H
	DD	imagerel $LN95
	DD	imagerel $LN95+41
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN95
	DD	imagerel $LN95+41
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD 0a2821H
	DD	04f428H
	DD	05c420H
	DD	066413H
	DD	0d540eH
	DD	0c3405H
	DD	imagerel $LN95
	DD	imagerel $LN95+41
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD 031001H
	DD	0e00c6210H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN122
	DD	imagerel $LN122+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD 080021H
	DD	04f400H
	DD	05e400H
	DD	067400H
	DD	0c5400H
	DD	imagerel $LN122
	DD	imagerel $LN122+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN122
	DD	imagerel $LN122+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD 082221H
	DD	04f422H
	DD	05e41dH
	DD	06740eH
	DD	0c5405H
	DD	imagerel $LN122
	DD	imagerel $LN122+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD 030f01H
	DD	0600b620fH
	DD	0300aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN83
	DD	imagerel $LN83+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD 080021H
	DD	04f400H
	DD	05e400H
	DD	067400H
	DD	0c3400H
	DD	imagerel $LN83
	DD	imagerel $LN83+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN83
	DD	imagerel $LN83+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD 081c21H
	DD	04f41cH
	DD	05e417H
	DD	06740aH
	DD	0c3405H
	DD	imagerel $LN83
	DD	imagerel $LN83+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD 030f01H
	DD	0600b620fH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z DB 06H
	DB	01dH, 04H
	DB	00H
	DB	'>'
	DB	02H
	DB	'Q', 02H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z
	DD	imagerel $ip2state$??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z DD 081011H
	DD	0c3410H
	DD	0f00c5210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z DB 06H
	DB	01dH, 04H
	DB	00H
	DB	'>'
	DB	02H
	DB	0f9H, 02H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
	DD	imagerel $ip2state$??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z DD 081011H
	DD	0c3410H
	DD	0f00c5210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 08H
	DB	0dH, 03H
	DB	02H
	DB	'8'
	DB	04H
	DB	014H
	DB	06H
	DB	0a8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0a1611H
	DD	0125416H
	DD	0103416H
	DD	0f0129216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+91
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	083405H
	DD	imagerel $LN36
	DD	imagerel $LN36+91
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN39+50
	DD	imagerel $LN39+67
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN39+50
	DD	imagerel $LN39+67
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	077405H
	DD	imagerel $LN39
	DD	imagerel $LN39+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040b01H
	DD	08640bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+51
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN36
	DD	imagerel $LN36+51
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 061001H
	DD	087410H
	DD	076410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@$$V@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_K@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+53
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	087405H
	DD	imagerel $LN41
	DD	imagerel $LN41+53
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+53
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	087405H
	DD	imagerel $LN41
	DD	imagerel $LN41+53
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+51
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN28
	DD	imagerel $LN28+51
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 061001H
	DD	087410H
	DD	076410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z DB 04H
	DB	'd'
	DB	00H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z
	DD	imagerel $ip2state$??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z DD 060f11H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z DD 020521H
	DD	057405H
	DD	imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z DD 040d01H
	DD	0e009520dH
	DD	030066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+93
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	083405H
	DD	imagerel $LN36
	DD	imagerel $LN36+93
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+36
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD 020521H
	DD	087405H
	DD	imagerel $LN45
	DD	imagerel $LN45+36
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z DD 040f01H
	DD	09340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEBE_K@Z DD 075201H
	DD	045452H
	DD	0e006420aH
	DD	060037004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z DD 040021H
	DD	086400H
	DD	073400H
	DD	imagerel $LN62
	DD	imagerel $LN62+10
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z DD 021H
	DD	imagerel $LN62
	DD	imagerel $LN62+10
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z DD 040d21H
	DD	08640dH
	DD	073405H
	DD	imagerel $LN62
	DD	imagerel $LN62+10
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAXPEAUVertexBufferAttribute@BfresFile@@QEAU12@AEAV?$allocator@UVertexBufferAttribute@BfresFile@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z DD 021H
	DD	imagerel $LN76
	DD	imagerel $LN76+25
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN76
	DD	imagerel $LN76+25
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD 020021H
	DD	063400H
	DD	imagerel $LN45
	DD	imagerel $LN45+28
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+28
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN45
	DD	imagerel $LN45+28
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD 020021H
	DD	063400H
	DD	imagerel $LN45
	DD	imagerel $LN45+28
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+28
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN45
	DD	imagerel $LN45+28
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD 020021H
	DD	063400H
	DD	imagerel $LN45
	DD	imagerel $LN45+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN45
	DD	imagerel $LN45+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN151
	DD	imagerel $LN151+136
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z DD 020521H
	DD	086405H
	DD	imagerel $LN151
	DD	imagerel $LN151+136
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z DD 043a01H
	DD	06343aH
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAPEAUVertexBuffer@BfresFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAPEAUVertexBufferSize@BfresFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN94
	DD	imagerel $LN94+62
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN94+62
	DD	imagerel $LN94+86
	DD	imagerel $chain$0$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD 020521H
	DD	093405H
	DD	imagerel $LN94+62
	DD	imagerel $LN94+86
	DD	imagerel $chain$0$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD 020521H
	DD	0a6405H
	DD	imagerel $LN94
	DD	imagerel $LN94+62
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 021H
	DD	imagerel $LN248
	DD	imagerel $LN248+44
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 0a2121H
	DD	0af421H
	DD	0bd413H
	DD	013740fH
	DD	012640bH
	DD	0113404H
	DD	imagerel $LN248
	DD	imagerel $LN248+44
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 040c01H
	DD	0e008b20cH
	DD	05004c006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+35
	DD	imagerel $unwind$?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ DD 020521H
	DD	073405H
	DD	imagerel $LN79
	DD	imagerel $LN79+35
	DD	imagerel $unwind$?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DB 06H
	DB	0dH, 03H
	DB	02H
	DB	'('
	DB	04H
	DB	0c2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
	DD	imagerel $ip2state$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DD 0a1611H
	DD	0135416H
	DD	0103416H
	DD	0f0129216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+42
	DD	imagerel $unwind$??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z DD 020521H
	DD	047405H
	DD	imagerel $LN41
	DD	imagerel $LN41+42
	DD	imagerel $unwind$??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z DD 050f01H
	DD	0f00b420fH
	DD	06007e009H
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+42
	DD	imagerel $unwind$??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z DD 020521H
	DD	047405H
	DD	imagerel $LN45
	DD	imagerel $LN45+42
	DD	imagerel $unwind$??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z DD 050f01H
	DD	0f00b420fH
	DD	06007e009H
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DB 06H
	DB	0dH, 03H
	DB	02H
	DB	'('
	DB	04H
	DB	0d5H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
	DD	imagerel $ip2state$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DD 0a1611H
	DD	0135416H
	DD	0103416H
	DD	0f0129216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAPEAUVertexBuffer@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z DD 060021H
	DD	04f400H
	DD	05e400H
	DD	067400H
	DD	imagerel $LN156
	DD	imagerel $LN156+106
	DD	imagerel $unwind$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z DD 021H
	DD	imagerel $LN156
	DD	imagerel $LN156+106
	DD	imagerel $unwind$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z DD 060021H
	DD	04f400H
	DD	05e400H
	DD	067400H
	DD	imagerel $LN156
	DD	imagerel $LN156+106
	DD	imagerel $unwind$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z DD 061a21H
	DD	04f41aH
	DD	05e412H
	DD	067405H
	DD	imagerel $LN156
	DD	imagerel $LN156+106
	DD	imagerel $unwind$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z DD 050a01H
	DD	0c006620aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	'Z'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z DB 02H
	DB	'L'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
	DD	imagerel $ip2state$??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z DD 061411H
	DD	086414H
	DD	073414H
	DD	070103214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 06H
	DB	'P'
	DB	02H
	DB	':'
	DB	04H
	DB	014H
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03cH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD 060f11H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z DD 021H
	DD	imagerel $LN85
	DD	imagerel $LN85+26
	DD	imagerel $unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z DD 060f21H
	DD	04740fH
	DD	05640aH
	DD	0d5405H
	DD	imagerel $LN85
	DD	imagerel $LN85+26
	DD	imagerel $unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z DD 040a01H
	DD	0f006520aH
	DD	03002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN65
	DD	imagerel $LN65+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 042a21H
	DD	0be42aH
	DD	0a5405H
	DD	imagerel $LN65
	DD	imagerel $LN65+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@G@std@@@std@@YAPEAGPEAG_KAEAV?$allocator@G@0@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN98
	DD	imagerel $LN98+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040021H
	DD	04f400H
	DD	0c6400H
	DD	imagerel $LN98
	DD	imagerel $LN98+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020021H
	DD	04f400H
	DD	imagerel $LN98+33
	DD	imagerel $LN98+41
	DD	imagerel $chain$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 042021H
	DD	04f420H
	DD	05e405H
	DD	imagerel $LN98+33
	DD	imagerel $LN98+41
	DD	imagerel $chain$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	0c6405H
	DD	imagerel $LN98
	DD	imagerel $LN98+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040801H
	DD	070045208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+40
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 043821H
	DD	07e438H
	DD	065405H
	DD	imagerel $LN21
	DD	imagerel $LN21+40
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z DB 06H
	DB	'q', 02H
	DB	00H
	DB	'`'
	DB	02H
	DB	0b4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z DD 081419H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	030066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+41
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040d21H
	DD	07640dH
	DD	065405H
	DD	imagerel $LN21
	DD	imagerel $LN21+41
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 061001H
	DD	097410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z DB 06H
	DB	0e8H
	DB	00H
	DB	'`'
	DB	02H
	DB	0b4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z DD 081419H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	030066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020021H
	DD	0bf400H
	DD	imagerel $LN51
	DD	imagerel $LN51+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 043821H
	DD	0bf438H
	DD	0a6405H
	DD	imagerel $LN51
	DD	imagerel $LN51+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040901H
	DD	0e0053209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+127
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z DD 020521H
	DD	087405H
	DD	imagerel $LN41
	DD	imagerel $LN41+127
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z DD 0a1901H
	DD	0b6419H
	DD	0a5419H
	DD	093419H
	DD	0f0153219H
	DD	0c011e013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+50
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07e40aH
	DD	065405H
	DD	imagerel $LN21
	DD	imagerel $LN21+50
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z DB 06H
	DB	08dH, 02H
	DB	00H
	DB	'h'
	DB	02H
	DB	0b4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z DD 081419H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	030066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN208
	DD	imagerel $LN208+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060021H
	DD	04f400H
	DD	05c400H
	DD	0c3400H
	DD	imagerel $LN208
	DD	imagerel $LN208+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN208+34
	DD	imagerel $LN208+418
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	0d5405H
	DD	imagerel $LN208+34
	DD	imagerel $LN208+418
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 063921H
	DD	04f439H
	DD	05c41bH
	DD	0c3405H
	DD	imagerel $LN208
	DD	imagerel $LN208+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040901H
	DD	0e0055209H
	DD	060027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020021H
	DD	0bf400H
	DD	imagerel $LN51
	DD	imagerel $LN51+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 043821H
	DD	0bf438H
	DD	0a6405H
	DD	imagerel $LN51
	DD	imagerel $LN51+34
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040901H
	DD	0e0053209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+127
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z DD 020521H
	DD	087405H
	DD	imagerel $LN41
	DD	imagerel $LN41+127
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z DD 0a1901H
	DD	0b6419H
	DD	0a5419H
	DD	093419H
	DD	0f0153219H
	DD	0c011e013H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 06H
	DB	0c6H
	DB	00H
	DB	'T'
	DB	02H
	DB	'l'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
	DD	imagerel $tryMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
	DD	imagerel $ip2state$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 061019H
	DD	0f00c5210H
	DD	07008e00aH
	DD	030066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z DB 04H
	DB	'1', 02H
	DB	04H
	DB	'@'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAA@XZ
	DB	050H
	DB	036H
	DD	imagerel ?dtor$1@?0???$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z DD 061e19H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z DB 04H
	DB	'X'
	DB	00H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z
	DD	imagerel $ip2state$??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z DD 060f11H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$2@?0???$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z DB 08H
	DB	0e6H
	DB	00H
	DB	'r'
	DB	02H
	DB	01cH
	DB	04H
	DB	0b8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$2@?0???$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z DB 02H
	DB	00H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z DB 06H
	DB	08H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z@4HA
	DB	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z DD 081019H
	DD	0f00c5210H
	DD	0d008e00aH
	DD	07004c006H
	DD	030026003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEBQEAVTexture@@PEBQEAV1@V?$allocator@PEAVTexture@@@std@@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@AEAV?$allocator@PEAVTexture@@@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN69
	DD	imagerel $LN69+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 042c21H
	DD	0be42cH
	DD	0a5405H
	DD	imagerel $LN69
	DD	imagerel $LN69+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEBEV?$allocator@E@std@@@std@@YAPEAEPEBE_KPEAEAEAV?$allocator@E@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_n@PEBEPEAE@std@@YAPEAEPEBE_KPEAE@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEBE_KPEAE@std@@YAPEAEPEBE_KPEAE@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@UVertexBuffer@BfresFile@@@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBuffer@BfresFile@@@1@QEAUVertexBuffer@BfresFile@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z DD 081401H
	DD	0b6414H
	DD	0a3414H
	DD	0f0103214H
	DD	0c00ce00eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXQEAUSkeletonBone@BfresFile@@_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z DD 021H
	DD	imagerel $LN58
	DD	imagerel $LN58+43
	DD	imagerel $unwind$?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z DD 020521H
	DD	096405H
	DD	imagerel $LN58
	DD	imagerel $LN58+43
	DD	imagerel $unwind$?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0700be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z DD 021H
	DD	imagerel $LN55
	DD	imagerel $LN55+39
	DD	imagerel $unwind$?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN55
	DD	imagerel $LN55+39
	DD	imagerel $unwind$?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXQEAV?$vector@MV?$allocator@M@std@@@2@_K1@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAXQEAV?$vector@IV?$allocator@I@std@@@2@_K1@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DB 04H
	DB	'R'
	DB	02H
	DB	'&'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03cH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
	DD	imagerel $ip2state$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z DD 060d11H
	DD	0b340dH
	DD	0e009520dH
	DD	060067007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DB 04H
	DB	'X'
	DB	02H
	DB	'&'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03cH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
	DD	imagerel $ip2state$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z DD 081211H
	DD	0c5412H
	DD	0b3412H
	DD	0e00e5212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 04H
	DB	'0'
	DB	00H
	DB	014H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU01@@Z DD 060f01H
	DD	08640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAG@std@@YAPEAGQEAG0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUSkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z DD 021H
	DD	imagerel $LN107
	DD	imagerel $LN107+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z DD 020521H
	DD	037405H
	DD	imagerel $LN107
	DD	imagerel $LN107+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z DD 021H
	DD	imagerel $LN107
	DD	imagerel $LN107+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z DD 020521H
	DD	037405H
	DD	imagerel $LN107
	DD	imagerel $LN107+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z DD 021H
	DD	imagerel $LN96
	DD	imagerel $LN96+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z DD 020521H
	DD	037405H
	DD	imagerel $LN96
	DD	imagerel $LN96+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z DD 021H
	DD	imagerel $LN84
	DD	imagerel $LN84+22
	DD	imagerel $unwind$??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z DD 020421H
	DD	03404H
	DD	imagerel $LN84
	DD	imagerel $LN84+22
	DD	imagerel $unwind$??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z DD 021H
	DD	imagerel $LN99
	DD	imagerel $LN99+22
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z DD 020421H
	DD	03404H
	DD	imagerel $LN99
	DD	imagerel $LN99+22
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ DB 02H
	DB	08eH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ
	DD	imagerel $ip2state$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z DB 04H
	DB	'P'
	DB	00H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z
	DD	imagerel $ip2state$??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEBQEAVTexture@@PEAPEAV1@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@UVertexBuffer@BfresFile@@@std@@YAXQEAUVertexBuffer@BfresFile@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1VertexBuffer@BfresFile@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GVertexBuffer@BfresFile@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GVertexBufferAttribute@BfresFile@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DB 02H
	DB	'2'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@$$QEAU31@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@$$QEAU31@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z DB 04H
	DB	'*'
	DB	00H
	DB	014H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z
	DD	imagerel $ip2state$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@UModel@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX$$QEAUModel@BfresFile@@@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@ULOD@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX$$QEAULOD@BfresFile@@@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@VMesh@@@?$_Uninitialized_backout_al@V?$allocator@VMesh@@@std@@@std@@QEAAX$$QEAVMesh@@@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z DB 02H
	DB	086H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z
	DD	imagerel $ip2state$??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z DD 010911H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z DB 04H
	DB	'F'
	DB	00H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z
	DD	imagerel $ip2state$??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z DD 040a11H
	DD	07340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z DB 04H
	DB	' '
	DB	00H
	DB	014H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@$$QEAU10@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@$$QEAU10@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z DB 02H
	DB	086H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z
	DD	imagerel $ip2state$??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@$$QEAU01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@$$QEAU01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 04H
	DB	' '
	DB	00H
	DB	014H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
	DD	imagerel $ip2state$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UModel@BfresFile@@U12@$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@$$QEAU12@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@ULOD@BfresFile@@U12@$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@$$QEAU12@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@VMesh@@V1@$0A@@std@@YAPEAVMesh@@QEAV1@$$QEAV1@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Model@BfresFile@@QEAA@$$QEAU01@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0LOD@BfresFile@@QEAA@$$QEAU01@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Mesh@@QEAA@$$QEAV0@@Z DD 020501H
	DD	013405H
?Models$initializer$@BfresLibrary@@3P6AXXZEA DQ FLAT:??__EModels@BfresLibrary@@YAXXZ ; BfresLibrary::Models$initializer$
?Textures$initializer$@GLTextureLibrary@@3P6AXXZEA DQ FLAT:??__ETextures@GLTextureLibrary@@YAXXZ ; GLTextureLibrary::Textures$initializer$
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?GetModels@BfresFile@@QEAAAEAV?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@XZ
_TEXT	SEGMENT
this$ = 8
?GetModels@BfresFile@@QEAAAEAV?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@XZ PROC ; BfresFile::GetModels, COMDAT

; 376  :     return this->m_Models;

	mov	rax, rcx

; 377  : }

	ret	0
?GetModels@BfresFile@@QEAAAEAV?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@XZ ENDP ; BfresFile::GetModels
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T3 = 64
$T4 = 80
$T5 = 80
$T6 = 80
_Loc$1 = 96
$T7 = 96
$T8 = 96
$T9 = 128
$T10 = 160
$T11 = 304
ModelName$GSCopy$ = 416
__$ArrayPad$ = 424
ModelName$ = 480
?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BfresLibrary::GetModel, COMDAT

; 22   : {

$LN228:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-176]
	sub	rsp, 432				; 000001b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rsi, rcx
	mov	QWORD PTR ModelName$GSCopy$[rbp-256], rcx
	xor	r12d, r12d

; 23   :     if (!BfresLibrary::IsModelLoaded(ModelName))

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax

; 19   :     return BfresLibrary::Models.count(ModelName);

	mov	rdx, rax
	call	?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::count
	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 23   :     if (!BfresLibrary::IsModelLoaded(ModelName))

	test	rdi, rdi
	jne	$LN63@GetModel
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	rcx, QWORD PTR [rsi+16]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	sub	rax, rcx
	cmp	rax, 6
	jb	$LN225@GetModel

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN25@GetModel

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rsi]
$LN25@GetModel:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 6
	lea	rax, OFFSET FLAT:??_C@_06CFGHAFBF@?4bfres@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 24   :         BfresLibrary::Models.insert({ ModelName, BfresFile(Editor::GetBfresFile(ModelName + ".bfres")) });

	lea	rdx, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	?GetBfresFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; Editor::GetBfresFile
	mov	rdx, rax
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BfresFile::BfresFile
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rbx
	lea	rcx, QWORD PTR $T10[rbp-224]
	call	??0BfresFile@@QEAA@$$QEAV0@@Z
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 24   :         BfresLibrary::Models.insert({ ModelName, BfresFile(Editor::GetBfresFile(ModelName + ".bfres")) });

	lea	r8, QWORD PTR $T10[rbp-256]
	lea	rdx, QWORD PTR $T6[rsp]
	call	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::insert<0,0>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T10[rbp-144]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR $T10[rbp-176]
	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR $T10[rbp-200]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR $T10[rbp-224]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T10[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T11[rbp-176]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR $T11[rbp-208]
	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR $T11[rbp-232]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
$LN63@GetModel:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	r14, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [r14+8]
	mov	QWORD PTR _Loc$1[rsp], rbx
	mov	DWORD PTR _Loc$1[rsp+8], r12d
	mov	rdi, r14

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN72@GetModel
	npad	1
$LL71@GetModel:

; 1616 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR _Loc$1[rsp], rbx

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	test	al, al
	jns	SHORT $LN73@GetModel

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR _Loc$1[rsp+8], r12d

; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]

; 1620 :             } else {

	jmp	SHORT $LN74@GetModel
$LN73@GetModel:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR _Loc$1[rsp+8], 1

; 1622 :                 _Result._Bound           = _Trynode;

	mov	rdi, rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rbx, QWORD PTR [rbx]
$LN74@GetModel:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL71@GetModel
$LN72@GetModel:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdi+25], 0
	jne	SHORT $LN67@GetModel
	lea	rdx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	test	al, al
	jns	$LN66@GetModel
$LN67@GetModel:

; 1631 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 104811045873349725			; 01745d1745d1745dH
	cmp	QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A+8, rax
	je	$LN226@GetModel
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	r15, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	mov	QWORD PTR $T5[rsp], r15

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T5[rsp+8], r12

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR $T5[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 806  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

	lea	rbx, QWORD PTR [rax+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T3[rsp], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, rsi
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	call	??0BfresFile@@QEAA@XZ			; BfresFile::BfresFile
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rdi], r14

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rdi+8], r14

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rdi+16], r14

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rdi+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 212  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	movups	xmm0, XMMWORD PTR _Loc$1[rsp]
	movaps	XMMWORD PTR $T4[rsp], xmm0
	mov	r8, rdi
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, r15
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Insert_node
	mov	rdi, rax
$LN66@GetModel:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 25   :     return &BfresLibrary::Models[ModelName];

	lea	rax, QWORD PTR [rdi+64]

; 26   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+432]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN226@GetModel:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1632 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	npad	1
$LN225@GetModel:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN223@GetModel:
?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BfresLibrary::GetModel
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 80
$T5 = 80
$T6 = 80
_Loc$1 = 96
$T7 = 96
$T8 = 96
$T9 = 128
$T10 = 160
$T11 = 304
ModelName$GSCopy$ = 416
__$ArrayPad$ = 424
ModelName$ = 480
?dtor$0@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresLibrary::GetModel'::`1'::dtor$0
	mov	rcx, QWORD PTR ModelName$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresLibrary::GetModel'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 80
$T5 = 80
$T6 = 80
_Loc$1 = 96
$T7 = 96
$T8 = 96
$T9 = 128
$T10 = 160
$T11 = 304
ModelName$GSCopy$ = 416
__$ArrayPad$ = 424
ModelName$ = 480
?dtor$4@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresLibrary::GetModel'::`1'::dtor$4
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1BfresFile@@QEAA@XZ
?dtor$4@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresLibrary::GetModel'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 80
$T5 = 80
$T6 = 80
_Loc$1 = 96
$T7 = 96
$T8 = 96
$T9 = 128
$T10 = 160
$T11 = 304
ModelName$GSCopy$ = 416
__$ArrayPad$ = 424
ModelName$ = 480
?dtor$5@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresLibrary::GetModel'::`1'::dtor$5
	lea	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@XZ
?dtor$5@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresLibrary::GetModel'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 80
$T5 = 80
$T6 = 80
_Loc$1 = 96
$T7 = 96
$T8 = 96
$T9 = 128
$T10 = 160
$T11 = 304
ModelName$GSCopy$ = 416
__$ArrayPad$ = 424
ModelName$ = 480
?dtor$18@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresLibrary::GetModel'::`1'::dtor$18
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
?dtor$18@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresLibrary::GetModel'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 80
$T5 = 80
$T6 = 80
_Loc$1 = 96
$T7 = 96
$T8 = 96
$T9 = 128
$T10 = 160
$T11 = 304
ModelName$GSCopy$ = 416
__$ArrayPad$ = 424
ModelName$ = 480
?dtor$17@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresLibrary::GetModel'::`1'::dtor$17
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$17@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresLibrary::GetModel'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 80
$T5 = 80
$T6 = 80
_Loc$1 = 96
$T7 = 96
$T8 = 96
$T9 = 128
$T10 = 160
$T11 = 304
ModelName$GSCopy$ = 416
__$ArrayPad$ = 424
ModelName$ = 480
?dtor$20@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresLibrary::GetModel'::`1'::dtor$20
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$20@?0??GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresLibrary::GetModel'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.h
;	COMDAT ??0VBO@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0VBO@@QEAA@XZ PROC					; VBO::VBO, COMDAT

; 15   : 	VBO() {}

	mov	rax, rcx
	ret	0
??0VBO@@QEAA@XZ ENDP					; VBO::VBO
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.h
;	COMDAT ??0VAO@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0VAO@@QEAA@XZ PROC					; VAO::VAO, COMDAT

; 13   : 	VAO() {}

	mov	rax, rcx
	ret	0
??0VAO@@QEAA@XZ ENDP					; VAO::VAO
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.h
;	COMDAT ??0EBO@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0EBO@@QEAA@XZ PROC					; EBO::EBO, COMDAT

; 13   : 	EBO() {}

	mov	rax, rcx
	ret	0
??0EBO@@QEAA@XZ ENDP					; EBO::EBO
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
;	COMDAT ??0TextureToGo@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0TextureToGo@@QEAA@XZ PROC				; TextureToGo::TextureToGo, COMDAT

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	xor	eax, eax

; 26   : private:
; 27   : 	struct SurfaceInfo
; 28   : 	{
; 29   : 		uint16_t MipMapLevel;
; 30   : 		uint8_t ArrayLevel;
; 31   : 		uint8_t SurfaceCount;
; 32   : 		uint32_t Size;
; 33   : 	};
; 34   : 
; 35   : 	std::vector<unsigned char> m_Pixels;
; 36   : 	uint16_t m_Width;
; 37   : 	uint16_t m_Height;
; 38   : 	uint16_t m_Depth;
; 39   : 	uint8_t m_MipMapCount;
; 40   : 	uint16_t m_Format;
; 41   : 	bool m_Transparent = false;

	mov	WORD PTR [rcx+42], 256			; 00000100H
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 25   : 	}

	mov	rax, rcx
	ret	0
??0TextureToGo@@QEAA@XZ ENDP				; TextureToGo::TextureToGo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Texture.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Texture.h
;	COMDAT ??0Texture@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Texture@@QEAA@XZ PROC				; Texture::Texture, COMDAT

; 22   : 	Texture() {};

	xorps	xmm0, xmm0
	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+8], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+24], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+32], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+8], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Texture.h

; 22   : 	Texture() {};

	ret	0
??0Texture@@QEAA@XZ ENDP				; Texture::Texture
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.h
;	COMDAT ??0Mesh@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Mesh@@QEAA@XZ PROC					; Mesh::Mesh, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
	mov	QWORD PTR [rcx+56], rax
	mov	QWORD PTR [rcx+64], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.h

; 26   : 	Mesh() {}

	mov	rax, rcx
	ret	0
??0Mesh@@QEAA@XZ ENDP					; Mesh::Mesh
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ??__EModels@BfresLibrary@@YAXXZ
text$di	SEGMENT
??__EModels@BfresLibrary@@YAXXZ PROC			; BfresLibrary::`dynamic initializer for 'Models'', COMDAT

; 8    : std::map<std::string, BfresFile> BfresLibrary::Models;

	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 8    : std::map<std::string, BfresFile> BfresLibrary::Models;

	lea	rcx, OFFSET FLAT:??__FModels@BfresLibrary@@YAXXZ ; BfresLibrary::`dynamic atexit destructor for 'Models''
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 8    : std::map<std::string, BfresFile> BfresLibrary::Models;

	add	rsp, 40					; 00000028H
	jmp	atexit
??__EModels@BfresLibrary@@YAXXZ ENDP			; BfresLibrary::`dynamic initializer for 'Models''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??__FModels@BfresLibrary@@YAXXZ
text$yd	SEGMENT
??__FModels@BfresLibrary@@YAXXZ PROC			; BfresLibrary::`dynamic atexit destructor for 'Models'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	r8, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	lea	rdx, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	lea	rcx, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	mov	r8, QWORD PTR [r8+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	mov	edx, 176				; 000000b0H
	add	rsp, 40					; 00000028H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??__FModels@BfresLibrary@@YAXXZ ENDP			; BfresLibrary::`dynamic atexit destructor for 'Models''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$dead$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A, xmm0
	ret	0
?__autoclassinit2@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >, COMDAT
$LN55:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	r8, QWORD PTR [rcx]
	mov	rdx, rcx
	mov	rbx, rcx
	mov	r8, QWORD PTR [r8+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rbx]
	mov	edx, 176				; 000000b0H
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??3@YAXPEAX_K@Z				; operator delete
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?Initialize@BfresLibrary@@YAXXZ
_TEXT	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 240
$T6 = 240
$T7 = 256
$T8 = 256
?Initialize@BfresLibrary@@YAXXZ PROC			; BfresLibrary::Initialize, COMDAT

; 11   : {

$LN127:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	lea	rbp, QWORD PTR [rsp-112]
	sub	rsp, 368				; 00000170H
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	edi, edi
	mov	QWORD PTR $T2[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+4]
	lea	rdx, OFFSET FLAT:??_C@_04KPICECCB@Area@
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 12   :     BfresLibrary::Models.insert({ "Area", BfresFile::CreateDefaultAreaModel("Area", 0, 255, 0, 50, 2.0f) });

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [rsp+48], xmm0
	mov	BYTE PTR [rsp+40], 50			; 00000032H
	mov	BYTE PTR [rsp+32], dil
	mov	r9b, 255				; 000000ffH
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T8[rbp-256]
	call	?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z ; BfresFile::CreateDefaultAreaModel
	mov	rbx, rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rsp], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqa	XMMWORD PTR $T4[rsp+16], xmm1

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+4]
	lea	rdx, OFFSET FLAT:??_C@_04KPICECCB@Area@
	lea	rcx, QWORD PTR $T4[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T4[rbp-224]
	call	??0BfresFile@@QEAA@$$QEAV0@@Z
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 12   :     BfresLibrary::Models.insert({ "Area", BfresFile::CreateDefaultAreaModel("Area", 0, 255, 0, 50, 2.0f) });

	lea	r8, QWORD PTR $T4[rsp]
	lea	rdx, QWORD PTR $T6[rbp-256]
	call	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::insert<0,0>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T4[rbp-144]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR $T4[rbp-176]
	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR $T4[rbp-200]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR $T4[rbp-224]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T4[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T8[rbp-176]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR $T8[rbp-208]
	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR $T8[rbp-232]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR $T8[rbp-256]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T1[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+7]
	lea	rdx, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 13   :     BfresLibrary::Models.insert({ "Default", BfresFile::CreateDefaultModel("Default", 0, 0, 255, 255) });

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [rsp+48], xmm0
	mov	BYTE PTR [rsp+40], 255			; 000000ffH
	mov	BYTE PTR [rsp+32], 255			; 000000ffH
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T7[rbp-256]
	call	?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z ; BfresFile::CreateDefaultModel
	mov	rbx, rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rsp], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqa	XMMWORD PTR $T3[rsp+16], xmm1

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+7]
	lea	rdx, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T3[rbp-224]
	call	??0BfresFile@@QEAA@$$QEAV0@@Z
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 13   :     BfresLibrary::Models.insert({ "Default", BfresFile::CreateDefaultModel("Default", 0, 0, 255, 255) });

	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR $T5[rbp-256]
	call	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::insert<0,0>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T3[rbp-144]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR $T3[rbp-176]
	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR $T3[rbp-200]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR $T3[rbp-224]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T3[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T7[rbp-176]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR $T7[rbp-208]
	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR $T7[rbp-232]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR $T7[rbp-256]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 15   : }

	lea	r11, QWORD PTR [rsp+368]
	mov	rbx, QWORD PTR [r11+24]
	mov	rdi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rbp
	ret	0
?Initialize@BfresLibrary@@YAXXZ ENDP			; BfresLibrary::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 240
$T6 = 240
$T7 = 256
$T8 = 256
?dtor$1@?0??Initialize@BfresLibrary@@YAXXZ@4HA PROC	; `BfresLibrary::Initialize'::`1'::dtor$1
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1BfresFile@@QEAA@XZ
?dtor$1@?0??Initialize@BfresLibrary@@YAXXZ@4HA ENDP	; `BfresLibrary::Initialize'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 240
$T6 = 240
$T7 = 256
$T8 = 256
?dtor$2@?0??Initialize@BfresLibrary@@YAXXZ@4HA PROC	; `BfresLibrary::Initialize'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@XZ
?dtor$2@?0??Initialize@BfresLibrary@@YAXXZ@4HA ENDP	; `BfresLibrary::Initialize'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 240
$T6 = 240
$T7 = 256
$T8 = 256
?dtor$4@?0??Initialize@BfresLibrary@@YAXXZ@4HA PROC	; `BfresLibrary::Initialize'::`1'::dtor$4
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1BfresFile@@QEAA@XZ
?dtor$4@?0??Initialize@BfresLibrary@@YAXXZ@4HA ENDP	; `BfresLibrary::Initialize'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 240
$T6 = 240
$T7 = 256
$T8 = 256
?dtor$5@?0??Initialize@BfresLibrary@@YAXXZ@4HA PROC	; `BfresLibrary::Initialize'::`1'::dtor$5
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@XZ
?dtor$5@?0??Initialize@BfresLibrary@@YAXXZ@4HA ENDP	; `BfresLibrary::Initialize'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?IsModelLoaded@BfresLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
ModelName$ = 48
?IsModelLoaded@BfresLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BfresLibrary::IsModelLoaded, COMDAT

; 18   : {

$LN8:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 19   :     return BfresLibrary::Models.count(ModelName);

	mov	rdx, rcx
	mov	rdi, rcx
	call	?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::count
	test	rax, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 19   :     return BfresLibrary::Models.count(ModelName);

	setne	bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 19   :     return BfresLibrary::Models.count(ModelName);

	movzx	eax, bl

; 20   : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?IsModelLoaded@BfresLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BfresLibrary::IsModelLoaded
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?Cleanup@BfresLibrary@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 112
?Cleanup@BfresLibrary@@YAXXZ PROC			; BfresLibrary::Cleanup, COMDAT

; 28   : {

$LN75:
	push	rbx
	sub	rsp, 96					; 00000060H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rbx, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 29   :     for (auto& [Gyml, Model] : BfresLibrary::Models)

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN3@Cleanup
$LL24@Cleanup:
	lea	rcx, QWORD PTR [rbx+64]

; 30   :     {
; 31   :         Model.Delete();

	call	?Delete@BfresFile@@QEAAXXZ		; BfresFile::Delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN23@Cleanup

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN22@Cleanup
$LL21@Cleanup:
	cmp	rbx, QWORD PTR [rax+16]
	jne	SHORT $LN22@Cleanup

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL21@Cleanup
$LN22@Cleanup:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	SHORT $LN65@Cleanup
$LN23@Cleanup:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rax]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN65@Cleanup
	npad	9
$LL27@Cleanup:

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx

; 60   :         }
; 61   : 
; 62   :         return *this;
; 63   :     }
; 64   : 
; 65   :     _Tree_unchecked_const_iterator operator++(int) noexcept {
; 66   :         _Tree_unchecked_const_iterator _Tmp = *this;
; 67   :         ++*this;
; 68   :         return _Tmp;
; 69   :     }
; 70   : 
; 71   :     _Tree_unchecked_const_iterator& operator--() noexcept {
; 72   :         if (_Ptr->_Isnil) {
; 73   :             _Ptr = _Ptr->_Right; // end() ==> rightmost
; 74   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree
; 75   :             _Nodeptr _Pnode;
; 76   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {
; 77   :                 _Ptr = _Pnode; // ==> parent while left subtree
; 78   :             }
; 79   : 
; 80   :             if (!_Ptr->_Isnil) { // decrement non-begin()
; 81   :                 _Ptr = _Pnode; // ==> parent if not head
; 82   :             }
; 83   :         } else {
; 84   :             _Ptr = _Mytree::_Max(_Ptr->_Left); // ==> largest of left subtree
; 85   :         }
; 86   : 
; 87   :         return *this;
; 88   :     }
; 89   : 
; 90   :     _Tree_unchecked_const_iterator operator--(int) noexcept {
; 91   :         _Tree_unchecked_const_iterator _Tmp = *this;
; 92   :         --*this;
; 93   :         return _Tmp;
; 94   :     }
; 95   : 
; 96   :     _NODISCARD bool operator==(const _Tree_unchecked_const_iterator& _Right) const noexcept {
; 97   :         return _Ptr == _Right._Ptr;
; 98   :     }
; 99   : 
; 100  : #if !_HAS_CXX20
; 101  :     _NODISCARD bool operator!=(const _Tree_unchecked_const_iterator& _Right) const noexcept {
; 102  :         return !(*this == _Right);
; 103  :     }
; 104  : #endif // !_HAS_CXX20
; 105  : 
; 106  :     _NODISCARD bool operator==(_Default_sentinel) const noexcept {
; 107  :         return !!_Ptr->_Isnil; // TRANSITION, avoid warning C4800:
; 108  :                                // "Implicit conversion from 'char' to bool. Possible information loss" (/Wall)
; 109  :     }
; 110  : 
; 111  : #if !_HAS_CXX20
; 112  :     _NODISCARD bool operator!=(_Default_sentinel) const noexcept {
; 113  :         return !_Ptr->_Isnil;
; 114  :     }
; 115  : #endif // !_HAS_CXX20
; 116  : 
; 117  :     _Nodeptr _Ptr; // pointer to node
; 118  : };
; 119  : 
; 120  : template <class _Mytree>
; 121  : class _Tree_unchecked_iterator : public _Tree_unchecked_const_iterator<_Mytree> {
; 122  : public:
; 123  :     using _Mybase           = _Tree_unchecked_const_iterator<_Mytree>;
; 124  :     using iterator_category = bidirectional_iterator_tag;
; 125  : 
; 126  :     using _Nodeptr        = typename _Mytree::_Nodeptr;
; 127  :     using value_type      = typename _Mytree::value_type;
; 128  :     using difference_type = typename _Mytree::difference_type;
; 129  :     using pointer         = typename _Mytree::pointer;
; 130  :     using reference       = value_type&;
; 131  : 
; 132  :     using _Mybase::_Mybase;
; 133  : 
; 134  :     _NODISCARD reference operator*() const noexcept {
; 135  :         return const_cast<reference>(_Mybase::operator*());
; 136  :     }
; 137  : 
; 138  :     _NODISCARD pointer operator->() const noexcept {
; 139  :         return pointer_traits<pointer>::pointer_to(**this);
; 140  :     }
; 141  : 
; 142  :     _Tree_unchecked_iterator& operator++() noexcept {
; 143  :         _Mybase::operator++();
; 144  :         return *this;
; 145  :     }
; 146  : 
; 147  :     _Tree_unchecked_iterator operator++(int) noexcept {
; 148  :         _Tree_unchecked_iterator _Tmp = *this;
; 149  :         _Mybase::operator++();
; 150  :         return _Tmp;
; 151  :     }
; 152  : 
; 153  :     _Tree_unchecked_iterator& operator--() noexcept {
; 154  :         _Mybase::operator--();
; 155  :         return *this;
; 156  :     }
; 157  : 
; 158  :     _Tree_unchecked_iterator operator--(int) noexcept {
; 159  :         _Tree_unchecked_iterator _Tmp = *this;
; 160  :         _Mybase::operator--();
; 161  :         return _Tmp;
; 162  :     }
; 163  : };
; 164  : 
; 165  : template <class _Mytree>
; 166  : class _Tree_const_iterator : public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> {
; 167  : public:
; 168  :     using _Mybase           = _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>;
; 169  :     using iterator_category = bidirectional_iterator_tag;
; 170  : 
; 171  :     using _Nodeptr        = typename _Mytree::_Nodeptr;
; 172  :     using value_type      = typename _Mytree::value_type;
; 173  :     using difference_type = typename _Mytree::difference_type;
; 174  :     using pointer         = typename _Mytree::const_pointer;
; 175  :     using reference       = const value_type&;
; 176  : 
; 177  :     using _Mybase::_Mybase;
; 178  : 
; 179  :     _NODISCARD reference operator*() const noexcept {
; 180  : #if _ITERATOR_DEBUG_LEVEL == 2
; 181  :         const auto _Mycont = static_cast<const _Mytree*>(this->_Getcont());
; 182  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized map/set iterator");
; 183  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");
; 184  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 185  : 
; 186  :         return this->_Ptr->_Myval;
; 187  :     }
; 188  : 
; 189  :     _NODISCARD pointer operator->() const noexcept {
; 190  :         return pointer_traits<pointer>::pointer_to(**this);
; 191  :     }
; 192  : 
; 193  :     _Tree_const_iterator& operator++() noexcept {
; 194  : #if _ITERATOR_DEBUG_LEVEL == 2
; 195  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 196  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         _Mybase::operator++();
; 200  :         return *this;
; 201  :     }
; 202  : 
; 203  :     _Tree_const_iterator operator++(int) noexcept {
; 204  :         _Tree_const_iterator _Tmp = *this;
; 205  :         ++*this;
; 206  :         return _Tmp;
; 207  :     }
; 208  : 
; 209  :     _Tree_const_iterator& operator--() noexcept {
; 210  : #if _ITERATOR_DEBUG_LEVEL == 2
; 211  :         _STL_ASSERT(this->_Getcont(), "cannot decrement value-initialized map/set iterator");
; 212  :         _Nodeptr _Ptrsav = this->_Ptr;
; 213  :         _Mybase::operator--();
; 214  :         _STL_VERIFY(_Ptrsav != this->_Ptr, "cannot decrement begin map/set iterator");
; 215  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 216  :         _Mybase::operator--();
; 217  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 218  : 
; 219  :         return *this;
; 220  :     }
; 221  : 
; 222  :     _Tree_const_iterator operator--(int) noexcept {
; 223  :         _Tree_const_iterator _Tmp = *this;
; 224  :         --*this;
; 225  :         return _Tmp;
; 226  :     }
; 227  : 
; 228  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const noexcept {
; 229  : #if _ITERATOR_DEBUG_LEVEL == 2
; 230  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 231  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 232  : 
; 233  :         return this->_Ptr == _Right._Ptr;
; 234  :     }
; 235  : 
; 236  : #if !_HAS_CXX20
; 237  :     _NODISCARD bool operator!=(const _Tree_const_iterator& _Right) const noexcept {
; 238  :         return !(*this == _Right);
; 239  :     }
; 240  : #endif // !_HAS_CXX20
; 241  : 
; 242  : #if _ITERATOR_DEBUG_LEVEL == 2
; 243  :     friend void _Verify_range(const _Tree_const_iterator& _First, const _Tree_const_iterator& _Last) noexcept {
; 244  :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "map/set iterators in range are from different containers");
; 245  :     }
; 246  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 247  : 
; 248  :     using _Prevent_inheriting_unwrap = _Tree_const_iterator;
; 249  : 
; 250  :     _NODISCARD _Tree_unchecked_const_iterator<_Mytree> _Unwrapped() const noexcept {
; 251  :         return _Tree_unchecked_const_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 252  :     }
; 253  : 
; 254  :     void _Seek_to(const _Tree_unchecked_const_iterator<_Mytree> _It) noexcept {
; 255  :         this->_Ptr = _It._Ptr;
; 256  :     }
; 257  : };
; 258  : 
; 259  : template <class _Mytree>
; 260  : class _Tree_iterator : public _Tree_const_iterator<_Mytree> {
; 261  : public:
; 262  :     using _Mybase           = _Tree_const_iterator<_Mytree>;
; 263  :     using iterator_category = bidirectional_iterator_tag;
; 264  : 
; 265  :     using _Nodeptr        = typename _Mytree::_Nodeptr;
; 266  :     using value_type      = typename _Mytree::value_type;
; 267  :     using difference_type = typename _Mytree::difference_type;
; 268  : 
; 269  :     using pointer   = typename _Mytree::pointer;
; 270  :     using reference = value_type&;
; 271  : 
; 272  :     using _Mybase::_Mybase;
; 273  : 
; 274  :     _NODISCARD reference operator*() const noexcept {
; 275  :         return const_cast<reference>(_Mybase::operator*());
; 276  :     }
; 277  : 
; 278  :     _NODISCARD pointer operator->() const noexcept {
; 279  :         return pointer_traits<pointer>::pointer_to(**this);
; 280  :     }
; 281  : 
; 282  :     _Tree_iterator& operator++() noexcept {
; 283  :         _Mybase::operator++();
; 284  :         return *this;
; 285  :     }
; 286  : 
; 287  :     _Tree_iterator operator++(int) noexcept {
; 288  :         _Tree_iterator _Tmp = *this;
; 289  :         _Mybase::operator++();
; 290  :         return _Tmp;
; 291  :     }
; 292  : 
; 293  :     _Tree_iterator& operator--() noexcept {
; 294  :         _Mybase::operator--();
; 295  :         return *this;
; 296  :     }
; 297  : 
; 298  :     _Tree_iterator operator--(int) noexcept {
; 299  :         _Tree_iterator _Tmp = *this;
; 300  :         _Mybase::operator--();
; 301  :         return _Tmp;
; 302  :     }
; 303  : 
; 304  :     using _Prevent_inheriting_unwrap = _Tree_iterator;
; 305  : 
; 306  :     _NODISCARD _Tree_unchecked_iterator<_Mytree> _Unwrapped() const noexcept {
; 307  :         return _Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 308  :     }
; 309  : };
; 310  : 
; 311  : template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
; 312  :     class _Reference, class _Const_reference, class _Nodeptr_type>
; 313  : struct _Tree_iter_types {
; 314  :     using value_type      = _Value_type;
; 315  :     using size_type       = _Size_type;
; 316  :     using difference_type = _Difference_type;
; 317  :     using pointer         = _Pointer;
; 318  :     using const_pointer   = _Const_pointer;
; 319  :     using _Nodeptr        = _Nodeptr_type;
; 320  : };
; 321  : 
; 322  : template <class _Value_type, class _Voidptr>
; 323  : struct _Tree_node {
; 324  :     using _Nodeptr   = _Rebind_pointer_t<_Voidptr, _Tree_node>;
; 325  :     using value_type = _Value_type;
; 326  :     _Nodeptr _Left; // left subtree, or smallest element if head
; 327  :     _Nodeptr _Parent; // parent, or root of tree if head
; 328  :     _Nodeptr _Right; // right subtree, or largest element if head
; 329  :     char _Color; // _Red or _Black, _Black if head
; 330  :     char _Isnil; // true only if head (also nil) node; TRANSITION, should be bool
; 331  :     value_type _Myval = // the stored value, unused if head
; 332  :         _Returns_exactly<value_type>(); // fake a viable constructor to workaround GH-2749
; 333  : 
; 334  :     enum _Redbl { // colors for link to parent
; 335  :         _Red,
; 336  :         _Black
; 337  :     };
; 338  : 
; 339  :     _Tree_node()                             = default;
; 340  :     _Tree_node(const _Tree_node&)            = delete;
; 341  :     _Tree_node& operator=(const _Tree_node&) = delete;
; 342  : 
; 343  :     template <class _Alloc>
; 344  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {
; 345  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buyheadnode call");
; 346  :         const auto _Pnode = _Al.allocate(1);
; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);
; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);
; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);
; 350  :         _Pnode->_Color = _Black;
; 351  :         _Pnode->_Isnil = true;
; 352  :         return _Pnode;
; 353  :     }
; 354  : 
; 355  :     template <class _Alloc, class... _Valty>
; 356  :     static _Nodeptr _Buynode(_Alloc& _Al, _Nodeptr _Myhead, _Valty&&... _Val) {
; 357  :         // allocate a node with defaults and set links and value
; 358  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buynode call");
; 359  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);
; 360  :         _Newnode._Allocate();
; 361  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);
; 362  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);
; 363  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);
; 364  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);
; 365  :         _Newnode._Ptr->_Color = _Red;
; 366  :         _Newnode._Ptr->_Isnil = false;
; 367  :         return _Newnode._Release();
; 368  :     }
; 369  : 
; 370  :     template <class _Alloc>
; 371  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 372  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 373  :         _Destroy_in_place(_Ptr->_Left);
; 374  :         _Destroy_in_place(_Ptr->_Parent);
; 375  :         _Destroy_in_place(_Ptr->_Right);
; 376  :         allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
; 377  :     }
; 378  : 
; 379  :     template <class _Alloc>
; 380  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 381  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 382  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));
; 383  :         _Freenode0(_Al, _Ptr);
; 384  :     }
; 385  : };
; 386  : 
; 387  : template <class _Ty>
; 388  : struct _Tree_simple_types : _Simple_types<_Ty> {
; 389  :     using _Node    = _Tree_node<_Ty, void*>;
; 390  :     using _Nodeptr = _Node*;
; 391  : };
; 392  : 
; 393  : enum class _Tree_child {
; 394  :     _Right, // perf note: compare with _Right rather than _Left where possible for comparison with zero
; 395  :     _Left,
; 396  :     _Unused // indicates that tree child should never be used for insertion
; 397  : };
; 398  : 
; 399  : template <class _Nodeptr>
; 400  : struct _Tree_id {
; 401  :     _Nodeptr _Parent; // the leaf node under which a new node should be inserted
; 402  :     _Tree_child _Child;
; 403  : };
; 404  : 
; 405  : template <class _Nodeptr>
; 406  : struct _Tree_find_result {
; 407  :     _Tree_id<_Nodeptr> _Location;
; 408  :     _Nodeptr _Bound;
; 409  : };
; 410  : 
; 411  : template <class _Nodeptr>
; 412  : struct _Tree_find_hint_result {
; 413  :     _Tree_id<_Nodeptr> _Location;
; 414  :     bool _Duplicate;
; 415  : };
; 416  : 
; 417  : [[noreturn]] inline void _Throw_tree_length_error() {
; 418  :     _Xlength_error("map/set too long");
; 419  : }
; 420  : 
; 421  : template <class _Val_types>
; 422  : class _Tree_val : public _Container_base {
; 423  : public:
; 424  :     using _Nodeptr = typename _Val_types::_Nodeptr;
; 425  : 
; 426  :     using value_type      = typename _Val_types::value_type;
; 427  :     using size_type       = typename _Val_types::size_type;
; 428  :     using difference_type = typename _Val_types::difference_type;
; 429  :     using pointer         = typename _Val_types::pointer;
; 430  :     using const_pointer   = typename _Val_types::const_pointer;
; 431  :     using reference       = value_type&;
; 432  :     using const_reference = const value_type&;
; 433  : 
; 434  :     using _Unchecked_const_iterator = _Tree_unchecked_const_iterator<_Tree_val>;
; 435  :     using const_iterator            = _Tree_const_iterator<_Tree_val>;
; 436  : 
; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}
; 438  : 
; 439  :     enum _Redbl { // colors for link to parent
; 440  :         _Red,
; 441  :         _Black
; 442  :     };
; 443  : 
; 444  :     static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { // return rightmost node in subtree at _Pnode
; 445  :         while (!_Pnode->_Right->_Isnil) {
; 446  :             _Pnode = _Pnode->_Right;
; 447  :         }
; 448  : 
; 449  :         return _Pnode;
; 450  :     }
; 451  : 
; 452  :     static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { // return leftmost node in subtree at _Pnode
; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [rcx]
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL27@Cleanup
$LN65@Cleanup:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 29   :     for (auto& [Gyml, Model] : BfresLibrary::Models)

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL24@Cleanup
$LN3@Cleanup:

; 33   :     Logger::Info("BfresLibrary", "Deleted models");

	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T3[rsp], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	ebx, ebx
	mov	QWORD PTR $T1[rsp+16], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rsp+24], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+14]
	lea	rdx, OFFSET FLAT:??_C@_0P@PDPHHJCD@Deleted?5models@
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rsp+16], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rsp+24], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:??_C@_0N@DOLLKCOO@BfresLibrary@
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 33   :     Logger::Info("BfresLibrary", "Deleted models");

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?Info@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Info

; 34   : }

	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
?Cleanup@BfresLibrary@@YAXXZ ENDP			; BfresLibrary::Cleanup
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 112
?dtor$0@?0??Cleanup@BfresLibrary@@YAXXZ@4HA PROC	; `BfresLibrary::Cleanup'::`1'::dtor$0
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Cleanup@BfresLibrary@@YAXXZ@4HA ENDP	; `BfresLibrary::Cleanup'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ??__ETextures@GLTextureLibrary@@YAXXZ
text$di	SEGMENT
??__ETextures@GLTextureLibrary@@YAXXZ PROC		; GLTextureLibrary::`dynamic initializer for 'Textures'', COMDAT

; 38   : std::unordered_map<TextureToGo*, Texture> GLTextureLibrary::Textures;

	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 72					; 00000048H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24, 0
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+32, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48, 7
	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+56, 8

; 377  :         // construct empty hash table
; 378  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A, 1065353216 ; 3f800000H

; 379  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, rax
	mov	edx, 16
	lea	rcx, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Assign_grow
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 38   : std::unordered_map<TextureToGo*, Texture> GLTextureLibrary::Textures;

	lea	rcx, OFFSET FLAT:??__FTextures@GLTextureLibrary@@YAXXZ ; GLTextureLibrary::`dynamic atexit destructor for 'Textures''
	add	rsp, 40					; 00000028H
	jmp	atexit
??__ETextures@GLTextureLibrary@@YAXXZ ENDP		; GLTextureLibrary::`dynamic initializer for 'Textures''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$1@?0???__ETextures@GLTextureLibrary@@YAXXZ@4HA PROC ; `GLTextureLibrary::`dynamic initializer for 'Textures'''::`1'::dtor$1
	lea	rcx, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures
	add	rcx, 8
	jmp	??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::~list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >
?dtor$1@?0???__ETextures@GLTextureLibrary@@YAXXZ@4HA ENDP ; `GLTextureLibrary::`dynamic initializer for 'Textures'''::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
?dtor$2@?0???__ETextures@GLTextureLibrary@@YAXXZ@4HA PROC ; `GLTextureLibrary::`dynamic initializer for 'Textures'''::`1'::dtor$2
	lea	rcx, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >
?dtor$2@?0???__ETextures@GLTextureLibrary@@YAXXZ@4HA ENDP ; `GLTextureLibrary::`dynamic initializer for 'Textures'''::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??__FTextures@GLTextureLibrary@@YAXXZ
text$yd	SEGMENT
??__FTextures@GLTextureLibrary@@YAXXZ PROC		; GLTextureLibrary::`dynamic atexit destructor for 'Textures'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 312  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	test	rcx, rcx
	je	SHORT $LN12@dynamic

; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+40
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@dynamic

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@dynamic

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@dynamic:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 315  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24, 0

; 316  :             _Mypair._Myval2._Mylast  = nullptr;

	movdqa	XMMWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+32, xmm0
$LN12@dynamic:
	lea	rcx, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
	add	rsp, 40					; 00000028H
	jmp	??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::~list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >
$LN29@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN40@dynamic:
??__FTextures@GLTextureLibrary@@YAXXZ ENDP		; GLTextureLibrary::`dynamic atexit destructor for 'Textures''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$dead$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAAX_K@Z PROC ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A, xmm0
	movups	XMMWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16, xmm0
	movups	XMMWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+32, xmm0
	movups	XMMWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48, xmm0
	ret	0
?__autoclassinit2@?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAAX_K@Z ENDP ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ PROC ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::~unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >, COMDAT
	jmp	??1?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
??1?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ ENDP ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::~unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::~_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >, COMDAT
$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 312  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx+24]
	test	rcx, rcx
	je	SHORT $LN6@Hash

; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+40]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN26@Hash

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN23@Hash

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN26@Hash:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 315  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+24], rax

; 316  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+32], rax

; 317  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+40], rax
$LN6@Hash:
	lea	rcx, QWORD PTR [rbx+8]
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::~list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >
$LN23@Hash:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN35@Hash:
??1?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::~_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?IsTextureLoaded@GLTextureLibrary@@YA_NPEAVTextureToGo@@@Z
_TEXT	SEGMENT
TexToGo$ = 8
?IsTextureLoaded@GLTextureLibrary@@YA_NPEAVTextureToGo@@@Z PROC ; GLTextureLibrary::IsTextureLoaded, COMDAT

; 41   : {

	mov	r11, rsp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	edx, cl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 41   : {

	mov	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 41   : {

	mov	QWORD PTR [r11+8], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	movzx	eax, BYTE PTR [r11+9]
	imul	rdx, rcx
	xor	rdx, rax
	movzx	eax, BYTE PTR [r11+10]
	imul	rdx, rcx
	xor	rdx, rax
	movzx	eax, BYTE PTR [r11+11]
	imul	rdx, rcx
	xor	rdx, rax
	movzx	eax, BYTE PTR [r11+12]
	imul	rdx, rcx
	xor	rdx, rax
	movzx	eax, BYTE PTR [r11+13]
	imul	rdx, rcx
	xor	rdx, rax
	movzx	eax, BYTE PTR [r11+14]
	imul	rdx, rcx
	xor	rdx, rax
	movzx	eax, BYTE PTR [r11+15]
	imul	rdx, rcx
	xor	rdx, rax
	imul	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
	and	rcx, rdx

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	shl	rcx, 4
	add	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	mov	rax, QWORD PTR [rcx+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1570 :         if (_Where == _End) {

	cmp	rax, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
	je	SHORT $LN36@IsTextureL

; 1571 :             return {_End, _Nodeptr{}};
; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	r8, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN22@IsTextureL
$LL21@IsTextureL:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};
; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rax, rcx
	je	SHORT $LN36@IsTextureL

; 1588 :                 return {_Where, _Nodeptr{}};
; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	r8, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL21@IsTextureL

; 1249 :             return static_cast<bool>(_Find_last(_Keyval, _Hashval)._Duplicate);

	test	rax, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 42   :     return GLTextureLibrary::Textures.count(TexToGo);

	setne	al

; 43   : }

	ret	0
$LN36@IsTextureL:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1249 :             return static_cast<bool>(_Find_last(_Keyval, _Hashval)._Duplicate);

	xor	eax, eax
$LN22@IsTextureL:
	test	rax, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 42   :     return GLTextureLibrary::Textures.count(TexToGo);

	setne	al

; 43   : }

	ret	0
?IsTextureLoaded@GLTextureLibrary@@YA_NPEAVTextureToGo@@@Z ENDP ; GLTextureLibrary::IsTextureLoaded
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 80
$T4 = 136
$T5 = 168
TexToGo$GSCopy$ = 216
Sampler$GSCopy$ = 224
__$ArrayPad$ = 232
TexToGo$ = 272
Sampler$ = 280
Slot$dead$ = 288
?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; GLTextureLibrary::GetTexture, COMDAT

; 45   : {

$LN125:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 240				; 000000f0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rdx
	mov	rdi, rcx

; 44   : Texture* GLTextureLibrary::GetTexture(TextureToGo* TexToGo, std::string Sampler, GLenum Slot)

	mov	QWORD PTR TexToGo$GSCopy$[rsp], rcx
	mov	rbx, rcx
	shr	rbx, 56					; 00000038H
	mov	rax, rcx
	shr	rax, 48					; 00000030H
	movzx	r11d, al
	mov	rax, rcx
	shr	rax, 40					; 00000028H
	movzx	r10d, al
	mov	rax, rcx
	shr	rax, 32					; 00000020H
	movzx	r9d, al
	mov	rax, rcx
	shr	rax, 24
	movzx	r8d, al
	mov	rax, rcx
	shr	rax, 16
	movzx	edx, al
	mov	rax, rcx
	shr	rax, 8
	movzx	ecx, al
	movzx	eax, dil
	mov	QWORD PTR Sampler$GSCopy$[rsp], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rbp, -3750763034362895579		; cbf29ce484222325H
	xor	rax, rbp

; 2346 :         _Val *= _FNV_prime;

	mov	rbp, 1099511628211			; 00000100000001b3H
	imul	rax, rbp

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rax, rcx

; 2346 :         _Val *= _FNV_prime;

	imul	rax, rbp

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rax, rdx

; 2346 :         _Val *= _FNV_prime;

	imul	rax, rbp

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rax, r8

; 2346 :         _Val *= _FNV_prime;

	imul	rax, rbp

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rax, r9

; 2346 :         _Val *= _FNV_prime;

	imul	rax, rbp

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rax, r10

; 2346 :         _Val *= _FNV_prime;

	imul	rax, rbp

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rax, r11

; 2346 :         _Val *= _FNV_prime;

	imul	rax, rbp

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rax, rbx

; 2346 :         _Val *= _FNV_prime;

	imul	rax, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
	and	rcx, rax

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	shl	rcx, 4
	add	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	mov	rax, QWORD PTR [rcx+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1570 :         if (_Where == _End) {

	cmp	rax, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
	je	SHORT $LN102@GetTexture

; 1571 :             return {_End, _Nodeptr{}};
; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rcx]

; 1575 :         for (;;) {
; 1576 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	rdi, QWORD PTR [rax+16]
	je	SHORT $LN29@GetTexture
	npad	7
$LL28@GetTexture:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};
; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rax, rcx
	je	SHORT $LN102@GetTexture

; 1588 :                 return {_Where, _Nodeptr{}};
; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]

; 1575 :         for (;;) {
; 1576 :             // Search backwards to maintain sorted [_Bucket_lo, _Bucket_hi] when !_Standard
; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	rdi, QWORD PTR [rax+16]
	jne	SHORT $LL28@GetTexture
	jmp	SHORT $LN29@GetTexture
$LN102@GetTexture:

; 1249 :             return static_cast<bool>(_Find_last(_Keyval, _Hashval)._Duplicate);

	xor	eax, eax
$LN29@GetTexture:
	test	rax, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 46   :     if (!GLTextureLibrary::IsTextureLoaded(TexToGo))

	jne	$LN90@GetTexture

; 47   :         GLTextureLibrary::Textures.insert({ TexToGo, Texture(TexToGo, GL_RGBA, GL_TEXTURE_2D, Slot, GL_RGBA, GL_UNSIGNED_BYTE, Sampler) });

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR [rsp+56], rax
	mov	rdx, QWORD PTR TexToGo$GSCopy$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0Texture@@QEAA@PEAVTextureToGo@@IIIIIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Texture::Texture
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rcx, QWORD PTR TexToGo$GSCopy$[rsp]
	mov	QWORD PTR $T3[rsp], rcx
	mov	ecx, DWORD PTR [rax]
	mov	DWORD PTR $T3[rsp+8], ecx
	mov	ecx, DWORD PTR [rax+4]
	mov	DWORD PTR $T3[rsp+12], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm1, XMMWORD PTR [rax+8]
	movups	XMMWORD PTR $T3[rsp+16], xmm1
	movups	xmm0, XMMWORD PTR [rax+24]
	movups	XMMWORD PTR $T3[rsp+32], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 47   :         GLTextureLibrary::Textures.insert({ TexToGo, Texture(TexToGo, GL_RGBA, GL_TEXTURE_2D, Slot, GL_RGBA, GL_UNSIGNED_BYTE, Sampler) });

	mov	QWORD PTR [rax+24], 0
	mov	QWORD PTR [rax+32], 15
	mov	BYTE PTR [rax+8], 0
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR $T3[rsp+48], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	call	??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::emplace<std::pair<TextureToGo * const,Texture> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T3[rsp+16]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T5[rsp+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN90@GetTexture:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 438  :         return this->_Try_emplace(_Keyval).first->_Myval.second;

	lea	r8, QWORD PTR TexToGo$GSCopy$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Try_emplace<TextureToGo * const &>
	mov	rbx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 48   :     return &GLTextureLibrary::Textures[TexToGo];

	lea	rax, QWORD PTR [rbx+24]

; 49   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+288]
	add	rsp, 240				; 000000f0H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; GLTextureLibrary::GetTexture
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 80
$T4 = 136
$T5 = 168
TexToGo$GSCopy$ = 216
Sampler$GSCopy$ = 224
__$ArrayPad$ = 232
TexToGo$ = 272
Sampler$ = 280
Slot$dead$ = 288
?dtor$0@?0??GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA PROC ; `GLTextureLibrary::GetTexture'::`1'::dtor$0
	mov	rcx, QWORD PTR Sampler$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA ENDP ; `GLTextureLibrary::GetTexture'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 80
$T4 = 136
$T5 = 168
TexToGo$GSCopy$ = 216
Sampler$GSCopy$ = 224
__$ArrayPad$ = 232
TexToGo$ = 272
Sampler$ = 280
Slot$dead$ = 288
?dtor$2@?0??GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA PROC ; `GLTextureLibrary::GetTexture'::`1'::dtor$2
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1Texture@@QEAA@XZ
?dtor$2@?0??GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA ENDP ; `GLTextureLibrary::GetTexture'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 80
$T4 = 136
$T5 = 168
TexToGo$GSCopy$ = 216
Sampler$GSCopy$ = 224
__$ArrayPad$ = 232
TexToGo$ = 272
Sampler$ = 280
Slot$dead$ = 288
?dtor$3@?0??GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA PROC ; `GLTextureLibrary::GetTexture'::`1'::dtor$3
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@XZ
?dtor$3@?0??GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z@4HA ENDP ; `GLTextureLibrary::GetTexture'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??1Texture@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Texture@@QEAA@XZ PROC				; Texture::~Texture, COMDAT
	add	rcx, 8

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??1Texture@@QEAA@XZ ENDP				; Texture::~Texture
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??1?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@XZ PROC	; std::pair<TextureToGo * const,Texture>::~pair<TextureToGo * const,Texture>, COMDAT
	add	rcx, 16

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??1?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@XZ ENDP	; std::pair<TextureToGo * const,Texture>::~pair<TextureToGo * const,Texture>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Texture.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?Cleanup@GLTextureLibrary@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 112
?Cleanup@GLTextureLibrary@@YAXXZ PROC			; GLTextureLibrary::Cleanup, COMDAT

; 60   : {

$LN70:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rdi, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rbx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 61   :     for (auto& [TexToGo, Tex] : GLTextureLibrary::Textures)

	cmp	rbx, rdi
	je	SHORT $LN3@Cleanup
	npad	7
$LL31@Cleanup:
	lea	rdx, QWORD PTR [rbx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Texture.cpp

; 145  : 	glDeleteTextures(1, &ID);

	mov	ecx, 1
	call	QWORD PTR glad_glDeleteTextures
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 51   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rbx]
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 61   :     for (auto& [TexToGo, Tex] : GLTextureLibrary::Textures)

	cmp	rax, rdi
	jne	SHORT $LL31@Cleanup
$LN3@Cleanup:

; 65   :     Logger::Info("GLTextureLibrary", "Deleted textures");

	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR $T3[rsp], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	ebx, ebx
	mov	QWORD PTR $T1[rsp+16], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rsp+24], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+16]
	lea	rdx, OFFSET FLAT:??_C@_0BB@PBGFDDAA@Deleted?5textures@
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rsp+16], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rsp+24], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+16]
	lea	rdx, OFFSET FLAT:??_C@_0BB@OOKFAFMK@GLTextureLibrary@
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 65   :     Logger::Info("GLTextureLibrary", "Deleted textures");

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?Info@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Info

; 66   : }

	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?Cleanup@GLTextureLibrary@@YAXXZ ENDP			; GLTextureLibrary::Cleanup
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 112
?dtor$0@?0??Cleanup@GLTextureLibrary@@YAXXZ@4HA PROC	; `GLTextureLibrary::Cleanup'::`1'::dtor$0
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Cleanup@GLTextureLibrary@@YAXXZ@4HA ENDP	; `GLTextureLibrary::Cleanup'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?GenerateBoundingBox@BfresFile@@AEAAXXZ
_TEXT	SEGMENT
this$ = 112
?GenerateBoundingBox@BfresFile@@AEAAXXZ PROC		; BfresFile::GenerateBoundingBox, COMDAT

; 72   : void BfresFile::GenerateBoundingBox() {

$LN64:
	mov	r11, rsp
	push	rdi
	push	r12
	push	r13
	push	r15
	sub	rsp, 72					; 00000048H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	rdi, QWORD PTR [rcx]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r13, -6148914691236517205		; aaaaaaaaaaaaaaabH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 73   :     for (int SubModelIndex = 0; SubModelIndex < this->m_Models[0].Vertices.size(); SubModelIndex++)

	xor	r15d, r15d
	mov	r12, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rdi+32]
	sub	rax, QWORD PTR [rdi+24]
	sar	rax, 3
	imul	rax, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 73   :     for (int SubModelIndex = 0; SubModelIndex < this->m_Models[0].Vertices.size(); SubModelIndex++)

	test	rax, rax
	je	$LN3@GenerateBo
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+16], rbp
	mov	QWORD PTR [r11+24], rsi
	xor	esi, esi
	mov	QWORD PTR [r11-40], r14
	movaps	XMMWORD PTR [rsp+48], xmm6
	movaps	XMMWORD PTR [rsp+32], xmm7
	movsd	xmm7, QWORD PTR __real@4000000000000000
	npad	2
$LL4@GenerateBo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdi+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 75   :         for (int VertexIndex = 0; VertexIndex < this->m_Models[0].Vertices[SubModelIndex].size() / 3; VertexIndex++)

	xor	r14d, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rsi+rax+8]
	sub	rcx, QWORD PTR [rsi+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 75   :         for (int VertexIndex = 0; VertexIndex < this->m_Models[0].Vertices[SubModelIndex].size() / 3; VertexIndex++)

	mov	rax, r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 75   :         for (int VertexIndex = 0; VertexIndex < this->m_Models[0].Vertices[SubModelIndex].size() / 3; VertexIndex++)

	mul	rcx
	shr	rdx, 1
	je	$LN2@GenerateBo
	xor	ebp, ebp
$LL7@GenerateBo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 674  : _GENERIC_MATH2(pow)

	movaps	xmm1, xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rbx, QWORD PTR [rax+rsi]
	movss	xmm0, DWORD PTR [rbx+rbp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 674  : _GENERIC_MATH2(pow)

	cvtps2pd xmm0, xmm0
	call	pow
	movaps	xmm6, xmm0
	movaps	xmm1, xmm7
	movss	xmm0, DWORD PTR [rbx+rbp]
	cvtps2pd xmm0, xmm0
	call	pow
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 77   :             this->m_Models[0].BoundingBoxSphereRadius = std::fmax(this->m_Models[0].BoundingBoxSphereRadius, std::sqrt( std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 1], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 2], 2))); //sqrt(PointA^2 + PointB^2 + PointC^2) = distance to middle

	addsd	xmm6, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 674  : _GENERIC_MATH2(pow)

	movaps	xmm1, xmm7
	movss	xmm0, DWORD PTR [rbx+rbp+8]
	cvtps2pd xmm0, xmm0
	call	pow
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 77   :             this->m_Models[0].BoundingBoxSphereRadius = std::fmax(this->m_Models[0].BoundingBoxSphereRadius, std::sqrt( std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 1], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 2], 2))); //sqrt(PointA^2 + PointB^2 + PointC^2) = distance to middle

	addsd	xmm6, xmm0
	xorps	xmm1, xmm1
	ucomisd	xmm1, xmm6
	ja	SHORT $LN57@GenerateBo
	xorps	xmm1, xmm1
	sqrtsd	xmm1, xmm6
	jmp	SHORT $LN58@GenerateBo
$LN57@GenerateBo:
	movaps	xmm0, xmm6
	call	sqrt
	movaps	xmm1, xmm0
$LN58@GenerateBo:
	movss	xmm0, DWORD PTR [rdi+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 698  : _GENERIC_MATH2(fmax)

	cvtps2pd xmm0, xmm0
	call	QWORD PTR __imp_fmax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 77   :             this->m_Models[0].BoundingBoxSphereRadius = std::fmax(this->m_Models[0].BoundingBoxSphereRadius, std::sqrt( std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 1], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 2], 2))); //sqrt(PointA^2 + PointB^2 + PointC^2) = distance to middle

	mov	rax, QWORD PTR [r12]
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	inc	r14d
	add	rbp, 12
	movss	DWORD PTR [rax+96], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdi, QWORD PTR [r12]
	mov	rax, QWORD PTR [rdi+24]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rsi+rax+8]
	sub	rcx, QWORD PTR [rsi+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 75   :         for (int VertexIndex = 0; VertexIndex < this->m_Models[0].Vertices[SubModelIndex].size() / 3; VertexIndex++)

	mov	rax, r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 75   :         for (int VertexIndex = 0; VertexIndex < this->m_Models[0].Vertices[SubModelIndex].size() / 3; VertexIndex++)

	mul	rcx
	movsxd	rax, r14d
	shr	rdx, 1
	cmp	rax, rdx
	jb	$LL7@GenerateBo
$LN2@GenerateBo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 73   :     for (int SubModelIndex = 0; SubModelIndex < this->m_Models[0].Vertices.size(); SubModelIndex++)

	inc	r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 73   :     for (int SubModelIndex = 0; SubModelIndex < this->m_Models[0].Vertices.size(); SubModelIndex++)

	add	rsi, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 3
	imul	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 73   :     for (int SubModelIndex = 0; SubModelIndex < this->m_Models[0].Vertices.size(); SubModelIndex++)

	movsxd	rax, r15d
	cmp	rax, rcx
	jb	$LL4@GenerateBo
	movaps	xmm7, XMMWORD PTR [rsp+32]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+128]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+112]
$LN3@GenerateBo:

; 78   :         }
; 79   :     }
; 80   : }

	add	rsp, 72					; 00000048H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?GenerateBoundingBox@BfresFile@@AEAAXXZ ENDP		; BfresFile::GenerateBoundingBox
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?CreateOpenGLObjects@BfresFile@@QEAAXXZ
_TEXT	SEGMENT
SubModelIndex$1$ = 48
$T3 = 48
$T4 = 48
$T5 = 48
tv3603 = 56
<begin>$L1$1$ = 64
tv3604 = 72
<begin>$L0$1$ = 80
$T6 = 88
<end>$L1$1$ = 112
<end>$L0$1$ = 120
this$GSCopy$1$ = 128
$T7 = 144
$T8 = 176
$T9 = 208
Vertices$10 = 304
__$ArrayPad$ = 328
this$ = 416
?CreateOpenGLObjects@BfresFile@@QEAAXXZ PROC		; BfresFile::CreateOpenGLObjects, COMDAT

; 83   : {

$LN480:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-112]
	sub	rsp, 368				; 00000170H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r13, rcx
	mov	QWORD PTR this$GSCopy$1$[rbp-256], rcx

; 84   :     /* Creating OpenGL Objects */
; 85   :     for (BfresFile::Model& Model : this->m_Models)

	mov	r15, QWORD PTR [rcx]
	mov	QWORD PTR <begin>$L0$1$[rsp], r15
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR <end>$L0$1$[rsp], rax
	mov	r12, -6148914691236517205		; aaaaaaaaaaaaaaabH
	cmp	r15, rax
	je	$LN469@CreateOpen
	npad	11
$LL4@CreateOpen:

; 86   :     {
; 87   :         for (BfresFile::LOD& LODModel : Model.LODs)

	mov	r13, QWORD PTR [r15]
	mov	QWORD PTR <begin>$L1$1$[rsp], r13
	mov	rax, QWORD PTR [r15+8]
	mov	QWORD PTR <end>$L1$1$[rsp], rax
	cmp	r13, rax
	je	$LN2@CreateOpen
	lea	rdi, QWORD PTR [r13+32]
	npad	2
$LL7@CreateOpen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rdi+40]
	cmp	rax, QWORD PTR [rdi+48]
	je	SHORT $LN333@CreateOpen

; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rdi+48], rax
$LN333@CreateOpen:

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rdi+16]
	cmp	rax, QWORD PTR [rdi+24]
	je	SHORT $LN336@CreateOpen

; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rdi+24], rax
$LN336@CreateOpen:

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rdi-8]
	mov	rsi, QWORD PTR [rdi]
	cmp	rbx, rsi
	je	SHORT $LN360@CreateOpen
$LL366@CreateOpen:
	mov	rcx, rbx
	call	??1Mesh@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 96					; 00000060H
	cmp	rbx, rsi
	jne	SHORT $LL366@CreateOpen
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rsi, QWORD PTR [rdi-8]
	mov	QWORD PTR [rdi], rsi
	mov	rbx, rsi
$LN360@CreateOpen:

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rdi-24]
	sub	rdx, QWORD PTR [r13]
	sar	rdx, 3
	imul	rdx, r12

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rcx, rsi
	sub	rcx, rbx
	sar	rcx, 5
	imul	rcx, r12

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN344@CreateOpen

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	r14, QWORD PTR [rdx+rdx*2]
	shl	r14, 5
	add	r14, rbx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	r14, rsi
	je	SHORT $LN350@CreateOpen
	npad	7
$LL351@CreateOpen:
	mov	rcx, rbx
	call	??1Mesh@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rsi
	jne	SHORT $LL351@CreateOpen
$LN350@CreateOpen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rdi], r14

; 1564 :             return;

	jmp	SHORT $LN345@CreateOpen
$LN344@CreateOpen:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN345@CreateOpen

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+8]
	sub	rax, rbx
	sar	rax, 5
	imul	rax, r12

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN346@CreateOpen

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	lea	rcx, QWORD PTR [rdi-8]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<Mesh,std::allocator<Mesh> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN345@CreateOpen
$LN346@CreateOpen:

; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rsi
	call	??$_Uninitialized_value_construct_n@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@PEAV1@_KAEAV?$allocator@VMesh@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<Mesh> >
	mov	QWORD PTR [rdi], rax
$LN345@CreateOpen:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 94   :             for (int SubModelIndex = 0; SubModelIndex < LODModel.Faces.size(); SubModelIndex++)

	xor	r12d, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rdi-24]
	sub	rax, QWORD PTR [r13]
	sar	rax, 3
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 94   :             for (int SubModelIndex = 0; SubModelIndex < LODModel.Faces.size(); SubModelIndex++)

	test	rax, rax
	je	$LN5@CreateOpen
	xor	r13d, r13d
	mov	QWORD PTR tv3604[rsp], r12
	xor	r8d, r8d
	mov	QWORD PTR tv3603[rsp], r8
	npad	5
$LL10@CreateOpen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r15+48]

; 1864 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rbx, QWORD PTR [rax+r13+40]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 96   :                 if (Model.Materials[SubModelIndex].Textures.empty())

	cmp	rbx, QWORD PTR [rax+r13+48]
	je	$LN8@CreateOpen

; 97   :                 {
; 98   :                     continue;
; 99   :                 }
; 100  :                 std::vector<float>* TexCoords = &Model.Materials[SubModelIndex].Textures[0].TexCoordinates;
; 101  :                 if (TexCoords->empty())

	mov	rax, QWORD PTR [rbx+16]
	cmp	QWORD PTR [rbx+8], rax
	je	$LN8@CreateOpen
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR Vertices$10[rbp-256], xmm0
	mov	QWORD PTR Vertices$10[rbp-240], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r15+24]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [r8+rax+8]
	sub	rcx, QWORD PTR [r8+rax]
	sar	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 106  :                 std::vector<float> Vertices(Model.Vertices[SubModelIndex].size() / 3 * 5);

	mov	rax, rdx
	mul	rcx
	shr	rdx, 1
	lea	rsi, QWORD PTR [rdx+rdx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Vertices$10[rbp-256], xmm0
	mov	QWORD PTR Vertices$10[rbp-240], 0

; 2065 :         if (_Count != 0) {

	test	rsi, rsi
	je	SHORT $LN472@CreateOpen

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rsi, rax
	ja	$LN435@CreateOpen

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rsi
	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR Vertices$10[rbp-256], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r8, QWORD PTR [rsi*4]
	lea	rsi, QWORD PTR [r8+rax]
	mov	QWORD PTR Vertices$10[rbp-240], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR Vertices$10[rbp-248], rsi

; 2052 :         }
; 2053 :     }
; 2054 : 
; 2055 :     template <class... _Valty>
; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {
; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	mov	r8, QWORD PTR tv3603[rsp]
	jmp	SHORT $LN330@CreateOpen
$LN472@CreateOpen:
	mov	rsi, QWORD PTR Vertices$10[rbp-248]
$LN330@CreateOpen:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 108  :                 for (int VertexIndex = 0; VertexIndex < Vertices.size() / 5; VertexIndex++)

	xor	r14d, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r10, QWORD PTR Vertices$10[rbp-256]
	sub	rsi, r10
	sar	rsi, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 108  :                 for (int VertexIndex = 0; VertexIndex < Vertices.size() / 5; VertexIndex++)

	mov	rax, -3689348814741910323		; cccccccccccccccdH
	mul	rsi
	shr	rdx, 2
	test	rdx, rdx
	je	$LN12@CreateOpen
	mov	rax, QWORD PTR [r15+24]
	mov	rsi, QWORD PTR [r8+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	xor	r8d, r8d
	xor	r9d, r9d
	xor	r11d, r11d
$LL13@CreateOpen:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 110  :                     Vertices[VertexIndex * 5] = Model.Vertices[SubModelIndex][VertexIndex * 3];

	mov	eax, DWORD PTR [r11+rsi]
	mov	DWORD PTR [r8+r10], eax

; 111  :                     Vertices[VertexIndex * 5 + 1] = Model.Vertices[SubModelIndex][VertexIndex * 3 + 1];

	movss	xmm0, DWORD PTR [r11+rsi+4]
	movss	DWORD PTR [r8+r10+4], xmm0

; 112  :                     Vertices[VertexIndex * 5 + 2] = Model.Vertices[SubModelIndex][VertexIndex * 3 + 2];

	movss	xmm1, DWORD PTR [r11+rsi+8]
	movss	DWORD PTR [r8+r10+8], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1904 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx+16]
	sub	rax, rcx
	sar	rax, 2
	cmp	rax, r9
	jbe	$LN434@CreateOpen
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 114  :                     Vertices[VertexIndex * 5 + 3] = TexCoords->at(VertexIndex * 2);

	movss	xmm0, DWORD PTR [rcx+r9*4]
	movss	DWORD PTR [r8+r10+12], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1904 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx+16]
	sub	rcx, rdx
	sar	rcx, 2
	lea	rax, QWORD PTR [r9+1]
	cmp	rcx, rax
	jbe	$LN434@CreateOpen
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 115  :                     Vertices[VertexIndex * 5 + 4] = TexCoords->at(VertexIndex * 2 + 1);

	movss	xmm0, DWORD PTR [rdx+r9*4+4]
	movss	DWORD PTR [r8+r10+16], xmm0

; 108  :                 for (int VertexIndex = 0; VertexIndex < Vertices.size() / 5; VertexIndex++)

	inc	r14d
	add	r11, 12
	add	r9, 2
	add	r8, 20
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Vertices$10[rbp-248]
	sub	rcx, QWORD PTR Vertices$10[rbp-256]
	sar	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 108  :                 for (int VertexIndex = 0; VertexIndex < Vertices.size() / 5; VertexIndex++)

	mov	rax, -3689348814741910323		; cccccccccccccccdH
	mul	rcx
	shr	rdx, 2
	movsxd	rax, r14d
	cmp	rax, rdx
	jb	$LL13@CreateOpen
$LN12@CreateOpen:

; 118  :                 LODModel.GL_Meshes[SubModelIndex] = Mesh(Vertices, LODModel.Faces[SubModelIndex], { GLTextureLibrary::GetTexture(Model.Materials[SubModelIndex].Textures[0].Texture) });

	lea	rax, QWORD PTR $T8[rbp-256]
	mov	QWORD PTR $T5[rsp], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T8[rbp-256], xmm0
	mov	QWORD PTR $T8[rbp-240], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T7[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T7[rbp-240], 0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T7[rbp-232], 0

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR $T7[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r15+48]
	mov	rax, QWORD PTR [rax+r13+40]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 118  :                 LODModel.GL_Meshes[SubModelIndex] = Mesh(Vertices, LODModel.Faces[SubModelIndex], { GLTextureLibrary::GetTexture(Model.Materials[SubModelIndex].Textures[0].Texture) });

	lea	rdx, QWORD PTR $T7[rbp-256]
	mov	rcx, QWORD PTR [rax]
	call	?GetTexture@GLTextureLibrary@@YAPEAVTexture@@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; GLTextureLibrary::GetTexture
	mov	rbx, rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T6[rsp], xmm0
	mov	QWORD PTR $T6[rsp+16], 0

; 2010 :         _Buy_raw(_Newcapacity);

	mov	edx, 1
	lea	rcx, QWORD PTR $T6[rsp]
	call	?_Buy_raw@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K@Z ; std::vector<Texture *,std::allocator<Texture *> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rax, QWORD PTR $T6[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	QWORD PTR [rax], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	add	rax, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR $T6[rsp+8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 118  :                 LODModel.GL_Meshes[SubModelIndex] = Mesh(Vertices, LODModel.Faces[SubModelIndex], { GLTextureLibrary::GetTexture(Model.Materials[SubModelIndex].Textures[0].Texture) });

	movsxd	rax, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR <begin>$L1$1$[rsp]
	mov	rax, QWORD PTR [rax]
	lea	r8, QWORD PTR [rax+rcx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 118  :                 LODModel.GL_Meshes[SubModelIndex] = Mesh(Vertices, LODModel.Faces[SubModelIndex], { GLTextureLibrary::GetTexture(Model.Materials[SubModelIndex].Textures[0].Texture) });

	lea	rax, QWORD PTR $T8[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR Vertices$10[rbp-256]
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	??0Mesh@@QEAA@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@2@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@2@IV?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@2@@Z ; Mesh::Mesh
	mov	r14, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r15, QWORD PTR tv3604[rsp]
	add	r15, QWORD PTR [rdi-8]
	mov	rdx, rax
	mov	rcx, r15
	call	??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<float,std::allocator<float> >::operator=
	lea	rdx, QWORD PTR [r14+24]
	lea	rcx, QWORD PTR [r15+24]
	call	??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
	lea	rsi, QWORD PTR [r14+48]
	lea	rbx, QWORD PTR [r15+48]

; 737  :         if (this == _STD addressof(_Right)) {

	cmp	rbx, rsi
	je	SHORT $LN255@CreateOpen

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN231@CreateOpen

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR [rbx+16]
	sub	rax, rcx
	sar	rax, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN249@CreateOpen

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN179@CreateOpen

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN249@CreateOpen:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	ecx, ecx
	mov	QWORD PTR [rbx], rcx

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rcx

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rcx
$LN231@CreateOpen:

; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rbx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR [rbx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rsi+16]
	mov	QWORD PTR [rbx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	mov	QWORD PTR [rsi], rcx

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rcx

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rcx
$LN255@CreateOpen:
	mov	eax, DWORD PTR [r14+72]
	mov	DWORD PTR [r15+72], eax
	mov	eax, DWORD PTR [r14+76]
	mov	DWORD PTR [r15+76], eax
	mov	eax, DWORD PTR [r14+80]
	mov	DWORD PTR [r15+80], eax
	mov	eax, DWORD PTR [r14+84]
	mov	DWORD PTR [r15+84], eax
	mov	eax, DWORD PTR [r14+88]
	mov	DWORD PTR [r15+88], eax

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T9[rbp-208]
	test	rcx, rcx
	je	SHORT $LN111@CreateOpen

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T9[rbp-192]
	sub	rax, rcx
	sar	rax, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN129@CreateOpen

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN179@CreateOpen
$LN129@CreateOpen:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR $T9[rbp-208], 0
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqu	XMMWORD PTR $T9[rbp-200], xmm0
$LN111@CreateOpen:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T9[rbp-232]
	test	rcx, rcx
	je	SHORT $LN138@CreateOpen

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T9[rbp-216]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN156@CreateOpen

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN179@CreateOpen
$LN156@CreateOpen:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR $T9[rbp-232], 0
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqu	XMMWORD PTR $T9[rbp-224], xmm0
$LN138@CreateOpen:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T9[rbp-256]
	test	rcx, rcx
	je	SHORT $LN170@CreateOpen

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T9[rbp-240]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN182@CreateOpen

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN179@CreateOpen
$LN182@CreateOpen:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN170@CreateOpen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r15, QWORD PTR <begin>$L0$1$[rsp]
	mov	rax, QWORD PTR [r15+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 120  :                 if (Model.Materials[SubModelIndex].IsTransparent) LODModel.TransparentObjects.push_back(SubModelIndex);

	mov	DWORD PTR $T4[rsp], r12d
	cmp	BYTE PTR [rax+r13+32], 0
	je	SHORT $LN16@CreateOpen
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+48]
	cmp	rdx, QWORD PTR [rdi+56]
	je	SHORT $LN270@CreateOpen

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], r12d

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [rdi+48], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN276@CreateOpen
$LN270@CreateOpen:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	rcx, QWORD PTR [rdi+40]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 120  :                 if (Model.Materials[SubModelIndex].IsTransparent) LODModel.TransparentObjects.push_back(SubModelIndex);

	jmp	SHORT $LN477@CreateOpen
$LN16@CreateOpen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rdx, QWORD PTR [rdi+32]
	je	SHORT $LN277@CreateOpen

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], r12d

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [rdi+24], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN276@CreateOpen
$LN277@CreateOpen:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	rcx, QWORD PTR [rdi+16]
$LN477@CreateOpen:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 122  :             }

	lea	r8, QWORD PTR $T3[rsp]
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
	npad	1
$LN276@CreateOpen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Vertices$10[rbp-256]
	test	rcx, rcx
	je	SHORT $LN473@CreateOpen

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Vertices$10[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN210@CreateOpen

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN207@CreateOpen
$LN210@CreateOpen:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN473@CreateOpen:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 94   :             for (int SubModelIndex = 0; SubModelIndex < LODModel.Faces.size(); SubModelIndex++)

	mov	r8, QWORD PTR tv3603[rsp]
$LN8@CreateOpen:
	inc	r12d
	add	r8, 24
	mov	QWORD PTR tv3603[rsp], r8
	add	QWORD PTR tv3604[rsp], 96		; 00000060H
	add	r13, 64					; 00000040H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdi-24]
	mov	rax, QWORD PTR <begin>$L1$1$[rsp]
	sub	rcx, QWORD PTR [rax]
	sar	rcx, 3
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 94   :             for (int SubModelIndex = 0; SubModelIndex < LODModel.Faces.size(); SubModelIndex++)

	movsxd	rax, r12d
	cmp	rax, rcx
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	jb	$LL10@CreateOpen
	mov	r13, QWORD PTR <begin>$L1$1$[rsp]
$LN5@CreateOpen:

; 86   :     {
; 87   :         for (BfresFile::LOD& LODModel : Model.LODs)

	add	r13, 96					; 00000060H
	mov	QWORD PTR <begin>$L1$1$[rsp], r13
	add	rdi, 96					; 00000060H
	cmp	r13, QWORD PTR <end>$L1$1$[rsp]
	mov	r12, -6148914691236517205		; aaaaaaaaaaaaaaabH
	jne	$LL7@CreateOpen
$LN2@CreateOpen:

; 84   :     /* Creating OpenGL Objects */
; 85   :     for (BfresFile::Model& Model : this->m_Models)

	add	r15, 104				; 00000068H
	mov	QWORD PTR <begin>$L0$1$[rsp], r15
	cmp	r15, QWORD PTR <end>$L0$1$[rsp]
	jne	$LL4@CreateOpen
	mov	r13, QWORD PTR this$GSCopy$1$[rbp-256]
$LN469@CreateOpen:

; 73   :     for (int SubModelIndex = 0; SubModelIndex < this->m_Models[0].Vertices.size(); SubModelIndex++)

	xor	r12d, r12d
	mov	DWORD PTR SubModelIndex$1$[rsp], r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	rdi, QWORD PTR [r13]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rdi+32]
	sub	rax, QWORD PTR [rdi+24]
	sar	rax, 3
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 73   :     for (int SubModelIndex = 0; SubModelIndex < this->m_Models[0].Vertices.size(); SubModelIndex++)

	test	rax, rax
	je	$LN377@CreateOpen

; 86   :     {
; 87   :         for (BfresFile::LOD& LODModel : Model.LODs)

	xor	r14d, r14d
	movsd	xmm7, QWORD PTR __real@4000000000000000
	npad	6
$LL378@CreateOpen:

; 75   :         for (int VertexIndex = 0; VertexIndex < this->m_Models[0].Vertices[SubModelIndex].size() / 3; VertexIndex++)

	xor	r15d, r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdi+24]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [r14+rax+8]
	sub	rcx, QWORD PTR [r14+rax]
	sar	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 75   :         for (int VertexIndex = 0; VertexIndex < this->m_Models[0].Vertices[SubModelIndex].size() / 3; VertexIndex++)

	mov	rax, rdx
	mul	rcx
	shr	rdx, 1
	je	$LN376@CreateOpen

; 86   :     {
; 87   :         for (BfresFile::LOD& LODModel : Model.LODs)

	xor	esi, esi
	mov	r12, -6148914691236517205		; aaaaaaaaaaaaaaabH
	npad	1
$LL381@CreateOpen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdi+24]
	mov	rbx, QWORD PTR [rax+r14]
	movss	xmm0, DWORD PTR [rbx+rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 674  : _GENERIC_MATH2(pow)

	cvtps2pd xmm0, xmm0
	movaps	xmm1, xmm7
	call	pow
	movaps	xmm6, xmm0
	movss	xmm0, DWORD PTR [rbx+rsi+4]
	cvtps2pd xmm0, xmm0
	movaps	xmm1, xmm7
	call	pow
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 77   :             this->m_Models[0].BoundingBoxSphereRadius = std::fmax(this->m_Models[0].BoundingBoxSphereRadius, std::sqrt( std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 1], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 2], 2))); //sqrt(PointA^2 + PointB^2 + PointC^2) = distance to middle

	addsd	xmm6, xmm0
	movss	xmm0, DWORD PTR [rbx+rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 674  : _GENERIC_MATH2(pow)

	cvtps2pd xmm0, xmm0
	movaps	xmm1, xmm7
	call	pow
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 77   :             this->m_Models[0].BoundingBoxSphereRadius = std::fmax(this->m_Models[0].BoundingBoxSphereRadius, std::sqrt( std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 1], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 2], 2))); //sqrt(PointA^2 + PointB^2 + PointC^2) = distance to middle

	addsd	xmm6, xmm0
	xorps	xmm1, xmm1
	ucomisd	xmm1, xmm6
	ja	SHORT $LN470@CreateOpen
	xorps	xmm1, xmm1
	sqrtsd	xmm1, xmm6
	jmp	SHORT $LN471@CreateOpen
$LN179@CreateOpen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN207@CreateOpen:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN470@CreateOpen:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 77   :             this->m_Models[0].BoundingBoxSphereRadius = std::fmax(this->m_Models[0].BoundingBoxSphereRadius, std::sqrt( std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 1], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 2], 2))); //sqrt(PointA^2 + PointB^2 + PointC^2) = distance to middle

	movaps	xmm0, xmm6
	call	sqrt
	movaps	xmm1, xmm0
$LN471@CreateOpen:
	movss	xmm0, DWORD PTR [rdi+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 698  : _GENERIC_MATH2(fmax)

	cvtps2pd xmm0, xmm0
	call	QWORD PTR __imp_fmax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 77   :             this->m_Models[0].BoundingBoxSphereRadius = std::fmax(this->m_Models[0].BoundingBoxSphereRadius, std::sqrt( std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 1], 2) + std::pow(this->m_Models[0].Vertices[SubModelIndex][VertexIndex * 3 + 2], 2))); //sqrt(PointA^2 + PointB^2 + PointC^2) = distance to middle

	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
	mov	rax, QWORD PTR [r13]
	movss	DWORD PTR [rax+96], xmm1

; 75   :         for (int VertexIndex = 0; VertexIndex < this->m_Models[0].Vertices[SubModelIndex].size() / 3; VertexIndex++)

	inc	r15d
	add	rsi, 12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdi, QWORD PTR [r13]
	mov	rax, QWORD PTR [rdi+24]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [r14+rax+8]
	sub	rcx, QWORD PTR [r14+rax]
	sar	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 75   :         for (int VertexIndex = 0; VertexIndex < this->m_Models[0].Vertices[SubModelIndex].size() / 3; VertexIndex++)

	mov	rax, r12
	mul	rcx
	shr	rdx, 1
	movsxd	rax, r15d
	cmp	rax, rdx
	jb	$LL381@CreateOpen
	mov	r12d, DWORD PTR SubModelIndex$1$[rsp]
$LN376@CreateOpen:

; 73   :     for (int SubModelIndex = 0; SubModelIndex < this->m_Models[0].Vertices.size(); SubModelIndex++)

	inc	r12d
	mov	DWORD PTR SubModelIndex$1$[rsp], r12d
	add	r14, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rdi+32]
	sub	rcx, QWORD PTR [rdi+24]
	sar	rcx, 3
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rcx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 73   :     for (int SubModelIndex = 0; SubModelIndex < this->m_Models[0].Vertices.size(); SubModelIndex++)

	movsxd	rax, r12d
	cmp	rax, rcx
	jb	$LL378@CreateOpen
$LN377@CreateOpen:

; 127  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+368]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN434@CreateOpen:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1905 :             _Xrange();

	call	?_Xrange@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xrange
	npad	1
$LN435@CreateOpen:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN476@CreateOpen:
?CreateOpenGLObjects@BfresFile@@QEAAXXZ ENDP		; BfresFile::CreateOpenGLObjects
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
SubModelIndex$1$ = 48
$T3 = 48
$T4 = 48
$T5 = 48
tv3603 = 56
<begin>$L1$1$ = 64
tv3604 = 72
<begin>$L0$1$ = 80
$T6 = 88
<end>$L1$1$ = 112
<end>$L0$1$ = 120
this$GSCopy$1$ = 128
$T7 = 144
$T8 = 176
$T9 = 208
Vertices$10 = 304
__$ArrayPad$ = 328
this$ = 416
?dtor$0@?0??CreateOpenGLObjects@BfresFile@@QEAAXXZ@4HA PROC ; `BfresFile::CreateOpenGLObjects'::`1'::dtor$0
	lea	rcx, QWORD PTR Vertices$10[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??CreateOpenGLObjects@BfresFile@@QEAAXXZ@4HA ENDP ; `BfresFile::CreateOpenGLObjects'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
SubModelIndex$1$ = 48
$T3 = 48
$T4 = 48
$T5 = 48
tv3603 = 56
<begin>$L1$1$ = 64
tv3604 = 72
<begin>$L0$1$ = 80
$T6 = 88
<end>$L1$1$ = 112
<end>$L0$1$ = 120
this$GSCopy$1$ = 128
$T7 = 144
$T8 = 176
$T9 = 208
Vertices$10 = 304
__$ArrayPad$ = 328
this$ = 416
?dtor$1@?0??CreateOpenGLObjects@BfresFile@@QEAAXXZ@4HA PROC ; `BfresFile::CreateOpenGLObjects'::`1'::dtor$1
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::~vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
?dtor$1@?0??CreateOpenGLObjects@BfresFile@@QEAAXXZ@4HA ENDP ; `BfresFile::CreateOpenGLObjects'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z PROC ; std::vector<float,std::allocator<float> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z ENDP ; std::vector<float,std::allocator<float> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??4Mesh@@QEAAAEAV0@$$QEAV0@@Z
_TEXT	SEGMENT
this$ = 64
__that$ = 72
??4Mesh@@QEAAAEAV0@$$QEAV0@@Z PROC			; Mesh::operator=, COMDAT
$LN40:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx
	call	??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<float,std::allocator<float> >::operator=
	lea	rdx, QWORD PTR [rdi+24]
	lea	rcx, QWORD PTR [rbx+24]
	call	??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
	lea	r14, QWORD PTR [rdi+48]
	lea	rsi, QWORD PTR [rbx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 737  :         if (this == _STD addressof(_Right)) {

	cmp	rsi, r14
	je	SHORT $LN31@operator

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rsi]
	xor	ebp, ebp
	test	rcx, rcx
	je	SHORT $LN7@operator

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@operator

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN22@operator

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN25@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rsi], rbp

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rbp

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rbp
$LN7@operator:

; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR [rsi], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [r14+8]
	mov	QWORD PTR [rsi+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [r14+16]
	mov	QWORD PTR [rsi+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	mov	QWORD PTR [r14], rbp

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [r14+8], rbp

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [r14+16], rbp
$LN31@operator:
	mov	ecx, DWORD PTR [rdi+72]
	mov	rax, rbx
	mov	rbp, QWORD PTR [rsp+88]
	mov	DWORD PTR [rbx+72], ecx
	mov	ecx, DWORD PTR [rdi+76]
	mov	DWORD PTR [rbx+76], ecx
	mov	ecx, DWORD PTR [rdi+80]
	mov	DWORD PTR [rbx+80], ecx
	mov	ecx, DWORD PTR [rdi+84]
	mov	DWORD PTR [rbx+84], ecx
	mov	ecx, DWORD PTR [rdi+88]
	mov	DWORD PTR [rbx+88], ecx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN22@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN37@operator:
??4Mesh@@QEAAAEAV0@$$QEAV0@@Z ENDP			; Mesh::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z
_TEXT	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z PROC ; BfresFile::CreateDefaultModel, COMDAT

; 130  : {

$LN649:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-688]
	sub	rsp, 944				; 000003b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	movzx	r15d, r9b
	movzx	r12d, r8b
	mov	r14, rdx
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-256], rcx
	mov	QWORD PTR DefaultName$GSCopy$[rbp-256], rdx
	xor	r13d, r13d
	mov	DWORD PTR $T12[rsp], r13d
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	movups	XMMWORD PTR [rcx+96], xmm0

; 131  :     BfresFile DefaultModel;

	call	??0BfresFile@@QEAA@XZ			; BfresFile::BfresFile

; 221  :     return DefaultModel;

	mov	eax, 1
	mov	DWORD PTR $T12[rsp], eax

; 132  :     DefaultModel.IsDefaultModel() = true;

	mov	BYTE PTR [rsi+72], al

; 133  : 
; 134  :     float Vertices[] =
; 135  :     {
; 136  :         -Size, -Size, -Size,

	movss	xmm1, DWORD PTR Size$[rbp-256]
	movaps	xmm0, xmm1
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR Vertices$[rbp-256], xmm0
	movss	DWORD PTR Vertices$[rbp-252], xmm0
	movss	DWORD PTR Vertices$[rbp-248], xmm0

; 137  :          Size, -Size, -Size,

	movss	DWORD PTR Vertices$[rbp-244], xmm1
	movss	DWORD PTR Vertices$[rbp-240], xmm0
	movss	DWORD PTR Vertices$[rbp-236], xmm0

; 138  :          Size, -Size,  Size,

	movss	DWORD PTR Vertices$[rbp-232], xmm1
	movss	DWORD PTR Vertices$[rbp-228], xmm0
	movss	DWORD PTR Vertices$[rbp-224], xmm1

; 139  :         -Size, -Size,  Size,

	movss	DWORD PTR Vertices$[rbp-220], xmm0
	movss	DWORD PTR Vertices$[rbp-216], xmm0
	movss	DWORD PTR Vertices$[rbp-212], xmm1

; 140  : 
; 141  :         // Top face
; 142  :         -Size,  Size, -Size,

	movss	DWORD PTR Vertices$[rbp-208], xmm0
	movss	DWORD PTR Vertices$[rbp-204], xmm1
	movss	DWORD PTR Vertices$[rbp-200], xmm0

; 143  :          Size,  Size, -Size,

	movss	DWORD PTR Vertices$[rbp-196], xmm1
	movss	DWORD PTR Vertices$[rbp-192], xmm1
	movss	DWORD PTR Vertices$[rbp-188], xmm0

; 144  :          Size,  Size,  Size,

	movss	DWORD PTR Vertices$[rbp-184], xmm1
	movss	DWORD PTR Vertices$[rbp-180], xmm1
	movss	DWORD PTR Vertices$[rbp-176], xmm1

; 145  :         -Size,  Size,  Size,

	movss	DWORD PTR Vertices$[rbp-172], xmm0
	movss	DWORD PTR Vertices$[rbp-168], xmm1
	movss	DWORD PTR Vertices$[rbp-164], xmm1

; 146  :     };
; 147  : 
; 148  :     unsigned int Indices[] =
; 149  :     {
; 150  :         // Bottom face
; 151  :         0, 1, 2,

	mov	DWORD PTR Indices$[rbp-256], r13d
	mov	DWORD PTR Indices$[rbp-252], eax
	mov	QWORD PTR Indices$[rbp-248], 2

; 152  :         0, 2, 3,

	mov	DWORD PTR Indices$[rbp-240], 2
	mov	DWORD PTR Indices$[rbp-236], 3
	mov	DWORD PTR Indices$[rbp-232], 4
	mov	DWORD PTR Indices$[rbp-228], 5
	mov	DWORD PTR Indices$[rbp-224], 6

; 153  : 
; 154  :         // Top face
; 155  :         4, 5, 6,
; 156  :         4, 6, 7,

	mov	DWORD PTR Indices$[rbp-220], 4
	mov	DWORD PTR Indices$[rbp-216], 6
	mov	QWORD PTR Indices$[rbp-212], 7

; 157  : 
; 158  :         // Front face
; 159  :         0, 4, 5,

	mov	DWORD PTR Indices$[rbp-204], 4
	mov	QWORD PTR Indices$[rbp-200], 5

; 160  :         0, 5, 1,

	mov	DWORD PTR Indices$[rbp-192], 5
	mov	DWORD PTR Indices$[rbp-188], eax

; 161  : 
; 162  :         // Back face
; 163  :         3, 7, 6,

	mov	DWORD PTR Indices$[rbp-184], 3
	mov	DWORD PTR Indices$[rbp-180], 7
	mov	DWORD PTR Indices$[rbp-176], 6

; 164  :         3, 6, 2,

	mov	DWORD PTR Indices$[rbp-172], 3
	mov	DWORD PTR Indices$[rbp-168], 6
	mov	QWORD PTR Indices$[rbp-164], 2

; 165  : 
; 166  :         // Left face
; 167  :         0, 3, 7,

	mov	DWORD PTR Indices$[rbp-156], 3
	mov	QWORD PTR Indices$[rbp-152], 7

; 168  :         0, 7, 4,

	mov	DWORD PTR Indices$[rbp-144], 7
	mov	DWORD PTR Indices$[rbp-140], 4

; 169  : 
; 170  :         1, 5, 6,

	mov	DWORD PTR Indices$[rbp-136], eax
	mov	DWORD PTR Indices$[rbp-132], 5
	mov	DWORD PTR Indices$[rbp-128], 6

; 171  :         1, 6, 2,

	mov	DWORD PTR Indices$[rbp-124], eax
	mov	DWORD PTR Indices$[rbp-120], 6
	mov	DWORD PTR Indices$[rbp-116], 2

; 172  :     };
; 173  : 
; 174  :     float TexCoords[] =
; 175  :     {
; 176  :         0.0f, 0.0f,

	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR TexCoords$[rbp-256], xmm0

; 177  :         1.0f, 0.0f,
; 178  :         1.0f, 1.0f,

	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000003f8000003f800000
	movaps	XMMWORD PTR TexCoords$[rbp-240], xmm1

; 179  :         0.0f, 1.0f,
; 180  : 
; 181  :         // Top face
; 182  :         0.0f, 0.0f,

	movaps	XMMWORD PTR TexCoords$[rbp-224], xmm0

; 183  :         1.0f, 0.0f,
; 184  :         1.0f, 1.0f,

	movaps	XMMWORD PTR TexCoords$[rbp-208], xmm1
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR Model$[rbp-256], xmm0
	xorps	xmm1, xmm1
	movdqa	XMMWORD PTR Model$[rbp-240], xmm1
	movdqa	XMMWORD PTR Model$[rbp-224], xmm0
	movdqa	XMMWORD PTR Model$[rbp-208], xmm1
	movdqa	XMMWORD PTR Model$[rbp-192], xmm0
	movdqa	XMMWORD PTR Model$[rbp-176], xmm1
	movdqa	XMMWORD PTR LODModel$[rbp-256], xmm0
	movdqa	XMMWORD PTR LODModel$[rbp-240], xmm1
	movdqa	XMMWORD PTR LODModel$[rbp-224], xmm0
	movdqa	XMMWORD PTR LODModel$[rbp-208], xmm1
	movdqa	XMMWORD PTR LODModel$[rbp-192], xmm0
	movdqa	XMMWORD PTR LODModel$[rbp-176], xmm1
	movdqu	XMMWORD PTR $T8[rsp], xmm0
	mov	QWORD PTR $T8[rsp+16], r13

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	lea	edx, QWORD PTR [rax+35]
	call	?allocate@?$allocator@I@std@@QEAAPEAI_K@Z ; std::allocator<unsigned int>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR $T8[rsp], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rax+144]
	mov	QWORD PTR $T8[rsp+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 144				; 00000090H
	lea	rdx, QWORD PTR Indices$[rbp-256]
	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR $T8[rsp+8], rbx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR LODModel$[rbp-248]
	cmp	rdx, QWORD PTR LODModel$[rbp-240]
	je	SHORT $LN117@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR $T8[rsp+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T8[rsp+16], r13
	mov	QWORD PTR $T8[rsp+8], r13

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR $T8[rsp]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T8[rsp], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx+16], rcx
	add	QWORD PTR LODModel$[rbp-248], 24

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN116@CreateDefa
$LN117@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T8[rsp]
	lea	rcx, QWORD PTR LODModel$[rbp-256]
	call	??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_reallocate<std::vector<unsigned int,std::allocator<unsigned int> > >
	npad	1
$LN116@CreateDefa:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T8[rsp]
	test	rcx, rcx
	je	SHORT $LN160@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T8[rsp+16]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN172@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN172@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN172@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN160@CreateDefa:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T11[rsp], xmm0
	mov	QWORD PTR $T11[rsp+16], r13

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, 24
	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR $T11[rsp], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rax+96]
	mov	QWORD PTR $T11[rsp+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 96					; 00000060H
	lea	rdx, QWORD PTR Vertices$[rbp-256]
	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR $T11[rsp+8], rbx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR Model$[rbp-224]
	cmp	rdx, QWORD PTR Model$[rbp-216]
	je	SHORT $LN222@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR $T11[rsp+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T11[rsp+16], r13
	mov	QWORD PTR $T11[rsp+8], r13

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR $T11[rsp]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T11[rsp], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx+16], rcx
	add	QWORD PTR Model$[rbp-224], 24

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN221@CreateDefa
$LN222@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T11[rsp]
	lea	rcx, QWORD PTR Model$[rbp-232]
	call	??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_reallocate<std::vector<float,std::allocator<float> > >
	npad	1
$LN221@CreateDefa:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T11[rsp]
	test	rcx, rcx
	je	SHORT $LN265@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T11[rsp+16]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN277@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN277@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN277@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN265@CreateDefa:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Material$[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	movdqa	xmm1, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR Material$[rbp-240], xmm1

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Material$[rbp-256], 0
	mov	BYTE PTR Material$[rbp-224], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR Material$[rbp-216], r13
	movdqa	XMMWORD PTR Material$[rbp-208], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 15
	lea	rdx, OFFSET FLAT:??_C@_0BA@DMKNGAPB@Mt_DefaultModel@
	lea	rcx, QWORD PTR Material$[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR Texture$[rbp-248], r13
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR Texture$[rbp-240], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Texture$[rbp-224], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqa	XMMWORD PTR Texture$[rbp-208], xmm1

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR Texture$[rbp-224]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, 16
	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate
	mov	rbx, rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rdi, QWORD PTR [rax+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 64					; 00000040H
	lea	rdx, QWORD PTR TexCoords$[rbp-256]
	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Texture$[rbp-248]
	test	rcx, rcx
	je	SHORT $LN384@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR Texture$[rbp-232]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN396@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN396@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN396@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN384@CreateDefa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 412  :         _Myfirst = _Right._Myfirst;

	mov	QWORD PTR Texture$[rbp-248], rbx

; 413  :         _Mylast  = _Right._Mylast;

	mov	QWORD PTR Texture$[rbp-240], rdi

; 414  :         _Myend   = _Right._Myend;

	mov	QWORD PTR Texture$[rbp-232], rdi
	xorps	xmm0, xmm0
	movups	XMMWORD PTR TexToGo$[rbp-256], xmm0
	movups	XMMWORD PTR TexToGo$[rbp-240], xmm0
	movups	XMMWORD PTR TexToGo$[rbp-224], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	mov	QWORD PTR TexToGo$[rbp-256], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR TexToGo$[rbp-248], xmm0
	mov	QWORD PTR TexToGo$[rbp-232], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 41   : 	bool m_Transparent = false;

	mov	WORD PTR TexToGo$[rbp-214], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 201  :     TexToGo.GetPixels() = { Red, Green, Blue, Alpha };

	mov	BYTE PTR $T5[rsp], r12b
	mov	BYTE PTR $T5[rsp+1], r15b
	movzx	eax, BYTE PTR Blue$[rbp-256]
	mov	BYTE PTR $T5[rsp+2], al
	movzx	ebx, BYTE PTR Alpha$[rbp-256]
	mov	BYTE PTR $T5[rsp+3], bl
	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T6[rsp], rax
	lea	rax, QWORD PTR $T5[rsp+4]
	mov	QWORD PTR $T6[rsp+8], rax
	lea	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR TexToGo$[rbp-248]
	call	??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@V?$initializer_list@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=

; 202  :     TexToGo.GetWidth() = 1;

	mov	DWORD PTR TexToGo$[rbp-224], 65537	; 00010001H

; 203  :     TexToGo.GetHeight() = 1;
; 204  :     if (Alpha < 255)

	cmp	bl, 255					; 000000ffH
	jae	SHORT $LN2@CreateDefa

; 205  :     {
; 206  :         TexToGo.IsTransparent() = true;

	mov	BYTE PTR TexToGo$[rbp-214], 1

; 207  :         Material.IsTransparent = true;

	mov	BYTE PTR Material$[rbp-224], 1
$LN2@CreateDefa:

; 209  :     if(!TextureToGoLibrary::IsTextureLoaded(DefaultName))

	mov	rdx, r14
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 211  :     return TextureToGoLibrary::Textures.count(Name);

	mov	rdx, rax
	call	?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::count
	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 209  :     if(!TextureToGoLibrary::IsTextureLoaded(DefaultName))

	test	rdi, rdi
	jne	$LN614@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, r14
	lea	rcx, QWORD PTR $T13[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR TexToGo$[rbp-256]
	mov	QWORD PTR $T13[rbp-224], rax
	lea	rdx, QWORD PTR TexToGo$[rbp-248]
	lea	rcx, QWORD PTR $T13[rbp-216]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	movzx	eax, WORD PTR TexToGo$[rbp-224]
	mov	WORD PTR $T13[rbp-192], ax
	movzx	eax, WORD PTR TexToGo$[rbp-222]
	mov	WORD PTR $T13[rbp-190], ax
	movzx	eax, WORD PTR TexToGo$[rbp-220]
	mov	WORD PTR $T13[rbp-188], ax
	movzx	eax, BYTE PTR TexToGo$[rbp-218]
	mov	BYTE PTR $T13[rbp-186], al
	movzx	eax, WORD PTR TexToGo$[rbp-216]
	mov	WORD PTR $T13[rbp-184], ax
	movzx	eax, BYTE PTR TexToGo$[rbp-214]
	mov	BYTE PTR $T13[rbp-182], al
	movzx	eax, BYTE PTR TexToGo$[rbp-213]
	mov	BYTE PTR $T13[rbp-181], al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 210  :         TextureToGoLibrary::Textures.insert({ DefaultName, TexToGo });

	lea	r8, QWORD PTR $T13[rbp-256]
	lea	rdx, QWORD PTR $T7[rsp]
	call	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::insert<0,0>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T13[rbp-216]
	test	rcx, rcx
	je	SHORT $LN588@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T13[rbp-200]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN606@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN606@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN606@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR $T13[rbp-216], r13
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqa	XMMWORD PTR $T13[rbp-208], xmm0
$LN588@CreateDefa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T13[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN614@CreateDefa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 212  :     Texture.Texture = TextureToGoLibrary::GetTexture(DefaultName);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureToGoLibrary::GetTexture
	mov	QWORD PTR Texture$[rbp-256], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rbx, QWORD PTR Material$[rbp-208]
	cmp	rbx, QWORD PTR Material$[rbp-200]
	je	SHORT $LN449@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T4[rsp], rbx
	mov	QWORD PTR [rbx], rax
	lea	rcx, QWORD PTR [rbx+8]
	lea	rdx, QWORD PTR Texture$[rbp-248]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR Texture$[rbp-224]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR Material$[rbp-208], 64	; 00000040H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN448@CreateDefa
$LN449@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Texture$[rbp-256]
	mov	rdx, rbx
	lea	rcx, QWORD PTR Material$[rbp-216]
	call	??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>
$LN448@CreateDefa:

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR Model$[rbp-200]
	cmp	rax, QWORD PTR Model$[rbp-192]
	je	SHORT $LN464@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR Material$[rbp-256]
	mov	rcx, rax
	call	??0Material@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR Model$[rbp-200], 64		; 00000040H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN463@CreateDefa
$LN464@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Material$[rbp-256]
	mov	rdx, rax
	lea	rcx, QWORD PTR Model$[rbp-208]
	call	??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_reallocate<BfresFile::Material const &>
$LN463@CreateDefa:

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR Model$[rbp-248]
	cmp	rax, QWORD PTR Model$[rbp-240]
	je	SHORT $LN475@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR LODModel$[rbp-256]
	mov	rcx, rax
	call	??0LOD@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR Model$[rbp-248], 96		; 00000060H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN474@CreateDefa
$LN475@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR LODModel$[rbp-256]
	mov	rdx, rax
	lea	rcx, QWORD PTR Model$[rbp-256]
	call	??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_reallocate<BfresFile::LOD const &>
$LN474@CreateDefa:

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rsi+8]
	cmp	rax, QWORD PTR [rsi+16]
	je	SHORT $LN486@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR Model$[rbp-256]
	mov	rcx, rax
	call	??0Model@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rsi+8], 104			; 00000068H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN485@CreateDefa
$LN486@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Model$[rbp-256]
	mov	rdx, rax
	mov	rcx, rsi
	call	??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_reallocate<BfresFile::Model const &>
$LN485@CreateDefa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 219  :     DefaultModel.CreateOpenGLObjects();

	mov	rcx, rsi
	call	?CreateOpenGLObjects@BfresFile@@QEAAXXZ	; BfresFile::CreateOpenGLObjects
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR TexToGo$[rbp-248]
	test	rcx, rcx
	je	SHORT $LN500@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR TexToGo$[rbp-232]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN518@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN518@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN518@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR TexToGo$[rbp-248], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR TexToGo$[rbp-232], r13
$LN500@CreateDefa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Texture$[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Texture$[rbp-248]
	test	rcx, rcx
	je	SHORT $LN539@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR Texture$[rbp-232]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN551@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN551@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN551@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN539@CreateDefa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Material$[rbp-216]
	call	?_Tidy@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Material$[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 221  :     return DefaultModel;

	lea	rcx, QWORD PTR LODModel$[rbp-256]
	call	??1LOD@BfresFile@@QEAA@XZ
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Model$[rbp-184]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	lea	rcx, QWORD PTR Model$[rbp-208]
	call	?_Tidy@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Tidy
	lea	rcx, QWORD PTR Model$[rbp-232]
	call	?_Tidy@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Tidy
	lea	rcx, QWORD PTR Model$[rbp-256]
	call	?_Tidy@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Tidy
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, r14
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 221  :     return DefaultModel;

	mov	rax, rsi

; 222  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+1024]
	add	rsp, 944				; 000003b0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
	int	3
$LN646@CreateDefa:
?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z ENDP ; BfresFile::CreateDefaultModel
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$0@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$0
	mov	rcx, QWORD PTR DefaultName$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$1@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T12[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@dtor$1
	and	DWORD PTR $T12[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1BfresFile@@QEAA@XZ
$LN7@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$2@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$2
	lea	rcx, QWORD PTR Model$[rdx]
	jmp	??1Model@BfresFile@@QEAA@XZ
?dtor$2@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$3@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$3
	lea	rcx, QWORD PTR LODModel$[rdx]
	jmp	??1LOD@BfresFile@@QEAA@XZ
?dtor$3@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$4@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$4
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$4@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$5@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$5
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$5@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$6@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$6
	lea	rcx, QWORD PTR Material$[rdx]
	jmp	??1Material@BfresFile@@QEAA@XZ
?dtor$6@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$21@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$21
	lea	rcx, QWORD PTR Texture$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$21@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$7@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$7
	lea	rcx, QWORD PTR Texture$[rdx]
	jmp	??1BfresTexture@BfresFile@@QEAA@XZ
?dtor$7@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$9@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$9
	lea	rcx, QWORD PTR TexToGo$[rdx]
	jmp	??1TextureToGo@@QEAA@XZ
?dtor$9@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$39@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$39
	lea	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$39@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$39
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$11@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$11
	lea	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
?dtor$11@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$27@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultModel'::`1'::dtor$27
	mov	rcx, QWORD PTR $T4[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$27@?0??CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultModel'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0Model@BfresFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Model@BfresFile@@QEAA@XZ PROC			; BfresFile::Model::Model, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
	mov	QWORD PTR [rcx+56], rax
	mov	QWORD PTR [rcx+64], rax
	mov	QWORD PTR [rcx+72], rax
	mov	QWORD PTR [rcx+80], rax
	mov	QWORD PTR [rcx+88], rax
	mov	rax, rcx
	ret	0
??0Model@BfresFile@@QEAA@XZ ENDP			; BfresFile::Model::Model
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0LOD@BfresFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0LOD@BfresFile@@QEAA@XZ PROC				; BfresFile::LOD::LOD, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
	mov	QWORD PTR [rcx+56], rax
	mov	QWORD PTR [rcx+64], rax
	mov	QWORD PTR [rcx+72], rax
	mov	QWORD PTR [rcx+80], rax
	mov	QWORD PTR [rcx+88], rax
	mov	rax, rcx
	ret	0
??0LOD@BfresFile@@QEAA@XZ ENDP				; BfresFile::LOD::LOD
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0Material@BfresFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Material@BfresFile@@QEAA@XZ PROC			; BfresFile::Material::Material, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
	mov	BYTE PTR [rcx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
	mov	QWORD PTR [rcx+56], rax
	mov	rax, rcx
	ret	0
??0Material@BfresFile@@QEAA@XZ ENDP			; BfresFile::Material::Material
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@BfresFile@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@BfresFile@@QEAAX_K@Z PROC		; BfresFile::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	movups	XMMWORD PTR [rcx+96], xmm0
	ret	0
?__autoclassinit2@BfresFile@@QEAAX_K@Z ENDP		; BfresFile::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0BfresTexture@BfresFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0BfresTexture@BfresFile@@QEAA@XZ PROC			; BfresFile::BfresTexture::BfresTexture, COMDAT
$LN25:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	add	rcx, 32					; 00000020H
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0BfresTexture@BfresFile@@QEAA@XZ ENDP			; BfresFile::BfresTexture::BfresTexture
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0BfresTexture@BfresFile@@QEAA@XZ@4HA PROC	; `BfresFile::BfresTexture::BfresTexture'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0BfresTexture@BfresFile@@QEAA@XZ@4HA ENDP	; `BfresFile::BfresTexture::BfresTexture'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1TextureToGo@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1TextureToGo@@QEAA@XZ PROC				; TextureToGo::~TextureToGo, COMDAT
$LN36:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN6@TextureToG

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+24]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@TextureToG

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@TextureToG

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+8], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+16], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+24], rax
$LN6@TextureToG:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN33@TextureToG:
??1TextureToGo@@QEAA@XZ ENDP				; TextureToGo::~TextureToGo
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@TextureToGo@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@TextureToGo@@QEAAX_K@Z PROC		; TextureToGo::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	ret	0
?__autoclassinit2@TextureToGo@@QEAAX_K@Z ENDP		; TextureToGo::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>, COMDAT
$LN43:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx+40]
	test	rcx, rcx
	je	SHORT $LN9@pair

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+56]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@pair

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@pair

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@pair:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+40], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+48], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+56], rax
$LN9@pair:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN24@pair:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN40@pair:
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0BfresFile@@QEAA@$$QEAV0@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0BfresFile@@QEAA@$$QEAV0@@Z PROC			; BfresFile::BfresFile, COMDAT
$LN77:
	mov	QWORD PTR [rsp+8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]
	mov	r10, rdx
	mov	r9, QWORD PTR [rdx+16]
	mov	r11, rcx
	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	ebx, ebx
	mov	QWORD PTR [rdx+16], rbx
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r10+32]
	mov	rax, QWORD PTR [r10+24]
	mov	rdx, QWORD PTR [rdx+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+32], rbx
	mov	QWORD PTR [r10+24], rbx
	mov	QWORD PTR [r10+40], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+24], rax
	mov	QWORD PTR [r11+32], rcx
	mov	QWORD PTR [r11+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r10+48]
	mov	rdx, QWORD PTR [r10+64]
	mov	rcx, QWORD PTR [r10+56]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+64], rbx
	mov	QWORD PTR [r10+56], rbx
	mov	QWORD PTR [r10+48], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+48], rax
	mov	QWORD PTR [r11+56], rcx
	mov	QWORD PTR [r11+64], rdx
	movzx	eax, BYTE PTR [r10+72]
	mov	BYTE PTR [r11+72], al
	mov	rax, r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r11+80], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r11+96], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r11+104], rbx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r10+80]
	movups	XMMWORD PTR [r11+80], xmm0
	movups	xmm1, XMMWORD PTR [r10+96]
	movups	XMMWORD PTR [r11+96], xmm1
	mov	QWORD PTR [r10+96], rbx
	mov	QWORD PTR [r10+104], 15
	mov	BYTE PTR [r10+80], bl
	mov	rbx, QWORD PTR [rsp+8]
	ret	0
??0BfresFile@@QEAA@$$QEAV0@@Z ENDP			; BfresFile::BfresFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z
_TEXT	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z PROC ; BfresFile::CreateDefaultAreaModel, COMDAT

; 225  : {

$LN649:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-688]
	sub	rsp, 944				; 000003b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	movzx	r15d, r9b
	movzx	r12d, r8b
	mov	r14, rdx
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-256], rcx
	mov	QWORD PTR DefaultName$GSCopy$[rbp-256], rdx
	xor	r13d, r13d
	mov	DWORD PTR $T12[rsp], r13d
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	movups	XMMWORD PTR [rcx+96], xmm0

; 226  :     BfresFile DefaultModel;

	call	??0BfresFile@@QEAA@XZ			; BfresFile::BfresFile

; 316  :     return DefaultModel;

	mov	eax, 1
	mov	DWORD PTR $T12[rsp], eax

; 227  :     DefaultModel.IsDefaultModel() = true;

	mov	BYTE PTR [rsi+72], al

; 228  : 
; 229  :     float Vertices[] =
; 230  :     {
; 231  :         -Size * 0.5f, 0, -Size * 0.5f,

	movss	xmm4, DWORD PTR Size$[rbp-256]
	movaps	xmm3, xmm4
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm3, DWORD PTR __real@3f000000
	movss	DWORD PTR Vertices$[rbp-256], xmm3
	mov	DWORD PTR Vertices$[rbp-252], r13d
	movss	DWORD PTR Vertices$[rbp-248], xmm3

; 232  :          Size * 0.5f, 0, -Size * 0.5f,

	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR __real@3f000000
	movss	DWORD PTR Vertices$[rbp-244], xmm2
	mov	DWORD PTR Vertices$[rbp-240], r13d
	movss	DWORD PTR Vertices$[rbp-236], xmm3

; 233  :          Size * 0.5f, 0,  Size * 0.5f,

	movss	DWORD PTR Vertices$[rbp-232], xmm2
	mov	DWORD PTR Vertices$[rbp-228], r13d
	movss	DWORD PTR Vertices$[rbp-224], xmm2

; 234  :         -Size * 0.5f, 0,  Size * 0.5f,

	movss	DWORD PTR Vertices$[rbp-220], xmm3
	mov	DWORD PTR Vertices$[rbp-216], r13d
	movss	DWORD PTR Vertices$[rbp-212], xmm2

; 235  : 
; 236  :         // Top face
; 237  :         -Size * 0.5f,  Size, -Size * 0.5f,

	movss	DWORD PTR Vertices$[rbp-208], xmm3
	movss	DWORD PTR Vertices$[rbp-204], xmm4
	movss	DWORD PTR Vertices$[rbp-200], xmm3

; 238  :          Size * 0.5f,  Size, -Size * 0.5f,

	movss	DWORD PTR Vertices$[rbp-196], xmm2
	movss	DWORD PTR Vertices$[rbp-192], xmm4
	movss	DWORD PTR Vertices$[rbp-188], xmm3

; 239  :          Size * 0.5f,  Size,  Size * 0.5f,

	movss	DWORD PTR Vertices$[rbp-184], xmm2
	movss	DWORD PTR Vertices$[rbp-180], xmm4
	movss	DWORD PTR Vertices$[rbp-176], xmm2

; 240  :         -Size * 0.5f,  Size,  Size * 0.5f,

	movss	DWORD PTR Vertices$[rbp-172], xmm3
	movss	DWORD PTR Vertices$[rbp-168], xmm4
	movss	DWORD PTR Vertices$[rbp-164], xmm2

; 241  :     };
; 242  : 
; 243  :     unsigned int Indices[] =
; 244  :     {
; 245  :         // Bottom face
; 246  :         0, 1, 2,

	mov	DWORD PTR Indices$[rbp-256], r13d
	mov	DWORD PTR Indices$[rbp-252], eax
	mov	QWORD PTR Indices$[rbp-248], 2

; 247  :         0, 2, 3,

	mov	DWORD PTR Indices$[rbp-240], 2
	mov	DWORD PTR Indices$[rbp-236], 3
	mov	DWORD PTR Indices$[rbp-232], 4
	mov	DWORD PTR Indices$[rbp-228], 5
	mov	DWORD PTR Indices$[rbp-224], 6

; 248  : 
; 249  :         // Top face
; 250  :         4, 5, 6,
; 251  :         4, 6, 7,

	mov	DWORD PTR Indices$[rbp-220], 4
	mov	DWORD PTR Indices$[rbp-216], 6
	mov	QWORD PTR Indices$[rbp-212], 7

; 252  : 
; 253  :         // Front face
; 254  :         0, 4, 5,

	mov	DWORD PTR Indices$[rbp-204], 4
	mov	QWORD PTR Indices$[rbp-200], 5

; 255  :         0, 5, 1,

	mov	DWORD PTR Indices$[rbp-192], 5
	mov	DWORD PTR Indices$[rbp-188], eax

; 256  : 
; 257  :         // Back face
; 258  :         3, 7, 6,

	mov	DWORD PTR Indices$[rbp-184], 3
	mov	DWORD PTR Indices$[rbp-180], 7
	mov	DWORD PTR Indices$[rbp-176], 6

; 259  :         3, 6, 2,

	mov	DWORD PTR Indices$[rbp-172], 3
	mov	DWORD PTR Indices$[rbp-168], 6
	mov	QWORD PTR Indices$[rbp-164], 2

; 260  : 
; 261  :         // Left face
; 262  :         0, 3, 7,

	mov	DWORD PTR Indices$[rbp-156], 3
	mov	QWORD PTR Indices$[rbp-152], 7

; 263  :         0, 7, 4,

	mov	DWORD PTR Indices$[rbp-144], 7
	mov	DWORD PTR Indices$[rbp-140], 4

; 264  : 
; 265  :         1, 5, 6,

	mov	DWORD PTR Indices$[rbp-136], eax
	mov	DWORD PTR Indices$[rbp-132], 5
	mov	DWORD PTR Indices$[rbp-128], 6

; 266  :         1, 6, 2,

	mov	DWORD PTR Indices$[rbp-124], eax
	mov	DWORD PTR Indices$[rbp-120], 6
	mov	DWORD PTR Indices$[rbp-116], 2

; 267  :     };
; 268  : 
; 269  :     float TexCoords[] =
; 270  :     {
; 271  :         0.0f, 0.0f,

	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR TexCoords$[rbp-256], xmm0

; 272  :         1.0f, 0.0f,
; 273  :         1.0f, 1.0f,

	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000003f8000003f800000
	movaps	XMMWORD PTR TexCoords$[rbp-240], xmm1

; 274  :         0.0f, 1.0f,
; 275  : 
; 276  :         // Top face
; 277  :         0.0f, 0.0f,

	movaps	XMMWORD PTR TexCoords$[rbp-224], xmm0

; 278  :         1.0f, 0.0f,
; 279  :         1.0f, 1.0f,

	movaps	XMMWORD PTR TexCoords$[rbp-208], xmm1
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR Model$[rbp-256], xmm0
	xorps	xmm1, xmm1
	movdqa	XMMWORD PTR Model$[rbp-240], xmm1
	movdqa	XMMWORD PTR Model$[rbp-224], xmm0
	movdqa	XMMWORD PTR Model$[rbp-208], xmm1
	movdqa	XMMWORD PTR Model$[rbp-192], xmm0
	movdqa	XMMWORD PTR Model$[rbp-176], xmm1
	movdqa	XMMWORD PTR LODModel$[rbp-256], xmm0
	movdqa	XMMWORD PTR LODModel$[rbp-240], xmm1
	movdqa	XMMWORD PTR LODModel$[rbp-224], xmm0
	movdqa	XMMWORD PTR LODModel$[rbp-208], xmm1
	movdqa	XMMWORD PTR LODModel$[rbp-192], xmm0
	movdqa	XMMWORD PTR LODModel$[rbp-176], xmm1
	movdqu	XMMWORD PTR $T8[rsp], xmm0
	mov	QWORD PTR $T8[rsp+16], r13

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	lea	edx, QWORD PTR [rax+35]
	call	?allocate@?$allocator@I@std@@QEAAPEAI_K@Z ; std::allocator<unsigned int>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR $T8[rsp], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rax+144]
	mov	QWORD PTR $T8[rsp+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 144				; 00000090H
	lea	rdx, QWORD PTR Indices$[rbp-256]
	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR $T8[rsp+8], rbx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR LODModel$[rbp-248]
	cmp	rdx, QWORD PTR LODModel$[rbp-240]
	je	SHORT $LN117@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR $T8[rsp+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T8[rsp+16], r13
	mov	QWORD PTR $T8[rsp+8], r13

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR $T8[rsp]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T8[rsp], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx+16], rcx
	add	QWORD PTR LODModel$[rbp-248], 24

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN116@CreateDefa
$LN117@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T8[rsp]
	lea	rcx, QWORD PTR LODModel$[rbp-256]
	call	??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_reallocate<std::vector<unsigned int,std::allocator<unsigned int> > >
	npad	1
$LN116@CreateDefa:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T8[rsp]
	test	rcx, rcx
	je	SHORT $LN160@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T8[rsp+16]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN172@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN172@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN172@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN160@CreateDefa:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T11[rsp], xmm0
	mov	QWORD PTR $T11[rsp+16], r13

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, 24
	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR $T11[rsp], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rax+96]
	mov	QWORD PTR $T11[rsp+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 96					; 00000060H
	lea	rdx, QWORD PTR Vertices$[rbp-256]
	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR $T11[rsp+8], rbx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR Model$[rbp-224]
	cmp	rdx, QWORD PTR Model$[rbp-216]
	je	SHORT $LN222@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR $T11[rsp+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T11[rsp+16], r13
	mov	QWORD PTR $T11[rsp+8], r13

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR $T11[rsp]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T11[rsp], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx+16], rcx
	add	QWORD PTR Model$[rbp-224], 24

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN221@CreateDefa
$LN222@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T11[rsp]
	lea	rcx, QWORD PTR Model$[rbp-232]
	call	??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_reallocate<std::vector<float,std::allocator<float> > >
	npad	1
$LN221@CreateDefa:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T11[rsp]
	test	rcx, rcx
	je	SHORT $LN265@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T11[rsp+16]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN277@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN277@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN277@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN265@CreateDefa:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Material$[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	movdqa	xmm1, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR Material$[rbp-240], xmm1

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Material$[rbp-256], 0
	mov	BYTE PTR Material$[rbp-224], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR Material$[rbp-216], r13
	movdqa	XMMWORD PTR Material$[rbp-208], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 15
	lea	rdx, OFFSET FLAT:??_C@_0BA@DMKNGAPB@Mt_DefaultModel@
	lea	rcx, QWORD PTR Material$[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR Texture$[rbp-248], r13
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR Texture$[rbp-240], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Texture$[rbp-224], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqa	XMMWORD PTR Texture$[rbp-208], xmm1

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR Texture$[rbp-224]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, 16
	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate
	mov	rbx, rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rdi, QWORD PTR [rax+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 64					; 00000040H
	lea	rdx, QWORD PTR TexCoords$[rbp-256]
	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Texture$[rbp-248]
	test	rcx, rcx
	je	SHORT $LN384@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR Texture$[rbp-232]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN396@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN396@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN396@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN384@CreateDefa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 412  :         _Myfirst = _Right._Myfirst;

	mov	QWORD PTR Texture$[rbp-248], rbx

; 413  :         _Mylast  = _Right._Mylast;

	mov	QWORD PTR Texture$[rbp-240], rdi

; 414  :         _Myend   = _Right._Myend;

	mov	QWORD PTR Texture$[rbp-232], rdi
	xorps	xmm0, xmm0
	movups	XMMWORD PTR TexToGo$[rbp-256], xmm0
	movups	XMMWORD PTR TexToGo$[rbp-240], xmm0
	movups	XMMWORD PTR TexToGo$[rbp-224], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	mov	QWORD PTR TexToGo$[rbp-256], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR TexToGo$[rbp-248], xmm0
	mov	QWORD PTR TexToGo$[rbp-232], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 41   : 	bool m_Transparent = false;

	mov	WORD PTR TexToGo$[rbp-214], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 296  :     TexToGo.GetPixels() = { Red, Green, Blue, Alpha };

	mov	BYTE PTR $T5[rsp], r12b
	mov	BYTE PTR $T5[rsp+1], r15b
	movzx	eax, BYTE PTR Blue$[rbp-256]
	mov	BYTE PTR $T5[rsp+2], al
	movzx	ebx, BYTE PTR Alpha$[rbp-256]
	mov	BYTE PTR $T5[rsp+3], bl
	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T6[rsp], rax
	lea	rax, QWORD PTR $T5[rsp+4]
	mov	QWORD PTR $T6[rsp+8], rax
	lea	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR TexToGo$[rbp-248]
	call	??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@V?$initializer_list@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=

; 297  :     TexToGo.GetWidth() = 1;

	mov	DWORD PTR TexToGo$[rbp-224], 65537	; 00010001H

; 298  :     TexToGo.GetHeight() = 1;
; 299  :     if (Alpha < 255)

	cmp	bl, 255					; 000000ffH
	jae	SHORT $LN2@CreateDefa

; 300  :     {
; 301  :         TexToGo.IsTransparent() = true;

	mov	BYTE PTR TexToGo$[rbp-214], 1

; 302  :         Material.IsTransparent = true;

	mov	BYTE PTR Material$[rbp-224], 1
$LN2@CreateDefa:

; 304  :     if (!TextureToGoLibrary::IsTextureLoaded(DefaultName))

	mov	rdx, r14
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 211  :     return TextureToGoLibrary::Textures.count(Name);

	mov	rdx, rax
	call	?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::count
	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 304  :     if (!TextureToGoLibrary::IsTextureLoaded(DefaultName))

	test	rdi, rdi
	jne	$LN614@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, r14
	lea	rcx, QWORD PTR $T13[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR TexToGo$[rbp-256]
	mov	QWORD PTR $T13[rbp-224], rax
	lea	rdx, QWORD PTR TexToGo$[rbp-248]
	lea	rcx, QWORD PTR $T13[rbp-216]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	movzx	eax, WORD PTR TexToGo$[rbp-224]
	mov	WORD PTR $T13[rbp-192], ax
	movzx	eax, WORD PTR TexToGo$[rbp-222]
	mov	WORD PTR $T13[rbp-190], ax
	movzx	eax, WORD PTR TexToGo$[rbp-220]
	mov	WORD PTR $T13[rbp-188], ax
	movzx	eax, BYTE PTR TexToGo$[rbp-218]
	mov	BYTE PTR $T13[rbp-186], al
	movzx	eax, WORD PTR TexToGo$[rbp-216]
	mov	WORD PTR $T13[rbp-184], ax
	movzx	eax, BYTE PTR TexToGo$[rbp-214]
	mov	BYTE PTR $T13[rbp-182], al
	movzx	eax, BYTE PTR TexToGo$[rbp-213]
	mov	BYTE PTR $T13[rbp-181], al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 305  :         TextureToGoLibrary::Textures.insert({ DefaultName, TexToGo });

	lea	r8, QWORD PTR $T13[rbp-256]
	lea	rdx, QWORD PTR $T7[rsp]
	call	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::insert<0,0>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T13[rbp-216]
	test	rcx, rcx
	je	SHORT $LN588@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T13[rbp-200]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN606@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN606@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN606@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR $T13[rbp-216], r13
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqa	XMMWORD PTR $T13[rbp-208], xmm0
$LN588@CreateDefa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T13[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN614@CreateDefa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 307  :     Texture.Texture = TextureToGoLibrary::GetTexture(DefaultName);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T9[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureToGoLibrary::GetTexture
	mov	QWORD PTR Texture$[rbp-256], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rbx, QWORD PTR Material$[rbp-208]
	cmp	rbx, QWORD PTR Material$[rbp-200]
	je	SHORT $LN449@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T4[rsp], rbx
	mov	QWORD PTR [rbx], rax
	lea	rcx, QWORD PTR [rbx+8]
	lea	rdx, QWORD PTR Texture$[rbp-248]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR Texture$[rbp-224]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR Material$[rbp-208], 64	; 00000040H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN448@CreateDefa
$LN449@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Texture$[rbp-256]
	mov	rdx, rbx
	lea	rcx, QWORD PTR Material$[rbp-216]
	call	??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>
$LN448@CreateDefa:

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR Model$[rbp-200]
	cmp	rax, QWORD PTR Model$[rbp-192]
	je	SHORT $LN464@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR Material$[rbp-256]
	mov	rcx, rax
	call	??0Material@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR Model$[rbp-200], 64		; 00000040H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN463@CreateDefa
$LN464@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Material$[rbp-256]
	mov	rdx, rax
	lea	rcx, QWORD PTR Model$[rbp-208]
	call	??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_reallocate<BfresFile::Material const &>
$LN463@CreateDefa:

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR Model$[rbp-248]
	cmp	rax, QWORD PTR Model$[rbp-240]
	je	SHORT $LN475@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR LODModel$[rbp-256]
	mov	rcx, rax
	call	??0LOD@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR Model$[rbp-248], 96		; 00000060H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN474@CreateDefa
$LN475@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR LODModel$[rbp-256]
	mov	rdx, rax
	lea	rcx, QWORD PTR Model$[rbp-256]
	call	??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_reallocate<BfresFile::LOD const &>
$LN474@CreateDefa:

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rsi+8]
	cmp	rax, QWORD PTR [rsi+16]
	je	SHORT $LN486@CreateDefa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR Model$[rbp-256]
	mov	rcx, rax
	call	??0Model@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rsi+8], 104			; 00000068H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN485@CreateDefa
$LN486@CreateDefa:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Model$[rbp-256]
	mov	rdx, rax
	mov	rcx, rsi
	call	??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_reallocate<BfresFile::Model const &>
$LN485@CreateDefa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 314  :     DefaultModel.CreateOpenGLObjects();

	mov	rcx, rsi
	call	?CreateOpenGLObjects@BfresFile@@QEAAXXZ	; BfresFile::CreateOpenGLObjects
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR TexToGo$[rbp-248]
	test	rcx, rcx
	je	SHORT $LN500@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR TexToGo$[rbp-232]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN518@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN518@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN518@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR TexToGo$[rbp-248], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR TexToGo$[rbp-232], r13
$LN500@CreateDefa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Texture$[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Texture$[rbp-248]
	test	rcx, rcx
	je	SHORT $LN539@CreateDefa

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR Texture$[rbp-232]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN551@CreateDefa

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN551@CreateDefa
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN551@CreateDefa:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN539@CreateDefa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Material$[rbp-216]
	call	?_Tidy@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Material$[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 316  :     return DefaultModel;

	lea	rcx, QWORD PTR LODModel$[rbp-256]
	call	??1LOD@BfresFile@@QEAA@XZ
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Model$[rbp-184]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	lea	rcx, QWORD PTR Model$[rbp-208]
	call	?_Tidy@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Tidy
	lea	rcx, QWORD PTR Model$[rbp-232]
	call	?_Tidy@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Tidy
	lea	rcx, QWORD PTR Model$[rbp-256]
	call	?_Tidy@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Tidy
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, r14
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 316  :     return DefaultModel;

	mov	rax, rsi

; 317  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+1024]
	add	rsp, 944				; 000003b0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
	int	3
$LN646@CreateDefa:
?CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z ENDP ; BfresFile::CreateDefaultAreaModel
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$0@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$0
	mov	rcx, QWORD PTR DefaultName$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$1@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T12[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@dtor$1
	and	DWORD PTR $T12[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1BfresFile@@QEAA@XZ
$LN7@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$2@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$2
	lea	rcx, QWORD PTR Model$[rdx]
	jmp	??1Model@BfresFile@@QEAA@XZ
?dtor$2@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$3@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$3
	lea	rcx, QWORD PTR LODModel$[rdx]
	jmp	??1LOD@BfresFile@@QEAA@XZ
?dtor$3@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$4@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$4
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$4@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$5@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$5
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$5@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$6@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$6
	lea	rcx, QWORD PTR Material$[rdx]
	jmp	??1Material@BfresFile@@QEAA@XZ
?dtor$6@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$21@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$21
	lea	rcx, QWORD PTR Texture$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$21@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$7@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$7
	lea	rcx, QWORD PTR Texture$[rdx]
	jmp	??1BfresTexture@BfresFile@@QEAA@XZ
?dtor$7@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$9@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$9
	lea	rcx, QWORD PTR TexToGo$[rdx]
	jmp	??1TextureToGo@@QEAA@XZ
?dtor$9@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$39@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$39
	lea	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$39@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$39
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$11@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$11
	lea	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
?dtor$11@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 80
$T10 = 80
$T11 = 80
$T12 = 112
$T13 = 128
__$ReturnUdt$GSCopy$ = 208
Texture$ = 224
DefaultName$GSCopy$ = 288
TexToGo$ = 296
Material$ = 352
Model$ = 416
LODModel$ = 528
Vertices$ = 624
Indices$ = 720
TexCoords$ = 864
__$ArrayPad$ = 928
__$ReturnUdt$ = 1008
DefaultName$ = 1016
Red$ = 1024
Green$ = 1032
Blue$ = 1040
Alpha$ = 1048
Size$ = 1056
?dtor$27@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA PROC ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$27
	mov	rcx, QWORD PTR $T4[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$27@?0??CreateDefaultAreaModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z@4HA ENDP ; `BfresFile::CreateDefaultAreaModel'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?ShortToFloat@BfresFile@@AEAAMEE@Z
_TEXT	SEGMENT
this$dead$ = 8
Result$ = 16
Byte1$ = 16
Byte2$ = 24
?ShortToFloat@BfresFile@@AEAAMEE@Z PROC			; BfresFile::ShortToFloat, COMDAT

; 321  :     uint16_t CombinedValue = (static_cast<uint16_t>(Byte2) << 8) | static_cast<uint16_t>(Byte1);

	movzx	ecx, r8b
	shl	cx, 8
	movzx	eax, dl
	or	cx, ax

; 322  :     if (CombinedValue == 0)

	jne	SHORT $LN2@ShortToFlo
	xorps	xmm0, xmm0

; 335  : }

	ret	0
$LN2@ShortToFlo:

; 323  :     {
; 324  :         return 0;
; 325  :     }
; 326  :     int32_t BiasedExponent = (CombinedValue >> 10) & 0x1F;
; 327  :     int32_t Mantissa = CombinedValue & 0x3FF;
; 328  : 
; 329  :     // Reconstruct the half-float value with proper exponent bias
; 330  :     int32_t RealExponent = BiasedExponent - 15 + 127;
; 331  :     uint32_t HalfFloatBits = ((CombinedValue & 0x8000) << 16) | (RealExponent << 23) | (Mantissa << 13);

	movzx	ecx, cx
	mov	edx, ecx
	mov	eax, ecx
	shr	edx, 10
	and	eax, 1023				; 000003ffH
	and	edx, 31
	shl	eax, 13
	shl	edx, 23
	add	edx, 939524096				; 38000000H
	shl	ecx, 16
	or	edx, eax
	and	ecx, -2147483648			; 80000000H
	or	edx, ecx

; 332  :     float Result;
; 333  :     std::memcpy(&Result, &HalfFloatBits, sizeof(float));

	mov	DWORD PTR Result$[rsp], edx

; 334  :     return Result;

	movss	xmm0, DWORD PTR Result$[rsp]

; 335  : }

	ret	0
?ShortToFloat@BfresFile@@AEAAMEE@Z ENDP			; BfresFile::ShortToFloat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?UInt32ToFloat@BfresFile@@AEAAMEEEE@Z
_TEXT	SEGMENT
this$dead$ = 8
Byte1$ = 16
Byte2$ = 24
Byte3$ = 32
ret$ = 40
Byte4$ = 40
?UInt32ToFloat@BfresFile@@AEAAMEEEE@Z PROC		; BfresFile::UInt32ToFloat, COMDAT

; 339  :     // Combine the four bytes into a uint32_t
; 340  :     uint32_t combinedValue = (static_cast<uint32_t>(Byte4) << 24) |

	movzx	ecx, BYTE PTR Byte4$[rsp]
	shl	ecx, 8
	movzx	eax, r9b
	or	ecx, eax
	movzx	eax, r8b
	shl	ecx, 8
	or	ecx, eax
	movzx	eax, dl
	shl	ecx, 8
	or	ecx, eax

; 341  :         (static_cast<uint32_t>(Byte3) << 16) |
; 342  :         (static_cast<uint32_t>(Byte2) << 8) |
; 343  :         static_cast<uint32_t>(Byte1);
; 344  : 
; 345  :     if (combinedValue == 0)

	jne	SHORT $LN2@UInt32ToFl
	xorps	xmm0, xmm0

; 353  : }

	ret	0
$LN2@UInt32ToFl:

; 346  :     {
; 347  :         return 0;
; 348  :     }
; 349  : 
; 350  :     float ret;
; 351  :     std::memcpy(&ret, &combinedValue, sizeof(float));

	mov	DWORD PTR ret$[rsp], ecx

; 352  :     return ret;

	movss	xmm0, DWORD PTR ret$[rsp]

; 353  : }

	ret	0
?UInt32ToFloat@BfresFile@@AEAAMEEEE@Z ENDP		; BfresFile::UInt32ToFloat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?CombineToUInt16@BfresFile@@AEAAGEE@Z
_TEXT	SEGMENT
this$dead$ = 8
Byte1$ = 16
Byte2$ = 24
?CombineToUInt16@BfresFile@@AEAAGEE@Z PROC		; BfresFile::CombineToUInt16, COMDAT

; 357  :     return (static_cast<uint16_t>(Byte2) << 8) | Byte1;

	movzx	eax, r8b
	shl	ax, 8
	movzx	ecx, dl
	or	ax, cx

; 358  : }

	ret	0
?CombineToUInt16@BfresFile@@AEAAGEE@Z ENDP		; BfresFile::CombineToUInt16
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
this$dead$ = 64
__$ReturnUdt$ = 72
Reader$ = 80
Offset$ = 88
?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z PROC ; BfresFile::ReadString, COMDAT

; 361  : {

$LN72:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, r8
	mov	rdi, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	ecx, ecx
	mov	DWORD PTR $T1[rsp], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	lea	eax, DWORD PTR [r9-1]
	mov	DWORD PTR [r8+8], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rcx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], cl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 371  :     return Result;

	mov	DWORD PTR $T1[rsp], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	movsxd	rcx, DWORD PTR [r8+8]
	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [r8+8], eax

; 51   : 	return this->m_Bytes[this->m_Offset];

	mov	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 51   : 	return this->m_Bytes[this->m_Offset];

	mov	rcx, QWORD PTR [rax]
	movzx	ebx, BYTE PTR [rdx+rcx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN35@ReadString

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN68@ReadString

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN68@ReadString:

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], bl

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 4053 :             return;

	jmp	SHORT $LN65@ReadString
$LN35@ReadString:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	movzx	r9d, bl
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN65@ReadString:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 366  :     while (CurrentCharacter != 0x00) {

	test	bl, bl
	je	SHORT $LN3@ReadString
	npad	8
$LL2@ReadString:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	movsxd	rcx, DWORD PTR [rsi+8]
	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rsi+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 51   : 	return this->m_Bytes[this->m_Offset];

	mov	rbx, QWORD PTR [rax]
	movzx	ebx, BYTE PTR [rcx+rbx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN49@ReadString

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN69@ReadString

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN69@ReadString:

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], bl

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 4053 :             return;

	jmp	SHORT $LN48@ReadString
$LN49@ReadString:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	movzx	r9d, bl
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN48@ReadString:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 366  :     while (CurrentCharacter != 0x00) {

	test	bl, bl
	jne	SHORT $LL2@ReadString
$LN3@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4071 :         _Eos(_Old_size - 1);

	mov	rax, QWORD PTR [rdi+16]
	dec	rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rcx, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN61@ReadString

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi]
$LN61@ReadString:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [rdi+16], rax
	mov	BYTE PTR [rcx+rax], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 371  :     return Result;

	mov	rax, rdi

; 372  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
	int	3
?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z ENDP ; BfresFile::ReadString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
this$dead$ = 64
__$ReturnUdt$ = 72
Reader$ = 80
Offset$ = 88
?dtor$0@?0??ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z@4HA PROC ; `BfresFile::ReadString'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z@4HA ENDP ; `BfresFile::ReadString'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?IsDefaultModel@BfresFile@@QEAAAEA_NXZ
_TEXT	SEGMENT
this$ = 8
?IsDefaultModel@BfresFile@@QEAAAEA_NXZ PROC		; BfresFile::IsDefaultModel, COMDAT

; 381  :     return this->m_DefaultModel;

	lea	rax, QWORD PTR [rcx+72]

; 382  : }

	ret	0
?IsDefaultModel@BfresFile@@QEAAAEA_NXZ ENDP		; BfresFile::IsDefaultModel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z
_TEXT	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z PROC ; BfresFile::BfresFile, COMDAT

; 385  : {

$LN2913:
	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-1640]
	sub	rsp, 1840				; 00000730H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	movaps	XMMWORD PTR [rax-104], xmm8
	movaps	XMMWORD PTR [rax-120], xmm9
	movaps	XMMWORD PTR [rax-136], xmm10
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rbx, r8
	mov	QWORD PTR Bytes$GSCopy$1$[rbp-256], rbx
	mov	r13, rdx
	mov	QWORD PTR Path$GSCopy$1$[rbp-256], rdx
	mov	r12, rcx
	mov	QWORD PTR this$GSCopy$1$[rbp-256], rcx
	mov	QWORD PTR this$GSCopy$[rbp-256], rcx
	mov	QWORD PTR Path$GSCopy$[rbp-256], rdx
	mov	QWORD PTR Bytes$GSCopy$[rbp-256], rbx
	xor	ecx, ecx
	mov	DWORD PTR $T18[rbp-256], ecx
	mov	DWORD PTR $T17[rbp-256], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r12], rcx
	mov	QWORD PTR [r12+8], rcx
	mov	QWORD PTR [r12+16], rcx
	mov	QWORD PTR [r12+24], rcx
	mov	QWORD PTR [r12+32], rcx
	mov	QWORD PTR [r12+40], rcx
	mov	QWORD PTR [r12+48], rcx
	mov	QWORD PTR [r12+56], rcx
	mov	QWORD PTR [r12+64], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.h

; 128  : 	bool m_DefaultModel = false;

	mov	BYTE PTR [r12+72], cl

; 129  : 	std::string m_Path = "";

	lea	rcx, QWORD PTR [r12+80]
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 6    : BinaryVectorReader::BinaryVectorReader(std::vector<unsigned char>& Bytes, bool BigEndian) : m_Bytes(Bytes) {}

	mov	QWORD PTR Reader$[rsp], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.h

; 39   : 	int m_Offset = -1;

	mov	DWORD PTR Reader$[rsp+8], -1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 389  :     Reader.Read(Magic, 4);

	mov	r8d, 4
	lea	rdx, QWORD PTR Magic$[rbp-256]
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Read@BinaryVectorReader@@QEAAXPEADH@Z	; BinaryVectorReader::Read

; 390  :     if (Magic[0] != 'F' && Magic[1] != 'R' && Magic[2] != 'E' && Magic[3] != 'S')

	cmp	BYTE PTR Magic$[rbp-256], 70		; 00000046H
	je	SHORT $LN75@BfresFile
	cmp	BYTE PTR Magic$[rbp-255], 82		; 00000052H
	je	SHORT $LN75@BfresFile
	cmp	BYTE PTR Magic$[rbp-254], 69		; 00000045H
	je	SHORT $LN75@BfresFile
	cmp	BYTE PTR Magic$[rbp-253], 83		; 00000053H
	je	SHORT $LN75@BfresFile

; 391  :     {
; 392  :         Logger::Error("Bfres", "Wrong magic, expected FRES");

	lea	rax, QWORD PTR $T41[rbp-256]
	mov	QWORD PTR $T16[rbp-256], rax
	lea	rdx, OFFSET FLAT:??_C@_0BL@PJEMKFHB@Wrong?5magic?0?5expected?5FRES@
	lea	rcx, QWORD PTR $T41[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	lea	rcx, QWORD PTR $T42[rbp-256]
$LN2910@BfresFile:

; 930  : }

	lea	rdx, OFFSET FLAT:??_C@_05JBOHDMDP@Bfres@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rbx
	mov	rcx, rax
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	jmp	$LN1@BfresFile
$LN75@BfresFile:

; 393  :         return;
; 394  :     }
; 395  : 
; 396  :     /* Check if BFRES is for switch, expecting 0x20202020 padding (4 bytes) */
; 397  :     uint32_t SwitchPadding = Reader.ReadUInt32();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32

; 398  :     if (SwitchPadding != 0x20202020)

	cmp	eax, 538976288				; 20202020H
	je	SHORT $LN76@BfresFile

; 399  :     {
; 400  :         Logger::Error("Bfres", "File is not a switch model");

	lea	rax, QWORD PTR $T43[rbp-256]
	mov	QWORD PTR $T15[rbp-256], rax
	lea	rdx, OFFSET FLAT:??_C@_0BL@CHFNEMLJ@File?5is?5not?5a?5switch?5model@
	lea	rcx, QWORD PTR $T43[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	lea	rcx, QWORD PTR $T44[rbp-256]

; 401  :         return;

	jmp	SHORT $LN2910@BfresFile
$LN76@BfresFile:

; 402  :     }
; 403  : 
; 404  :     /* Cheking Version, should be 0.10.0.0 */
; 405  :     uint8_t VersionNumberD = Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	movzx	r8d, al

; 406  :     uint8_t VersionNumberC = Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	movzx	ebx, al

; 407  :     uint8_t VersionNumberB = Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	movzx	r14d, al

; 408  :     uint8_t VersionNumberA = Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	movzx	r15d, al

; 409  :     if (VersionNumberA != 0x00 || VersionNumberB != 0x0A || VersionNumberC != 0x00 || VersionNumberD != 0x00)

	test	al, al
	jne	$LN78@BfresFile
	cmp	r14b, 10
	jne	$LN78@BfresFile
	test	bl, bl
	jne	$LN78@BfresFile
	test	r8b, r8b
	jne	$LN78@BfresFile

; 412  :         return;
; 413  :     }
; 414  : 
; 415  :     /* Checking Endian, 0xFEFF indicates that it is Little Endian, what this parser supports */
; 416  :     uint16_t Endian = Reader.ReadUInt16();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16

; 417  :     if (Endian != 0xFEFF)

	mov	ecx, 65279				; 0000feffH
	cmp	ax, cx
	je	SHORT $LN79@BfresFile

; 418  :     {
; 419  :         Logger::Error("Bfres", "Only little endian supported, got " + std::to_string(Endian));

	lea	rcx, QWORD PTR $T45[rbp-256]
	mov	QWORD PTR $T13[rbp-256], rcx
	movzx	edx, ax
	lea	rcx, QWORD PTR $T47[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
	mov	r8, rax
	lea	rdx, OFFSET FLAT:??_C@_0CD@ECKIPNII@Only?5little?5endian?5supported?0?5g@
	lea	rcx, QWORD PTR $T45[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	lea	rdx, OFFSET FLAT:??_C@_05JBOHDMDP@Bfres@
	lea	rcx, QWORD PTR $T46[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rbx
	mov	rcx, rax
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T47[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 420  :         return;

	jmp	$LN2900@BfresFile
$LN79@BfresFile:

; 421  :     }
; 422  : 
; 423  :     Reader.Seek(6, BinaryVectorReader::Position::Current); //Padding

	mov	r8b, 1
	mov	edx, 6
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 424  : 
; 425  :     uint32_t FileAlignment = Reader.ReadUInt32();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32

; 426  :     uint32_t RelocationTableOffset = Reader.ReadUInt32();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	edi, eax

; 427  :     uint32_t GlobalBufferOffset = Reader.ReadUInt32();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	ebx, eax

; 428  : 
; 429  :     Reader.Seek(8, BinaryVectorReader::Position::Current);

	mov	r8b, 1
	mov	edx, 8
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 430  : 
; 431  :     uint64_t FMDLOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	rsi, rax

; 432  :     uint64_t FMDLDict = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64

; 433  : 
; 434  :     Reader.Seek(0xDC, BinaryVectorReader::Position::Begin); //Skipping unnecessary information

	xor	r8d, r8d
	mov	edx, 220				; 000000dcH
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 435  :     uint16_t FMDLCount = Reader.ReadUInt16();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	movzx	r14d, ax
	mov	WORD PTR FMDLCount$1$[rbp-256], r14w

; 436  : 
; 437  :     this->m_Models.resize(FMDLCount);

	mov	edx, r14d
	mov	rcx, r12
	call	?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR Bytes$GSCopy$1$[rbp-256]
	mov	rcx, QWORD PTR [rax+8]
	sub	rcx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 440  :     if (GlobalBufferOffset == Bytes.size())

	cmp	rbx, rcx
	jne	SHORT $LN80@BfresFile

; 441  :     {
; 442  :         Reader.Seek(RelocationTableOffset, BinaryVectorReader::Position::Begin);

	xor	r8d, r8d
	mov	edx, edi
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 443  :         Reader.Seek(0x30, BinaryVectorReader::Position::Current);

	mov	r8b, 1
	mov	edx, 48					; 00000030H
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 444  :         DataStart = Reader.ReadUInt32();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32

; 445  :     }

	jmp	SHORT $LN2901@BfresFile
$LN80@BfresFile:

; 446  :     else
; 447  :     {
; 448  :         DataStart = GlobalBufferOffset + 288;

	lea	eax, DWORD PTR [rbx+288]
$LN2901@BfresFile:

; 449  :     }
; 450  : 
; 451  :     Reader.Seek(FMDLOffset, BinaryVectorReader::Position::Begin);

	mov	DWORD PTR DataStart$1$[rbp-256], eax
	xor	r8d, r8d
	mov	edx, esi
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 452  :     for (uint16_t FMDLIndex = 0; FMDLIndex < FMDLCount; FMDLIndex++)

	xor	eax, eax
	movzx	esi, ax
	mov	WORD PTR FMDLIndex$1$[rbp-256], ax
	cmp	ax, r14w
	jae	$LN2882@BfresFile
	xorps	xmm6, xmm6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	movss	xmm9, DWORD PTR __real@37800000
	movss	xmm7, DWORD PTR __real@3c000000
	movss	xmm8, DWORD PTR __real@3b800000
	movss	xmm10, DWORD PTR __real@38000000
	mov	r13d, DWORD PTR Reader$[rsp+8]
$LL4@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 457  :         Reader.Seek(FMDLBaseOffset + 24, BinaryVectorReader::Position::Begin);

	lea	edx, DWORD PTR [r13+25]
	xor	r8d, r8d
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 458  :         uint64_t FSKLOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	QWORD PTR FSKLOffset$1$[rbp-256], rax

; 459  :         uint64_t FVTXOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	QWORD PTR FVTXOffset$1$[rbp-256], rax

; 460  :         uint64_t FSHPOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	QWORD PTR FSHPOffset$1$[rbp-256], rax

; 461  :         uint64_t FMATValuesOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64

; 462  :         uint64_t FMATDictOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	rdi, rax

; 463  : 
; 464  :         Reader.Seek(FMDLBaseOffset + 104, BinaryVectorReader::Position::Begin);

	lea	edx, DWORD PTR [r13+105]
	xor	r8d, r8d
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 465  :         uint16_t FVTXCount = Reader.ReadUInt16();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	mov	WORD PTR FVTXCount$1$[rsp], ax

; 466  :         uint16_t FSHPCount = Reader.ReadUInt16();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	movzx	r9d, ax

; 467  :         uint16_t FMATCount = Reader.ReadUInt16();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	movzx	ebx, ax

; 469  :         this->m_Models[FMDLIndex].Materials.resize(FSHPCount);

	movzx	eax, si
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	r15, rax, 104				; 00000068H
	mov	QWORD PTR tv23932[rbp-256], r15
	mov	rcx, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 469  :         this->m_Models[FMDLIndex].Materials.resize(FSHPCount);

	add	rcx, 48					; 00000030H
	add	rcx, r15
	mov	QWORD PTR _Newsize$1$[rbp-256], r9
	mov	edx, r9d
	call	?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::resize

; 470  : 
; 471  :         std::vector<Material> Materials(FMATCount);

	lea	rcx, QWORD PTR Materials$60[rbp-256]
	call	?__autoclassinit2@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z
	mov	edx, ebx
	lea	rcx, QWORD PTR Materials$60[rbp-256]
	call	??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UMaterial@BfresFile@@@1@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::vector<BfresFile::Material,std::allocator<BfresFile::Material> >
	npad	1

; 472  : 
; 473  :         //Materials
; 474  :         Reader.Seek(FMATDictOffset, BinaryVectorReader::Position::Begin);

	xor	r8d, r8d
	mov	edx, edi
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 475  :         for (int FMATIndex = 0; FMATIndex < FMATCount; FMATIndex++)

	xor	r14d, r14d
	mov	edi, r14d
	mov	DWORD PTR FMATIndex$1$[rsp], r14d
	mov	DWORD PTR tv23863[rbp-256], ebx
	test	ebx, ebx
	je	$LN6@BfresFile
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 26   : 	return this->m_Offset + 1;

	mov	r13d, r14d
	mov	esi, DWORD PTR Reader$[rsp+8]
	npad	10
$LL7@BfresFile:
	lea	ebx, DWORD PTR [rsi+1]
	mov	DWORD PTR tv24012[rbp-256], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 478  :             Reader.Seek(8, BinaryVectorReader::Position::Current);

	mov	r8b, 1
	mov	edx, 8
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 480  :             Materials[FMATIndex].Name = this->ReadString(Reader, Reader.ReadUInt64() + 2);

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	lea	r9, QWORD PTR [rax+2]
	lea	r8, QWORD PTR Reader$[rsp]
	lea	rdx, QWORD PTR $T28[rbp-256]
	call	?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z ; BfresFile::ReadString
	mov	rdx, rax
	movsxd	rcx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rcx, 6
	mov	QWORD PTR tv23862[rbp-256], rcx
	add	rcx, QWORD PTR Materials$60[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 480  :             Materials[FMATIndex].Name = this->ReadString(Reader, Reader.ReadUInt64() + 2);

	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T28[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 482  :             Reader.Seek(FMATBaseOffset + 32, BinaryVectorReader::Position::Begin);

	lea	edx, DWORD PTR [rbx+32]
	xor	r8d, r8d
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 483  :             uint64_t TextureArrayOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	rsi, rax
	mov	QWORD PTR TextureArrayOffset$1$[rbp-256], rax

; 484  :             uint64_t TextureNameArray = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64

; 485  :             uint64_t SamplerArrayOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64

; 486  : 
; 487  :             uint64_t SamplerValuesOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	QWORD PTR SamplerValuesOffset$1$[rbp-256], rax

; 488  :             uint64_t SamplerOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64

; 489  : 
; 490  :             Reader.Seek(FMATBaseOffset + 162, BinaryVectorReader::Position::Begin);

	lea	edx, DWORD PTR [rbx+162]
	xor	r8d, r8d
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 491  :             uint8_t SamplerCount = Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8

; 492  :             uint8_t TextureCount = Reader.ReadUInt8();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	movzx	ebx, al

; 493  : 
; 494  :             Reader.Seek(TextureArrayOffset, BinaryVectorReader::Position::Begin);

	mov	edx, esi
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 495  : 
; 496  :             //std::vector<std::string> NrmTextureNames;
; 497  : 
; 498  :             std::vector<std::pair<TextureToGo*, std::string>> LocalTextures; //Texture pointer -> Sampler (_aN = Albedo)

	lea	rcx, QWORD PTR LocalTextures$53[rbp-256]
	call	?__autoclassinit2@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAX_K@Z
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR LocalTextures$53[rbp-256], xmm0
	mov	QWORD PTR LocalTextures$53[rbp-240], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 499  :             std::vector<std::pair<TextureToGo*, std::string>> LocalTransparentTextures; // - "" -

	lea	rcx, QWORD PTR LocalTransparentTextures$54[rbp-256]
	call	?__autoclassinit2@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAX_K@Z
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR LocalTransparentTextures$54[rbp-256], xmm0
	mov	QWORD PTR LocalTransparentTextures$54[rbp-240], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 501  :             if (Path.find("WaterPlane") != std::string::npos)

	lea	rdx, OFFSET FLAT:??_C@_0L@DMHOGPOL@WaterPlane@
	mov	rcx, QWORD PTR Path$GSCopy$1$[rbp-256]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	cmp	rax, -1
	je	SHORT $LN82@BfresFile

; 502  :             {
; 503  :                 LocalTextures.push_back({ TextureToGoLibrary::GetTexture("TerraWater01_Alb.txtg"), "_a0" });

	lea	rdx, OFFSET FLAT:??_C@_0BG@CFBMLDHA@TerraWater01_Alb?4txtg@
	lea	rcx, QWORD PTR $T40[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureToGoLibrary::GetTexture
	mov	QWORD PTR $T10[rsp], rax
	lea	rdx, QWORD PTR $T10[rsp]
	lea	rcx, QWORD PTR $T27[rbp-256]
	call	??$?0PEAVTextureToGo@@AEAY03$$CBD$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAPEAVTextureToGo@@AEAY03$$CBD@Z ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><TextureToGo *,char const (&)[4],0>
	npad	1
	lea	rdx, QWORD PTR $T27[rbp-256]
	lea	rcx, QWORD PTR LocalTextures$53[rbp-256]
	call	?push_back@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::push_back
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T27[rbp-248]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	DWORD PTR tv23860[rbp-256], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 504  :                 goto TextureInterpreter;

	jmp	$TextureInterpreter$2914
$LN82@BfresFile:

; 507  :             for (int i = 0; i < TextureCount; i++)

	mov	edi, r14d
	mov	DWORD PTR i$1$[rbp-256], r14d
	mov	DWORD PTR tv23860[rbp-256], ebx
	test	bl, bl
	je	$LN2898@BfresFile
	lea	r14d, DWORD PTR [rsi+7]
	mov	rsi, QWORD PTR SamplerValuesOffset$1$[rbp-256]
	add	esi, 32					; 00000020H
	mov	DWORD PTR tv24141[rsp], esi
	npad	1
$LL10@BfresFile:

; 508  :             {
; 509  :                 std::string TextureName = this->ReadString(Reader, Reader.ReadUInt64() + 2);

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	lea	r9, QWORD PTR [rax+2]
	lea	r8, QWORD PTR Reader$[rsp]
	lea	rdx, QWORD PTR TextureName$63[rbp-256]
	call	?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z ; BfresFile::ReadString
	npad	1

; 510  : 
; 511  :                 Reader.Seek(SamplerValuesOffset + 32 + i * 16, BinaryVectorReader::Position::Begin);

	xor	r8d, r8d
	mov	edx, esi
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 512  :                 Reader.Seek(Reader.ReadUInt64(), BinaryVectorReader::Position::Begin);

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	rdx, rax
	xor	r8d, r8d
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 513  : 
; 514  :                 uint16_t NameLength = Reader.ReadUInt16();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	movzx	ebx, ax

; 515  :                 std::string Sampler = "";

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR Sampler$61[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 516  :                 for (int j = 0; j < NameLength; j++) { //-1 to remove the index, normally textures are not _a, they are _a0, _a1, _a2 ... _an. Same for Nrm...

	xor	eax, eax
	cmp	ax, bx
	jae	SHORT $LN12@BfresFile

; 508  :             {
; 509  :                 std::string TextureName = this->ReadString(Reader, Reader.ReadUInt64() + 2);

	mov	edi, ebx
	mov	rsi, QWORD PTR Reader$[rsp]
	mov	ebx, DWORD PTR Reader$[rsp+8]
$LL13@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	inc	ebx
	movsxd	rax, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3236 :         push_back(_Ch);

	movzx	r9d, BYTE PTR [rax]

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR Sampler$61[rbp-240]
	mov	rdx, QWORD PTR Sampler$61[rbp-232]
	cmp	rcx, rdx

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN2311@BfresFile

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR Sampler$61[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Sampler$61[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR Sampler$61[rbp-256]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 4053 :             return;

	jmp	SHORT $LN11@BfresFile
$LN2311@BfresFile:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR Sampler$61[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN11@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 516  :                 for (int j = 0; j < NameLength; j++) { //-1 to remove the index, normally textures are not _a, they are _a0, _a1, _a2 ... _an. Same for Nrm...

	sub	rdi, 1
	jne	SHORT $LL13@BfresFile
	mov	edi, DWORD PTR i$1$[rbp-256]
	mov	esi, DWORD PTR tv24141[rsp]
$LN12@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Sampler$61[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Sampler$61[rbp-232], 16
	cmovae	rax, QWORD PTR Sampler$61[rbp-256]

; 1419 :         const auto _Rightsize = _Right._Mysize;

	cmp	QWORD PTR Sampler$61[rbp-240], 2

; 1420 :         if (_Mysize < _Rightsize) {

	jb	$LN2587@BfresFile

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	cmp	BYTE PTR [rax], 95			; 0000005fH
	jne	SHORT $LN2884@BfresFile
	cmp	BYTE PTR [rax+1], 97			; 00000061H
	jne	SHORT $LN2884@BfresFile
	xor	ebx, ebx
	mov	eax, ebx
	jmp	SHORT $LN2885@BfresFile
$LN2884@BfresFile:
	sbb	eax, eax
	or	eax, 1
	xor	ebx, ebx
$LN2885@BfresFile:

; 1423 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 522  :                 if (Sampler.starts_with("_a"))

	jne	$LN2587@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	rcx, QWORD PTR TextureName$63[rbp-240]
	sub	rax, rcx
	cmp	rax, 5
	jb	$LN2723@BfresFile

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r9, QWORD PTR TextureName$63[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR TextureName$63[rbp-232], 16
	cmovae	r9, QWORD PTR TextureName$63[rbp-256]

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 5
	lea	rax, OFFSET FLAT:??_C@_05KIAGMJIK@?4txtg@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T25[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	DWORD PTR $T18[rbp-256], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 524  :                     TextureToGo* TexToGo = TextureToGoLibrary::GetTexture(TextureName + ".txtg");

	lea	rcx, QWORD PTR $T25[rbp-256]
	call	?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureToGoLibrary::GetTexture

; 525  :                     if (TexToGo->IsTransparent())

	lea	rdx, QWORD PTR Sampler$61[rbp-256]
	cmp	BYTE PTR [rax+42], 0
	je	SHORT $LN85@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T21[rbp-256], rax
	lea	rcx, QWORD PTR $T21[rbp-248]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR LocalTransparentTextures$54[rbp-248]
	cmp	rdx, QWORD PTR LocalTransparentTextures$54[rbp-240]
	je	SHORT $LN2419@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR $T21[rbp-256]
	mov	QWORD PTR [rdx], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+24], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+32], rbx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR $T21[rbp-248]
	movups	XMMWORD PTR [rdx+8], xmm0
	movups	xmm1, XMMWORD PTR $T21[rbp-232]
	movups	XMMWORD PTR [rdx+24], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T21[rbp-232], rbx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T21[rbp-224], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T21[rbp-248], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR LocalTransparentTextures$54[rbp-248], 40 ; 00000028H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2418@BfresFile
$LN2419@BfresFile:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T21[rbp-256]
	lea	rcx, QWORD PTR LocalTransparentTextures$54[rbp-256]
	call	??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_reallocate<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
$LN2418@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T21[rbp-248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 528  :                     }

	jmp	SHORT $LN2902@BfresFile
$LN85@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T22[rbp-256], rax
	lea	rcx, QWORD PTR $T22[rbp-248]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR LocalTextures$53[rbp-248]
	cmp	rdx, QWORD PTR LocalTextures$53[rbp-240]
	je	SHORT $LN2507@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR $T22[rbp-256]
	mov	QWORD PTR [rdx], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+24], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+32], rbx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR $T22[rbp-248]
	movups	XMMWORD PTR [rdx+8], xmm0
	movups	xmm1, XMMWORD PTR $T22[rbp-232]
	movups	XMMWORD PTR [rdx+24], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T22[rbp-232], rbx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T22[rbp-224], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T22[rbp-248], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR LocalTextures$53[rbp-248], 40	; 00000028H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2506@BfresFile
$LN2507@BfresFile:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T22[rbp-256]
	lea	rcx, QWORD PTR LocalTextures$53[rbp-256]
	call	??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_reallocate<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	npad	1
$LN2506@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T22[rbp-248]
$LN2902@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN2587@BfresFile:
	mov	DWORD PTR Reader$[rsp+8], r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Sampler$61[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR TextureName$63[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 507  :             for (int i = 0; i < TextureCount; i++)

	inc	edi
	mov	DWORD PTR i$1$[rbp-256], edi
	add	esi, 16
	mov	DWORD PTR tv24141[rsp], esi
	add	r14d, 8
	cmp	edi, DWORD PTR tv23860[rbp-256]
	jl	$LL10@BfresFile
$LN2898@BfresFile:

; 529  :                     else
; 530  :                     {
; 531  :                         LocalTextures.push_back({ TexToGo, Sampler });
; 532  :                     }
; 533  :                     Reader.Seek(TextureArrayOffset + (i + 1) * 8, BinaryVectorReader::Position::Begin);
; 534  :                 }
; 535  :                 //else if (Sampler == "_n") NrmTextureNames.push_back(TextureName);
; 536  : 
; 537  :                 Reader.Seek(TextureArrayOffset + (i + 1) * 8, BinaryVectorReader::Position::Begin);
; 538  :             }
; 539  : 
; 540  :             TextureInterpreter:
; 541  : 
; 542  :             int LocalTextureCount = LocalTextures.size();

	xor	r14d, r14d
$TextureInterpreter$2914:
	lea	rcx, QWORD PTR LocalTextures$53[rbp-256]
	call	?size@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::size
	mov	r8, rax
	mov	QWORD PTR tv24151[rsp], rax

; 543  :             int LocalTransparentTextureCount = LocalTransparentTextures.size();

	lea	rcx, QWORD PTR LocalTransparentTextures$54[rbp-256]
	call	?size@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::size

; 544  :             Materials[FMATIndex].Textures.resize(LocalTextureCount + LocalTransparentTextureCount);

	lea	ebx, DWORD PTR [r8+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Materials$60[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 544  :             Materials[FMATIndex].Textures.resize(LocalTextureCount + LocalTransparentTextureCount);

	mov	rcx, QWORD PTR tv23862[rbp-256]
	add	rax, 40					; 00000028H
	add	rcx, rax
	mov	DWORD PTR tv23844[rsp], ebx
	movsxd	rdx, ebx
	call	?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::resize

; 547  :             for (int i = 0; i < (LocalTextureCount + LocalTransparentTextureCount); i++)

	mov	rsi, r14
	test	ebx, ebx
	jle	$LN15@BfresFile
	mov	rax, QWORD PTR tv24151[rsp]
	movsxd	rcx, eax
	mov	rbx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	xor	edx, edx
	mov	edi, edx
	mov	QWORD PTR tv24135[rsp], rdx
	neg	eax
	cdqe
	lea	rax, QWORD PTR [rax+rax*4]
	shl	rax, 3
	mov	QWORD PTR tv24134[rbp-256], rax
	imul	rax, rcx, -40				; ffffffffffffffd8H
	mov	QWORD PTR tv24133[rbp-256], rax
	mov	r15d, DWORD PTR tv23844[rsp]
	mov	r12, rcx
	npad	5
$LL16@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR MaterialTexture$49[rbp-248], rdx
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR MaterialTexture$49[rbp-240], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR MaterialTexture$49[rbp-224], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR MaterialTexture$49[rbp-208], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR MaterialTexture$49[rbp-200], rdx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR MaterialTexture$49[rbp-224]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 550  :                 MaterialTexture.Texture = i < LocalTextureCount ? LocalTextures[i].first : LocalTransparentTextures[i - LocalTextureCount].first;

	cmp	rsi, r12
	jge	SHORT $LN112@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR LocalTextures$53[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 550  :                 MaterialTexture.Texture = i < LocalTextureCount ? LocalTextures[i].first : LocalTransparentTextures[i - LocalTextureCount].first;

	mov	rax, QWORD PTR [rcx+r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdx, QWORD PTR [rcx+rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 551  :                 MaterialTexture.Sampler = i < LocalTextureCount ? LocalTextures[i].second : LocalTransparentTextures[i - LocalTextureCount].second;

	jmp	SHORT $LN2903@BfresFile
$LN112@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR tv24133[rbp-256]
	add	rax, QWORD PTR LocalTransparentTextures$54[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 550  :                 MaterialTexture.Texture = i < LocalTextureCount ? LocalTextures[i].first : LocalTransparentTextures[i - LocalTextureCount].first;

	mov	rax, QWORD PTR [rax+r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR tv24134[rbp-256]
	add	rdx, QWORD PTR LocalTransparentTextures$54[rbp-256]
	add	rdx, rdi
$LN2903@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 551  :                 MaterialTexture.Sampler = i < LocalTextureCount ? LocalTextures[i].second : LocalTransparentTextures[i - LocalTextureCount].second;

	mov	QWORD PTR MaterialTexture$49[rbp-256], rax
	add	rdx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR MaterialTexture$49[rbp-224]
	cmp	rax, rdx
	je	SHORT $LN2231@BfresFile

; 3157 :             return *this;
; 3158 :         }
; 3159 : 
; 3160 :         auto& _Al             = _Getal();
; 3161 :         const auto& _Right_al = _Right._Getal();
; 3162 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3163 :             if (_Al != _Right_al) {
; 3164 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3165 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3166 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3167 : 
; 3168 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3169 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3170 :                     const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3171 :                     auto _Right_al_non_const = _Right_al;
; 3172 :                     const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity + 1); // throws
; 3173 : 
; 3174 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_size + 1);
; 3175 : 
; 3176 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3177 :                     _Tidy_deallocate();
; 3178 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3179 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3180 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3181 :                 } else {
; 3182 :                     _Copy_assign_val_from_small(_Right);
; 3183 :                 }
; 3184 : 
; 3185 :                 _Pocca(_Al, _Right_al);
; 3186 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3187 :                 return *this;
; 3188 :             }
; 3189 :         }
; 3190 : 
; 3191 :         _Pocca(_Al, _Right_al);
; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdx+24], 16
	jb	SHORT $LN2235@BfresFile

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN2235@BfresFile:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	lea	rcx, QWORD PTR MaterialTexture$49[rbp-224]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2231@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 552  :                 if (i >= LocalTextureCount)

	cmp	rsi, r12
	jl	SHORT $LN87@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Materials$60[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 554  :                     Materials[FMATIndex].IsTransparent = true;

	mov	BYTE PTR [rax+r13+32], 1
$LN87@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Materials$60[rbp-256]
	mov	rdi, QWORD PTR [rax+r13+40]
	mov	rax, QWORD PTR MaterialTexture$49[rbp-256]
	mov	QWORD PTR [rbx+rdi], rax
	lea	rcx, QWORD PTR [rdi+8]
	add	rcx, rbx

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR MaterialTexture$49[rbp-248]
	cmp	rcx, rax
	je	SHORT $LN2267@BfresFile

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR MaterialTexture$49[rbp-240]
	mov	rdx, QWORD PTR MaterialTexture$49[rbp-248]
	sub	r8, rdx
	sar	r8, 2
	call	??$_Assign_counted_range@PEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAXPEAM_K@Z ; std::vector<float,std::allocator<float> >::_Assign_counted_range<float *>
$LN2267@BfresFile:
	lea	rcx, QWORD PTR [rdi+32]
	add	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR MaterialTexture$49[rbp-224]
	cmp	rcx, rax
	je	SHORT $LN2270@BfresFile

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR MaterialTexture$49[rbp-224]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR MaterialTexture$49[rbp-200], 16
	cmovae	rdx, QWORD PTR MaterialTexture$49[rbp-224]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR MaterialTexture$49[rbp-208]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
$LN2270@BfresFile:

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR MaterialTexture$49[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR MaterialTexture$49[rbp-248]
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 547  :             for (int i = 0; i < (LocalTextureCount + LocalTransparentTextureCount); i++)

	mov	rdi, QWORD PTR tv24135[rsp]
	add	rdi, 40					; 00000028H
	mov	QWORD PTR tv24135[rsp], rdi
	inc	rsi
	add	r14, 40					; 00000028H
	add	rbx, 64					; 00000040H
	sub	r15, 1
	mov	edx, 0
	jne	$LL16@BfresFile
	mov	r15, QWORD PTR tv23932[rbp-256]
	mov	r12, QWORD PTR this$GSCopy$1$[rbp-256]
	xor	r14d, r14d
$LN15@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR Materials$60[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 559  :             if (Materials[FMATIndex].Textures.empty())

	mov	rax, QWORD PTR [rcx+r13+48]
	cmp	QWORD PTR [rcx+r13+40], rax
	jne	$LN2887@BfresFile
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	rcx, QWORD PTR TextureArrayOffset$1$[rbp-256]
	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR Reader$[rsp+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 563  :                 for (int i = 0; i < TextureCount; i++)

	mov	DWORD PTR i$1$[rsp], r14d
	cmp	DWORD PTR tv23860[rbp-256], 0
	jbe	$LN2887@BfresFile
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	lea	eax, DWORD PTR [rcx+7]
	mov	DWORD PTR tv24132[rsp], eax
	mov	rdi, QWORD PTR SamplerValuesOffset$1$[rbp-256]
	add	edi, 31
	mov	DWORD PTR tv24131[rbp-256], edi
	npad	1
$LL19@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 565  :                     std::string TextureName = this->ReadString(Reader, Reader.ReadUInt64() + 2);

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	lea	r9, QWORD PTR [rax+2]
	lea	r8, QWORD PTR Reader$[rsp]
	lea	rdx, QWORD PTR TextureName$62[rbp-256]
	call	?ReadString@BfresFile@@AEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVBinaryVectorReader@@_K@Z ; BfresFile::ReadString
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	DWORD PTR Reader$[rsp+8], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 568  :                     Reader.Seek(Reader.ReadUInt64(), BinaryVectorReader::Position::Begin);

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 56   : 	this->m_Offset += 2;

	lea	edi, DWORD PTR [rax+1]

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movsxd	rcx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r14, QWORD PTR Reader$[rsp]
	mov	rax, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	esi, BYTE PTR [rax+rcx+1]
	movzx	ebx, BYTE PTR [rax+rcx]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Sampler$59[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR Sampler$59[rbp-240], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR Sampler$59[rbp-232], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR Sampler$59[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 572  :                     for (int j = 0; j < NameLength; j++) {

	shl	esi, 8
	or	esi, ebx
	jbe	SHORT $LN21@BfresFile

; 565  :                     std::string TextureName = this->ReadString(Reader, Reader.ReadUInt64() + 2);

	mov	ebx, esi
$LL22@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	movsxd	rax, edi
	lea	edi, DWORD PTR [rax+1]
	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3236 :         push_back(_Ch);

	movzx	r9d, BYTE PTR [rcx+rax+1]

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR Sampler$59[rbp-240]
	mov	rdx, QWORD PTR Sampler$59[rbp-232]
	cmp	rcx, rdx

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN1282@BfresFile

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR Sampler$59[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Sampler$59[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR Sampler$59[rbp-256]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 4053 :             return;

	jmp	SHORT $LN20@BfresFile
$LN1282@BfresFile:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR Sampler$59[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN20@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 572  :                     for (int j = 0; j < NameLength; j++) {

	sub	rbx, 1
	jne	SHORT $LL22@BfresFile
$LN21@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	r14d, r14d
	mov	QWORD PTR MaterialTexture$50[rbp-248], r14
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR MaterialTexture$50[rbp-240], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR MaterialTexture$50[rbp-224], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR MaterialTexture$50[rbp-208], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR MaterialTexture$50[rbp-200], r14

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR MaterialTexture$50[rbp-224]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	rcx, QWORD PTR TextureName$62[rbp-240]
	sub	rax, rcx
	cmp	rax, 5
	jb	$LN2724@BfresFile

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r9, QWORD PTR TextureName$62[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR TextureName$62[rbp-232], 16
	cmovae	r9, QWORD PTR TextureName$62[rbp-256]

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 5
	lea	rax, OFFSET FLAT:??_C@_05KIAGMJIK@?4txtg@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T26[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	DWORD PTR $T18[rbp-256], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 577  :                     MaterialTexture.Texture = TextureToGoLibrary::GetTexture(TextureName + ".txtg");

	lea	rcx, QWORD PTR $T26[rbp-256]
	call	?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureToGoLibrary::GetTexture
	mov	QWORD PTR MaterialTexture$50[rbp-256], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdi, QWORD PTR Materials$60[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 578  :                     Materials[FMATIndex].Textures.push_back(MaterialTexture);

	lea	rcx, QWORD PTR [rdi+40]
	add	rcx, r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rbx, QWORD PTR [rdi+r13+48]
	cmp	rbx, QWORD PTR [rdi+r13+56]
	je	SHORT $LN1292@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T19[rbp-256], rbx
	mov	QWORD PTR [rbx], rax
	lea	rcx, QWORD PTR [rbx+8]
	lea	rdx, QWORD PTR MaterialTexture$50[rbp-248]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR MaterialTexture$50[rbp-224]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rdi+r13+48], 64		; 00000040H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN1291@BfresFile
$LN1292@BfresFile:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR MaterialTexture$50[rbp-256]
	mov	rdx, rbx
	call	??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>
$LN1291@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 579  :                     Materials[FMATIndex].IsTransparent = MaterialTexture.Texture->IsTransparent();

	mov	rax, QWORD PTR MaterialTexture$50[rbp-256]
	movzx	ecx, BYTE PTR [rax+42]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Materials$60[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 579  :                     Materials[FMATIndex].IsTransparent = MaterialTexture.Texture->IsTransparent();

	mov	BYTE PTR [rax+r13+32], cl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	ebx, DWORD PTR tv24132[rsp]
	mov	DWORD PTR Reader$[rsp+8], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR MaterialTexture$50[rbp-224]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR MaterialTexture$50[rbp-248]
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
	npad	1

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR Sampler$59[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1219@BfresFile

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR Sampler$59[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1219@BfresFile:

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR Sampler$59[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Sampler$59[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Sampler$59[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR TextureName$62[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN1198@BfresFile

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR TextureName$62[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1210@BfresFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1207@BfresFile
$LN1210@BfresFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN1198@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR TextureName$62[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR TextureName$62[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR TextureName$62[rbp-256], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 563  :                 for (int i = 0; i < TextureCount; i++)

	mov	eax, DWORD PTR i$1$[rsp]
	inc	eax
	mov	DWORD PTR i$1$[rsp], eax
	mov	edi, DWORD PTR tv24131[rbp-256]
	add	edi, 16
	mov	DWORD PTR tv24131[rbp-256], edi
	add	ebx, 8
	mov	DWORD PTR tv24132[rsp], ebx
	cmp	eax, DWORD PTR tv23860[rbp-256]
	jl	$LL19@BfresFile
$LN2887@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	esi, DWORD PTR tv24012[rbp-256]
	add	esi, 175				; 000000afH
	mov	DWORD PTR Reader$[rsp+8], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR LocalTransparentTextures$54[rbp-256]
	test	rbx, rbx
	je	SHORT $LN1870@BfresFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR LocalTransparentTextures$54[rbp-248]
	cmp	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	je	SHORT $LN1874@BfresFile
$LL1875@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL1875@BfresFile
	mov	rbx, QWORD PTR LocalTransparentTextures$54[rbp-256]
$LN1874@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	r8, QWORD PTR LocalTransparentTextures$54[rbp-240]
	sub	r8, rbx
	sar	r8, 3
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	imul	r8, rax
	mov	rdx, rbx
	call	?deallocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z ; std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
	xorps	xmm0, xmm0

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR LocalTransparentTextures$54[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR LocalTransparentTextures$54[rbp-240], r14
$LN1870@BfresFile:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR LocalTextures$53[rbp-256]
	test	rbx, rbx
	je	SHORT $LN5@BfresFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR LocalTextures$53[rbp-248]
	cmp	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	je	SHORT $LN1897@BfresFile
	npad	7
$LL1898@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL1898@BfresFile
	mov	rbx, QWORD PTR LocalTextures$53[rbp-256]
$LN1897@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	r8, QWORD PTR LocalTextures$53[rbp-240]
	sub	r8, rbx
	sar	r8, 3
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	imul	r8, rax
	mov	rdx, rbx
	call	?deallocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z ; std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
	xorps	xmm0, xmm0

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR LocalTextures$53[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR LocalTextures$53[rbp-240], r14
$LN5@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 475  :         for (int FMATIndex = 0; FMATIndex < FMATCount; FMATIndex++)

	mov	edi, DWORD PTR FMATIndex$1$[rsp]
	inc	edi
	mov	DWORD PTR FMATIndex$1$[rsp], edi
	add	r13, 64					; 00000040H
	cmp	edi, DWORD PTR tv23863[rbp-256]
	jl	$LL7@BfresFile
$LN6@BfresFile:

; 580  : 
; 581  :                     Reader.Seek(TextureArrayOffset + (i + 1) * 8, BinaryVectorReader::Position::Begin);
; 582  :                 }
; 583  :             }
; 584  : 
; 585  :             //LocalTextures[FMATIndex] = TextureToGo(TexToGoPath + "/" + AlbTextureNames[AlbTextureNames.size() - 1] + ".txtg");
; 586  :             //this->m_Models[FMDLIndex].Textures[FMATIndex].Normal = TextureToGo(TexToGoPath + "/" + NrmTextureNames[AlbTextureNames.size() - 1] + ".txtg");
; 587  : 
; 588  :             Reader.Seek(FMATBaseOffset + 176, BinaryVectorReader::Position::Begin);
; 589  :         }
; 590  : 
; 591  :         //Parsing FSKL
; 592  :         Reader.Seek(FSKLOffset, BinaryVectorReader::Position::Begin);

	xor	r8d, r8d
	mov	edx, DWORD PTR FSKLOffset$1$[rbp-256]
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 593  :         {
; 594  :             uint32_t FSKLBaseOffset = Reader.GetPosition();
; 595  :             Reader.Seek(4, BinaryVectorReader::Position::Current);

	mov	r8b, 1
	mov	edx, 4
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 596  : 
; 597  :             uint32_t FSKLFlags = Reader.ReadUInt32();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32

; 598  :             uint64_t BoneDictOffset = Reader.ReadUInt64();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64

; 599  :             uint64_t BoneArrayOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	r13, rax

; 600  :             uint64_t MatrixToBoneListOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	rbx, rax

; 601  :             uint64_t InverseModelMatricesOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64

; 602  : 
; 603  :             Reader.Seek(8, BinaryVectorReader::Position::Current); //Padding

	mov	r8b, 1
	mov	edx, 8
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 604  :             uint64_t FSKLUserPointer = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64

; 605  :             uint16_t NumBones = Reader.ReadUInt16();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	movzx	esi, ax

; 606  :             uint16_t NumSmoothMatrices = Reader.ReadUInt16();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	movzx	r14d, ax

; 607  :             uint16_t NumRigidMatrices = Reader.ReadUInt16();

	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	movzx	edi, ax

; 608  :             
; 609  :             //std::cout << "NumBones: " << NumBones << ", NumSmoothMatrices: " << NumSmoothMatrices << ", NumRigidMatrices: " << NumRigidMatrices << std::endl;
; 610  : 
; 611  :             /*
; 612  :             Reader.Seek(BoneDictOffset, BinaryVectorReader::Position::Begin);
; 613  :             Reader.Seek(4, BinaryVectorReader::Position::Current); //Always 0x00000000
; 614  :             uint32_t NumBoneEntries = Reader.ReadUInt32();
; 615  :             */
; 616  :             this->m_SkeletonBones.resize(NumBones);

	mov	edx, esi
	lea	rcx, QWORD PTR [r12+24]
	call	?resize@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX_K@Z ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::resize

; 617  : 
; 618  :             Reader.Seek(MatrixToBoneListOffset, BinaryVectorReader::Position::Begin);

	xor	r8d, r8d
	mov	edx, ebx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 619  : 
; 620  :             if (NumRigidMatrices > 0)

	test	di, di
	je	SHORT $LN89@BfresFile

; 621  :             {
; 622  :                 m_Rigids.resize(NumSmoothMatrices + NumRigidMatrices);

	lea	ebx, DWORD PTR [r14+rdi]
	mov	edx, ebx
	lea	rcx, QWORD PTR [r12+48]
	call	?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::resize

; 623  :                 Reader.ReadStruct(m_Rigids.data(), (NumSmoothMatrices + NumRigidMatrices) * 2);

	lea	r8d, DWORD PTR [rbx+rbx]
	mov	rdx, QWORD PTR [r12+48]
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadStruct@BinaryVectorReader@@QEAAXPEAXIH@Z ; BinaryVectorReader::ReadStruct
$LN89@BfresFile:

; 626  :             for (int BoneNodeIndex = 0; BoneNodeIndex < NumBones; BoneNodeIndex++)

	mov	rdi, QWORD PTR Reader$[rsp]
	xor	eax, eax
	cmp	ax, si
	jae	SHORT $LN24@BfresFile
	mov	edx, eax
	lea	eax, DWORD PTR [r13+31]
	movsxd	r8, eax
	mov	r9, rsi
	npad	5
$LL25@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 146  : 	std::memcpy(Dest, this->m_Bytes.data() + this->m_Offset + 1, Size);

	mov	rax, QWORD PTR [rdi]
	mov	rcx, QWORD PTR [r12+24]
	movups	xmm0, XMMWORD PTR [rax+r8+1]
	movups	XMMWORD PTR [rcx+rdx], xmm0
	movups	xmm1, XMMWORD PTR [rax+r8+17]
	movups	XMMWORD PTR [rcx+rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [rax+r8+33]
	movups	XMMWORD PTR [rcx+rdx+32], xmm0
	movsd	xmm1, QWORD PTR [rax+r8+49]
	movsd	QWORD PTR [rcx+rdx+48], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 626  :             for (int BoneNodeIndex = 0; BoneNodeIndex < NumBones; BoneNodeIndex++)

	lea	r8, QWORD PTR [r8+88]
	lea	rdx, QWORD PTR [rdx+56]
	sub	r9, 1
	jne	SHORT $LL25@BfresFile
$LN24@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	rcx, QWORD PTR FSHPOffset$1$[rbp-256]
	dec	ecx
	mov	DWORD PTR Reader$10$[rbp-256], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 637  :         for (int FSHPIndex = 0; FSHPIndex < FSHPCount; FSHPIndex++)

	mov	rax, QWORD PTR _Newsize$1$[rbp-256]
	test	rax, rax
	je	$LN27@BfresFile
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	xor	edi, edi
	mov	QWORD PTR tv24121[rbp-256], rdi
	mov	ebx, edi
	mov	QWORD PTR tv24120[rsp], rbx
	mov	QWORD PTR tv24009[rsp], rax
	npad	5
$LL28@BfresFile:

; 26   : 	return this->m_Offset + 1;

	lea	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR Reader$[rsp+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 642  :             uint64_t NameOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 26   : 	return this->m_Offset + 1;

	mov	r13d, DWORD PTR Reader$[rsp+8]

; 56   : 	this->m_Offset += 2;

	lea	esi, DWORD PTR [rax+1]
	mov	DWORD PTR Reader$[rsp+8], esi

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movsxd	rdx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r14, QWORD PTR Reader$[rsp]
	mov	rax, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	r8d, BYTE PTR [rax+rdx+1]
	movzx	ecx, BYTE PTR [rax+rdx]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Name$55[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR Name$55[rbp-240], rdi

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Name$55[rbp-232], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Name$55[rbp-256], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 647  :             Name.resize(NameSize);

	shl	r8, 8
	or	r8, rcx
	movzx	edi, r8w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4140 :         if (_New_size <= _Old_size) {

	test	rdi, rdi
	jne	SHORT $LN2086@BfresFile

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR Name$55[rbp-240], rdi
	mov	BYTE PTR Name$55[rbp+rdi-256], dil

; 4142 :         } else {

	jmp	SHORT $LN2096@BfresFile
$LN2086@BfresFile:

; 3298 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	lea	rcx, QWORD PTR Name$55[rbp-256]
	cmp	rdi, 15
	ja	SHORT $LN2097@BfresFile

; 3299 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3300 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR Name$55[rbp-240], rdi

; 437  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, rdi
	xor	edx, edx
	call	memset

; 3303 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR Name$55[rbp+rdi-256], 0

; 3304 :             return *this;

	jmp	SHORT $LN2096@BfresFile
$LN2097@BfresFile:

; 3305 :         }
; 3306 : 
; 3307 :         return _Reallocate_grow_by(

	mov	r9, rdi
	mov	rdx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KD@Z@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@0D@Z@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,unsigned __int64,char>
$LN2096@BfresFile:

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	r9, QWORD PTR Name$55[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Name$55[rbp-232], 16
	cmovae	r9, QWORD PTR Name$55[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 146  : 	std::memcpy(Dest, this->m_Bytes.data() + this->m_Offset + 1, Size);

	movsxd	rcx, esi
	mov	rdx, QWORD PTR [r14]
	inc	rdx
	add	rdx, rcx
	mov	r8, rdi
	mov	rcx, r9
	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdi, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 650  :             this->m_Models[FMDLIndex].ShapeNames.push_back(Name);

	lea	rcx, QWORD PTR [rdi+72]
	add	rcx, r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [r15+rdi+80]
	cmp	rax, QWORD PTR [r15+rdi+88]
	je	SHORT $LN2004@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR Name$55[rbp-256]
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [r15+rdi+80], 32		; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2003@BfresFile
$LN2004@BfresFile:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Name$55[rbp-256]
	mov	rdx, rax
	call	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
$LN2003@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 16   : 		this->m_Offset += Offset;

	lea	eax, DWORD PTR [r13+8]
	mov	DWORD PTR Reader$[rsp+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 653  :             uint64_t MeshArrayOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
	mov	r14, rax
	mov	QWORD PTR MeshArrayOffset$1$[rbp-256], rax

; 654  :             uint64_t SkinBoneIndexListOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 16   : 		this->m_Offset += Offset;

	add	DWORD PTR Reader$[rsp+8], 24
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 656  :             uint64_t BoundingBoxOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64

; 657  :             uint64_t RadiusOffset = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64

; 658  :             int64_t UserPointer = Reader.ReadInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadInt64@BinaryVectorReader@@QEAA_J_N@Z ; BinaryVectorReader::ReadInt64
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 56   : 	this->m_Offset += 2;

	mov	ecx, DWORD PTR Reader$10$[rbp-256]
	add	ecx, 84					; 00000054H

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movsxd	rax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rsi, QWORD PTR Reader$[rsp]
	mov	QWORD PTR Reader$4$[rbp-256], rsi
	mov	rdx, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	r8d, BYTE PTR [rdx+rax]
	mov	BYTE PTR tv26950[rbp-256], r8b
	movzx	eax, BYTE PTR [rdx+rax-1]
	mov	BYTE PTR tv26948[rsp], al

; 44   : 	this->m_Offset++;

	lea	eax, DWORD PTR [rcx+8]
	movsxd	rcx, eax

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	edi, BYTE PTR [rcx+rdx]
	mov	BYTE PTR NumLODs$1$[rsp], dil

; 12   : 		this->m_Offset = Offset - 1;

	lea	eax, DWORD PTR [r14-1]
	mov	DWORD PTR Reader$9$[rbp-256], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r13, QWORD PTR [r12]
	add	r13, r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 673  :             this->m_Models[FMDLIndex].LODs.resize(NumLODs);

	mov	edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [r13]
	mov	r14, QWORD PTR [r13+8]
	mov	rcx, r14
	sub	rcx, r8
	sar	rcx, 5
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdi, rcx
	jae	SHORT $LN2139@BfresFile

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rdi+rdi*2]
	shl	rsi, 5
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, r14
	je	SHORT $LN2145@BfresFile
$LL2146@BfresFile:
	mov	rcx, rdi
	call	??1LOD@BfresFile@@QEAA@XZ
	add	rdi, 96					; 00000060H
	cmp	rdi, r14
	jne	SHORT $LL2146@BfresFile
$LN2145@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [r13+8], rsi

; 1564 :             return;

	mov	rsi, QWORD PTR Reader$4$[rbp-256]
	movzx	edi, BYTE PTR NumLODs$1$[rsp]
	jmp	SHORT $LN2140@BfresFile
$LN2139@BfresFile:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN2140@BfresFile

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r13+16]
	sub	rax, r8
	sar	rax, 5
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN2141@BfresFile

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r13
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN2140@BfresFile
$LN2141@BfresFile:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, r14
	call	??$_Uninitialized_value_construct_n@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@PEAU12@_KAEAV?$allocator@ULOD@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::LOD> >
	mov	QWORD PTR [r13+8], rax
$LN2140@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 675  :             for (int LODIndex = 0; LODIndex < NumLODs; LODIndex++)

	test	dil, dil
	je	$LN30@BfresFile
	xor	eax, eax
	mov	r13d, eax
	mov	rax, QWORD PTR MeshArrayOffset$1$[rbp-256]
	add	eax, 55					; 00000037H
	mov	DWORD PTR tv24122[rsp], eax
	movzx	ecx, dil
	mov	QWORD PTR tv23972[rbp-256], rcx
	mov	edx, DWORD PTR Reader$9$[rbp-256]
	jmp	SHORT $LN31@BfresFile
	npad	1
$LL2888@BfresFile:
	mov	rsi, QWORD PTR Reader$4$[rbp-256]
$LN31@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rdi, QWORD PTR [r15+rax]
	add	rdi, r13

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR [rdi+8]
	mov	r8, QWORD PTR [rdi]
	mov	rcx, r9
	sub	rcx, r8
	sar	rcx, 3
	mov	r11, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rcx, r11

; 1558 :         if (_Newsize < _Oldsize) { // trim

	mov	r10, QWORD PTR _Newsize$1$[rbp-256]
	cmp	r10, rcx
	jae	SHORT $LN1863@BfresFile

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r10+r10*2]
	lea	rbx, QWORD PTR [r8+rax*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdx, r9
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAXPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rdi+8], rbx

; 1564 :             return;

	jmp	SHORT $LN2904@BfresFile
$LN1863@BfresFile:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN1864@BfresFile

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r11

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	mov	rdx, r10
	cmp	r10, rax
	jbe	SHORT $LN1865@BfresFile

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rdi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN2904@BfresFile
$LN1865@BfresFile:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, r9
	call	??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
	mov	QWORD PTR [rdi+8], rax
$LN2904@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	mov	edx, DWORD PTR Reader$9$[rbp-256]
$LN1864@BfresFile:
	movsxd	rcx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	r8d, BYTE PTR [r9+rcx+35]
	shl	r8d, 8
	movzx	eax, BYTE PTR [r9+rcx+34]
	or	r8d, eax
	shl	r8d, 8
	movzx	eax, BYTE PTR [r9+rcx+36]
	shl	eax, 24
	or	r8d, eax
	movzx	eax, BYTE PTR [r9+rcx+33]
	or	r8d, eax

; 76   : 	this->m_Offset += 4;

	add	edx, 44					; 0000002cH

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, edx
	movzx	ebx, BYTE PTR [r9+rcx-1]
	shl	ebx, 8
	movzx	eax, BYTE PTR [r9+rcx-2]
	or	ebx, eax
	shl	ebx, 8
	movzx	eax, BYTE PTR [rcx+r9]
	shl	eax, 24
	or	ebx, eax
	movzx	eax, BYTE PTR [r9+rcx-3]
	or	ebx, eax
	mov	DWORD PTR FaceType$1$[rbp-256], ebx
	movzx	r10d, BYTE PTR [r9+rcx+3]
	shl	r10d, 8
	movzx	eax, BYTE PTR [r9+rcx+2]
	or	r10d, eax
	shl	r10d, 8
	movzx	eax, BYTE PTR [r9+rcx+4]
	shl	eax, 24
	or	r10d, eax
	movzx	eax, BYTE PTR [r9+rcx+1]
	or	r10d, eax
	mov	DWORD PTR FaceCount$1$[rsp], r10d

; 76   : 	this->m_Offset += 4;

	lea	eax, DWORD PTR [rdx+8]

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, eax
	movzx	r14d, BYTE PTR [r9+rcx-1]
	shl	r14d, 8
	movzx	eax, BYTE PTR [r9+rcx-2]
	or	r14d, eax
	shl	r14d, 8
	movzx	eax, BYTE PTR [rcx+r9]
	shl	eax, 24
	or	r14d, eax
	movzx	eax, BYTE PTR [r9+rcx-3]
	or	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 687  :                     Reader.Seek(DataStart + FaceBufferOffset, BinaryVectorReader::Position::Begin);

	mov	esi, DWORD PTR DataStart$1$[rbp-256]
	dec	esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	add	esi, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rax, QWORD PTR [r15+rax]
	mov	rcx, QWORD PTR [rax+r13]
	mov	r11, QWORD PTR tv24120[rsp]
	add	rcx, r11
	mov	QWORD PTR $T11[rbp-256], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 689  :                     this->m_Models[FMDLIndex].LODs[LODIndex].Faces[FSHPIndex].resize(FaceCount);

	mov	edi, r10d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR [rcx+8]
	mov	r8, QWORD PTR [rcx]
	mov	rdx, r9
	sub	rdx, r8
	sar	rdx, 2

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdi, rdx
	jae	SHORT $LN1506@BfresFile

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r8+r10*4]

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rcx+8], rax

; 1564 :             return;

	jmp	SHORT $LN1507@BfresFile
$LN1506@BfresFile:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN1507@BfresFile

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, r8
	sar	rax, 2

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdi, rax
	jbe	SHORT $LN1508@BfresFile

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rdi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@IV?$allocator@I@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN2905@BfresFile
$LN1508@BfresFile:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	r8, rdi
	sub	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	r8, QWORD PTR [r8*4]
	lea	rbx, QWORD PTR [r8+r9]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, r9
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rax, QWORD PTR $T11[rbp-256]
	mov	QWORD PTR [rax+8], rbx
	mov	ebx, DWORD PTR FaceType$1$[rbp-256]
$LN2905@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 690  :                     if (FaceType == 1)

	mov	r11, QWORD PTR tv24120[rsp]
	mov	r10d, DWORD PTR FaceCount$1$[rsp]
$LN1507@BfresFile:
	cmp	ebx, 1
	jne	SHORT $LN90@BfresFile

; 691  :                     {
; 692  :                         for (uint32_t FaceIndex = 0; FaceIndex < FaceCount; FaceIndex++)

	test	r10d, r10d
	je	$LN93@BfresFile
	xor	eax, eax
	mov	r8d, eax
	mov	r10, QWORD PTR Reader$4$[rbp-256]
$LL34@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 56   : 	this->m_Offset += 2;

	movsxd	rax, esi
	lea	esi, DWORD PTR [rax+2]

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r10]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 694  :                             this->m_Models[FMDLIndex].LODs[LODIndex].Faces[FSHPIndex][FaceIndex] = VertexSkip + Reader.ReadUInt16();

	movzx	edx, BYTE PTR [rax+rcx+2]
	shl	edx, 8
	movzx	eax, BYTE PTR [rax+rcx+1]
	or	edx, eax
	add	edx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rcx, QWORD PTR [r15+rax]
	mov	rax, QWORD PTR [rcx+r13]
	mov	rcx, QWORD PTR [r11+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 694  :                             this->m_Models[FMDLIndex].LODs[LODIndex].Faces[FSHPIndex][FaceIndex] = VertexSkip + Reader.ReadUInt16();

	mov	DWORD PTR [r8+rcx], edx

; 691  :                     {
; 692  :                         for (uint32_t FaceIndex = 0; FaceIndex < FaceCount; FaceIndex++)

	lea	r8, QWORD PTR [r8+4]
	sub	rdi, 1
	jne	SHORT $LL34@BfresFile

; 695  :                         }
; 696  :                     }

	jmp	$LN93@BfresFile
$LN90@BfresFile:

; 697  :                     else if(FaceType == 2)

	cmp	ebx, 2
	jne	SHORT $LN92@BfresFile

; 698  :                     {
; 699  :                         for (uint32_t FaceIndex = 0; FaceIndex < FaceCount; FaceIndex++)

	test	r10d, r10d
	je	$LN93@BfresFile
	xor	eax, eax
	mov	r9d, eax
	mov	r10, QWORD PTR Reader$4$[rbp-256]
	npad	6
$LL37@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	movsxd	rax, esi
	lea	esi, DWORD PTR [rax+4]

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	mov	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [r10]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	ecx, BYTE PTR [rdx+rax+3]
	shl	ecx, 8
	movzx	eax, BYTE PTR [rdx+rax+2]
	or	ecx, eax
	shl	ecx, 8
	movzx	eax, BYTE PTR [rdx+r8+4]
	shl	eax, 24
	or	ecx, eax
	movzx	edx, BYTE PTR [rdx+r8+1]
	or	edx, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 701  :                             this->m_Models[FMDLIndex].LODs[LODIndex].Faces[FSHPIndex][FaceIndex] = VertexSkip + Reader.ReadUInt32();

	add	edx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rcx, QWORD PTR [r15+rax]
	mov	rax, QWORD PTR [rcx+r13]
	mov	rcx, QWORD PTR [r11+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 701  :                             this->m_Models[FMDLIndex].LODs[LODIndex].Faces[FSHPIndex][FaceIndex] = VertexSkip + Reader.ReadUInt32();

	mov	DWORD PTR [r9+rcx], edx

; 698  :                     {
; 699  :                         for (uint32_t FaceIndex = 0; FaceIndex < FaceCount; FaceIndex++)

	lea	r9, QWORD PTR [r9+4]
	sub	rdi, 1
	jne	SHORT $LL37@BfresFile

; 702  :                         }
; 703  :                     }

	jmp	SHORT $LN93@BfresFile
$LN92@BfresFile:

; 706  :                         Logger::Error("Bfres", "Unknown face type");

	lea	rax, QWORD PTR $T24[rbp-256]
	mov	QWORD PTR $T12[rbp-256], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T24[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	ebx, ebx
	mov	QWORD PTR $T24[rbp-240], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T24[rbp-232], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+17]
	lea	rdx, OFFSET FLAT:??_C@_0BC@NKOCGIM@Unknown?5face?5type@
	lea	rcx, QWORD PTR $T24[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T23[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T23[rbp-240], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T23[rbp-232], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+5]
	lea	rdx, OFFSET FLAT:??_C@_05JBOHDMDP@Bfres@
	lea	rcx, QWORD PTR $T23[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 706  :                         Logger::Error("Bfres", "Unknown face type");

	lea	rdx, QWORD PTR $T24[rbp-256]
	lea	rcx, QWORD PTR $T23[rbp-256]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
$LN93@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	r10d, DWORD PTR tv24122[rsp]
	mov	edx, r10d
	mov	DWORD PTR Reader$9$[rbp-256], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 675  :             for (int LODIndex = 0; LODIndex < NumLODs; LODIndex++)

	add	r10d, 56				; 00000038H
	mov	DWORD PTR tv24122[rsp], r10d
	add	r13, 96					; 00000060H
	sub	QWORD PTR tv23972[rbp-256], 1
	jne	$LL2888@BfresFile
	mov	rbx, QWORD PTR tv24120[rsp]
$LN30@BfresFile:

; 707  :                     }
; 708  : 
; 709  :                 Reader.Seek(MeshBaseOffset + ((LODIndex+1) * 56), BinaryVectorReader::Position::Begin);
; 710  :             }
; 711  : 
; 712  :             this->m_Models[FMDLIndex].Materials[FSHPIndex] = Materials[MaterialIndex];

	movzx	edi, BYTE PTR tv26950[rbp-256]
	shl	rdi, 8
	movzx	eax, BYTE PTR tv26948[rsp]
	or	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdi, 6
	add	rdi, QWORD PTR Materials$60[rbp-256]
	mov	rax, QWORD PTR [r12]
	mov	rsi, QWORD PTR [r15+rax+48]
	mov	r14, QWORD PTR tv24121[rbp-256]
	add	rsi, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rsi, rdi
	je	SHORT $LN1474@BfresFile

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN1478@BfresFile

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN1478@BfresFile:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi+16]
	mov	rcx, rsi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN1474@BfresFile:
	movzx	eax, BYTE PTR [rdi+32]
	mov	BYTE PTR [rsi+32], al
	lea	r8, QWORD PTR [rdi+40]
	lea	rcx, QWORD PTR [rsi+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN1482@BfresFile

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 6
	call	??$_Assign_counted_range@PEAUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXPEAUBfresTexture@BfresFile@@_K@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Assign_counted_range<BfresFile::BfresTexture *>
$LN1482@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	ecx, DWORD PTR Reader$10$[rbp-256]
	add	ecx, 96					; 00000060H
	mov	DWORD PTR Reader$10$[rbp-256], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR Name$55[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1460@BfresFile

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR Name$55[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	mov	ecx, DWORD PTR Reader$10$[rbp-256]
$LN1460@BfresFile:

; 4841 :         _My_data._Mysize = 0;

	xor	edi, edi
	mov	QWORD PTR Name$55[rbp-240], rdi

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Name$55[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Name$55[rbp-256], dil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 637  :         for (int FSHPIndex = 0; FSHPIndex < FSHPCount; FSHPIndex++)

	add	rbx, 24
	mov	QWORD PTR tv24120[rsp], rbx
	add	r14, 64					; 00000040H
	mov	QWORD PTR tv24121[rbp-256], r14
	sub	QWORD PTR tv24009[rsp], 1
	jne	$LL28@BfresFile
	mov	rdi, QWORD PTR Reader$4$[rbp-256]
$LN27@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rsi, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 717  :         this->m_Models[FMDLIndex].Vertices.resize(FVTXCount);

	add	rsi, r15
	movzx	r14d, WORD PTR FVTXCount$1$[rsp]
	mov	QWORD PTR _Newsize$1$[rbp-256], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR [rsi+32]
	mov	r8, QWORD PTR [rsi+24]
	mov	rcx, r9
	sub	rcx, r8
	sar	rcx, 3
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rcx, rdx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	r14, rcx
	jae	SHORT $LN2130@BfresFile

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r14+r14*2]
	lea	rbx, QWORD PTR [r8+rax*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdx, r9
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAXPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<float,std::allocator<float> > > >

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rsi+32], rbx

; 1564 :             return;

	jmp	SHORT $LN2131@BfresFile
$LN2130@BfresFile:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN2131@BfresFile

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+40]
	sub	rax, r8
	sar	rax, 3
	imul	rax, rdx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	mov	rdx, r14
	cmp	r14, rax
	jbe	SHORT $LN2132@BfresFile

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	lea	rcx, QWORD PTR [rsi+24]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN2131@BfresFile
$LN2132@BfresFile:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, r9
	call	??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<float,std::allocator<float> > > >
	mov	QWORD PTR [rsi+32], rax
$LN2131@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	r13, QWORD PTR FVTXOffset$1$[rbp-256]
	dec	r13d
	mov	DWORD PTR Reader$15$[rsp], r13d
	mov	DWORD PTR Reader$[rsp+8], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 719  :         for (int FVTXIndex = 0; FVTXIndex < FVTXCount; FVTXIndex++)

	xor	eax, eax
	mov	QWORD PTR $T51[rbp-256], rax
	test	r14, r14
	je	$LN39@BfresFile
	npad	7
$LL40@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 26   : 	return this->m_Offset + 1;

	lea	eax, DWORD PTR [r13+16]
	mov	DWORD PTR Reader$[rsp+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 100  : 	this->m_Offset += 8;

	movsxd	rdx, r13d

; 101  : 	uint64_t Data = (static_cast<uint64_t>(this->m_Bytes[this->m_Offset - 7])) |

	lea	eax, DWORD PTR [r13+15]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [r13+14]
	movsxd	r8, eax
	lea	eax, DWORD PTR [r13+13]
	movsxd	r10, eax
	lea	eax, DWORD PTR [r13+12]
	movsxd	r11, eax
	lea	eax, DWORD PTR [r13+11]
	movsxd	rbx, eax
	lea	eax, DWORD PTR [r13+10]
	movsxd	rdi, eax
	lea	eax, DWORD PTR [r13+9]
	movsxd	rsi, eax
	movzx	r14d, BYTE PTR [rdx+r9+16]
	shl	r14, 8
	movzx	eax, BYTE PTR [rcx+r9]
	or	r14, rax
	shl	r14, 8
	movzx	eax, BYTE PTR [r8+r9]
	or	r14, rax
	shl	r14, 8
	movzx	eax, BYTE PTR [r10+r9]
	or	r14, rax
	shl	r14, 8
	movzx	eax, BYTE PTR [r11+r9]
	or	r14, rax
	shl	r14, 8
	movzx	eax, BYTE PTR [rbx+r9]
	or	r14, rax
	shl	r14, 8
	movzx	eax, BYTE PTR [rdi+r9]
	or	r14, rax
	shl	r14, 8
	movzx	eax, BYTE PTR [rsi+r9]
	or	r14, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 725  :             uint64_t FVTXAttArrDictionary = Reader.ReadUInt64();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rsp]
	call	?ReadUInt64@BinaryVectorReader@@QEAA_K_N@Z ; BinaryVectorReader::ReadUInt64
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 100  : 	this->m_Offset += 8;

	lea	edx, DWORD PTR [r13+56]
	movsxd	rcx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rsi, QWORD PTR Reader$[rsp]
	mov	QWORD PTR Reader$4$[rbp-256], rsi
	mov	r8, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 101  : 	uint64_t Data = (static_cast<uint64_t>(this->m_Bytes[this->m_Offset - 7])) |

	movzx	r9d, BYTE PTR [r8+rcx]
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx-1]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx-2]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx-3]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx-4]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx-5]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx-6]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx-7]
	or	r9, rax
	mov	QWORD PTR Data$1$[rbp-256], r9
	movzx	r9d, BYTE PTR [r8+rcx+8]
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx+7]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx+6]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx+5]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx+4]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx+3]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx+2]
	or	r9, rax
	shl	r9, 8
	movzx	eax, BYTE PTR [r8+rcx+1]
	or	r9, rax
	mov	QWORD PTR Data$1$[rsp], r9

; 88   : 	this->m_Offset += 4;

	add	edx, 20

; 89   : 	return !BigEndian ? (static_cast<int32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, edx
	movzx	r9d, BYTE PTR [r8+rcx]
	shl	r9d, 8
	movzx	eax, BYTE PTR [r8+rcx-1]
	or	r9d, eax
	shl	r9d, 8
	movzx	eax, BYTE PTR [r8+rcx-2]
	or	r9d, eax
	shl	r9d, 8
	movzx	eax, BYTE PTR [r8+rcx-3]
	or	r9d, eax
	mov	DWORD PTR BufferOffset$1$[rbp-256], r9d

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	eax, BYTE PTR [r8+rcx+1]
	mov	BYTE PTR NumVertexAttrib$1$[rsp], al

; 44   : 	this->m_Offset++;

	lea	ecx, DWORD PTR [rdx+2]
	movsxd	rax, ecx

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	r13d, BYTE PTR [rax+r8]

; 76   : 	this->m_Offset += 4;

	lea	eax, DWORD PTR [rcx+6]

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, eax
	movzx	r9d, BYTE PTR [r8+rcx-1]
	shl	r9d, 8
	movzx	eax, BYTE PTR [r8+rcx-2]
	or	r9d, eax
	shl	r9d, 8
	movzx	eax, BYTE PTR [r8+rcx]
	shl	eax, 24
	or	r9d, eax
	movzx	eax, BYTE PTR [r8+rcx-3]
	or	r9d, eax
	mov	DWORD PTR VertexCount$1$[rsp], r9d

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	eax, BYTE PTR [r8+rcx+1]
	mov	BYTE PTR VertexSkinCount$1$[rsp], al
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 740  :             std::vector<BfresFile::VertexBufferSize> VertexBufferSizeArray(NumBuffer);

	mov	QWORD PTR _Count$1$[rbp-256], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR VertexBufferSizeArray$58[rbp-256], xmm0
	xor	edx, edx
	mov	QWORD PTR VertexBufferSizeArray$58[rbp-240], rdx

; 2065 :         if (_Count != 0) {

	test	r13, r13
	je	SHORT $LN1702@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [r13*8]

; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, rbx
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR VertexBufferSizeArray$58[rbp-256], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rbx, rax
	mov	QWORD PTR VertexBufferSizeArray$58[rbp-240], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	lea	r8, QWORD PTR [r13*8]
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR VertexBufferSizeArray$58[rbp-248], rbx
	xor	edx, edx
$LN1702@BfresFile:
	xorps	xmm0, xmm0

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR VertexBufferStrideArray$57[rbp-256], xmm0
	mov	QWORD PTR VertexBufferStrideArray$57[rbp-240], rdx

; 2065 :         if (_Count != 0) {

	test	r13, r13
	je	SHORT $LN1857@BfresFile

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r13
	call	?allocate@?$allocator@I@std@@QEAAPEAI_K@Z ; std::allocator<unsigned int>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR VertexBufferStrideArray$57[rbp-256], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r8, QWORD PTR [r13*4]
	lea	rbx, QWORD PTR [rax+r8]
	mov	QWORD PTR VertexBufferStrideArray$57[rbp-240], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR VertexBufferStrideArray$57[rbp-248], rbx
	xor	edx, edx
$LN1857@BfresFile:
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 742  :             std::vector<BfresFile::VertexBufferAttribute> VertexBufferAttributes(NumVertexAttrib);

	movzx	ebx, BYTE PTR NumVertexAttrib$1$[rsp]
	mov	edi, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR VertexBufferAttributes$56[rbp-256], xmm0
	mov	QWORD PTR VertexBufferAttributes$56[rbp-240], rdx

; 2065 :         if (_Count != 0) {

	test	bl, bl
	je	SHORT $LN1807@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rbx+rbx*4]
	lea	rbx, QWORD PTR [rax*8]

; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, rbx
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR VertexBufferAttributes$56[rbp-256], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx
	mov	QWORD PTR VertexBufferAttributes$56[rbp-240], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	xor	edx, edx
	npad	7
$LL1756@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+32], rdx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 40					; 00000028H

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdi, 1
	jne	SHORT $LL1756@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR VertexBufferAttributes$56[rbp-248], rcx
	movzx	ebx, BYTE PTR NumVertexAttrib$1$[rsp]
$LN1807@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	r9, QWORD PTR Data$1$[rbp-256]
	dec	r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 742  :             std::vector<BfresFile::VertexBufferAttribute> VertexBufferAttributes(NumVertexAttrib);

	mov	r11, rdx

; 743  : 
; 744  :             Reader.Seek(VertexBufferSizeOffset, BinaryVectorReader::Position::Begin);
; 745  :             for (int i = 0; i < NumBuffer; i++)

	test	r13, r13
	je	$LN42@BfresFile
$LL43@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	r8d, DWORD PTR [r9+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r10, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rdx, r8d
	movsxd	r9, r9d
	movzx	ecx, BYTE PTR [r10+r9+3]
	shl	ecx, 8
	movzx	eax, BYTE PTR [r10+r9+2]
	or	ecx, eax
	shl	ecx, 8
	movzx	eax, BYTE PTR [rdx+r10]
	shl	eax, 24
	or	ecx, eax
	movzx	eax, BYTE PTR [r10+r9+1]
	or	ecx, eax
	mov	DWORD PTR VBufferSize$20[rbp-256], ecx

; 76   : 	this->m_Offset += 4;

	add	r8d, 4

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, r8d
	movzx	edx, BYTE PTR [r9+r10+7]
	shl	edx, 8
	movzx	eax, BYTE PTR [r9+r10+6]
	or	edx, eax
	shl	edx, 8
	movzx	eax, BYTE PTR [rcx+r10]
	shl	eax, 24
	or	edx, eax
	movzx	eax, BYTE PTR [r9+r10+5]
	or	edx, eax
	mov	DWORD PTR VBufferSize$20[rbp-252], edx

; 16   : 		this->m_Offset += Offset;

	lea	r9d, DWORD PTR [r8+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 751  :                 VertexBufferSizeArray[i] = VBufferSize;

	mov	rcx, QWORD PTR VBufferSize$20[rbp-256]
	mov	rax, QWORD PTR VertexBufferSizeArray$58[rbp-256]
	mov	QWORD PTR [rax+r11*8], rcx

; 743  : 
; 744  :             Reader.Seek(VertexBufferSizeOffset, BinaryVectorReader::Position::Begin);
; 745  :             for (int i = 0; i < NumBuffer; i++)

	inc	r11
	cmp	r11, r13
	jl	$LL43@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR Data$1$[rsp]
	dec	eax
	xor	r11d, r11d
$LL46@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	r10d, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, r10d
	movsxd	rdx, eax
	movzx	r8d, BYTE PTR [r9+rdx+3]
	shl	r8d, 8
	movzx	eax, BYTE PTR [r9+rdx+2]
	or	r8d, eax
	shl	r8d, 8
	movzx	eax, BYTE PTR [rcx+r9]
	shl	eax, 24
	or	r8d, eax
	movzx	eax, BYTE PTR [r9+rdx+1]
	or	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 757  :                 VertexBufferStrideArray[i] = Reader.ReadUInt32();

	mov	rax, QWORD PTR VertexBufferStrideArray$57[rbp-256]
	mov	DWORD PTR [rax+r11*4], r8d
	lea	eax, DWORD PTR [r10+12]

; 752  :             }
; 753  : 
; 754  :             Reader.Seek(VertexStrideSizeOffset, BinaryVectorReader::Position::Begin);
; 755  :             for (int i = 0; i < NumBuffer; i++)

	inc	r11
	cmp	r11, r13
	jl	SHORT $LL46@BfresFile
	xor	edx, edx
	jmp	SHORT $LN45@BfresFile
$LN42@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	rax, QWORD PTR Data$1$[rsp]
	dec	eax
	mov	DWORD PTR Reader$[rsp+8], eax
$LN45@BfresFile:
	lea	r9d, DWORD PTR [r14-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 762  :             for (int i = 0; i < NumVertexAttrib; i++)

	test	bl, bl
	je	$LN48@BfresFile
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	r13, rdx
	lea	r15d, DWORD PTR [r14+15]
	movsxd	rax, r14d
	add	rax, 9
	lea	r12, QWORD PTR [rax-1]
	movsxd	rcx, r14d
	sub	rcx, rax
	mov	QWORD PTR tv24588[rbp-256], rcx
	movzx	eax, bl
	mov	QWORD PTR tv24069[rsp], rax
	npad	2
$LL49@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r14, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 100  : 	this->m_Offset += 8;

	movsxd	rdi, r9d

; 101  : 	uint64_t Data = (static_cast<uint64_t>(this->m_Bytes[this->m_Offset - 7])) |

	lea	eax, DWORD PTR [r9+7]
	movsxd	rsi, eax
	lea	eax, DWORD PTR [r9+6]
	movsxd	r11, eax
	lea	eax, DWORD PTR [r9+5]
	movsxd	rdx, eax
	lea	eax, DWORD PTR [r9+4]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [r9+3]
	movsxd	rbx, eax
	lea	eax, DWORD PTR [r9+2]
	movsxd	r8, eax
	lea	eax, DWORD PTR [r9+1]
	movsxd	r9, eax
	movzx	r10d, BYTE PTR [rcx+r14]
	shl	r10, 24
	movzx	eax, BYTE PTR [rdx+r14]
	shl	rax, 32					; 00000020H
	or	r10d, eax
	movzx	eax, BYTE PTR [rdi+r14+8]
	shl	rax, 56					; 00000038H
	or	r10d, eax
	movzx	eax, BYTE PTR [r11+r14]
	shl	rax, 40					; 00000028H
	or	r10d, eax
	movzx	eax, BYTE PTR [r8+r14]
	shl	rax, 8
	or	r10d, eax
	movzx	eax, BYTE PTR [rsi+r14]
	shl	rax, 48					; 00000030H
	or	r10d, eax
	movzx	eax, BYTE PTR [rbx+r14]
	shl	rax, 16
	or	r10d, eax
	movzx	eax, BYTE PTR [r9+r14]
	or	r10d, eax

; 56   : 	this->m_Offset += 2;

	lea	edi, DWORD PTR [r10+1]

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movsxd	rax, r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 767  :                 for (int j = 0; j < NameLength; j++) {

	movzx	ecx, BYTE PTR [r14+rax+1]
	shl	ecx, 8
	movzx	eax, BYTE PTR [r14+rax]
	or	ecx, eax
	mov	rsi, QWORD PTR Reader$4$[rbp-256]
	jbe	SHORT $LN51@BfresFile
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 100  : 	this->m_Offset += 8;

	mov	ebx, ecx
$LL52@BfresFile:

; 50   : 	this->m_Offset++;

	movsxd	rax, edi
	lea	edi, DWORD PTR [rax+1]
	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 51   : 	return this->m_Bytes[this->m_Offset];

	movzx	r9d, BYTE PTR [rcx+rax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR VertexBufferAttributes$56[rbp-256]
	add	rcx, r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR [rcx+16]

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	r8, QWORD PTR [rcx+24]
	cmp	rdx, r8
	jae	SHORT $LN881@BfresFile

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rcx+16], rax

; 2227 :         if (_Large_string_engaged()) {

	cmp	r8, 16
	jb	SHORT $LN884@BfresFile

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN884@BfresFile:

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rcx+rdx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rcx+rdx+1], 0

; 4053 :             return;

	jmp	SHORT $LN50@BfresFile
$LN881@BfresFile:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN50@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 767  :                 for (int j = 0; j < NameLength; j++) {

	sub	rbx, 1
	jne	SHORT $LL52@BfresFile
$LN51@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	ecx, BYTE PTR [rax+r12+1]
	shl	cx, 8
	movzx	eax, BYTE PTR [rax+r12]
	or	cx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR VertexBufferAttributes$56[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 773  :                 VertexBufferAttributes[i].Format = Reader.ReadUInt16();

	mov	WORD PTR [rax+r13+32], cx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	ecx, BYTE PTR [r12+rax+5]
	shl	cx, 8
	movzx	eax, BYTE PTR [r12+rax+4]
	or	cx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR VertexBufferAttributes$56[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 775  :                 VertexBufferAttributes[i].Offset = Reader.ReadUInt16();

	mov	WORD PTR [rax+r13+34], cx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
	mov	rcx, QWORD PTR tv24588[rbp-256]
	lea	rdx, QWORD PTR [rax+rcx]
	add	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	r8d, BYTE PTR [rdx+r12+16]
	shl	r8w, 8
	movzx	eax, BYTE PTR [rcx+r12+15]
	or	r8w, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR VertexBufferAttributes$56[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 776  :                 VertexBufferAttributes[i].BufferIndex = Reader.ReadUInt16();

	mov	WORD PTR [rax+r13+36], r8w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	r9d, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 762  :             for (int i = 0; i < NumVertexAttrib; i++)

	add	r12, 16
	add	r15d, 16
	add	r13, 40					; 00000028H
	sub	QWORD PTR tv24069[rsp], 1
	jne	$LL49@BfresFile
	mov	r15, QWORD PTR tv23932[rbp-256]
	mov	r12, QWORD PTR this$GSCopy$1$[rbp-256]
	mov	r13, QWORD PTR _Count$1$[rbp-256]
$LN48@BfresFile:
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR VertexBuffers$52[rbp-256], xmm1
	xor	ebx, ebx
	mov	QWORD PTR VertexBuffers$52[rbp-240], rbx

; 620  :         _Construct_n(_Count);

	mov	rdx, r13
	lea	rcx, QWORD PTR VertexBuffers$52[rbp-256]
	call	??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Construct_n<>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	esi, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 782  :             for (int i = 0; i < NumBuffer; i++)

	test	r13, r13
	je	$LN54@BfresFile
	mov	r12, QWORD PTR Reader$4$[rbp-256]
	mov	r15d, DWORD PTR BufferOffset$1$[rbp-256]
	npad	13
$LL55@BfresFile:

; 784  :                 VertexBuffers[i].Stride = VertexBufferStrideArray[i];

	mov	rax, QWORD PTR VertexBufferStrideArray$57[rbp-256]
	mov	ecx, DWORD PTR [rax+rsi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdi, QWORD PTR [rsi+rsi*4]
	mov	rax, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 784  :                 VertexBuffers[i].Stride = VertexBufferStrideArray[i];

	mov	DWORD PTR [rax+rdi*8+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR VertexBufferSizeArray$58[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 785  :                 VertexBuffers[i].Size = VertexBufferSizeArray[i].Size;

	mov	ecx, DWORD PTR [rax+rsi*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 785  :                 VertexBuffers[i].Size = VertexBufferSizeArray[i].Size;

	mov	DWORD PTR [rax+rdi*8+4], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 786  :                 VertexBuffers[i].Data.resize(VertexBuffers[i].Size);

	lea	r14, QWORD PTR [rax+rdi*8]
	mov	r8d, DWORD PTR [rax+rdi*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [r14+16]
	mov	r9, QWORD PTR [r14+24]
	mov	rcx, r9
	sub	rcx, rdx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	r8, rcx
	jae	SHORT $LN772@BfresFile

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r8+rdx]

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [r14+24], rax

; 1564 :             return;

	jmp	SHORT $LN773@BfresFile
$LN772@BfresFile:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN773@BfresFile

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+32]
	sub	rax, rdx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	r8, rax
	jbe	SHORT $LN774@BfresFile

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, r8
	lea	rcx, QWORD PTR [r14+16]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN773@BfresFile
$LN774@BfresFile:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [r8+r9]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, r9
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [r14+24], rbx
$LN773@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 788  :                 if (i == 0) VertexBuffers[i].BufferOffset = DataStart + BufferOffset;

	test	rsi, rsi
	jne	SHORT $LN2907@BfresFile
	mov	ecx, DWORD PTR DataStart$1$[rbp-256]
	add	ecx, r15d
	mov	rax, QWORD PTR VertexBuffers$52[rbp-256]
	mov	DWORD PTR [rax], ecx

; 789  :                 if (i > 0) VertexBuffers[i].BufferOffset = VertexBuffers[i - 1].BufferOffset + VertexBuffers[i - 1].Size;

	jmp	SHORT $LN95@BfresFile
$LN2907@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 789  :                 if (i > 0) VertexBuffers[i].BufferOffset = VertexBuffers[i - 1].BufferOffset + VertexBuffers[i - 1].Size;

	mov	eax, DWORD PTR [rcx+rdi*8-36]
	add	eax, DWORD PTR [rcx+rdi*8-40]
	mov	DWORD PTR [rcx+rdi*8], eax
$LN95@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 790  :                 if (VertexBuffers[i].BufferOffset % 8 != 0) VertexBuffers[i].BufferOffset = VertexBuffers[i].BufferOffset + (8 - (VertexBuffers[i].BufferOffset % 8));

	mov	eax, DWORD PTR [rdx+rdi*8]
	mov	ecx, eax
	and	ecx, 7
	je	SHORT $LN96@BfresFile
	sub	eax, ecx
	add	eax, 8
	mov	DWORD PTR [rdx+rdi*8], eax
$LN96@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 792  :                 Reader.Seek(VertexBuffers[i].BufferOffset, BinaryVectorReader::Position::Begin);

	mov	eax, DWORD PTR [r9+rdi*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 146  : 	std::memcpy(Dest, this->m_Bytes.data() + this->m_Offset + 1, Size);

	mov	r8d, DWORD PTR [r9+rdi*8+4]

; 12   : 		this->m_Offset = Offset - 1;

	dec	eax

; 146  : 	std::memcpy(Dest, this->m_Bytes.data() + this->m_Offset + 1, Size);

	movsxd	rcx, eax
	mov	rdx, QWORD PTR [r12]
	inc	rdx
	add	rdx, rcx
	mov	rcx, QWORD PTR [r9+rdi*8+16]
	call	memcpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 782  :             for (int i = 0; i < NumBuffer; i++)

	inc	rsi
	cmp	rsi, r13
	jl	$LL55@BfresFile
	mov	r15, QWORD PTR tv23932[rbp-256]
	mov	r12, QWORD PTR this$GSCopy$1$[rbp-256]
$LN54@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rcx, QWORD PTR $T51[rbp-256]
	lea	rsi, QWORD PTR [rcx+rcx*2]
	mov	QWORD PTR tv25200[rbp-256], rsi
	mov	rax, QWORD PTR [r15+rax+24]
	lea	rdi, QWORD PTR [rax+rsi*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 796  :             this->m_Models[FMDLIndex].Vertices[FVTXIndex].resize(VertexCount * 3);

	mov	r14d, DWORD PTR VertexCount$1$[rsp]
	lea	eax, DWORD PTR [r14+r14*2]
	mov	r8d, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	mov	rcx, r9
	sub	rcx, rdx
	sar	rcx, 2

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	r8, rcx
	jae	SHORT $LN722@BfresFile

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rax*4]

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rdi+8], rax

; 1564 :             return;

	jmp	SHORT $LN723@BfresFile
$LN722@BfresFile:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN723@BfresFile

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rdx
	sar	rax, 2

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	r8, rax
	jbe	SHORT $LN724@BfresFile

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, r8
	mov	rcx, rdi
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<float,std::allocator<float> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN723@BfresFile
$LN724@BfresFile:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	r8, QWORD PTR [r8*4]
	lea	rbx, QWORD PTR [r8+r9]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, r9
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rdi+8], rbx
$LN723@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 799  :             for (int VertexIndex = 0; VertexIndex < VertexCount; VertexIndex++)

	xor	r10d, r10d
	mov	ebx, r10d
	test	r14d, r14d
	je	$LN57@BfresFile
	mov	rax, QWORD PTR VertexBufferAttributes$56[rbp-256]
	mov	QWORD PTR tv24283[rbp-256], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r11, QWORD PTR [r12]
	mov	QWORD PTR tv23904[rbp-256], r11
	mov	edi, r10d
	lea	r12, QWORD PTR [r15+r11]
	mov	r14, r12
	npad	6
$LL58@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 801  :                 if (VertexBufferAttributes[0].Format != (uint16_t)BfresFile::VertexBufferFormat::Format_32_32_32_Single)

	mov	ecx, 6149				; 00001805H
	cmp	WORD PTR [rax+32], cx
	mov	eax, ebx
	je	$LN97@BfresFile

; 803  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3] = this->ShortToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 1]);

	mov	r8, QWORD PTR VertexBuffers$52[rbp-256]
	imul	eax, DWORD PTR [r8+8]
	mov	edx, eax
	lea	ecx, DWORD PTR [rax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 321  :     uint16_t CombinedValue = (static_cast<uint16_t>(Byte2) << 8) | static_cast<uint16_t>(Byte1);

	movzx	r8d, BYTE PTR [rcx+rax]
	shl	r8w, 8
	movzx	eax, BYTE PTR [rdx+rax]
	or	r8w, ax

; 322  :     if (CombinedValue == 0)

	jne	SHORT $LN525@BfresFile

; 323  :     {
; 324  :         return 0;

	movaps	xmm0, xmm6
	jmp	SHORT $LN524@BfresFile
$LN525@BfresFile:

; 325  :     }
; 326  :     int32_t BiasedExponent = (CombinedValue >> 10) & 0x1F;

	movzx	edx, r8w
	mov	ecx, edx
	shr	ecx, 10
	and	ecx, 31

; 327  :     int32_t Mantissa = CombinedValue & 0x3FF;

	mov	eax, edx
	and	eax, 1023				; 000003ffH

; 328  : 
; 329  :     // Reconstruct the half-float value with proper exponent bias
; 330  :     int32_t RealExponent = BiasedExponent - 15 + 127;

	add	ecx, 112				; 00000070H

; 325  :     }
; 326  :     int32_t BiasedExponent = (CombinedValue >> 10) & 0x1F;

	shl	ecx, 10
	or	ecx, eax
	shl	ecx, 13

; 331  :     uint32_t HalfFloatBits = ((CombinedValue & 0x8000) << 16) | (RealExponent << 23) | (Mantissa << 13);

	shl	edx, 16
	and	edx, -2147483648			; 80000000H
	or	ecx, edx
	mov	r14, r12
	movd	xmm0, ecx
$LN524@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14+24]
	mov	r10, QWORD PTR [rax+rsi*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 803  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3] = this->ShortToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 1]);

	movss	DWORD PTR [rdi+r10], xmm0

; 804  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1] = this->ShortToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 2], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 3]);

	mov	rdx, QWORD PTR VertexBuffers$52[rbp-256]
	mov	eax, ebx
	imul	eax, DWORD PTR [rdx+8]
	mov	r9d, eax
	add	eax, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rdx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 804  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1] = this->ShortToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 2], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 3]);

	movzx	r8d, BYTE PTR [rdx+rax]
	lea	eax, DWORD PTR [r9+2]

; 321  :     uint16_t CombinedValue = (static_cast<uint16_t>(Byte2) << 8) | static_cast<uint16_t>(Byte1);

	movzx	r9d, r8w
	shl	r9w, 8
	movzx	eax, BYTE PTR [rax+rdx]
	or	r9w, ax

; 322  :     if (CombinedValue == 0)

	jne	SHORT $LN504@BfresFile

; 323  :     {
; 324  :         return 0;

	movaps	xmm0, xmm6
	jmp	SHORT $LN503@BfresFile
$LN504@BfresFile:

; 325  :     }
; 326  :     int32_t BiasedExponent = (CombinedValue >> 10) & 0x1F;

	movzx	edx, r9w
	mov	ecx, edx
	shr	ecx, 10
	and	ecx, 31

; 327  :     int32_t Mantissa = CombinedValue & 0x3FF;

	mov	eax, edx
	and	eax, 1023				; 000003ffH

; 328  : 
; 329  :     // Reconstruct the half-float value with proper exponent bias
; 330  :     int32_t RealExponent = BiasedExponent - 15 + 127;

	add	ecx, 112				; 00000070H

; 325  :     }
; 326  :     int32_t BiasedExponent = (CombinedValue >> 10) & 0x1F;

	shl	ecx, 10
	or	ecx, eax
	shl	ecx, 13

; 331  :     uint32_t HalfFloatBits = ((CombinedValue & 0x8000) << 16) | (RealExponent << 23) | (Mantissa << 13);

	shl	edx, 16
	and	edx, -2147483648			; 80000000H
	or	ecx, edx
	movd	xmm0, ecx
$LN503@BfresFile:

; 804  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1] = this->ShortToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 2], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 3]);

	movss	DWORD PTR [rdi+r10+4], xmm0

; 805  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] = this->ShortToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 4], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 5]);

	mov	rdx, QWORD PTR VertexBuffers$52[rbp-256]
	mov	eax, ebx
	imul	eax, DWORD PTR [rdx+8]
	mov	r9d, eax
	add	eax, 5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rdx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 805  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] = this->ShortToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 4], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 5]);

	movzx	r8d, BYTE PTR [rdx+rax]
	lea	eax, DWORD PTR [r9+4]

; 321  :     uint16_t CombinedValue = (static_cast<uint16_t>(Byte2) << 8) | static_cast<uint16_t>(Byte1);

	movzx	r9d, r8w
	shl	r9w, 8
	movzx	eax, BYTE PTR [rdx+rax]
	or	r9w, ax

; 322  :     if (CombinedValue == 0)

	jne	SHORT $LN542@BfresFile

; 323  :     {
; 324  :         return 0;

	movaps	xmm0, xmm6

; 805  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] = this->ShortToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 4], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 5]);

	movss	DWORD PTR [rdi+r10+8], xmm0
	lea	r14, QWORD PTR [r15+r11]

; 806  :                 }

	jmp	$LN56@BfresFile
$LN542@BfresFile:

; 326  :     int32_t BiasedExponent = (CombinedValue >> 10) & 0x1F;

	movzx	edx, r9w
	mov	ecx, edx
	shr	ecx, 10
	and	ecx, 31

; 327  :     int32_t Mantissa = CombinedValue & 0x3FF;

	mov	eax, edx
	and	eax, 1023				; 000003ffH

; 328  : 
; 329  :     // Reconstruct the half-float value with proper exponent bias
; 330  :     int32_t RealExponent = BiasedExponent - 15 + 127;

	add	ecx, 112				; 00000070H

; 325  :     }
; 326  :     int32_t BiasedExponent = (CombinedValue >> 10) & 0x1F;

	shl	ecx, 10
	or	ecx, eax
	shl	ecx, 13

; 331  :     uint32_t HalfFloatBits = ((CombinedValue & 0x8000) << 16) | (RealExponent << 23) | (Mantissa << 13);

	shl	edx, 16
	and	edx, -2147483648			; 80000000H
	or	ecx, edx
	movd	xmm0, ecx

; 805  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] = this->ShortToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 4], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 5]);

	movss	DWORD PTR [rdi+r10+8], xmm0
	lea	r14, QWORD PTR [r15+r11]

; 806  :                 }

	jmp	$LN56@BfresFile
$LN97@BfresFile:

; 809  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3] = this->UInt32ToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 1], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 2], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 3]);

	mov	rdx, QWORD PTR VertexBuffers$52[rbp-256]
	imul	eax, DWORD PTR [rdx+8]
	mov	r10d, eax
	add	eax, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [rdx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 809  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3] = this->UInt32ToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 1], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 2], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 3]);

	movzx	r11d, BYTE PTR [r8+rax]
	lea	eax, DWORD PTR [r10+2]
	movzx	edx, BYTE PTR [r8+rax]
	lea	eax, DWORD PTR [r10+1]

; 340  :     uint32_t combinedValue = (static_cast<uint32_t>(Byte4) << 24) |

	shl	r11d, 8
	or	r11d, edx
	shl	r11d, 8
	movzx	eax, BYTE PTR [rax+r8]
	or	r11d, eax
	shl	r11d, 8
	movzx	eax, BYTE PTR [r8+r10]
	or	r11d, eax

; 341  :         (static_cast<uint32_t>(Byte3) << 16) |
; 342  :         (static_cast<uint32_t>(Byte2) << 8) |
; 343  :         static_cast<uint32_t>(Byte1);
; 344  : 
; 345  :     if (combinedValue == 0)

	jne	SHORT $LN604@BfresFile

; 346  :     {
; 347  :         return 0;

	movaps	xmm0, xmm6
	jmp	SHORT $LN603@BfresFile
$LN604@BfresFile:

; 348  :     }
; 349  : 
; 350  :     float ret;
; 351  :     std::memcpy(&ret, &combinedValue, sizeof(float));
; 352  :     return ret;

	movd	xmm0, r11d
$LN603@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r14, r12
	mov	rax, QWORD PTR [r12+24]
	mov	r13, QWORD PTR [rax+rsi*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 809  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3] = this->UInt32ToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 1], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 2], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 3]);

	movss	DWORD PTR [rdi+r13], xmm0

; 810  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1] = this->UInt32ToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 4], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 5], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 6], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 7]);

	mov	rdx, QWORD PTR VertexBuffers$52[rbp-256]
	mov	eax, ebx
	imul	eax, DWORD PTR [rdx+8]
	mov	r11d, eax
	add	eax, 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [rdx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 810  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1] = this->UInt32ToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 4], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 5], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 6], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 7]);

	movzx	r9d, BYTE PTR [r8+rax]
	lea	eax, DWORD PTR [r11+6]
	movzx	edx, BYTE PTR [rax+r8]
	lea	eax, DWORD PTR [r11+5]
	movzx	r10d, BYTE PTR [rax+r8]
	lea	eax, DWORD PTR [r11+4]

; 340  :     uint32_t combinedValue = (static_cast<uint32_t>(Byte4) << 24) |

	mov	r11d, r9d
	shl	r11d, 8
	or	r11d, edx
	shl	r11d, 8
	or	r11d, r10d
	shl	r11d, 8
	movzx	eax, BYTE PTR [rax+r8]
	or	r11d, eax

; 341  :         (static_cast<uint32_t>(Byte3) << 16) |
; 342  :         (static_cast<uint32_t>(Byte2) << 8) |
; 343  :         static_cast<uint32_t>(Byte1);
; 344  : 
; 345  :     if (combinedValue == 0)

	jne	SHORT $LN571@BfresFile

; 346  :     {
; 347  :         return 0;

	movaps	xmm0, xmm6
	jmp	SHORT $LN570@BfresFile
$LN571@BfresFile:

; 348  :     }
; 349  : 
; 350  :     float ret;
; 351  :     std::memcpy(&ret, &combinedValue, sizeof(float));
; 352  :     return ret;

	movd	xmm0, r11d
$LN570@BfresFile:

; 810  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1] = this->UInt32ToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 4], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 5], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 6], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 7]);

	movss	DWORD PTR [rdi+r13+4], xmm0

; 811  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] = this->UInt32ToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 8], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 9], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 10], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 11]);

	mov	rdx, QWORD PTR VertexBuffers$52[rbp-256]
	mov	eax, ebx
	imul	eax, DWORD PTR [rdx+8]
	mov	r11d, eax
	add	eax, 11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [rdx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 811  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] = this->UInt32ToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 8], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 9], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 10], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 11]);

	movzx	r9d, BYTE PTR [rax+r8]
	lea	eax, DWORD PTR [r11+10]
	movzx	edx, BYTE PTR [rax+r8]
	lea	eax, DWORD PTR [r11+9]
	movzx	r10d, BYTE PTR [rax+r8]
	lea	eax, DWORD PTR [r11+8]

; 340  :     uint32_t combinedValue = (static_cast<uint32_t>(Byte4) << 24) |

	mov	r11d, r9d
	shl	r11d, 8
	or	r11d, edx
	shl	r11d, 8
	or	r11d, r10d
	shl	r11d, 8
	movzx	eax, BYTE PTR [rax+r8]
	or	r11d, eax

; 341  :         (static_cast<uint32_t>(Byte3) << 16) |
; 342  :         (static_cast<uint32_t>(Byte2) << 8) |
; 343  :         static_cast<uint32_t>(Byte1);
; 344  : 
; 345  :     if (combinedValue == 0)

	jne	SHORT $LN637@BfresFile

; 346  :     {
; 347  :         return 0;

	movaps	xmm0, xmm6
	jmp	SHORT $LN636@BfresFile
$LN637@BfresFile:

; 348  :     }
; 349  : 
; 350  :     float ret;
; 351  :     std::memcpy(&ret, &combinedValue, sizeof(float));
; 352  :     return ret;

	movd	xmm0, r11d
$LN636@BfresFile:

; 811  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] = this->UInt32ToFloat(VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 8], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 9], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 10], VertexBuffers[0].Data[VertexIndex * VertexBuffers[0].Stride + 11]);

	movss	DWORD PTR [rdi+r13+8], xmm0
	mov	r11, QWORD PTR tv23904[rbp-256]
$LN56@BfresFile:

; 799  :             for (int VertexIndex = 0; VertexIndex < VertexCount; VertexIndex++)

	inc	ebx
	add	rdi, 12
	cmp	ebx, DWORD PTR VertexCount$1$[rsp]
	mov	rax, QWORD PTR tv24283[rbp-256]
	jb	$LL58@BfresFile
	mov	r12, QWORD PTR this$GSCopy$1$[rbp-256]
	mov	r14d, DWORD PTR VertexCount$1$[rsp]
	xor	r10d, r10d
$LN57@BfresFile:

; 812  :                 }
; 813  :             }
; 814  : 
; 815  :             bool TransformedRoot = false;

	xor	al, al
	mov	BYTE PTR TransformedRoot$1$[rsp], al

; 816  :             int UVBufferIndex = 0;

	mov	r8d, r10d
	mov	DWORD PTR UVBufferIndex$1$[rbp-256], r10d

; 817  :             /* Parsing UV Data */
; 818  :             for (BfresFile::VertexBufferAttribute& Attribute : VertexBufferAttributes)

	mov	rax, QWORD PTR VertexBufferAttributes$56[rbp-248]
	mov	QWORD PTR <end>$L0$1$[rbp-256], rax
	mov	rdi, QWORD PTR VertexBufferAttributes$56[rbp-256]
	cmp	rdi, rax
	je	$LN2874@BfresFile

; 812  :                 }
; 813  :             }
; 814  : 
; 815  :             bool TransformedRoot = false;

	add	rdi, 36					; 00000024H
	mov	QWORD PTR tv24097[rbp-256], rdi
	mov	r13, r10
	mov	QWORD PTR tv24095[rbp-256], r10
	npad	1
$LL61@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR [rdi-36]
	mov	QWORD PTR _Result$1$[rbp-256], rdx
	mov	rax, rdx

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rcx, QWORD PTR [rdi-12]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rcx, 16
	jb	SHORT $LN2876@BfresFile

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdx]
$LN2876@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 820  :                 if (Attribute.Name[0] == '_' && Attribute.Name[1] == 'u') //UV Buffer Attribute

	cmp	BYTE PTR [rax], 95			; 0000005fH
	jne	$LN99@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdx

; 2227 :         if (_Large_string_engaged()) {

	cmp	rcx, 16
	jb	SHORT $LN2877@BfresFile

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdx]
$LN2877@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 820  :                 if (Attribute.Name[0] == '_' && Attribute.Name[1] == 'u') //UV Buffer Attribute

	cmp	BYTE PTR [rax+1], 117			; 00000075H
	jne	$LN99@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	r14, QWORD PTR $T51[rbp-256]
	shl	r14, 6
	mov	rax, QWORD PTR [r15+rax+48]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [r14+rax+40]
	mov	QWORD PTR tv23787[rbp-256], rdx
	mov	rcx, QWORD PTR [r14+rax+48]
	sub	rcx, rdx
	sar	rcx, 6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 822  :                     if (!(this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures.size()-1 >= UVBufferIndex)) continue;

	dec	rcx
	movsxd	rax, r8d
	cmp	rcx, rax
	jb	$LN2894@BfresFile

; 823  :                     this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates.resize(VertexCount * 2);

	lea	r9, QWORD PTR [rdx+r13]
	mov	eax, DWORD PTR VertexCount$1$[rsp]
	add	eax, eax
	mov	r8d, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r10, QWORD PTR [r9+16]
	mov	rdx, QWORD PTR [r9+8]
	mov	rcx, r10
	sub	rcx, rdx
	sar	rcx, 2

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	r8, rcx
	jae	SHORT $LN459@BfresFile

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rax*4]

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [r9+16], rax

; 1564 :             return;

	jmp	SHORT $LN460@BfresFile
$LN459@BfresFile:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN460@BfresFile

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r9+24]
	sub	rax, rdx
	sar	rax, 2

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	r8, rax
	jbe	SHORT $LN461@BfresFile

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, r8
	lea	rcx, QWORD PTR [r9+8]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<float,std::allocator<float> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN460@BfresFile
$LN461@BfresFile:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	r8, QWORD PTR [r8*4]
	lea	rbx, QWORD PTR [r10+r8]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, r10
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rax, QWORD PTR tv23787[rbp-256]
	mov	QWORD PTR [rax+r13+16], rbx
$LN460@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 828  :                     for (int VertexIndex = 0; VertexIndex < VertexCount; VertexIndex++)

	xor	r10d, r10d
	mov	ebx, r10d
	cmp	DWORD PTR VertexCount$1$[rsp], r10d
	jbe	$LN63@BfresFile
	mov	esi, r10d
	npad	13
$LL64@BfresFile:

; 829  :                     {
; 830  :                         switch (Attribute.Format)

	movzx	ecx, WORD PTR [rdi-4]
	cmp	ecx, 4610				; 00001202H
	ja	$LN116@BfresFile
	je	$LN103@BfresFile
	sub	ecx, 2305				; 00000901H
	je	$LN104@BfresFile
	sub	ecx, 1
	je	$LN105@BfresFile
	cmp	ecx, 2303				; 000008ffH
	jne	$LN62@BfresFile

; 837  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]) / 65536.0f;

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r9, QWORD PTR [rax+rax*4]
	mov	r8, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 837  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]) / 65536.0f;

	mov	edx, ebx
	imul	edx, DWORD PTR [r8+r9*8+8]
	movzx	eax, WORD PTR [rdi-2]
	add	edx, eax
	lea	ecx, DWORD PTR [rdx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [r8+r9*8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 837  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]) / 65536.0f;

	mov	eax, edx

; 357  :     return (static_cast<uint16_t>(Byte2) << 8) | Byte1;

	movzx	edx, BYTE PTR [rcx+r8]
	shl	edx, 8
	movzx	eax, BYTE PTR [rax+r8]
	or	edx, eax
	movd	xmm0, edx

; 837  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]) / 65536.0f;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rcx, QWORD PTR [r15+rax+48]
	mov	rax, QWORD PTR [r14+rcx+40]
	mov	r11, QWORD PTR [rax+r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 837  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]) / 65536.0f;

	movss	DWORD PTR [r11+rsi], xmm0

; 838  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]) / 65536.0f;

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r10, QWORD PTR [rax+rax*4]
	mov	r9, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 838  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]) / 65536.0f;

	mov	edx, ebx
	imul	edx, DWORD PTR [r9+r10*8+8]
	movzx	eax, WORD PTR [rdi-2]
	lea	r8d, DWORD PTR [rax+3]
	add	r8d, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [r9+r10*8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 838  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]) / 65536.0f;

	add	edx, 2
	add	eax, edx

; 357  :     return (static_cast<uint16_t>(Byte2) << 8) | Byte1;

	movzx	edx, BYTE PTR [r8+r9]
	shl	edx, 8
	movzx	eax, BYTE PTR [rax+r9]
	or	edx, eax
	movd	xmm0, edx

; 838  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]) / 65536.0f;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm9
	movss	DWORD PTR [r11+rsi+4], xmm0

; 839  :                             break;

	jmp	$LN62@BfresFile
$LN105@BfresFile:

; 849  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = (float)VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset] / 128.0f;

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r8, QWORD PTR [rax+rax*4]
	mov	rdx, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 849  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = (float)VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset] / 128.0f;

	mov	ecx, ebx
	imul	ecx, DWORD PTR [rdx+r8*8+8]
	movzx	eax, WORD PTR [rdi-2]
	add	ecx, eax
	mov	rax, QWORD PTR [rdx+r8*8+16]
	movzx	ecx, BYTE PTR [rcx+rax]
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rcx, QWORD PTR [r15+rax+48]
	mov	rax, QWORD PTR [r14+rcx+40]
	mov	r10, QWORD PTR [rax+r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 849  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = (float)VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset] / 128.0f;

	movss	DWORD PTR [rsi+r10], xmm0

; 850  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = (float)VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1] / 128.0f;

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r9, QWORD PTR [rax+rax*4]
	mov	r8, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 850  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = (float)VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1] / 128.0f;

	mov	ecx, ebx
	imul	ecx, DWORD PTR [r8+r9*8+8]
	movzx	eax, WORD PTR [rdi-2]
	inc	eax
	add	ecx, eax
	mov	rax, QWORD PTR [r8+r9*8+16]
	movzx	ecx, BYTE PTR [rcx+rax]
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm7

; 851  :                             break;

	jmp	$LN374@BfresFile
$LN104@BfresFile:

; 845  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = (float)VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset] / 256.0f;

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r8, QWORD PTR [rax+rax*4]
	mov	rdx, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 845  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = (float)VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset] / 256.0f;

	mov	ecx, ebx
	imul	ecx, DWORD PTR [rdx+r8*8+8]
	movzx	eax, WORD PTR [rdi-2]
	add	ecx, eax
	mov	rax, QWORD PTR [rdx+r8*8+16]
	movzx	ecx, BYTE PTR [rax+rcx]
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rcx, QWORD PTR [r15+rax+48]
	mov	rax, QWORD PTR [r14+rcx+40]
	mov	r10, QWORD PTR [rax+r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 845  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = (float)VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset] / 256.0f;

	movss	DWORD PTR [rsi+r10], xmm0

; 846  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = (float)VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1] / 256.0f;

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r9, QWORD PTR [rax+rax*4]
	mov	r8, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 846  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = (float)VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1] / 256.0f;

	mov	ecx, ebx
	imul	ecx, DWORD PTR [r8+r9*8+8]
	movzx	eax, WORD PTR [rdi-2]
	inc	eax
	add	ecx, eax
	mov	rax, QWORD PTR [r8+r9*8+16]
	movzx	ecx, BYTE PTR [rax+rcx]
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm8

; 847  :                             break;

	jmp	$LN374@BfresFile
$LN103@BfresFile:

; 841  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]) / 32768.0f;

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r9, QWORD PTR [rax+rax*4]
	mov	r8, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 841  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]) / 32768.0f;

	mov	edx, ebx
	imul	edx, DWORD PTR [r8+r9*8+8]
	movzx	eax, WORD PTR [rdi-2]
	add	edx, eax
	lea	ecx, DWORD PTR [rdx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [r8+r9*8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 841  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]) / 32768.0f;

	mov	eax, edx

; 357  :     return (static_cast<uint16_t>(Byte2) << 8) | Byte1;

	movzx	edx, BYTE PTR [r8+rcx]
	shl	edx, 8
	movzx	eax, BYTE PTR [r8+rax]
	or	edx, eax
	movd	xmm0, edx

; 841  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]) / 32768.0f;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rcx, QWORD PTR [r15+rax+48]
	mov	rax, QWORD PTR [r14+rcx+40]
	mov	r11, QWORD PTR [rax+r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 841  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]) / 32768.0f;

	movss	DWORD PTR [rsi+r11], xmm0

; 842  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]) / 32768.0f;

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r10, QWORD PTR [rax+rax*4]
	mov	r9, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 842  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]) / 32768.0f;

	mov	edx, ebx
	imul	edx, DWORD PTR [r9+r10*8+8]
	movzx	eax, WORD PTR [rdi-2]
	lea	r8d, DWORD PTR [rax+3]
	add	r8d, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [r9+r10*8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 842  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]) / 32768.0f;

	add	edx, 2
	add	eax, edx

; 357  :     return (static_cast<uint16_t>(Byte2) << 8) | Byte1;

	movzx	edx, BYTE PTR [r9+r8]
	shl	edx, 8
	movzx	eax, BYTE PTR [r9+rax]
	or	edx, eax
	movd	xmm0, edx

; 842  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->CombineToUInt16(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]) / 32768.0f;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm10
	movss	DWORD PTR [rsi+r11+4], xmm0

; 843  :                             break;

	jmp	$LN62@BfresFile
$LN116@BfresFile:

; 829  :                     {
; 830  :                         switch (Attribute.Format)

	cmp	ecx, 4613				; 00001205H
	je	$LN101@BfresFile
	cmp	ecx, 5893				; 00001705H
	jne	$LN62@BfresFile

; 853  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->UInt32ToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]);

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdx, QWORD PTR [rax+rax*4]
	mov	r8, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 853  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->UInt32ToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]);

	mov	ecx, ebx
	imul	ecx, DWORD PTR [r8+rdx*8+8]
	movzx	eax, WORD PTR [rdi-2]
	add	eax, ecx
	mov	r10d, eax
	add	eax, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [r8+rdx*8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 853  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->UInt32ToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]);

	movzx	r11d, BYTE PTR [rax+r8]
	lea	eax, DWORD PTR [r10+2]
	movzx	edx, BYTE PTR [rax+r8]
	lea	eax, DWORD PTR [r10+1]

; 340  :     uint32_t combinedValue = (static_cast<uint32_t>(Byte4) << 24) |

	shl	r11d, 8
	or	r11d, edx
	shl	r11d, 8
	movzx	eax, BYTE PTR [rax+r8]
	or	r11d, eax
	shl	r11d, 8
	movzx	eax, BYTE PTR [r10+r8]
	or	r11d, eax

; 341  :         (static_cast<uint32_t>(Byte3) << 16) |
; 342  :         (static_cast<uint32_t>(Byte2) << 8) |
; 343  :         static_cast<uint32_t>(Byte1);
; 344  : 
; 345  :     if (combinedValue == 0)

	jne	SHORT $LN684@BfresFile

; 346  :     {
; 347  :         return 0;

	movaps	xmm0, xmm6
	jmp	SHORT $LN683@BfresFile
$LN684@BfresFile:

; 348  :     }
; 349  : 
; 350  :     float ret;
; 351  :     std::memcpy(&ret, &combinedValue, sizeof(float));
; 352  :     return ret;

	movd	xmm0, r11d
$LN683@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rcx, QWORD PTR [r15+rax+48]
	mov	rax, QWORD PTR [r14+rcx+40]
	mov	rax, QWORD PTR [rax+r13+8]
	mov	QWORD PTR tv25055[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 853  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->UInt32ToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]);

	movss	DWORD PTR [rax+rsi], xmm0

; 854  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->UInt32ToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 4], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 5], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 6], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 7]);

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdx, QWORD PTR [rax+rax*4]
	mov	r8, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 854  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->UInt32ToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 4], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 5], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 6], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 7]);

	mov	r11d, ebx
	imul	r11d, DWORD PTR [r8+rdx*8+8]
	movzx	eax, WORD PTR [rdi-2]
	add	r11d, eax
	lea	eax, DWORD PTR [r11+7]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [r8+rdx*8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 854  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->UInt32ToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 4], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 5], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 6], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 7]);

	movzx	r9d, BYTE PTR [rax+r8]
	lea	eax, DWORD PTR [r11+6]
	movzx	edx, BYTE PTR [rax+r8]
	lea	eax, DWORD PTR [r11+5]
	movzx	r10d, BYTE PTR [rax+r8]
	lea	eax, DWORD PTR [r11+4]

; 340  :     uint32_t combinedValue = (static_cast<uint32_t>(Byte4) << 24) |

	mov	r11d, r9d
	shl	r11d, 8
	or	r11d, edx
	shl	r11d, 8
	or	r11d, r10d
	shl	r11d, 8
	movzx	eax, BYTE PTR [rax+r8]
	or	r11d, eax

; 341  :         (static_cast<uint32_t>(Byte3) << 16) |
; 342  :         (static_cast<uint32_t>(Byte2) << 8) |
; 343  :         static_cast<uint32_t>(Byte1);
; 344  : 
; 345  :     if (combinedValue == 0)

	jne	SHORT $LN717@BfresFile

; 346  :     {
; 347  :         return 0;

	movaps	xmm0, xmm6

; 854  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->UInt32ToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 4], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 5], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 6], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 7]);

	mov	rax, QWORD PTR tv25055[rbp-256]
	movss	DWORD PTR [rax+rsi+4], xmm0
	jmp	$LN62@BfresFile
$LN717@BfresFile:

; 352  :     return ret;

	movd	xmm0, r11d

; 854  :                              this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->UInt32ToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 4], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 5], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 6], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 7]);

	mov	rax, QWORD PTR tv25055[rbp-256]
	movss	DWORD PTR [rax+rsi+4], xmm0
	jmp	$LN62@BfresFile
$LN101@BfresFile:

; 833  :                             this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->ShortToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]);

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r9, QWORD PTR [rax+rax*4]
	mov	rdx, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 833  :                             this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->ShortToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]);

	mov	r8d, ebx
	imul	r8d, DWORD PTR [rdx+r9*8+8]
	movzx	eax, WORD PTR [rdi-2]
	add	r8d, eax
	lea	ecx, DWORD PTR [r8+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rdx+r9*8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 833  :                             this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->ShortToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]);

	mov	eax, r8d

; 321  :     uint16_t CombinedValue = (static_cast<uint16_t>(Byte2) << 8) | static_cast<uint16_t>(Byte1);

	movzx	r8d, BYTE PTR [rdx+rcx]
	shl	r8w, 8
	movzx	eax, BYTE PTR [rdx+rax]
	or	r8w, ax

; 322  :     if (CombinedValue == 0)

	jne	SHORT $LN398@BfresFile

; 323  :     {
; 324  :         return 0;

	movaps	xmm0, xmm6
	jmp	SHORT $LN397@BfresFile
$LN398@BfresFile:

; 325  :     }
; 326  :     int32_t BiasedExponent = (CombinedValue >> 10) & 0x1F;

	movzx	edx, r8w
	mov	ecx, edx
	shr	ecx, 10
	and	ecx, 31

; 327  :     int32_t Mantissa = CombinedValue & 0x3FF;

	mov	eax, edx
	and	eax, 1023				; 000003ffH

; 328  : 
; 329  :     // Reconstruct the half-float value with proper exponent bias
; 330  :     int32_t RealExponent = BiasedExponent - 15 + 127;

	add	ecx, 112				; 00000070H

; 325  :     }
; 326  :     int32_t BiasedExponent = (CombinedValue >> 10) & 0x1F;

	shl	ecx, 10
	or	ecx, eax
	shl	ecx, 13

; 331  :     uint32_t HalfFloatBits = ((CombinedValue & 0x8000) << 16) | (RealExponent << 23) | (Mantissa << 13);

	shl	edx, 16
	and	edx, -2147483648			; 80000000H
	or	ecx, edx
	movd	xmm0, ecx
$LN397@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rcx, QWORD PTR [r15+rax+48]
	mov	rax, QWORD PTR [r14+rcx+40]
	mov	r10, QWORD PTR [rax+r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 833  :                             this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2] = this->ShortToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 1]);

	movss	DWORD PTR [rsi+r10], xmm0

; 834  :                             this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->ShortToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]);                            

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r8, QWORD PTR [rax+rax*4]
	mov	rdx, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 834  :                             this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->ShortToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]);                            

	mov	r9d, ebx
	imul	r9d, DWORD PTR [rdx+r8*8+8]
	movzx	eax, WORD PTR [rdi-2]
	add	r9d, eax
	lea	eax, DWORD PTR [r9+3]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rdx+r8*8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 834  :                             this->m_Models[FMDLIndex].Materials[FVTXIndex].Textures[UVBufferIndex].TexCoordinates[VertexIndex * 2 + 1] = this->ShortToFloat(VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 2], VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset + 3]);                            

	movzx	r8d, BYTE PTR [rdx+rax]
	lea	eax, DWORD PTR [r9+2]

; 321  :     uint16_t CombinedValue = (static_cast<uint16_t>(Byte2) << 8) | static_cast<uint16_t>(Byte1);

	movzx	r9d, r8w
	shl	r9w, 8
	movzx	eax, BYTE PTR [rdx+rax]
	or	r9w, ax

; 322  :     if (CombinedValue == 0)

	jne	SHORT $LN375@BfresFile

; 323  :     {
; 324  :         return 0;

	movaps	xmm0, xmm6
	jmp	SHORT $LN374@BfresFile
$LN375@BfresFile:

; 325  :     }
; 326  :     int32_t BiasedExponent = (CombinedValue >> 10) & 0x1F;

	movzx	edx, r9w
	mov	ecx, edx
	shr	ecx, 10
	and	ecx, 31

; 327  :     int32_t Mantissa = CombinedValue & 0x3FF;

	mov	eax, edx
	and	eax, 1023				; 000003ffH

; 328  : 
; 329  :     // Reconstruct the half-float value with proper exponent bias
; 330  :     int32_t RealExponent = BiasedExponent - 15 + 127;

	add	ecx, 112				; 00000070H

; 325  :     }
; 326  :     int32_t BiasedExponent = (CombinedValue >> 10) & 0x1F;

	shl	ecx, 10
	or	ecx, eax
	shl	ecx, 13

; 331  :     uint32_t HalfFloatBits = ((CombinedValue & 0x8000) << 16) | (RealExponent << 23) | (Mantissa << 13);

	shl	edx, 16
	and	edx, -2147483648			; 80000000H
	or	ecx, edx
	movd	xmm0, ecx
$LN374@BfresFile:

; 828  :                     for (int VertexIndex = 0; VertexIndex < VertexCount; VertexIndex++)

	movss	DWORD PTR [rsi+r10+4], xmm0
$LN62@BfresFile:
	inc	ebx
	add	rsi, 8
	cmp	ebx, DWORD PTR VertexCount$1$[rsp]
	jb	$LL64@BfresFile
	mov	rsi, QWORD PTR tv25200[rbp-256]
	xor	r10d, r10d
$LN63@BfresFile:

; 855  :                             break;
; 856  :                         }
; 857  :                     }
; 858  : 
; 859  :                     UVBufferIndex++;

	inc	DWORD PTR UVBufferIndex$1$[rbp-256]
	add	r13, 64					; 00000040H
	mov	QWORD PTR tv24095[rbp-256], r13
	mov	rdx, QWORD PTR _Result$1$[rbp-256]
$LN99@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdx

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rcx, QWORD PTR [rdi-12]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rcx, 16
	jb	SHORT $LN2878@BfresFile

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdx]
$LN2878@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 862  :                 if (Attribute.Name[0] == '_' && Attribute.Name[1] == 'i' && !this->m_Rigids.empty() && VertexSkinCount == 1) //UV Buffer Attribute

	cmp	BYTE PTR [rax], 95			; 0000005fH
	jne	$LN2894@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2227 :         if (_Large_string_engaged()) {

	cmp	rcx, 16
	jb	SHORT $LN313@BfresFile

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN313@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 862  :                 if (Attribute.Name[0] == '_' && Attribute.Name[1] == 'i' && !this->m_Rigids.empty() && VertexSkinCount == 1) //UV Buffer Attribute

	cmp	BYTE PTR [rdx+1], 105			; 00000069H
	jne	$LN2894@BfresFile
	lea	r9, QWORD PTR [r12+48]
	mov	rax, QWORD PTR [r9+8]
	cmp	QWORD PTR [r9], rax
	je	$LN2894@BfresFile
	mov	r14d, DWORD PTR VertexCount$1$[rsp]
	cmp	BYTE PTR VertexSkinCount$1$[rsp], 1
	jne	$LN59@BfresFile

; 863  :                 {
; 864  :                     for (int VertexIndex = 0; VertexIndex < VertexCount; VertexIndex++)

	mov	ecx, r10d
	mov	DWORD PTR VertexIndex$1$[rsp], ecx
	test	r14d, r14d
	je	$LN59@BfresFile

; 898  :                             };

	lea	rax, QWORD PTR RootBone$64[rbp-256]
	mov	QWORD PTR ApplyTransformOfParent$9[rsp], rax

; 905  :                                     break;
; 906  :                             }
; 907  :                         }
; 908  : 
; 909  :                         TransformedRoot = true;

	mov	BYTE PTR TransformedRoot$1$[rsp], 1

; 863  :                 {
; 864  :                     for (int VertexIndex = 0; VertexIndex < VertexCount; VertexIndex++)

	mov	r13d, 1
	mov	DWORD PTR tv24101[rsp], r13d
	npad	11
$LL69@BfresFile:

; 866  :                         BfresFile::SkeletonBone RootBone = this->m_SkeletonBones[this->m_Rigids[VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset]]];

	movzx	eax, WORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r8, QWORD PTR [rax+rax*4]
	mov	rdx, QWORD PTR VertexBuffers$52[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 866  :                         BfresFile::SkeletonBone RootBone = this->m_SkeletonBones[this->m_Rigids[VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset]]];

	imul	ecx, DWORD PTR [rdx+r8*8+8]
	movzx	eax, WORD PTR [rdi-2]
	add	ecx, eax
	mov	rax, QWORD PTR [rdx+r8*8+16]
	movzx	edx, BYTE PTR [rax+rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r9]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 866  :                         BfresFile::SkeletonBone RootBone = this->m_SkeletonBones[this->m_Rigids[VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset]]];

	movzx	eax, WORD PTR [rax+rdx*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rcx, rax, 56				; 00000038H
	add	rcx, QWORD PTR [r12+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 866  :                         BfresFile::SkeletonBone RootBone = this->m_SkeletonBones[this->m_Rigids[VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset]]];

	movups	xmm2, XMMWORD PTR [rcx]
	movups	XMMWORD PTR RootBone$64[rbp-256], xmm2
	movups	xmm0, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR RootBone$64[rbp-240], xmm0
	movups	xmm1, XMMWORD PTR [rcx+32]
	movups	XMMWORD PTR RootBone$64[rbp-224], xmm1
	movsd	xmm0, QWORD PTR [rcx+48]
	movsd	QWORD PTR RootBone$64[rbp-208], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rcx, QWORD PTR [r15+rax+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 900  :                         if (ApplyTransformOfParent(RootBone.Index, m_SkeletonBones, this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3], this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1], this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2]))

	lea	eax, DWORD PTR [r13+1]
	movsxd	rbx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rcx+rsi*8]
	lea	r8, QWORD PTR [rdx+rbx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 900  :                         if (ApplyTransformOfParent(RootBone.Index, m_SkeletonBones, this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3], this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1], this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2]))

	movsxd	rsi, r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rdx+rsi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 900  :                         if (ApplyTransformOfParent(RootBone.Index, m_SkeletonBones, this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3], this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1], this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2]))

	lea	eax, DWORD PTR [r13-1]
	movsxd	r14, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r9, QWORD PTR [rdx+r14*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 900  :                         if (ApplyTransformOfParent(RootBone.Index, m_SkeletonBones, this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3], this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1], this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2]))

	movd	eax, xmm2
	movzx	edx, ax
	mov	QWORD PTR [rsp+40], r8
	mov	QWORD PTR [rsp+32], rcx
	lea	r8, QWORD PTR [r12+24]
	lea	rcx, QWORD PTR ApplyTransformOfParent$9[rsp]
	call	??R<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEBA@HAEAV?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@3@AEAM33@Z ; `BfresFile::BfresFile'::`116'::<lambda_1>::operator()
	test	al, al
	je	SHORT $LN2725@BfresFile
	mov	rdi, QWORD PTR tv25200[rbp-256]
$LL70@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
	mov	rax, QWORD PTR [r15+rax+24]
	mov	rcx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR [rcx+rbx*4]
	lea	r8, QWORD PTR [rcx+rsi*4]
	lea	r9, QWORD PTR [rcx+r14*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 904  :                                 if (!ApplyTransformOfParent(RootBone.ParentIndex, m_SkeletonBones, this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3], this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1], this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2]))

	movsx	edx, WORD PTR RootBone$64[rbp-254]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r8
	lea	r8, QWORD PTR [r12+24]
	lea	rcx, QWORD PTR ApplyTransformOfParent$9[rsp]
	call	??R<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEBA@HAEAV?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@3@AEAM33@Z ; `BfresFile::BfresFile'::`116'::<lambda_1>::operator()
	test	al, al
	jne	SHORT $LL70@BfresFile
	mov	rdi, QWORD PTR tv24097[rbp-256]
	mov	r13d, DWORD PTR tv24101[rsp]
$LN2725@BfresFile:

; 863  :                 {
; 864  :                     for (int VertexIndex = 0; VertexIndex < VertexCount; VertexIndex++)

	mov	ecx, DWORD PTR VertexIndex$1$[rsp]
	inc	ecx
	mov	DWORD PTR VertexIndex$1$[rsp], ecx
	add	r13d, 3
	mov	DWORD PTR tv24101[rsp], r13d
	mov	r14d, DWORD PTR VertexCount$1$[rsp]
	cmp	ecx, r14d
	mov	rsi, QWORD PTR tv25200[rbp-256]
	lea	r9, QWORD PTR [r12+48]
	jb	$LL69@BfresFile
	mov	r13, QWORD PTR tv24095[rbp-256]

; 862  :                 if (Attribute.Name[0] == '_' && Attribute.Name[1] == 'i' && !this->m_Rigids.empty() && VertexSkinCount == 1) //UV Buffer Attribute

	jmp	SHORT $LN59@BfresFile
$LN2894@BfresFile:

; 817  :             /* Parsing UV Data */
; 818  :             for (BfresFile::VertexBufferAttribute& Attribute : VertexBufferAttributes)

	mov	r14d, DWORD PTR VertexCount$1$[rsp]
$LN59@BfresFile:
	add	rdi, 40					; 00000028H
	mov	QWORD PTR tv24097[rbp-256], rdi
	lea	rax, QWORD PTR [rdi-36]
	cmp	rax, QWORD PTR <end>$L0$1$[rbp-256]
	mov	rsi, QWORD PTR tv25200[rbp-256]
	mov	r8d, DWORD PTR UVBufferIndex$1$[rbp-256]
	mov	r10d, 0
	jne	$LL61@BfresFile

; 910  :                         //std::cout << "_i Buffer Element: " << (int)VertexBuffers[Attribute.BufferIndex].Data[VertexIndex * VertexBuffers[Attribute.BufferIndex].Stride + Attribute.Offset] << std::endl;
; 911  :                     }
; 912  :                 }
; 913  :             }
; 914  : 
; 915  :             if (!TransformedRoot)

	cmp	BYTE PTR TransformedRoot$1$[rsp], r10b
	jne	$LN2820@BfresFile
$LN2874@BfresFile:

; 916  :             {
; 917  :                 for (int VertexIndex = 0; VertexIndex < VertexCount; VertexIndex++)

	mov	r11d, r10d
	mov	rbx, r10
	cmp	r14d, 4
	jb	$LN2827@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [r12]
	mov	r8, QWORD PTR [r12+24]
	mov	rdx, r10
	lea	eax, DWORD PTR [r14-4]
	shr	eax, 2
	inc	eax
	mov	r10d, eax
	lea	r11d, DWORD PTR [rax*4]
	lea	rbx, QWORD PTR [rax*4]
	npad	12
$LL2822@BfresFile:
	mov	rax, QWORD PTR [r15+r9+24]
	mov	rcx, QWORD PTR [rax+rsi*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 919  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3] += this->m_SkeletonBones[0].Position[0];

	movss	xmm0, DWORD PTR [rcx+rdx]
	addss	xmm0, DWORD PTR [r8+44]
	movss	DWORD PTR [rcx+rdx], xmm0

; 920  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1] += this->m_SkeletonBones[0].Position[1];

	movss	xmm1, DWORD PTR [r8+48]
	addss	xmm1, DWORD PTR [rcx+rdx+4]
	movss	DWORD PTR [rcx+rdx+4], xmm1

; 921  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] += this->m_SkeletonBones[0].Position[2];

	movss	xmm0, DWORD PTR [rcx+rdx+8]
	addss	xmm0, DWORD PTR [r8+52]
	movss	DWORD PTR [rcx+rdx+8], xmm0

; 919  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3] += this->m_SkeletonBones[0].Position[0];

	movss	xmm1, DWORD PTR [r8+44]
	addss	xmm1, DWORD PTR [rcx+rdx+12]
	movss	DWORD PTR [rcx+rdx+12], xmm1

; 920  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1] += this->m_SkeletonBones[0].Position[1];

	movss	xmm0, DWORD PTR [rcx+rdx+16]
	addss	xmm0, DWORD PTR [r8+48]
	movss	DWORD PTR [rcx+rdx+16], xmm0

; 921  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] += this->m_SkeletonBones[0].Position[2];

	movss	xmm1, DWORD PTR [r8+52]
	addss	xmm1, DWORD PTR [rcx+rdx+20]
	movss	DWORD PTR [rcx+rdx+20], xmm1

; 919  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3] += this->m_SkeletonBones[0].Position[0];

	movss	xmm0, DWORD PTR [r8+44]
	addss	xmm0, DWORD PTR [rcx+rdx+24]
	movss	DWORD PTR [rcx+rdx+24], xmm0

; 920  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1] += this->m_SkeletonBones[0].Position[1];

	movss	xmm1, DWORD PTR [r8+48]
	addss	xmm1, DWORD PTR [rcx+rdx+28]
	movss	DWORD PTR [rcx+rdx+28], xmm1

; 921  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] += this->m_SkeletonBones[0].Position[2];

	movss	xmm0, DWORD PTR [rcx+rdx+32]
	addss	xmm0, DWORD PTR [r8+52]
	movss	DWORD PTR [rcx+rdx+32], xmm0

; 919  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3] += this->m_SkeletonBones[0].Position[0];

	movss	xmm1, DWORD PTR [r8+44]
	addss	xmm1, DWORD PTR [rcx+rdx+36]
	movss	DWORD PTR [rcx+rdx+36], xmm1

; 920  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1] += this->m_SkeletonBones[0].Position[1];

	movss	xmm0, DWORD PTR [r8+48]
	addss	xmm0, DWORD PTR [rcx+rdx+40]
	movss	DWORD PTR [rcx+rdx+40], xmm0

; 921  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] += this->m_SkeletonBones[0].Position[2];

	movss	xmm1, DWORD PTR [r8+52]
	addss	xmm1, DWORD PTR [rcx+rdx+44]
	movss	DWORD PTR [rcx+rdx+44], xmm1
	add	rdx, 48					; 00000030H
	sub	r10, 1
	jne	$LL2822@BfresFile

; 916  :             {
; 917  :                 for (int VertexIndex = 0; VertexIndex < VertexCount; VertexIndex++)

	cmp	r11d, r14d
	jb	SHORT $LN2875@BfresFile
	jmp	SHORT $LN2820@BfresFile
$LN2827@BfresFile:
	test	r14d, r14d
	je	SHORT $LN2820@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [r12]
$LN2875@BfresFile:
	mov	r8, QWORD PTR [r12+24]

; 1883 :         auto& _My_data = _Mypair._Myval2;

	lea	rdx, QWORD PTR [rbx+rbx*2]
	shl	rdx, 2
	sub	r14d, r11d
	mov	r10d, r14d
$LC2873@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 919  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3] += this->m_SkeletonBones[0].Position[0];

	movss	xmm0, DWORD PTR [r8+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r15+r9+24]
	mov	rcx, QWORD PTR [rax+rsi*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 919  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3] += this->m_SkeletonBones[0].Position[0];

	addss	xmm0, DWORD PTR [rdx+rcx]
	movss	DWORD PTR [rdx+rcx], xmm0

; 920  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 1] += this->m_SkeletonBones[0].Position[1];

	movss	xmm0, DWORD PTR [r8+48]
	addss	xmm0, DWORD PTR [rdx+rcx+4]
	movss	DWORD PTR [rdx+rcx+4], xmm0

; 921  :                     this->m_Models[FMDLIndex].Vertices[FVTXIndex][VertexIndex * 3 + 2] += this->m_SkeletonBones[0].Position[2];

	movss	xmm1, DWORD PTR [r8+52]
	addss	xmm1, DWORD PTR [rdx+rcx+8]
	movss	DWORD PTR [rdx+rcx+8], xmm1

; 916  :             {
; 917  :                 for (int VertexIndex = 0; VertexIndex < VertexCount; VertexIndex++)

	add	rdx, 12
	sub	r10, 1
	jne	SHORT $LC2873@BfresFile
$LN2820@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	r13d, DWORD PTR Reader$15$[rsp]
	add	r13d, 88				; 00000058H
	mov	DWORD PTR Reader$15$[rsp], r13d
	mov	DWORD PTR Reader$[rsp+8], r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR VertexBuffers$52[rbp-256]
	test	rcx, rcx
	je	SHORT $LN2896@BfresFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, QWORD PTR VertexBuffers$52[rbp-248]
	call	??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::VertexBuffer> >

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR VertexBuffers$52[rbp-240]
	mov	rcx, QWORD PTR VertexBuffers$52[rbp-256]
	sub	rax, rcx
	sar	rax, 3
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN241@BfresFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN238@BfresFile
$LN241@BfresFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR VertexBuffers$52[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	xor	ebx, ebx
	mov	QWORD PTR VertexBuffers$52[rbp-240], rbx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	jmp	SHORT $LN223@BfresFile
$LN2896@BfresFile:
	xor	ebx, ebx
$LN223@BfresFile:

; 767  :         _Tidy();

	lea	rcx, QWORD PTR VertexBufferAttributes$56[rbp-256]
	call	?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Tidy
	npad	1

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR VertexBufferStrideArray$57[rbp-256]
	test	rcx, rcx
	je	SHORT $LN168@BfresFile

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR VertexBufferStrideArray$57[rbp-240]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN186@BfresFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN183@BfresFile
$LN186@BfresFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR VertexBufferStrideArray$57[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR VertexBufferStrideArray$57[rbp-240], rbx
$LN168@BfresFile:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR VertexBufferSizeArray$58[rbp-256]
	test	rcx, rcx
	je	SHORT $LN38@BfresFile

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR VertexBufferSizeArray$58[rbp-240]
	sub	rax, rcx
	sar	rax, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN213@BfresFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN210@BfresFile
$LN213@BfresFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR VertexBufferSizeArray$58[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR VertexBufferSizeArray$58[rbp-240], rbx
$LN38@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 719  :         for (int FVTXIndex = 0; FVTXIndex < FVTXCount; FVTXIndex++)

	mov	rax, QWORD PTR $T51[rbp-256]
	inc	rax
	mov	QWORD PTR $T51[rbp-256], rax
	cmp	rax, QWORD PTR _Newsize$1$[rbp-256]
	mov	rdi, QWORD PTR Reader$4$[rbp-256]
	jl	$LL40@BfresFile
$LN39@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Materials$60[rbp-256]
	call	?_Tidy@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Tidy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 452  :     for (uint16_t FMDLIndex = 0; FMDLIndex < FMDLCount; FMDLIndex++)

	movzx	esi, WORD PTR FMDLIndex$1$[rbp-256]
	inc	si
	mov	WORD PTR FMDLIndex$1$[rbp-256], si
	cmp	si, WORD PTR FMDLCount$1$[rbp-256]
	jb	$LL4@BfresFile
	mov	r13, QWORD PTR Path$GSCopy$1$[rbp-256]
$LN2882@BfresFile:

; 922  :                 }
; 923  :             }
; 924  : 
; 925  :             Reader.Seek(FVTXBaseOffset + 88, BinaryVectorReader::Position::Begin);
; 926  :         }
; 927  :     }
; 928  : 
; 929  :     this->CreateOpenGLObjects();

	mov	rcx, r12
	call	?CreateOpenGLObjects@BfresFile@@QEAAXXZ	; BfresFile::CreateOpenGLObjects
	jmp	$LN1@BfresFile
$LN1207@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN238@BfresFile:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN183@BfresFile:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN210@BfresFile:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN78@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 411  :         Logger::Error("Bfres", "Wrong version, expected v10, got v" + std::to_string((int)VersionNumberA) + "." + std::to_string((int)VersionNumberB) + "." + std::to_string((int)VersionNumberC) + "." + std::to_string((int)VersionNumberD));

	lea	rax, QWORD PTR $T39[rbp-256]
	mov	QWORD PTR $T14[rbp-256], rax
	mov	edx, r8d
	lea	rcx, QWORD PTR $T48[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	mov	rsi, rax
	mov	edx, ebx
	lea	rcx, QWORD PTR $T29[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	mov	rdi, rax
	mov	edx, r14d
	lea	rcx, QWORD PTR $T30[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	mov	rbx, rax
	mov	edx, r15d
	lea	rcx, QWORD PTR $T31[rbp-256]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
	mov	r8, rax
	lea	rdx, OFFSET FLAT:??_C@_0CD@FODENHEF@Wrong?5version?0?5expected?5v10?0?5go@
	lea	rcx, QWORD PTR $T32[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_01LFCBOECM@?4@
	mov	rdx, rax
	lea	rcx, QWORD PTR $T33[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	r8, rbx
	mov	rdx, rax
	lea	rcx, QWORD PTR $T34[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_01LFCBOECM@?4@
	mov	rdx, rax
	lea	rcx, QWORD PTR $T35[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	r8, rdi
	mov	rdx, rax
	lea	rcx, QWORD PTR $T36[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, OFFSET FLAT:??_C@_01LFCBOECM@?4@
	mov	rdx, rax
	lea	rcx, QWORD PTR $T37[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	r8, rsi
	mov	rdx, rax
	lea	rcx, QWORD PTR $T39[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
	lea	rdx, OFFSET FLAT:??_C@_05JBOHDMDP@Bfres@
	lea	rcx, QWORD PTR $T38[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rbx
	mov	rcx, rax
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T37[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T36[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T35[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T34[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T33[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T32[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T31[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T30[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T29[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T48[rbp-256]
$LN2900@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 930  : }

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
$LN1@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, r13
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 930  : }

	mov	rcx, QWORD PTR Bytes$GSCopy$1$[rbp-256]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	mov	rax, r12
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+1840]
	mov	rbx, QWORD PTR [r11+88]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN2724@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2723@BfresFile:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN2899@BfresFile:
??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z ENDP ; BfresFile::BfresFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$0@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$0
	mov	rcx, QWORD PTR Bytes$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$1@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$1
	mov	rcx, QWORD PTR Path$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$2@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::~vector<BfresFile::Model,std::allocator<BfresFile::Model> >
?dtor$2@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$3@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$3
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 24
	jmp	??1?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::~vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >
?dtor$3@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$4@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$4
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1?$vector@GV?$allocator@G@std@@@std@@QEAA@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
?dtor$4@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$5@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$5
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 80					; 00000050H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$6@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$6
	mov	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$8@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$8
	mov	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$10@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$10
	lea	rcx, QWORD PTR $T48[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$11@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$11
	lea	rcx, QWORD PTR $T29[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$12@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$12
	lea	rcx, QWORD PTR $T30[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$13@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$13
	lea	rcx, QWORD PTR $T31[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$13@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$14@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$14
	lea	rcx, QWORD PTR $T32[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$14@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$15@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$15
	lea	rcx, QWORD PTR $T33[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$15@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$16@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$16
	lea	rcx, QWORD PTR $T34[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$17@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$17
	lea	rcx, QWORD PTR $T35[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$17@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$18@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$18
	lea	rcx, QWORD PTR $T36[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$18@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$19@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$19
	lea	rcx, QWORD PTR $T37[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$19@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$20@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$20
	mov	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$20@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$22@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$22
	lea	rcx, QWORD PTR $T47[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$22@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$23@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$23
	mov	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$23@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$23
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$25@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$25
	lea	rcx, QWORD PTR Materials$60[rdx]
	jmp	??1?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::~vector<BfresFile::Material,std::allocator<BfresFile::Material> >
?dtor$25@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$27@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$27
	lea	rcx, QWORD PTR LocalTextures$53[rdx]
	jmp	??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
?dtor$27@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$28@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$28
	lea	rcx, QWORD PTR LocalTransparentTextures$54[rdx]
	jmp	??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
?dtor$28@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$28
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$30@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$30
	lea	rcx, QWORD PTR $T27[rdx]
	jmp	??1?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$30@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$30
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$31@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$31
	lea	rcx, QWORD PTR TextureName$63[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$31@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$31
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$32@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$32
	lea	rcx, QWORD PTR Sampler$61[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$32@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$32
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$34@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$34
	lea	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$34@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$34
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$35@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$35
	lea	rcx, QWORD PTR $T22[rdx]
	jmp	??1?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$35@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$35
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$82@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$82
	lea	rcx, QWORD PTR MaterialTexture$49[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$82@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$82
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$36@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$36
	lea	rcx, QWORD PTR MaterialTexture$49[rdx]
	jmp	??1BfresTexture@BfresFile@@QEAA@XZ
?dtor$36@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$36
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$37@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$37
	lea	rcx, QWORD PTR TextureName$62[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$37@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$37
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$38@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$38
	lea	rcx, QWORD PTR Sampler$59[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$38@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$38
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$53@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$53
	lea	rcx, QWORD PTR MaterialTexture$50[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$53@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$53
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$39@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$39
	lea	rcx, QWORD PTR MaterialTexture$50[rdx]
	jmp	??1BfresTexture@BfresFile@@QEAA@XZ
?dtor$39@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$39
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$57@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$57
	mov	rcx, QWORD PTR $T19[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$57@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$57
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$41@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$41
	lea	rcx, QWORD PTR Name$55[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$41@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$41
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$42@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$42
	mov	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$42@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$42
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$44@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$44
	lea	rcx, QWORD PTR VertexBufferSizeArray$58[rdx]
	jmp	??1?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::~vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >
?dtor$44@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$44
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$45@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$45
	lea	rcx, QWORD PTR VertexBufferStrideArray$57[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$45@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$45
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$46@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$46
	lea	rcx, QWORD PTR VertexBufferAttributes$56[rdx]
	jmp	??1?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::~vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >
?dtor$46@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$46
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
NumVertexAttrib$1$ = 64
NumLODs$1$ = 64
TransformedRoot$1$ = 64
Reader$ = 72
VertexSkinCount$1$ = 88
tv26948 = 88
VertexCount$1$ = 92
FVTXCount$1$ = 92
tv24132 = 96
tv24122 = 96
tv24101 = 96
tv23844 = 96
Data$1$ = 104
tv24151 = 104
tv24069 = 104
tv24009 = 104
tv23843 = 104
ApplyTransformOfParent$9 = 104
$T10 = 104
Reader$15$ = 112
i$1$ = 112
tv24141 = 112
tv24135 = 112
tv24120 = 112
FaceCount$1$ = 120
VertexIndex$1$ = 120
FMATIndex$1$ = 120
Reader$10$ = 128
UVBufferIndex$1$ = 128
i$1$ = 128
tv24134 = 128
tv24131 = 128
_Count$1$ = 136
_Result$1$ = 136
$T11 = 136
MeshArrayOffset$1$ = 136
FSHPOffset$1$ = 136
tv24283 = 136
$T12 = 136
tv26950 = 144
Data$1$ = 152
FVTXOffset$1$ = 152
tv25055 = 152
tv24588 = 152
tv23904 = 152
tv23787 = 152
$T13 = 152
$T14 = 152
$T15 = 152
$T16 = 152
Reader$4$ = 160
tv24012 = 160
BufferOffset$1$ = 168
FaceType$1$ = 168
tv25200 = 168
tv23863 = 168
$T17 = 168
FMDLIndex$1$ = 176
$T18 = 180
tv24133 = 184
tv24121 = 184
tv24095 = 184
tv23862 = 184
FMDLCount$1$ = 192
DataStart$1$ = 196
SamplerValuesOffset$1$ = 200
tv23972 = 200
_Newsize$1$ = 208
tv24097 = 208
_Newsize$1$ = 216
TextureArrayOffset$1$ = 216
$T19 = 216
this$GSCopy$1$ = 224
<end>$L0$1$ = 232
FSKLOffset$1$ = 232
tv23932 = 240
VBufferSize$20 = 248
Path$GSCopy$1$ = 256
Bytes$GSCopy$1$ = 264
$T21 = 272
$T22 = 312
$T23 = 352
$T24 = 384
this$GSCopy$ = 416
$T25 = 432
$T26 = 464
$T27 = 496
$T28 = 536
$T29 = 568
$T30 = 600
$T31 = 632
$T32 = 664
$T33 = 696
$T34 = 728
$T35 = 760
$T36 = 792
$T37 = 824
$T38 = 856
$T39 = 888
$T40 = 920
$T41 = 952
$T42 = 984
$T43 = 1016
$T44 = 1048
$T45 = 1080
$T46 = 1112
$T47 = 1144
$T48 = 1176
MaterialTexture$49 = 1216
MaterialTexture$50 = 1280
Bytes$GSCopy$ = 1344
Path$GSCopy$ = 1352
Reader$9$ = 1360
$T51 = 1360
tv23860 = 1360
Magic$ = 1360
VertexBuffers$52 = 1368
LocalTextures$53 = 1392
LocalTransparentTextures$54 = 1416
Name$55 = 1440
VertexBufferAttributes$56 = 1472
VertexBufferStrideArray$57 = 1496
VertexBufferSizeArray$58 = 1520
Sampler$59 = 1544
Materials$60 = 1576
Sampler$61 = 1600
TextureName$62 = 1632
TextureName$63 = 1664
RootBone$64 = 1696
__$ArrayPad$ = 1752
this$ = 1904
Path$ = 1912
Bytes$ = 1920
?dtor$47@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$47
	lea	rcx, QWORD PTR VertexBuffers$52[rdx]
	jmp	??1?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::~vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >
?dtor$47@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$47
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ??R<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEBA@HAEAV?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@3@AEAM33@Z
_TEXT	SEGMENT
tv917 = 32
tv918 = 36
this$ = 256
tv923 = 264
ParentIndex$ = 264
Bones$ = 272
X$ = 280
Y$ = 288
Z$ = 296
??R<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEBA@HAEAV?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@3@AEAM33@Z PROC ; `BfresFile::BfresFile'::`116'::<lambda_1>::operator(), COMDAT

; 870  :                             {

	push	r14
	push	r15
	sub	rsp, 232				; 000000e8H
	mov	r14, r9
	mov	r15, rcx

; 871  :                                 if (ParentIndex == -1) return false;

	cmp	edx, -1
	jne	SHORT $LN2@operator
	xor	al, al

; 898  :                             };

	add	rsp, 232				; 000000e8H
	pop	r15
	pop	r14
	ret	0
$LN2@operator:

; 873  :                                 X += Bones[ParentIndex].Position[0];

	movss	xmm0, DWORD PTR [r9]
	mov	QWORD PTR [rsp+256], rbx

; 874  :                                 Y += Bones[ParentIndex].Position[1];

	mov	rbx, QWORD PTR Y$[rsp]
	mov	QWORD PTR [rsp+272], rbp
	mov	rbp, QWORD PTR [r8]
	mov	QWORD PTR [rsp+280], rsi
	mov	QWORD PTR [rsp+224], rdi

; 875  :                                 Z += Bones[ParentIndex].Position[2];

	mov	rdi, QWORD PTR Z$[rsp]
	movaps	XMMWORD PTR [rsp+208], xmm6
	movaps	XMMWORD PTR [rsp+192], xmm7
	movaps	XMMWORD PTR [rsp+176], xmm8
	movaps	XMMWORD PTR [rsp+160], xmm9
	movaps	XMMWORD PTR [rsp+144], xmm10
	movaps	XMMWORD PTR [rsp+128], xmm11
	movaps	XMMWORD PTR [rsp+112], xmm12
	movsxd	rax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rsi, rax, 56				; 00000038H
	imul	rax, rax, 14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 873  :                                 X += Bones[ParentIndex].Position[0];

	addss	xmm0, DWORD PTR [rsi+rbp+44]
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	DWORD PTR [r9], xmm0

; 874  :                                 Y += Bones[ParentIndex].Position[1];

	movss	xmm0, DWORD PTR [rbx]
	addss	xmm0, DWORD PTR [rsi+rbp+48]
	movss	DWORD PTR [rbx], xmm0

; 875  :                                 Z += Bones[ParentIndex].Position[2];

	movss	xmm9, DWORD PTR [rsi+rbp+52]
	addss	xmm9, DWORD PTR [rdi]
	movss	DWORD PTR [rdi], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 9    : 	this->m_Data[1] = y;

	movss	xmm12, DWORD PTR [rbp+rax*4+36]
	movss	xmm8, DWORD PTR [rbp+rax*4+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 883  :                                 float NewY = Bones[ParentIndex].Position[1] + ((X - Bones[ParentIndex].Position[0]) * (std::sinf(Rotation.GetZ()) * std::cosf(Rotation.GetY()))) +

	movaps	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 8    : 	this->m_Data[0] = x;

	movss	xmm6, DWORD PTR [rsi+rbp+28]
	movss	DWORD PTR tv917[rsp], xmm6

; 9    : 	this->m_Data[1] = y;

	movss	DWORD PTR tv923[rsp], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 883  :                                 float NewY = Bones[ParentIndex].Position[1] + ((X - Bones[ParentIndex].Position[0]) * (std::sinf(Rotation.GetZ()) * std::cosf(Rotation.GetY()))) +

	call	sinf
	movaps	xmm11, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 9    : 	this->m_Data[1] = y;

	movaps	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 883  :                                 float NewY = Bones[ParentIndex].Position[1] + ((X - Bones[ParentIndex].Position[0]) * (std::sinf(Rotation.GetZ()) * std::cosf(Rotation.GetY()))) +

	call	sinf
	movss	xmm14, DWORD PTR [rsi+rbp+52]
	movss	xmm10, DWORD PTR [rsi+rbp+48]
	subss	xmm9, xmm14
	movss	xmm15, DWORD PTR [rbx]
	movss	xmm13, DWORD PTR [r14]
	subss	xmm15, xmm10
	subss	xmm13, DWORD PTR [rsi+rbp+44]
	mulss	xmm11, xmm0
	movaps	xmm0, xmm12
	movss	DWORD PTR tv918[rsp], xmm9
	call	cosf
	movaps	xmm9, xmm0
	movaps	xmm0, xmm8
	call	sinf
	mulss	xmm9, xmm0
	movaps	xmm0, xmm6
	call	sinf
	movaps	xmm8, xmm0
	movaps	xmm0, xmm6
	mulss	xmm8, xmm9
	call	cosf
	movaps	xmm6, xmm0
	movaps	xmm0, xmm12
	call	sinf
	mulss	xmm6, xmm0
	movaps	xmm0, xmm12
	subss	xmm8, xmm6
	mulss	xmm8, xmm15
	call	cosf
	movaps	xmm6, xmm0
	movss	xmm0, DWORD PTR tv923[rsp]
	call	cosf
	movss	xmm7, DWORD PTR tv917[rsp]
	mulss	xmm6, xmm0
	movaps	xmm0, xmm7
	mulss	xmm6, xmm13
	addss	xmm6, DWORD PTR [rsi+rbp+44]
	addss	xmm8, xmm6
	call	sinf
	movaps	xmm6, xmm0
	movaps	xmm0, xmm12
	call	sinf

; 876  : 
; 877  :                                 Vector3F Rotation(Bones[ParentIndex].Rotation[0], Bones[ParentIndex].Rotation[1], Bones[ParentIndex].Rotation[2]);
; 878  : 
; 879  :                                 float NewX = Bones[ParentIndex].Position[0] + ((X - Bones[ParentIndex].Position[0]) * (std::cosf(Rotation.GetZ()) * std::cosf(Rotation.GetY()))) +

	mulss	xmm6, xmm0
	movaps	xmm0, xmm7
	call	cosf
	mulss	xmm0, xmm9

; 883  :                                 float NewY = Bones[ParentIndex].Position[1] + ((X - Bones[ParentIndex].Position[0]) * (std::sinf(Rotation.GetZ()) * std::cosf(Rotation.GetY()))) +

	movaps	xmm9, xmm7
	addss	xmm6, xmm0
	movaps	xmm0, xmm7
	mulss	xmm6, DWORD PTR tv918[rsp]
	addss	xmm8, xmm6

; 884  :                                     ((Y - Bones[ParentIndex].Position[1]) * (std::sinf(Rotation.GetZ()) * std::sinf(Rotation.GetY()) * std::sinf(Rotation.GetX()) + std::cosf(Rotation.GetZ()) * std::cosf(Rotation.GetX()))) +
; 885  :                                     ((Z - Bones[ParentIndex].Position[2]) * (std::sinf(Rotation.GetZ()) * std::sinf(Rotation.GetY()) * std::cosf(Rotation.GetX()) - std::cosf(Rotation.GetZ()) * std::sinf(Rotation.GetX())));
; 886  : 
; 887  :                                 float NewZ = Bones[ParentIndex].Position[2] + ((X - Bones[ParentIndex].Position[0]) * (-std::sinf(Rotation.GetY()))) +
; 888  :                                     ((Y - Bones[ParentIndex].Position[1]) * (std::cosf(Rotation.GetY()) * std::sinf(Rotation.GetX()))) +
; 889  :                                     ((Z - Bones[ParentIndex].Position[2]) * (std::cosf(Rotation.GetY()) * std::cosf(Rotation.GetX())));
; 890  : 
; 891  :                                 X = NewX;

	movss	DWORD PTR [r14], xmm8
	call	cosf
	movaps	xmm8, xmm0
	movaps	xmm0, xmm12
	call	cosf
	mulss	xmm8, xmm0
	movaps	xmm0, xmm7
	call	sinf
	mulss	xmm0, xmm11
	addss	xmm8, xmm0
	movaps	xmm0, xmm12
	mulss	xmm8, xmm15
	call	sinf
	movaps	xmm6, xmm0
	movss	xmm0, DWORD PTR tv923[rsp]
	call	cosf
	mulss	xmm6, xmm0
	movaps	xmm0, xmm7
	mulss	xmm6, xmm13
	addss	xmm6, xmm10
	addss	xmm8, xmm6
	call	cosf
	movaps	xmm7, xmm0
	movaps	xmm0, xmm9
	mulss	xmm7, xmm11
	call	sinf
	movaps	xmm6, xmm0
	movaps	xmm0, xmm12
	call	cosf
	mulss	xmm6, xmm0
	movaps	xmm0, xmm9
	subss	xmm7, xmm6
	mulss	xmm7, DWORD PTR tv918[rsp]
	addss	xmm8, xmm7

; 892  :                                 Y = NewY;

	movss	DWORD PTR [rbx], xmm8
	call	sinf
	movss	xmm8, DWORD PTR tv923[rsp]
	movaps	xmm7, xmm0
	movaps	xmm0, xmm8
	call	cosf
	mulss	xmm7, xmm0
	movaps	xmm0, xmm8
	mulss	xmm7, xmm15
	call	sinf
	mulss	xmm0, xmm13
	subss	xmm14, xmm0
	movaps	xmm0, xmm9
	addss	xmm7, xmm14
	call	cosf
	movaps	xmm6, xmm0
	movaps	xmm0, xmm8
	call	cosf

; 893  :                                 Z = NewZ;
; 894  : 
; 895  :                                 RootBone = Bones[ParentIndex];

	mov	rax, QWORD PTR [r15]

; 896  : 
; 897  :                                 return true;

	movaps	xmm15, XMMWORD PTR [rsp+64]
	movaps	xmm14, XMMWORD PTR [rsp+80]
	movaps	xmm13, XMMWORD PTR [rsp+96]
	movaps	xmm12, XMMWORD PTR [rsp+112]
	movaps	xmm11, XMMWORD PTR [rsp+128]
	movaps	xmm10, XMMWORD PTR [rsp+144]
	mulss	xmm6, xmm0
	mulss	xmm6, DWORD PTR tv918[rsp]
	addss	xmm7, xmm6
	movss	DWORD PTR [rdi], xmm7
	movups	xmm0, XMMWORD PTR [rsi+rbp]
	movups	xmm1, XMMWORD PTR [rsi+rbp+16]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm0, XMMWORD PTR [rsi+rbp+32]
	movups	XMMWORD PTR [rax+16], xmm1
	movsd	xmm1, QWORD PTR [rsi+rbp+48]
	movups	XMMWORD PTR [rax+32], xmm0
	movsd	QWORD PTR [rax+48], xmm1
	mov	al, 1
	movaps	xmm9, XMMWORD PTR [rsp+160]
	movaps	xmm8, XMMWORD PTR [rsp+176]
	movaps	xmm7, XMMWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [rsp+208]
	mov	rdi, QWORD PTR [rsp+224]
	mov	rsi, QWORD PTR [rsp+280]
	mov	rbp, QWORD PTR [rsp+272]
	mov	rbx, QWORD PTR [rsp+256]

; 898  :                             };

	add	rsp, 232				; 000000e8H
	pop	r15
	pop	r14
	ret	0
??R<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEBA@HAEAV?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@3@AEAM33@Z ENDP ; `BfresFile::BfresFile'::`116'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ??0<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEAA@AEAUSkeletonBone@1@@Z
_TEXT	SEGMENT
this$ = 8
__RootBone$ = 16
??0<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEAA@AEAUSkeletonBone@1@@Z PROC ; `BfresFile::BfresFile'::`116'::<lambda_1>::<lambda_1>, COMDAT

; 898  :                             };

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0<lambda_1>@?HE@???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@3@@Z@QEAA@AEAUSkeletonBone@1@@Z ENDP ; `BfresFile::BfresFile'::`116'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??1?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ PROC ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
	add	rcx, 8

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??1?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ENDP ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 104
this$GSCopy$ = 112
$T7 = 128
Path$GSCopy$ = 160
File$ = 176
Bytes$8 = 448
$T9 = 472
FileSize$10 = 472
__$ArrayPad$ = 504
this$ = 576
Path$ = 584
??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; BfresFile::BfresFile, COMDAT

; 938  : {

$LN273:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-256]
	sub	rsp, 512				; 00000200H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rsi, rdx
	mov	r15, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	mov	QWORD PTR Path$GSCopy$[rbp-256], rdx
	xor	r12d, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], r12
	mov	QWORD PTR [rcx+8], r12
	mov	QWORD PTR [rcx+16], r12
	mov	QWORD PTR [rcx+24], r12
	mov	QWORD PTR [rcx+32], r12
	mov	QWORD PTR [rcx+40], r12
	mov	QWORD PTR [rcx+48], r12
	mov	QWORD PTR [rcx+56], r12
	mov	QWORD PTR [rcx+64], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.h

; 128  : 	bool m_DefaultModel = false;

	mov	BYTE PTR [rcx+72], r12b

; 129  : 	std::string m_Path = "";

	add	rcx, 80					; 00000050H
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r12

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xor	edx, edx
	mov	r8d, 272				; 00000110H
	lea	rcx, QWORD PTR File$[rbp-256]
	call	memset

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN264@BfresFile

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rsi]
$LN264@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 43   :         : basic_ifstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

	mov	r8d, 32					; 00000020H
	lea	rcx, QWORD PTR File$[rbp-256]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	r13, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR File$[rbp+rcx-256], r13
	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR File$[rbp+rcx-260], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 941  :     if (!File.eof() && !File.fail())

	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR File$[rbp-256]
	add	rcx, rax
	call	QWORD PTR __imp_?eof@ios_base@std@@QEBA_NXZ
	test	al, al
	jne	$LN2@BfresFile
	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR File$[rbp-256]
	add	rcx, rax
	call	QWORD PTR __imp_?fail@ios_base@std@@QEBA_NXZ
	test	al, al
	jne	$LN2@BfresFile

; 942  :     {
; 943  :         File.seekg(0, std::ios_base::end);

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+2]
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z

; 944  :         std::streampos FileSize = File.tellg();

	lea	rdx, QWORD PTR FileSize$10[rbp-256]
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@XZ
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd

; 68   :         return _Myoff + _Fpos;

	mov	rdi, QWORD PTR FileSize$10[rbp-248]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Bytes$8[rbp-256], xmm0
	mov	QWORD PTR Bytes$8[rbp-240], r12

; 2065 :         if (_Count != 0) {

	mov	r14, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd

; 68   :         return _Myoff + _Fpos;

	add	rdi, QWORD PTR FileSize$10[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2065 :         if (_Count != 0) {

	je	SHORT $LN160@BfresFile

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdi, r14
	ja	$LN267@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN116@BfresFile

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN268@BfresFile

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN248@BfresFile

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN114@BfresFile
$LN116@BfresFile:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
$LN114@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR Bytes$8[rbp-256], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rax+rdi]
	mov	QWORD PTR Bytes$8[rbp-240], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR Bytes$8[rbp-248], rbx
$LN160@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 948  :         File.seekg(0, std::ios_base::beg);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd

; 68   :         return _Myoff + _Fpos;

	mov	r8, QWORD PTR FileSize$10[rbp-248]
	add	r8, QWORD PTR FileSize$10[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 949  :         File.read(reinterpret_cast<char*>(Bytes.data()), FileSize);

	mov	rdx, QWORD PTR Bytes$8[rbp-256]
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 193  :         if (!_Filebuffer.close()) {

	lea	rcx, QWORD PTR File$[rbp-240]
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
	test	rax, rax
	jne	SHORT $LN166@BfresFile

; 194  :             _Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR File$[rbp-256]
	add	rcx, rax
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+2]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN166@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 953  :         this->BfresFile::BfresFile(Path, Bytes);

	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T3[rsp], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T5[rsp], xmm0
	mov	QWORD PTR $T5[rsp+16], r12

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR Bytes$8[rbp-248]
	sub	rbx, QWORD PTR Bytes$8[rbp-256]

; 2065 :         if (_Count != 0) {

	je	$LN227@BfresFile

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rbx, r14
	ja	$LN269@BfresFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN187@BfresFile

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN270@BfresFile

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN196@BfresFile

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN185@BfresFile
$LN196@BfresFile:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN187@BfresFile:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN185@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR $T5[rsp], rdi

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR $T5[rsp+8], rdi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rdi+rbx]
	mov	QWORD PTR $T5[rsp+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rbx, QWORD PTR Bytes$8[rbp-248]
	mov	rdx, QWORD PTR Bytes$8[rbp-256]
	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR $T5[rsp+8], rax
$LN227@BfresFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 953  :         this->BfresFile::BfresFile(Path, Bytes);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T7[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, QWORD PTR $T5[rsp]
	mov	rdx, rax
	mov	rcx, r15
	call	??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z ; BfresFile::BfresFile
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Bytes$8[rbp-256]
	test	rcx, rcx
	je	$LN3@BfresFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Bytes$8[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN251@BfresFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN251@BfresFile
$LN248@BfresFile:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN251@BfresFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 954  :     }

	jmp	$LN3@BfresFile
$LN2@BfresFile:

; 957  :         Logger::Error("Bfres", "Could not open file " + Path);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T6[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rcx, QWORD PTR [rsi+16]

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	r14, 9223372036854775807		; 7fffffffffffffffH
	sub	r14, rcx
	cmp	r14, 20
	jb	$LN271@BfresFile

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN76@BfresFile

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rsi]
$LN76@BfresFile:

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 20
	lea	r9, OFFSET FLAT:??_C@_0BF@BGOJHMKC@Could?5not?5open?5file?5@
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T9[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T9[rbp-240], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T9[rbp-232], r12

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05JBOHDMDP@Bfres@
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 957  :         Logger::Error("Bfres", "Could not open file " + Path);

	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
$LN3@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 161  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rdx, DWORD PTR [rax+4]
	mov	QWORD PTR File$[rbp+rdx-256], r13
	mov	rdx, QWORD PTR File$[rbp-256]
	movsxd	r8, DWORD PTR [rdx+4]
	lea	r9d, DWORD PTR [r8-176]
	mov	DWORD PTR File$[rbp+r8-260], r9d
	lea	rcx, QWORD PTR File$[rbp-240]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	rcx, QWORD PTR File$[rbp-232]
	call	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	lea	rcx, QWORD PTR File$[rbp-80]
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 959  : }

	mov	rax, r15
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+592]
	add	rsp, 512				; 00000200H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN271@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4917 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN267@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN268@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN269@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN270@BfresFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN265@BfresFile:
??0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; BfresFile::BfresFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 104
this$GSCopy$ = 112
$T7 = 128
Path$GSCopy$ = 160
File$ = 176
Bytes$8 = 448
$T9 = 472
FileSize$10 = 472
__$ArrayPad$ = 504
this$ = 576
Path$ = 584
?dtor$0@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$0
	mov	rcx, QWORD PTR Path$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 104
this$GSCopy$ = 112
$T7 = 128
Path$GSCopy$ = 160
File$ = 176
Bytes$8 = 448
$T9 = 472
FileSize$10 = 472
__$ArrayPad$ = 504
this$ = 576
Path$ = 584
?dtor$1@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::~vector<BfresFile::Model,std::allocator<BfresFile::Model> >
?dtor$1@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 104
this$GSCopy$ = 112
$T7 = 128
Path$GSCopy$ = 160
File$ = 176
Bytes$8 = 448
$T9 = 472
FileSize$10 = 472
__$ArrayPad$ = 504
this$ = 576
Path$ = 584
?dtor$2@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 24
	jmp	??1?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAA@XZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::~vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >
?dtor$2@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 104
this$GSCopy$ = 112
$T7 = 128
Path$GSCopy$ = 160
File$ = 176
Bytes$8 = 448
$T9 = 472
FileSize$10 = 472
__$ArrayPad$ = 504
this$ = 576
Path$ = 584
?dtor$3@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$3
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1?$vector@GV?$allocator@G@std@@@std@@QEAA@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
?dtor$3@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 104
this$GSCopy$ = 112
$T7 = 128
Path$GSCopy$ = 160
File$ = 176
Bytes$8 = 448
$T9 = 472
FileSize$10 = 472
__$ArrayPad$ = 504
this$ = 576
Path$ = 584
?dtor$4@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$4
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 80					; 00000050H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 104
this$GSCopy$ = 112
$T7 = 128
Path$GSCopy$ = 160
File$ = 176
Bytes$8 = 448
$T9 = 472
FileSize$10 = 472
__$ArrayPad$ = 504
this$ = 576
Path$ = 584
?dtor$5@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$5
	lea	rcx, QWORD PTR File$[rdx]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$5@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 104
this$GSCopy$ = 112
$T7 = 128
Path$GSCopy$ = 160
File$ = 176
Bytes$8 = 448
$T9 = 472
FileSize$10 = 472
__$ArrayPad$ = 504
this$ = 576
Path$ = 584
?dtor$6@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$6
	lea	rcx, QWORD PTR Bytes$8[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$6@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 104
this$GSCopy$ = 112
$T7 = 128
Path$GSCopy$ = 160
File$ = 176
Bytes$8 = 448
$T9 = 472
FileSize$10 = 472
__$ArrayPad$ = 504
this$ = 576
Path$ = 584
?dtor$7@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$7
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$7@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 72
$T5 = 72
$T6 = 104
this$GSCopy$ = 112
$T7 = 128
Path$GSCopy$ = 160
File$ = 176
Bytes$8 = 448
$T9 = 472
FileSize$10 = 472
__$ArrayPad$ = 504
this$ = 576
Path$ = 584
?dtor$9@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `BfresFile::BfresFile'::`1'::dtor$9
	mov	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0???0BfresFile@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `BfresFile::BfresFile'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp
;	COMDAT ?Delete@BfresFile@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Delete@BfresFile@@QEAAXXZ PROC				; BfresFile::Delete, COMDAT

; 962  : {

$LN42:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	cmp	QWORD PTR [rcx+8], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 963  :     if (this->m_Models.size() == 0) return;

	je	$LN3@Delete
	mov	QWORD PTR [rsp+48], rbp

; 965  :     for (BfresFile::LOD& LODModel : this->m_Models[0].LODs)

	mov	rbp, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rbx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 965  :     for (BfresFile::LOD& LODModel : this->m_Models[0].LODs)

	cmp	rbx, rbp
	je	$LN39@Delete
	mov	QWORD PTR [rsp+56], rsi
	mov	QWORD PTR [rsp+64], rdi
	mov	QWORD PTR [rsp+72], r14
	mov	r14, -6148914691236517205		; aaaaaaaaaaaaaaabH
$LL4@Delete:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 967  :         for (int SubModelIndex = 0; SubModelIndex < LODModel.Faces.size(); SubModelIndex++)

	xor	esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	imul	rax, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 967  :         for (int SubModelIndex = 0; SubModelIndex < LODModel.Faces.size(); SubModelIndex++)

	test	rax, rax
	je	SHORT $LN2@Delete
	xor	ecx, ecx
	npad	7
$LL7@Delete:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdi, QWORD PTR [rcx+rcx*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 33   : 	glDeleteVertexArrays(1, &ID);

	mov	ecx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdi, 5
	add	rdi, QWORD PTR [rbx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 33   : 	glDeleteVertexArrays(1, &ID);

	lea	rdx, QWORD PTR [rdi+72]
	call	QWORD PTR glad_glDeleteVertexArrays
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 33   : 	glDeleteBuffers(1, &ID);

	lea	rdx, QWORD PTR [rdi+76]
	mov	ecx, 1
	call	QWORD PTR glad_glDeleteBuffers
	lea	rdx, QWORD PTR [rdi+80]
	mov	ecx, 1
	call	QWORD PTR glad_glDeleteBuffers
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EBO.cpp

; 26   : 	glDeleteBuffers(1, &ID);

	lea	rdx, QWORD PTR [rdi+84]
	mov	ecx, 1
	call	QWORD PTR glad_glDeleteBuffers
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 967  :         for (int SubModelIndex = 0; SubModelIndex < LODModel.Faces.size(); SubModelIndex++)

	inc	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, QWORD PTR [rbx]
	sar	rax, 3
	imul	rax, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Bfres.cpp

; 967  :         for (int SubModelIndex = 0; SubModelIndex < LODModel.Faces.size(); SubModelIndex++)

	movsxd	rcx, esi
	cmp	rcx, rax
	jb	SHORT $LL7@Delete
$LN2@Delete:

; 965  :     for (BfresFile::LOD& LODModel : this->m_Models[0].LODs)

	add	rbx, 96					; 00000060H
	cmp	rbx, rbp
	jne	$LL4@Delete
	mov	r14, QWORD PTR [rsp+72]
	mov	rdi, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+56]
$LN39@Delete:
	mov	rbp, QWORD PTR [rsp+48]
$LN3@Delete:

; 968  :         {
; 969  :             LODModel.GL_Meshes[SubModelIndex].Delete();
; 970  :         }
; 971  :     }
; 972  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?Delete@BfresFile@@QEAAXXZ ENDP				; BfresFile::Delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAAEAUVertexBuffer@BfresFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAAEAUVertexBuffer@BfresFile@@_K@Z PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*4]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAAEAUVertexBuffer@BfresFile@@_K@Z ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::~vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >, COMDAT

; 767  :         _Tidy();

	jmp	?_Tidy@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Tidy
??1?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::~vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBuffer@BfresFile@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
_Al$dead$ = 64
??0?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBuffer@BfresFile@@@1@@Z PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >, COMDAT

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 620  :         _Construct_n(_Count);

	call	??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Construct_n<>

; 621  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBuffer@BfresFile@@@1@@Z ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UVertexBuffer@BfresFile@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UVertexBuffer@BfresFile@@@std@@QEAA@XZ PROC ; std::allocator<BfresFile::VertexBuffer>::allocator<BfresFile::VertexBuffer>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UVertexBuffer@BfresFile@@@std@@QEAA@XZ ENDP ; std::allocator<BfresFile::VertexBuffer>::allocator<BfresFile::VertexBuffer>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAAEAUVertexBufferAttribute@BfresFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAAEAUVertexBufferAttribute@BfresFile@@_K@Z PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*4]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAAEAUVertexBufferAttribute@BfresFile@@_K@Z ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::~vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >, COMDAT

; 767  :         _Tidy();

	jmp	?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Tidy
??1?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::~vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Al$dead$ = 80
??0?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >, COMDAT

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN125:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebp, ebp

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rbp

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rdi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rbp
	mov	QWORD PTR [rcx+16], rbp

; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN100@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 461168601842738790			; 0666666666666666H
	cmp	rdx, rax
	ja	$LN122@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	lea	rsi, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN24@vector

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN123@vector

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN33@vector

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rdx, rax

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	lea	rcx, QWORD PTR [rax+rsi]
	jmp	SHORT $LN120@vector
$LN33@vector:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN24@vector:

; 244  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN25@vector

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	mov	rdx, rax
	lea	rcx, QWORD PTR [rax+rsi]
	jmp	SHORT $LN120@vector
$LN25@vector:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	mov	rax, rbp
	lea	rcx, QWORD PTR [rsi+rbp]
	mov	rdx, rbp
$LN120@vector:
	mov	QWORD PTR [rdi], rdx
	mov	r8, rdi
	mov	QWORD PTR [rdi+16], rcx
	npad	10
$LL49@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rax+32], rbp
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rbp

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], bpl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 40					; 00000028H

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rbx, 1
	jne	SHORT $LL49@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [rdi+8], rax
$LN100@vector:

; 620  :         _Construct_n(_Count);
; 621  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN123@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN122@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Xlength
	int	3
$LN119@vector:
??0?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAA@XZ PROC ; std::allocator<BfresFile::VertexBufferAttribute>::allocator<BfresFile::VertexBufferAttribute>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAA@XZ ENDP ; std::allocator<BfresFile::VertexBufferAttribute>::allocator<BfresFile::VertexBufferAttribute>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAAEAUVertexBufferSize@BfresFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAAEAUVertexBufferSize@BfresFile@@_K@Z PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAAEAUVertexBufferSize@BfresFile@@_K@Z ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::~vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 772  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@vector:
??1?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::~vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Al$dead$ = 80
??0?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >, COMDAT

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN84:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebx, ebx

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbp, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rbx

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rbx
	mov	QWORD PTR [rcx+16], rbx

; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN64@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	$LN81@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rdi, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN24@vector

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	SHORT $LN82@vector

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN33@vector

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax
$LN25@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	lea	rax, QWORD PTR [rbx+rdi]
$LN79@vector:
	mov	rdx, rsi
	lea	r8, QWORD PTR [rbp*8]
	mov	rcx, rbx
	mov	QWORD PTR [rdx], rbx
	xor	edx, edx
	mov	QWORD PTR [rsi+16], rax
	call	memset
	add	rbx, rdi

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN64@vector:

; 620  :         _Construct_n(_Count);
; 621  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rsi
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN33@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN24@vector:

; 244  :     if (_Bytes != 0) {

	test	rdi, rdi
	je	SHORT $LN25@vector

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	add	rax, rdi
	jmp	SHORT $LN79@vector
$LN82@vector:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN81@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Xlength
	int	3
$LN78@vector:
??0?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAA@XZ PROC ; std::allocator<BfresFile::VertexBufferSize>::allocator<BfresFile::VertexBufferSize>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAA@XZ ENDP ; std::allocator<BfresFile::VertexBufferSize>::allocator<BfresFile::VertexBufferSize>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@_K@Z PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*4]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@_K@Z ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -3689348814741910323		; cccccccccccccccdH
	sar	rax, 3
	imul	rax, rcx

; 1870 :     }

	ret	0
?size@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::push_back, COMDAT

; 876  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

	mov	r8, rdx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [r8]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+24], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+32], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8+8]
	movups	XMMWORD PTR [rdx+8], xmm0
	movups	xmm1, XMMWORD PTR [r8+24]
	movups	XMMWORD PTR [rdx+24], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r8+24], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r8+32], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r8+8], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 40			; 00000028H

; 877  :         // insert by moving into element at end, provide strong guarantee
; 878  :         _Emplace_one_at_back(_STD move(_Val));
; 879  :     }

	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_reallocate<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?push_back@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN56:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]

; 766  :     _CONSTEXPR20 ~vector() noexcept {

	mov	rsi, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN4@vector
	mov	QWORD PTR [rsp+56], rdi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN8@vector
$LL9@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL9@vector
$LN8@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN40@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN37@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN40@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN4@vector:

; 772  :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN37@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN53@vector:
??1?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ??0?$initializer_list@PEAVTexture@@@std@@QEAA@PEBQEAVTexture@@0@Z
_TEXT	SEGMENT
this$ = 8
_First_arg$ = 16
_Last_arg$ = 24
??0?$initializer_list@PEAVTexture@@@std@@QEAA@PEBQEAVTexture@@0@Z PROC ; std::initializer_list<Texture *>::initializer_list<Texture *>, COMDAT

; 35   :         : _First(_First_arg), _Last(_Last_arg) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0?$initializer_list@PEAVTexture@@@std@@QEAA@PEBQEAVTexture@@0@Z ENDP ; std::initializer_list<Texture *>::initializer_list<Texture *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::operator++, COMDAT

; 51   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 108  :         _Mybase::operator++();
; 109  :         return *this;

	mov	rax, rcx

; 51   :         _Ptr = _Ptr->_Next;

	mov	QWORD PTR [rcx], rdx

; 110  :     }

	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@QEAVTextureToGo@@VTexture@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@QEAVTextureToGo@@VTexture@@@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::operator*, COMDAT

; 43   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 100  :         return const_cast<reference>(_Mybase::operator*());
; 101  :     }

	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@QEAVTextureToGo@@VTexture@@@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator==, COMDAT

; 73   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 74   :     }

	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??A?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAAAEAVTexture@@AEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
$T1 = 32
this$dead$ = 64
_Keyval$ = 72
??A?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAAAEAVTexture@@AEBQEAVTextureToGo@@@Z PROC ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::operator[], COMDAT

; 437  :     mapped_type& operator[](const key_type& _Keyval) {

$LN4:
	sub	rsp, 56					; 00000038H

; 438  :         return this->_Try_emplace(_Keyval).first->_Myval.second;

	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Try_emplace<TextureToGo * const &>
	mov	rax, QWORD PTR [rax]
	add	rax, 24

; 439  :     }

	add	rsp, 56					; 00000038H
	ret	0
??A?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAAAEAVTexture@@AEBQEAVTextureToGo@@@Z ENDP ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 48
this$ = 48
??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ PROC ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >, COMDAT

; 107  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN70:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rdi, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures
	mov	QWORD PTR this$[rsp], rdi

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8, 0
	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 72					; 00000048H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24, 0
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+32, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48, 7
	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+56, 8

; 377  :         // construct empty hash table
; 378  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A, 1065353216 ; 3f800000H

; 379  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, rax
	mov	edx, 16
	lea	rcx, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Assign_grow
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 107  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ ENDP ; std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
this$ = 48
?dtor$1@?0???0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::~list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >
?dtor$1@?0???0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
this$ = 48
?dtor$2@?0???0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >
?dtor$2@?0???0?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >::unordered_map<TextureToGo *,Texture,std::hash<TextureToGo *>,std::equal_to<TextureToGo *>,std::allocator<std::pair<TextureToGo * const,Texture> > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >, COMDAT

; 321  :     ~_Hash_vec() {

$LN35:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 312  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@Hash_vec

; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@Hash_vec

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@Hash_vec

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@Hash_vec:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 315  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 316  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 317  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@Hash_vec:

; 327  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@Hash_vec:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN32@Hash_vec:
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?insert@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 48
__$ReturnUdt$ = 56
_Val$ = 64
?insert@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@2@@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::insert, COMDAT

; 937  :     conditional_t<_Multi, iterator, pair<iterator, bool>> insert(value_type&& _Val) {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::emplace<std::pair<TextureToGo * const,Texture> >
	mov	rax, rbx

; 939  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?insert@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Unchecked_end, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 811  :         return _List._Unchecked_end();

	mov	rax, rdx

; 812  :     }

	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Unchecked_begin, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
	mov	rcx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 803  :         return _List._Unchecked_begin();

	mov	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 804  :     }

	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::~list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >, COMDAT

; 1045 :     ~list() noexcept {

$LN125:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1501 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]

; 1045 :     ~list() noexcept {

	mov	rsi, rcx

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rdi, QWORD PTR [rdx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rdi, rdi
	je	SHORT $LN7@list
	mov	QWORD PTR [rsp+56], rbx
	npad	8
$LL8@list:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rdi]

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rdi, rbx
	test	rbx, rbx
	jne	SHORT $LL8@list
	mov	rbx, QWORD PTR [rsp+56]
$LN7@list:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rsi]
	mov	edx, 72					; 00000048H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1051 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::~list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
;	COMDAT ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T3 = 32
$T4 = 32
_Loc$1 = 48
$T5 = 72
this$dead$ = 112
_Keyval$ = 120
??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::operator[], COMDAT

; 346  :     mapped_type& operator[](const key_type& _Keyval) {

$LN161:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rbp, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [rbp+8]
	mov	QWORD PTR _Loc$1[rsp], rbx
	xor	r15d, r15d
	mov	DWORD PTR _Loc$1[rsp+8], r15d
	mov	rdi, rbp

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r15b
	jne	SHORT $LN9@operator
	npad	4
$LL8@operator:

; 1616 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR _Loc$1[rsp], rbx

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	test	al, al
	jns	SHORT $LN10@operator

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR _Loc$1[rsp+8], r15d

; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]

; 1620 :             } else {

	jmp	SHORT $LN11@operator
$LN10@operator:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR _Loc$1[rsp+8], 1

; 1622 :                 _Result._Bound           = _Trynode;

	mov	rdi, rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rbx, QWORD PTR [rbx]
$LN11@operator:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r15b
	je	SHORT $LL8@operator
$LN9@operator:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdi+25], r15b
	jne	SHORT $LN4@operator
	lea	rdx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	test	al, al
	jns	$LN3@operator
$LN4@operator:

; 1631 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 104811045873349725			; 01745d1745d1745dH
	cmp	QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A+8, rax
	je	$LN159@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	r14, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	mov	QWORD PTR $T4[rsp], r14

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T4[rsp+8], r15

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR $T4[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 806  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

	lea	rbx, QWORD PTR [rax+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T5[rsp], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, rsi
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	call	??0BfresFile@@QEAA@XZ			; BfresFile::BfresFile
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rdi], rbp

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rdi+8], rbp

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rdi+16], rbp

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rdi+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 212  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	movups	xmm0, XMMWORD PTR _Loc$1[rsp]
	movaps	XMMWORD PTR $T3[rsp], xmm0
	mov	r8, rdi
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, r14
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Insert_node
	mov	rdi, rax
$LN3@operator:

; 347  :         return _Try_emplace(_Keyval).first->_Myval.second;

	lea	rax, QWORD PTR [rdi+64]

; 348  :     }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN159@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1632 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN157@operator:
??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
_Loc$1 = 48
$T5 = 72
this$dead$ = 112
_Keyval$ = 120
?dtor$2@?0???A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::operator[]'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
?dtor$2@?0???A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::operator[]'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
_Loc$1 = 48
$T5 = 72
this$dead$ = 112
_Keyval$ = 120
?dtor$1@?0???A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::operator[]'::`1'::dtor$1
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0???A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::operator[]'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
_Loc$1 = 48
$T5 = 72
this$dead$ = 112
_Keyval$ = 120
?dtor$4@?0???A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::operator[]'::`1'::dtor$4
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAAAEAVBfresFile@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::operator[]'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
;	COMDAT ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 48
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >, COMDAT

; 107  :     map() : _Mybase(key_compare()) {}

$LN46:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 107  :     map() : _Mybase(key_compare()) {}

	lea	rbx, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A, rax
	mov	QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A+8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 107  :     map() : _Mybase(key_compare()) {}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@QEAA@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Keyval$ = 56
?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::count, COMDAT

; 1406 :     _NODISCARD size_type count(const key_type& _Keyval) const {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rdi, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A

; 1406 :     _NODISCARD size_type count(const key_type& _Keyval) const {

	mov	rsi, rdx

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rbx, QWORD PTR [rdi+8]

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN5@count
$LL4@count:

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	jns	SHORT $LN6@count

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;
; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]

; 1620 :             } else {

	jmp	SHORT $LN7@count
$LN6@count:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;
; 1622 :                 _Result._Bound           = _Trynode;

	mov	rdi, rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rbx, QWORD PTR [rbx]
$LN7@count:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL4@count
$LN5@count:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdi+25], 0
	jne	SHORT $LN15@count
	lea	rdx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	js	SHORT $LN15@count

; 1407 :         if constexpr (_Multi) {
; 1408 :             const auto _Ans = _Eqrange(_Keyval);
; 1409 :             return static_cast<size_type>(_STD distance(
; 1410 :                 _Unchecked_const_iterator(_Ans.first, nullptr), _Unchecked_const_iterator(_Ans.second, nullptr)));
; 1411 :         } else {
; 1412 :             return _Lower_bound_duplicate(_Find_lower_bound(_Keyval)._Bound, _Keyval);

	mov	eax, 1

; 1413 :         }
; 1414 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@count:
	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >, COMDAT

; 1080 :     ~_Tree() noexcept {

$LN52:
	push	rbx
	sub	rsp, 32					; 00000020H

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	r8, QWORD PTR [rcx]
	mov	rdx, rcx

; 1080 :     ~_Tree() noexcept {

	mov	rbx, rcx

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	r8, QWORD PTR [r8+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rbx]
	mov	edx, 176				; 000000b0H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1087 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ??0?$initializer_list@E@std@@QEAA@PEBE0@Z
_TEXT	SEGMENT
this$ = 8
_First_arg$ = 16
_Last_arg$ = 24
??0?$initializer_list@E@std@@QEAA@PEBE0@Z PROC		; std::initializer_list<unsigned char>::initializer_list<unsigned char>, COMDAT

; 35   :         : _First(_First_arg), _Last(_Last_arg) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0?$initializer_list@E@std@@QEAA@PEBE0@Z ENDP		; std::initializer_list<unsigned char>::initializer_list<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?data@?$vector@GV?$allocator@G@std@@@std@@QEAAPEAGXZ
_TEXT	SEGMENT
this$ = 8
?data@?$vector@GV?$allocator@G@std@@@std@@QEAAPEAGXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::data, COMDAT

; 1787 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx]

; 1788 :     }

	ret	0
?data@?$vector@GV?$allocator@G@std@@@std@@QEAAPEAGXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN38:
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rdi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, r8
	sar	rcx, 1

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r8+rdx*2]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	QWORD PTR [rdi+8], rax
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, r8
	sar	rax, 1

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rdi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	QWORD PTR [rsp+64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	rcx, rsi

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rdx+rdx]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8, rbx
	call	memset

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rbx, QWORD PTR [rsp+64]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	QWORD PTR [rdi+8], rax
$LN5@resize:
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$vector@GV?$allocator@G@std@@@std@@QEAAX_K@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAAEAUSkeletonBone@BfresFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAAEAUSkeletonBone@BfresFile@@_K@Z PROC ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rax, rdx, 56				; 00000038H
	add	rax, QWORD PTR [rcx]

; 1890 :     }

	ret	0
??A?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAAEAUSkeletonBone@BfresFile@@_K@Z ENDP ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN10:
	sub	rsp, 40					; 00000028H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r10, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r8, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR [rcx]
	mov	r11, 7905747460161236407		; 6db6db6db6db6db7H
	mov	rcx, r10
	sub	rcx, r9
	sar	rcx, 3
	imul	rcx, r11

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rax, rdx, 56				; 00000038H
	add	rax, r9

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	QWORD PTR [r8+8], rax
	add	rsp, 40					; 00000028H
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r8+16]
	sub	rax, r9
	sar	rax, 3
	imul	rax, r11

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r8

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 40					; 00000028H

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, r10
	call	??$_Uninitialized_value_construct_n@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@PEAU12@_KAEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::SkeletonBone> >

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	QWORD PTR [r8+8], rax
$LN5@resize:
	add	rsp, 40					; 00000028H
	ret	0
?resize@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, 5675921253449092805		; 4ec4ec4ec4ec4ec5H
	sar	rax, 3
	imul	rax, rcx

; 1870 :     }

	ret	0
?size@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAPEAUModel@BfresFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAPEAUModel@BfresFile@@XZ PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAPEAUModel@BfresFile@@XZ ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAPEAUModel@BfresFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAPEAUModel@BfresFile@@XZ PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAPEAUModel@BfresFile@@XZ ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN41:
	mov	QWORD PTR [rsp+24], rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rcx, QWORD PTR [rcx]
	mov	r8, rsi
	sub	r8, rcx
	mov	r9, 5675921253449092805			; 4ec4ec4ec4ec4ec5H
	sar	r8, 3
	imul	r8, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, r8
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+56], rdi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rdi, rdx, 104				; 00000068H
	add	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rsi
	je	SHORT $LN10@resize
	mov	QWORD PTR [rsp+48], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbx, QWORD PTR [rdi+48]
	npad	4
$LL11@resize:

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+24]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	mov	rcx, rbx
	call	?_Tidy@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Tidy
	lea	rcx, QWORD PTR [rbx-24]
	call	?_Tidy@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx-48]
	call	?_Tidy@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 104				; 00000068H
	lea	rax, QWORD PTR [rbx-48]
	cmp	rax, rsi
	jne	SHORT $LL11@resize
	mov	rbx, QWORD PTR [rsp+48]
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [r14+8], rdi
	mov	rdi, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, r8
	mov	rcx, rsi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@PEAU12@_KAEAV?$allocator@UModel@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Model> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAXAEBUModel@BfresFile@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAXAEBUModel@BfresFile@@@Z PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::push_back, COMDAT

; 872  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rcx+8]

; 872  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	rbx, rcx

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rax, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, rax
	call	??0Model@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rbx+8], 104			; 00000068H

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rax

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_reallocate<BfresFile::Model const &>
?push_back@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAXAEBUModel@BfresFile@@@Z ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::vector<BfresFile::Model,std::allocator<BfresFile::Model> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::vector<BfresFile::Model,std::allocator<BfresFile::Model> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAAEAUMaterial@BfresFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAAEAUMaterial@BfresFile@@_K@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdx, 6
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1890 :     }

	ret	0
??A?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAAEAUMaterial@BfresFile@@_K@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN38:
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx
	mov	rdi, rdx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, rdx
	sar	rcx, 6

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdi, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rdi, 6
	add	rdi, rdx
	mov	QWORD PTR [rsp+48], rbx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rsi
	je	SHORT $LN10@resize
$LL11@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+40]
	call	?_Tidy@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	cmp	rbx, rsi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rdi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rdx
	sar	rax, 6

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdi, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rdi
	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdi, rcx
	mov	rcx, rsi
	mov	rdx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@PEAU12@_KAEAV?$allocator@UMaterial@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Material> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAXAEBUMaterial@BfresFile@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAXAEBUMaterial@BfresFile@@@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::push_back, COMDAT

; 872  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rcx+8]

; 872  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	rbx, rcx

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rax, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, rax
	call	??0Material@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rbx+8], 64			; 00000040H

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rax

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_reallocate<BfresFile::Material const &>
?push_back@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAXAEBUMaterial@BfresFile@@@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UMaterial@BfresFile@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
_Al$dead$ = 64
??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UMaterial@BfresFile@@@1@@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::vector<BfresFile::Material,std::allocator<BfresFile::Material> >, COMDAT

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN97:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	esi, esi

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rsi

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rdi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rsi
	mov	QWORD PTR [rcx+16], rsi

; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN79@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN95@vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@UMaterial@BfresFile@@@std@@QEAAPEAUMaterial@BfresFile@@_K@Z ; std::allocator<BfresFile::Material>::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	rcx, rbx
	mov	QWORD PTR [rdi], rax
	shl	rcx, 6
	add	rcx, rax
	mov	QWORD PTR [rdi+16], rcx
	lea	rcx, QWORD PTR [rax+56]
$LL20@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rax+16], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rcx, QWORD PTR [rcx+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rax+24], rsi
	xorps	xmm0, xmm0
	mov	QWORD PTR [rax+32], rsi
	mov	QWORD PTR [rax+40], rsi
	mov	QWORD PTR [rax+48], rsi
	mov	QWORD PTR [rax+56], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx-104], rsi

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx-96], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], sil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 64					; 00000040H
	mov	BYTE PTR [rcx-88], sil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx-80], rsi
	mov	QWORD PTR [rcx-72], rsi
	mov	QWORD PTR [rcx-64], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rbx, 1
	jne	SHORT $LL20@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [rdi+8], rax
$LN79@vector:

; 620  :         _Construct_n(_Count);
; 621  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rdi
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN95@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Xlength
	int	3
$LN93@vector:
??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UMaterial@BfresFile@@@1@@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::vector<BfresFile::Material,std::allocator<BfresFile::Material> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::vector<BfresFile::Material,std::allocator<BfresFile::Material> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::vector<BfresFile::Material,std::allocator<BfresFile::Material> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UMaterial@BfresFile@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UMaterial@BfresFile@@@std@@QEAA@XZ PROC	; std::allocator<BfresFile::Material>::allocator<BfresFile::Material>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UMaterial@BfresFile@@@std@@QEAA@XZ ENDP	; std::allocator<BfresFile::Material>::allocator<BfresFile::Material>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAAEAV?$vector@MV?$allocator@M@std@@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAAEAV?$vector@MV?$allocator@M@std@@@1@_K@Z PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*2]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAAEAV?$vector@MV?$allocator@M@std@@@1@_K@Z ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sar	rax, 3
	imul	rax, rcx

; 1870 :     }

	ret	0
?size@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN43:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rsi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rbx
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*2]
	mov	QWORD PTR [rsp+64], rdi
	lea	rdi, QWORD PTR [r8+rax*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??$_Destroy_range@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAXPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<float,std::allocator<float> > > >

; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rsi+8], rdi
	mov	rdi, QWORD PTR [rsp+64]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN10@resize
	xor	eax, eax
	npad	4
$LL11@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL11@resize
$LN10@resize:

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rbx
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAXPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<float,std::allocator<float> > > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?resize@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@MV?$allocator@M@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@MV?$allocator@M@std@@@2@@Z PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::push_back, COMDAT

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	r10, QWORD PTR [rcx+8]

; 876  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

	mov	r8, rdx
	mov	r9, rcx

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	r10, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR [rdx]
	xor	r11d, r11d
	mov	rcx, QWORD PTR [r8+8]
	mov	rax, QWORD PTR [r8+16]
	mov	QWORD PTR [r8+16], r11
	mov	QWORD PTR [r8+8], r11
	mov	QWORD PTR [r8], r11
	mov	QWORD PTR [r10], rdx
	mov	QWORD PTR [r10+8], rcx
	mov	QWORD PTR [r10+16], rax
	add	QWORD PTR [r9+8], 24

; 877  :         // insert by moving into element at end, provide strong guarantee
; 878  :         _Emplace_one_at_back(_STD move(_Val));
; 879  :     }

	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rdx, r10
	jmp	??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_reallocate<std::vector<float,std::allocator<float> > >
?push_back@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@MV?$allocator@M@std@@@2@@Z ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAPEAULOD@BfresFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAPEAULOD@BfresFile@@XZ PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAPEAULOD@BfresFile@@XZ ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAPEAULOD@BfresFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAPEAULOD@BfresFile@@XZ PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAPEAULOD@BfresFile@@XZ ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN30:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 5
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rdx+rdx*2]
	shl	rsi, 5
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN10@resize
	npad	1
$LL11@resize:
	mov	rcx, rbx
	call	??1LOD@BfresFile@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 5
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@PEAU12@_KAEAV?$allocator@ULOD@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::LOD> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAXAEBULOD@BfresFile@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAXAEBULOD@BfresFile@@@Z PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::push_back, COMDAT

; 872  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rcx+8]

; 872  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	rbx, rcx

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rax, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, rax
	call	??0LOD@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rbx+8], 96			; 00000060H

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rax

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_reallocate<BfresFile::LOD const &>
?push_back@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAXAEBULOD@BfresFile@@@Z ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAAEAVMesh@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAAEAVMesh@@_K@Z PROC ; std::vector<Mesh,std::allocator<Mesh> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 5
	add	rax, QWORD PTR [rcx]

; 1890 :     }

	ret	0
??A?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAAEAVMesh@@_K@Z ENDP ; std::vector<Mesh,std::allocator<Mesh> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?clear@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAXXZ PROC ; std::vector<Mesh,std::allocator<Mesh> >::clear, COMDAT

; 1761 :     _CONSTEXPR20 void clear() noexcept { // erase all

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1762 :         auto& _My_data    = _Mypair._Myval2;
; 1763 :         pointer& _Myfirst = _My_data._Myfirst;
; 1764 :         pointer& _Mylast  = _My_data._Mylast;
; 1765 : 
; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	mov	rdi, QWORD PTR [rcx+8]
	cmp	rbx, rdi
	je	SHORT $LN1@clear
	npad	2
$LL7@clear:
	mov	rcx, rbx
	call	??1Mesh@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL7@clear
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1776 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rsi+8], rax
$LN1@clear:

; 1777 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?clear@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAXXZ ENDP ; std::vector<Mesh,std::allocator<Mesh> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<Mesh,std::allocator<Mesh> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN30:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 5
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rdx+rdx*2]
	shl	rsi, 5
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN10@resize
	npad	1
$LL11@resize:
	mov	rcx, rbx
	call	??1Mesh@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 5
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<Mesh,std::allocator<Mesh> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@PEAV1@_KAEAV?$allocator@VMesh@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<Mesh> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<Mesh,std::allocator<Mesh> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAA@XZ PROC ; std::vector<Mesh,std::allocator<Mesh> >::vector<Mesh,std::allocator<Mesh> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Mesh,std::allocator<Mesh> >::vector<Mesh,std::allocator<Mesh> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAAEAV?$vector@IV?$allocator@I@std@@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAAEAV?$vector@IV?$allocator@I@std@@@1@_K@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*2]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAAEAV?$vector@IV?$allocator@I@std@@@1@_K@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sar	rax, 3
	imul	rax, rcx

; 1870 :     }

	ret	0
?size@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN43:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rsi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rbx
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*2]
	mov	QWORD PTR [rsp+64], rdi
	lea	rdi, QWORD PTR [r8+rax*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??$_Destroy_range@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAXPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >

; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rsi+8], rdi
	mov	rdi, QWORD PTR [rsp+64]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN10@resize
	xor	eax, eax
	npad	4
$LL11@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL11@resize
$LN10@resize:

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rbx
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAXPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?resize@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@IV?$allocator@I@std@@@2@@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::push_back, COMDAT

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	r10, QWORD PTR [rcx+8]

; 876  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

	mov	r8, rdx
	mov	r9, rcx

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	r10, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR [rdx]
	xor	r11d, r11d
	mov	rcx, QWORD PTR [r8+8]
	mov	rax, QWORD PTR [r8+16]
	mov	QWORD PTR [r8+16], r11
	mov	QWORD PTR [r8+8], r11
	mov	QWORD PTR [r8], r11
	mov	QWORD PTR [r10], rdx
	mov	QWORD PTR [r10+8], rcx
	mov	QWORD PTR [r10+16], rax
	add	QWORD PTR [r9+8], 24

; 877  :         // insert by moving into element at end, provide strong guarantee
; 878  :         _Emplace_one_at_back(_STD move(_Val));
; 879  :     }

	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rdx, r10
	jmp	??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_reallocate<std::vector<unsigned int,std::allocator<unsigned int> > >
?push_back@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@IV?$allocator@I@std@@@2@@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAAEAUBfresTexture@BfresFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAAEAUBfresTexture@BfresFile@@_K@Z PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdx, 6
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1890 :     }

	ret	0
??A?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAAEAUBfresTexture@BfresFile@@_K@Z ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 6

; 1870 :     }

	ret	0
?size@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?empty@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEBA_NXZ PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::empty, COMDAT

; 1863 :         auto& _My_data = _Mypair._Myval2;
; 1864 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1865 :     }

	ret	0
?empty@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEBA_NXZ ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN30:
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx
	mov	rdi, rdx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, rdx
	sar	rcx, 6

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdi, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rdi, 6
	add	rdi, rdx
	mov	QWORD PTR [rsp+48], rbx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rsi
	je	SHORT $LN10@resize
$LL11@resize:
	mov	rcx, rbx
	call	??1BfresTexture@BfresFile@@QEAA@XZ
	add	rbx, 64					; 00000040H
	cmp	rbx, rsi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rdi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rdx
	sar	rax, 6

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdi, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rdi
	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdi, rcx
	mov	r8, r14
	mov	rdx, rdi
	mov	rcx, rsi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::BfresTexture> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
_Val$ = 56
?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::push_back, COMDAT

; 872  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN18:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rbx, rcx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdi, QWORD PTR [rcx+8]
	cmp	rdi, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdi
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdi], rax
	lea	rcx, QWORD PTR [rdi+8]
	add	rdx, 8
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rsi+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rbx+8], 64			; 00000040H

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rsi
	mov	rdx, rdi

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>
?push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
_Val$ = 56
?dtor$0@?0??push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z@4HA PROC ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::push_back'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??push_back@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXAEBUBfresTexture@BfresFile@@@Z@4HA ENDP ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::push_back'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::~vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 772  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@vector:
??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::~vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::vector<Texture *,std::allocator<Texture *> >::operator=, COMDAT

; 736  :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN39:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 737  :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN36@operator

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rsi
	xor	esi, esi
	test	rcx, rcx
	je	SHORT $LN5@operator

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN23@operator

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN20@operator

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN23@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx], rsi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rsi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rsi
$LN5@operator:

; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rbx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rbx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	mov	QWORD PTR [rdi], rsi

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rsi

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rsi
	mov	rsi, QWORD PTR [rsp+64]
$LN36@operator:

; 764  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN20@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN35@operator:
??4?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::vector<Texture *,std::allocator<Texture *> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z
_TEXT	SEGMENT
this$ = 64
_Ilist$ = 72
_Al$dead$ = 80
??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z PROC ; std::vector<Texture *,std::allocator<Texture *> >::vector<Texture *,std::allocator<Texture *> >, COMDAT

; 657  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN47:
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	r14, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rbp, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 657  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	sub	rbp, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rsi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	sar	rsi, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+16], rax

; 2065 :         if (_Count != 0) {

	test	rsi, rsi
	je	SHORT $LN34@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rsi, rax
	ja	SHORT $LN45@vector

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	mov	rdx, rsi
	mov	QWORD PTR [rsp+80], rbx
	call	?_Buy_raw@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K@Z ; std::vector<Texture *,std::allocator<Texture *> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbp
	mov	rcx, rbx
	mov	rdx, r14
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rcx, QWORD PTR [rbx+rsi*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [rsp+80]
	mov	QWORD PTR [rdi+8], rcx
$LN34@vector:

; 658  :         _Construct_n(_Convert_size<size_type>(_Ilist.size()), _Ilist.begin(), _Ilist.end());
; 659  :     }

	mov	rbp, QWORD PTR [rsp+88]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN45@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@CAXXZ ; std::vector<Texture *,std::allocator<Texture *> >::_Xlength
	int	3
$LN43@vector:
??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@V?$initializer_list@PEAVTexture@@@1@AEBV?$allocator@PEAVTexture@@@1@@Z ENDP ; std::vector<Texture *,std::allocator<Texture *> >::vector<Texture *,std::allocator<Texture *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@XZ PROC ; std::vector<Texture *,std::allocator<Texture *> >::vector<Texture *,std::allocator<Texture *> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Texture *,std::allocator<Texture *> >::vector<Texture *,std::allocator<Texture *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@PEAVTexture@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@PEAVTexture@@@std@@QEAA@XZ PROC		; std::allocator<Texture *>::allocator<Texture *>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@PEAVTexture@@@std@@QEAA@XZ ENDP		; std::allocator<Texture *>::allocator<Texture *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?clear@?$vector@IV?$allocator@I@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@IV?$allocator@I@std@@@std@@QEAAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::clear, COMDAT

; 1762 :         auto& _My_data    = _Mypair._Myval2;
; 1763 :         pointer& _Myfirst = _My_data._Myfirst;
; 1764 :         pointer& _Mylast  = _My_data._Mylast;
; 1765 : 
; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [rcx]
	cmp	rax, QWORD PTR [rcx+8]
	je	SHORT $LN1@clear

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN1@clear:

; 1777 :     }

	ret	0
?clear@?$vector@IV?$allocator@I@std@@@std@@QEAAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=, COMDAT

; 736  :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN39:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 737  :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN36@operator

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rsi
	xor	esi, esi
	test	rcx, rcx
	je	SHORT $LN5@operator

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN23@operator

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN20@operator

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN23@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx], rsi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rsi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rsi
$LN5@operator:

; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rbx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rbx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	mov	QWORD PTR [rdi], rsi

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rsi

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rsi
	mov	rsi, QWORD PTR [rsp+64]
$LN36@operator:

; 764  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN20@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN35@operator:
??4?$vector@IV?$allocator@I@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?at@?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z
_TEXT	SEGMENT
this$ = 48
_Pos$ = 56
?at@?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z PROC ; std::vector<float,std::allocator<float> >::at, COMDAT

; 1902 :     _NODISCARD _CONSTEXPR20 _Ty& at(const size_type _Pos) {

$LN7:
	sub	rsp, 40					; 00000028H

; 1903 :         auto& _My_data = _Mypair._Myval2;
; 1904 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	mov	r8, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rcx+8]
	sub	rax, r8
	sar	rax, 2
	cmp	rax, rdx
	jbe	SHORT $LN6@at

; 1906 :         }
; 1907 : 
; 1908 :         return _My_data._Myfirst[_Pos];

	lea	rax, QWORD PTR [r8+rdx*4]

; 1909 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@at:

; 1905 :             _Xrange();

	call	?_Xrange@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xrange
	int	3
$LN4@at:
?at@?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z ENDP ; std::vector<float,std::allocator<float> >::at
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z PROC ; std::vector<float,std::allocator<float> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*4]

; 1890 :     }

	ret	0
??A?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z ENDP ; std::vector<float,std::allocator<float> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ PROC	; std::vector<float,std::allocator<float> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1870 :     }

	ret	0
?size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ ENDP	; std::vector<float,std::allocator<float> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?empty@?$vector@MV?$allocator@M@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@MV?$allocator@M@std@@@std@@QEBA_NXZ PROC ; std::vector<float,std::allocator<float> >::empty, COMDAT

; 1863 :         auto& _My_data = _Mypair._Myval2;
; 1864 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 1865 :     }

	ret	0
?empty@?$vector@MV?$allocator@M@std@@@std@@QEBA_NXZ ENDP ; std::vector<float,std::allocator<float> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z PROC ; std::vector<float,std::allocator<float> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN38:
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rdi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, r8
	sar	rcx, 2

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r8+rdx*4]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	QWORD PTR [rdi+8], rax
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, r8
	sar	rax, 2

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rdi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<float,std::allocator<float> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	QWORD PTR [rsp+64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	rcx, rsi

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rdx*4]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8, rbx
	call	memset

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rbx, QWORD PTR [rsp+64]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	QWORD PTR [rdi+8], rax
$LN5@resize:
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$vector@MV?$allocator@M@std@@@std@@QEAAX_K@Z ENDP ; std::vector<float,std::allocator<float> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::vector<float,std::allocator<float> >::operator=, COMDAT

; 736  :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN39:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 737  :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN36@operator

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rsi
	xor	esi, esi
	test	rcx, rcx
	je	SHORT $LN5@operator

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN23@operator

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN20@operator

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN23@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx], rsi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rsi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rsi
$LN5@operator:

; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rbx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rbx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	mov	QWORD PTR [rdi], rsi

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rsi

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rsi
	mov	rsi, QWORD PTR [rsp+64]
$LN36@operator:

; 764  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN20@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN35@operator:
??4?$vector@MV?$allocator@M@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::vector<float,std::allocator<float> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
_Al$dead$ = 64
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z PROC ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN51:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN38@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN49@vector
	mov	QWORD PTR [rsp+64], rdi

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rbx*4]
	mov	QWORD PTR [rsi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rax]
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	rcx, rax
	call	memset

; 2036 :             return _First + _Count;

	lea	rcx, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi+8], rcx
$LN38@vector:

; 620  :         _Construct_n(_Count);
; 621  :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN49@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN47@vector:
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@_KAEBV?$allocator@M@1@@Z ENDP ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ PROC	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ENDP	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@M@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@M@std@@QEAA@XZ PROC			; std::allocator<float>::allocator<float>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@M@std@@QEAA@XZ ENDP			; std::allocator<float>::allocator<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@V?$initializer_list@E@1@@Z
_TEXT	SEGMENT
this$ = 64
_Ilist$ = 72
??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@V?$initializer_list@E@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=, COMDAT

; 1503 :     _CONSTEXPR20 vector& operator=(initializer_list<_Ty> _Ilist) {

$LN88:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]

; 1503 :     _CONSTEXPR20 vector& operator=(initializer_list<_Ty> _Ilist) {

	mov	rsi, rcx

; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	r14, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	sub	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rdi, QWORD PTR [rdx+8]
	sub	rdi, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	rdi, rcx
	jbe	SHORT $LN9@operator

; 1395 :             _Clear_and_reserve_geometric(_Newsize);

	mov	rdx, rdi
	mov	rcx, rsi
	call	?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Clear_and_reserve_geometric

; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rbx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdi
	mov	rcx, rbx
	mov	rdx, r14
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rcx, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1507 :     }

	mov	rax, rsi
	mov	QWORD PTR [rsi+8], rcx
	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN9@operator:
	mov	QWORD PTR [rsp+80], rbp

; 1407 :         if (_Newsize > _Oldsize) {

	mov	rdx, r14
	mov	rbp, QWORD PTR [rsi+8]
	mov	rcx, rbx
	sub	rbp, rbx
	cmp	rdi, rbp
	jbe	SHORT $LN10@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbp
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1416 :                     _Copied = true;

	mov	rbx, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR [r14+rbp]

; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {
; 1422 :                     *_Mid = *_First;
; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rbx
	mov	r8, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1434 :         } else {

	jmp	SHORT $LN84@operator
$LN10@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rbx+rdi]
$LN84@operator:

; 1504 :         const auto _Count = _Convert_size<size_type>(_Ilist.size());
; 1505 :         _Assign_counted_range(_Ilist.begin(), _Count);
; 1506 :         return *this;

	mov	QWORD PTR [rsi+8], rax

; 1507 :     }

	mov	rax, rsi
	mov	rbp, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
??4?$vector@EV?$allocator@E@std@@@std@@QEAAAEAV01@V?$initializer_list@E@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ?size@?$initializer_list@E@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$initializer_list@E@std@@QEBA_KXZ PROC		; std::initializer_list<unsigned char>::size, COMDAT

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]

; 47   :     }

	ret	0
?size@?$initializer_list@E@std@@QEBA_KXZ ENDP		; std::initializer_list<unsigned char>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::pop_back, COMDAT

; 4067 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 4068 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 4069 :         _STL_VERIFY(_Old_size != 0, "invalid to pop_back empty string");
; 4070 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 4071 :         _Eos(_Old_size - 1);

	mov	rdx, QWORD PTR [rcx+16]
	dec	rdx

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@pop_back

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [rcx+16], rdx
	mov	BYTE PTR [rax+rdx], 0

; 4072 :     }

	ret	0
$LN10@pop_back:

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR [rcx+16], rdx
	mov	BYTE PTR [rcx+rdx], 0

; 4072 :     }

	ret	0
?pop_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAXXZ PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, QWORD PTR [rbx+8]
	call	??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::VertexBuffer> >

; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rbx]
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	mov	rax, QWORD PTR [rbx+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Tidy:
?_Tidy@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAXXZ ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN53:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Tidy
	mov	QWORD PTR [rsp+56], rdi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Tidy
$LL7@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL7@Tidy
$LN6@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN38@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN35@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN38@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN2@Tidy:

; 2053 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN35@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN50@Tidy:
?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAXXZ PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Tidy:
?_Tidy@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAXXZ ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN53:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Tidy
	mov	QWORD PTR [rsp+56], rdi

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Tidy
$LL7@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL7@Tidy
$LN6@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN38@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN35@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN38@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN2@Tidy:

; 2053 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN35@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN50@Tidy:
?_Tidy@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ?size@?$initializer_list@PEAVTexture@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$initializer_list@PEAVTexture@@@std@@QEBA_KXZ PROC ; std::initializer_list<Texture *>::size, COMDAT

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 47   :     }

	ret	0
?size@?$initializer_list@PEAVTexture@@@std@@QEBA_KXZ ENDP ; std::initializer_list<Texture *>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ?end@?$initializer_list@PEAVTexture@@@std@@QEBAPEBQEAVTexture@@XZ
_TEXT	SEGMENT
this$ = 8
?end@?$initializer_list@PEAVTexture@@@std@@QEBAPEBQEAVTexture@@XZ PROC ; std::initializer_list<Texture *>::end, COMDAT

; 42   :         return _Last;

	mov	rax, QWORD PTR [rcx+8]

; 43   :     }

	ret	0
?end@?$initializer_list@PEAVTexture@@@std@@QEBAPEBQEAVTexture@@XZ ENDP ; std::initializer_list<Texture *>::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ?begin@?$initializer_list@PEAVTexture@@@std@@QEBAPEBQEAVTexture@@XZ
_TEXT	SEGMENT
this$ = 8
?begin@?$initializer_list@PEAVTexture@@@std@@QEBAPEBQEAVTexture@@XZ PROC ; std::initializer_list<Texture *>::begin, COMDAT

; 38   :         return _First;

	mov	rax, QWORD PTR [rcx]

; 39   :     }

	ret	0
?begin@?$initializer_list@PEAVTexture@@@std@@QEBAPEBQEAVTexture@@XZ ENDP ; std::initializer_list<Texture *>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator++, COMDAT

; 51   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 52   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 53   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@QEAVTextureToGo@@VTexture@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@QEAVTextureToGo@@VTexture@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator*, COMDAT

; 43   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 44   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@QEAVTextureToGo@@VTexture@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Tidy, COMDAT

; 311  :     void _Tidy() noexcept {

$LN32:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 312  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 315  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 316  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 317  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 319  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN29@Tidy:
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Parg$ = 56
_Al$dead$ = 64
this$ = 64
??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >, COMDAT

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN60:
	mov	QWORD PTR [rsp+24], r8
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rdi, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures
	mov	QWORD PTR this$[rsp], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8, 0
	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 72					; 00000048H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24, 0
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+32, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48, 7
	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+56, 8

; 377  :         // construct empty hash table
; 378  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A, 1065353216 ; 3f800000H

; 379  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, rax
	mov	edx, 16
	lea	rcx, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Assign_grow
	npad	1

; 380  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 381  :         _Stl_internal_check_container_invariants();
; 382  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 383  :     }

	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
_Parg$ = 56
_Al$dead$ = 64
this$ = 64
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::~list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$dead$ = 48
_Parg$ = 56
_Al$dead$ = 64
this$ = 64
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Tidy, COMDAT

; 1497 :     void _Tidy() noexcept {

$LN122:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1498 :         auto& _Al      = _Getal();
; 1499 :         auto& _My_data = _Mypair._Myval2;
; 1500 :         _My_data._Orphan_all();
; 1501 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]
	mov	rsi, rcx

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rdi, QWORD PTR [rdx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rdi, rdi
	je	SHORT $LN5@Tidy
	mov	QWORD PTR [rsp+56], rbx
	npad	8
$LL6@Tidy:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rdi]

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rdi, rbx
	test	rbx, rbx
	jne	SHORT $LL6@Tidy
	mov	rbx, QWORD PTR [rsp+56]
$LN5@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rsi]
	mov	edx, 72					; 00000048H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1503 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
?_Tidy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Unchecked_end, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1114 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	mov	rax, rdx

; 1115 :     }

	ret	0
?_Unchecked_end@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Unchecked_begin, COMDAT

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rcx]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, rdx

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx

; 1107 :     }

	ret	0
?_Unchecked_begin@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<TextureToGo * const,Texture> >::allocator<std::pair<TextureToGo * const,Texture> >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<TextureToGo * const,Texture> >::allocator<std::pair<TextureToGo * const,Texture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??0?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEAA@XZ PROC ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	DWORD PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 134  :         : _Mypair(_Zero_then_variadic_args_t{}, _Zero_then_variadic_args_t{}, 0.0f) {}

	mov	rax, rcx
	ret	0
??0?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEAA@XZ ENDP ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Parg$dead$ = 56
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >, COMDAT

; 882  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

$LN42:
	sub	rsp, 40					; 00000028H
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	movdqa	XMMWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A, rax

; 883  :         _Alloc_sentinel_and_proxy();
; 884  :     }

	lea	rax, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ?begin@?$initializer_list@E@std@@QEBAPEBEXZ
_TEXT	SEGMENT
this$ = 8
?begin@?$initializer_list@E@std@@QEBAPEBEXZ PROC	; std::initializer_list<unsigned char>::begin, COMDAT

; 38   :         return _First;

	mov	rax, QWORD PTR [rcx]

; 39   :     }

	ret	0
?begin@?$initializer_list@E@std@@QEBAPEBEXZ ENDP	; std::initializer_list<unsigned char>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXXZ PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Tidy:
?_Tidy@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXXZ ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Take_contents@?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Take_contents@?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@std@@QEAAXAEAV12@@Z PROC ; std::_Vector_val<std::_Simple_types<Texture *> >::_Take_contents, COMDAT

; 411  :         this->_Swap_proxy_and_iterators(_Right);
; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdx], rax

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdx+8], rax

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdx+16], rax

; 419  :     }

	ret	0
?_Take_contents@?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Vector_val<std::_Simple_types<Texture *> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Take_contents@?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Take_contents@?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAAXAEAV12@@Z PROC ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Take_contents, COMDAT

; 411  :         this->_Swap_proxy_and_iterators(_Right);
; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdx], rax

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdx+8], rax

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdx+16], rax

; 419  :     }

	ret	0
?_Take_contents@?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Take_contents@?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Take_contents@?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAAXAEAV12@@Z PROC ; std::_Vector_val<std::_Simple_types<float> >::_Take_contents, COMDAT

; 411  :         this->_Swap_proxy_and_iterators(_Right);
; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdx], rax

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdx+8], rax

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdx+16], rax

; 419  :     }

	ret	0
?_Take_contents@?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Vector_val<std::_Simple_types<float> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xrange@?$vector@MV?$allocator@M@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@MV?$allocator@M@std@@@std@@CAXXZ PROC	; std::vector<float,std::allocator<float> >::_Xrange, COMDAT

; 2141 :     [[noreturn]] static void _Xrange() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2142 :         _Xout_of_range("invalid vector subscript");

	lea	rcx, OFFSET FLAT:??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN3@Xrange:
?_Xrange@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ENDP	; std::vector<float,std::allocator<float> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBuffer@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBuffer@BfresFile@@@2@XZ PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBuffer@BfresFile@@@2@XZ ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAXQEAUVertexBuffer@BfresFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAXQEAUVertexBuffer@BfresFile@@_K@Z PROC ; std::allocator<BfresFile::VertexBuffer>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAXQEAUVertexBuffer@BfresFile@@_K@Z ENDP ; std::allocator<BfresFile::VertexBuffer>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAXQEAUVertexBufferAttribute@BfresFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAXQEAUVertexBufferAttribute@BfresFile@@_K@Z PROC ; std::allocator<BfresFile::VertexBufferAttribute>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAXQEAUVertexBufferAttribute@BfresFile@@_K@Z ENDP ; std::allocator<BfresFile::VertexBufferAttribute>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAAEAV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAXQEAUVertexBufferSize@BfresFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAXQEAUVertexBufferSize@BfresFile@@_K@Z PROC ; std::allocator<BfresFile::VertexBufferSize>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAXQEAUVertexBufferSize@BfresFile@@_K@Z ENDP ; std::allocator<BfresFile::VertexBufferSize>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z PROC ; std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z ENDP ; std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx

; 39   :         this->_Adopt(_Plist);
; 40   :     }

	mov	rax, rcx
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 64
_Cells$ = 72
_Val$ = 80
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Assign_grow, COMDAT

; 287  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN88:
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	r14
	sub	rsp, 40					; 00000028H
	mov	r14, rcx
	mov	rbx, r8

; 273  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, rcx
	mov	r9, QWORD PTR [r14]
	sub	rax, r9
	sar	rax, 3

; 288  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 289  :         const auto _Oldsize = size();
; 290  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 291  :         auto& _Alvec = _Mypair._Get_first();
; 292  :         if (_Oldsize < _Cells) {

	cmp	rax, rdx
	jae	$LN2@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR [rsp+88], rsi
	mov	QWORD PTR [rsp+32], rdi
	cmp	rdx, rax
	ja	$LN71@Assign_gro

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rsi, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN16@Assign_gro

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN71@Assign_gro

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN51@Assign_gro

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN14@Assign_gro
$LN16@Assign_gro:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN17@Assign_gro

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN14@Assign_gro
$LN17@Assign_gro:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN14@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3

; 293  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws
; 294  :             // nothrow hereafter
; 295  :             const auto _Oldcapacity = capacity();
; 296  :             if (_Oldcapacity != 0) {

	test	rax, rax
	je	SHORT $LN42@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN54@Assign_gro

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN51@Assign_gro

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN54@Assign_gro:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN42@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 302  :             const auto _Newend       = _Newvec + _Cells;

	lea	rax, QWORD PTR [rsi+rdi]
	mov	QWORD PTR [r14], rdi

; 303  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	QWORD PTR [r14+8], rax

; 304  :             _Mypair._Myval2._Myend   = _Newend;

	mov	QWORD PTR [r14+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1602 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rdi, rax

; 2002 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN84@Assign_gro
	npad	4
$LL58@Assign_gro:

; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	QWORD PTR [rdi], rbx

; 1617 :         ++_Last;

	add	rdi, 8

; 2002 :         while (_Backout._Last != _ULast) {

	cmp	rdi, rax
	jne	SHORT $LL58@Assign_gro
$LN84@Assign_gro:
	mov	rsi, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 309  :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rbx
	ret	0
$LN51@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 307  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	mov	rdx, rcx
	lea	r8, QWORD PTR _Val$[rsp]
	mov	rcx, r9
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >

; 309  :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rbx
	ret	0
$LN71@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN85@Assign_gro:
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::capacity, COMDAT

; 282  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 283  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 285  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Max_bucket_size, COMDAT

; 1801 :         return _Traitsobj._Get_max_bucket_size();

	lea	rax, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures

; 1802 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Getal@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Getal, COMDAT

; 1848 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1849 :     }

	ret	0
?_Getal@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$dead$ = 56
??0?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >, COMDAT

; 803  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN41:
	push	rbx
	sub	rsp, 32					; 00000020H

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax

; 803  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rcx

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+72]
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx], rax

; 804  :         _Alloc_sentinel_and_proxy();
; 805  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??0?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Traits$ = 16
??0?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@@Z PROC ; std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0>::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0>, COMDAT

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A, eax
	lea	rax, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures
	ret	0
??0?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@QEAA@AEBV?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@1@@Z ENDP ; std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0>::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Alloc_sentinel_and_proxy, COMDAT

; 1939 :     void _Alloc_sentinel_and_proxy() {

$LN32:
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1940 :         const auto _Scary = _Get_scary();
; 1941 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1942 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A, rax

; 1944 :         _Proxy._Release();
; 1945 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAXQEAU?$mat@$03$03M$0A@@glm@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAXQEAU?$mat@$03$03M$0A@@glm@@_K@Z PROC ; std::allocator<glm::mat<4,4,float,0> >::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	shl	r8, 6
	mov	rax, rdx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAXQEAU?$mat@$03$03M$0A@@glm@@_K@Z ENDP ; std::allocator<glm::mat<4,4,float,0> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBuffer@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBuffer@BfresFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBuffer@BfresFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::size, COMDAT

; 273  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 274  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_sentinel_and_proxy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1832 :     void _Alloc_sentinel_and_proxy() {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 72					; 00000048H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx], rax

; 1840 :         _Proxy._Release();
; 1841 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEAAAEAMXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEAAAEAMXZ PROC ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::_Get_max_bucket_size, COMDAT

; 158  :         return _Mypair._Myval2._Myval2;

	lea	rax, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures

; 159  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEAAAEAMXZ ENDP ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$dead$ = 16
?allocate@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >::allocate, COMDAT

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 72					; 00000048H
	jmp	??2@YAPEAX_K@Z				; operator new
?allocate@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAY04$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY04$$CBD$$QEAVBfresFile@@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$dead$ = 56
_Val2$ = 64
??$?0AEAY04$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY04$$CBD$$QEAVBfresFile@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><char const (&)[5],BfresFile,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_04KPICECCB@Area@
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rbx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+4]

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	lea	rcx, QWORD PTR [rdi+32]
	mov	rdx, rbx
	call	??0BfresFile@@QEAA@$$QEAV0@@Z

; 243  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEAY04$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY04$$CBD$$QEAVBfresFile@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><char const (&)[5],BfresFile,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
_Val$ = 144
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::insert<0,0>, COMDAT

; 1230 :     pair<iterator, bool> insert(value_type&& _Val) {

$LN156:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rsi, r8
	mov	r14, rdx

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rbp, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [rbp+8]
	mov	QWORD PTR $T3[rsp], rbx
	xor	r12d, r12d
	mov	DWORD PTR $T3[rsp+8], r12d
	mov	rdi, rbp

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	jne	SHORT $LN9@insert
	npad	3
$LL8@insert:

; 1616 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR $T3[rsp], rbx

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	test	al, al
	jns	SHORT $LN10@insert

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR $T3[rsp+8], r12d

; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]

; 1620 :             } else {

	jmp	SHORT $LN11@insert
$LN10@insert:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR $T3[rsp+8], 1

; 1622 :                 _Result._Bound           = _Trynode;

	mov	rdi, rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rbx, QWORD PTR [rbx]
$LN11@insert:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	je	SHORT $LL8@insert
$LN9@insert:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdi+25], r12b
	jne	SHORT $LN4@insert
	lea	rdx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	test	al, al
	js	SHORT $LN4@insert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	xor	al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1004 :                 return {_Loc._Bound, false};

	jmp	$LN138@insert
$LN4@insert:

; 1631 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 104811045873349725			; 01745d1745d1745dH
	cmp	QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A+8, rax
	je	$LN154@insert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	r15, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	mov	QWORD PTR $T2[rsp], r15

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], r12

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR $T2[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rdx, rsi
	lea	rcx, QWORD PTR [rax+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rsi+32]
	call	??0BfresFile@@QEAA@$$QEAV0@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rdi], rbp

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rdi+8], rbp

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rdi+16], rbp

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rdi+24], 0

; 1027 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	movups	xmm0, XMMWORD PTR $T3[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	mov	r8, rdi
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, r15
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Insert_node
	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	al, 1
$LN138@insert:
	mov	QWORD PTR [r14], rdi
	mov	BYTE PTR [r14+8], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1232 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

	mov	rax, r14

; 1233 :     }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN154@insert:

; 1632 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN152@insert:
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::insert<0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
_Val$ = 144
?dtor$2@?0???$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA PROC ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::insert<0,0>'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
?dtor$2@?0???$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA ENDP ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::insert<0,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
_Val$ = 144
?dtor$1@?0???$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA PROC ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::insert<0,0>'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0???$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA ENDP ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::insert<0,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAY07$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY07$$CBD$$QEAVBfresFile@@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$dead$ = 56
_Val2$ = 64
??$?0AEAY07$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY07$$CBD$$QEAVBfresFile@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><char const (&)[8],BfresFile,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rbx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+7]

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	lea	rcx, QWORD PTR [rdi+32]
	mov	rdx, rbx
	call	??0BfresFile@@QEAA@$$QEAV0@@Z

; 243  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEAY07$$CBDVBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAY07$$CBD$$QEAVBfresFile@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><char const (&)[8],BfresFile,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAVBfresFile@@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAVBfresFile@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,BfresFile,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, QWORD PTR [rdi+32]
	mov	rdx, rbx
	call	??0BfresFile@@QEAA@$$QEAV0@@Z

; 243  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAVBfresFile@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,BfresFile,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$count@X@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KAEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Keyval$ = 16
??$count@X@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KAEBQEAVTextureToGo@@@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::count<void>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]

; 2346 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1244 :     _NODISCARD size_type count(typename _Traits::template _Deduce_key<_Keyty> _Keyval) const {

	mov	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]

; 2346 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+4]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+5]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+6]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+7]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	imul	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	and	rdx, r8

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;
; 1570 :         if (_Where == _End) {

	xor	r8d, r8d
	shl	rdx, 4
	add	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	mov	rax, QWORD PTR [rdx+8]
	cmp	rax, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
	je	SHORT $LN34@count
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	rcx, QWORD PTR [r9]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdx, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	rcx, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN20@count
$LL19@count:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};
; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rax, rdx
	je	SHORT $LN34@count

; 1588 :                 return {_Where, _Nodeptr{}};
; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	rcx, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL19@count

; 1245 :         const size_t _Hashval = _Traitsobj(_Keyval);
; 1246 :         if constexpr (_Multi) {
; 1247 :             return _Equal_range(_Keyval, _Hashval)._Distance;
; 1248 :         } else {
; 1249 :             return static_cast<bool>(_Find_last(_Keyval, _Hashval)._Duplicate);

	test	rax, rax
	setne	r8b
	mov	rax, r8

; 1250 :         }
; 1251 :     }

	ret	0
$LN34@count:

; 1245 :         const size_t _Hashval = _Traitsobj(_Keyval);
; 1246 :         if constexpr (_Multi) {
; 1247 :             return _Equal_range(_Keyval, _Hashval)._Distance;
; 1248 :         } else {
; 1249 :             return static_cast<bool>(_Find_last(_Keyval, _Hashval)._Duplicate);

	mov	rax, r8
$LN20@count:
	test	rax, rax
	setne	r8b
	mov	rax, r8

; 1250 :         }
; 1251 :     }

	ret	0
??$count@X@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KAEBQEAVTextureToGo@@@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::count<void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAVTextureToGo@@VTexture@@$0A@@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@AEAPEAVTextureToGo@@$$QEAVTexture@@@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAVTextureToGo@@VTexture@@$0A@@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@AEAPEAVTextureToGo@@$$QEAVTexture@@@Z PROC ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture><TextureToGo * &,Texture,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx], rax
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rcx+12], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+16], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+32], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+40], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8+8]
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	xmm1, XMMWORD PTR [r8+24]
	movups	XMMWORD PTR [rcx+32], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 243  :     }

	mov	QWORD PTR [r8+24], rax
	mov	QWORD PTR [r8+32], 15
	mov	BYTE PTR [r8+8], al
	mov	eax, DWORD PTR [r8+40]
	mov	DWORD PTR [rcx+48], eax
	mov	rax, rcx
	ret	0
??$?0AEAPEAVTextureToGo@@VTexture@@$0A@@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@AEAPEAVTextureToGo@@$$QEAVTexture@@@Z ENDP ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture><TextureToGo * &,Texture,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0Texture@@QEAA@$$QEAV0@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0Texture@@QEAA@$$QEAV0@@Z PROC			; Texture::Texture, COMDAT
	mov	eax, DWORD PTR [rdx]
	xorps	xmm0, xmm0
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+24], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+32], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+8]
	movups	XMMWORD PTR [rcx+8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+24]
	movups	XMMWORD PTR [rcx+24], xmm1
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], 15
	mov	BYTE PTR [rdx+8], al
	mov	eax, DWORD PTR [rdx+40]
	mov	DWORD PTR [rcx+40], eax
	mov	rax, rcx
	ret	0
??0Texture@@QEAA@$$QEAV0@@Z ENDP			; Texture::Texture
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$get@$0A@QEAVTextureToGo@@VTexture@@@std@@YAAEBQEAVTextureToGo@@AEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z
_TEXT	SEGMENT
_Pr$ = 8
??$get@$0A@QEAVTextureToGo@@VTexture@@@std@@YAAEBQEAVTextureToGo@@AEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z PROC ; std::get<0,TextureToGo * const,Texture>, COMDAT

; 664  :     // get reference to element at _Idx in pair _Pr
; 665  :     if constexpr (_Idx == 0) {
; 666  :         return _Pr.first;

	mov	rax, rcx

; 667  :     } else {
; 668  :         return _Pr.second;
; 669  :     }
; 670  : }

	ret	0
??$get@$0A@QEAVTextureToGo@@VTexture@@@std@@YAAEBQEAVTextureToGo@@AEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z ENDP ; std::get<0,TextureToGo * const,Texture>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$get@$00QEAVTextureToGo@@VTexture@@@std@@YAAEAVTexture@@AEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z
_TEXT	SEGMENT
_Pr$ = 8
??$get@$00QEAVTextureToGo@@VTexture@@@std@@YAAEAVTexture@@AEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z PROC ; std::get<1,TextureToGo * const,Texture>, COMDAT

; 664  :     // get reference to element at _Idx in pair _Pr
; 665  :     if constexpr (_Idx == 0) {
; 666  :         return _Pr.first;
; 667  :     } else {
; 668  :         return _Pr.second;

	lea	rax, QWORD PTR [rcx+8]

; 669  :     }
; 670  : }

	ret	0
??$get@$00QEAVTextureToGo@@VTexture@@@std@@YAAEAVTexture@@AEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z ENDP ; std::get<1,TextureToGo * const,Texture>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
;	COMDAT ??$pow@MH$0A@@@YANMH@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$dead$ = 16
??$pow@MH$0A@@@YANMH@Z PROC				; pow<float,int,0>, COMDAT

; 674  : _GENERIC_MATH2(pow)

	movsd	xmm1, QWORD PTR __real@4000000000000000
	cvtss2sd xmm0, xmm0
	jmp	pow
??$pow@MH$0A@@@YANMH@Z ENDP				; pow<float,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
;	COMDAT ??$fmax@MN$0A@@@YANMN@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$fmax@MN$0A@@@YANMN@Z PROC				; fmax<float,double,0>, COMDAT

; 698  : _GENERIC_MATH2(fmax)

	cvtss2sd xmm0, xmm0
	rex_jmp	QWORD PTR __imp_fmax
??$fmax@MN$0A@@@YANMN@Z ENDP				; fmax<float,double,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$begin@I$0CE@@std@@YAPEAIAEAY0CE@I@Z
_TEXT	SEGMENT
_Array$ = 8
??$begin@I$0CE@@std@@YAPEAIAEAY0CE@I@Z PROC		; std::begin<unsigned int,36>, COMDAT

; 1805 :     return _Array;

	mov	rax, rcx

; 1806 : }

	ret	0
??$begin@I$0CE@@std@@YAPEAIAEAY0CE@I@Z ENDP		; std::begin<unsigned int,36>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$end@I$0CE@@std@@YAPEAIAEAY0CE@I@Z
_TEXT	SEGMENT
_Array$ = 8
??$end@I$0CE@@std@@YAPEAIAEAY0CE@I@Z PROC		; std::end<unsigned int,36>, COMDAT

; 1810 :     return _Array + _Size;

	lea	rax, QWORD PTR [rcx+144]

; 1811 : }

	ret	0
??$end@I$0CE@@std@@YAPEAIAEAY0CE@I@Z ENDP		; std::end<unsigned int,36>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z
_TEXT	SEGMENT
this$ = 80
_First$ = 88
_Last$ = 96
_Al$dead$ = 104
??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> ><unsigned int *,0>, COMDAT

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN49:
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbp, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	sub	rbp, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	mov	rsi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	sar	rsi, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	r14, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+16], rax

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rdi, rcx

; 2065 :         if (_Count != 0) {

	test	rbp, rbp
	je	SHORT $LN36@allocator

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rsi, rax
	ja	SHORT $LN47@allocator

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rsi
	mov	QWORD PTR [rsp+32], rbx
	call	?allocate@?$allocator@I@std@@QEAAPEAI_K@Z ; std::allocator<unsigned int>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rbx, rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rax+rsi*4]
	mov	QWORD PTR [rdi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rcx, QWORD PTR [rbx+rsi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [rsp+32]
	mov	QWORD PTR [rdi+8], rcx
$LN36@allocator:

; 631  :         _Adl_verify_range(_First, _Last);
; 632  :         auto _UFirst = _Get_unwrapped(_First);
; 633  :         auto _ULast  = _Get_unwrapped(_Last);
; 634  :         if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
; 635  :             const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
; 636  :             const auto _Count  = _Convert_size<size_type>(_Length);
; 637  :             _Construct_n(_Count, _STD move(_UFirst), _STD move(_ULast));
; 638  : #ifdef __cpp_lib_concepts
; 639  :         } else if constexpr (forward_iterator<_Iter>) {
; 640  :             const auto _Length = _To_unsigned_like(_RANGES distance(_UFirst, _ULast));
; 641  :             const auto _Count  = _Convert_size<size_type>(_Length);
; 642  :             _Construct_n(_Count, _STD move(_UFirst), _STD move(_ULast));
; 643  : #endif // __cpp_lib_concepts
; 644  :         } else {
; 645  :             auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 646  :             _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 647  :             _Tidy_guard<vector> _Guard{this};
; 648  : 
; 649  :             _Append_uncounted_range(_STD move(_UFirst), _STD move(_ULast));
; 650  : 
; 651  :             _Guard._Target = nullptr;
; 652  :             _Proxy._Release();
; 653  :         }
; 654  :     }

	mov	rax, rdi
	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN47@allocator:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength
	int	3
$LN45@allocator:
??$?0PEAI$0A@@?$vector@IV?$allocator@I@std@@@std@@QEAA@PEAI0AEBV?$allocator@I@1@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> ><unsigned int *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEAI@std@@YA?A_TAEAPEAI@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAPEAI@std@@YA?A_TAEAPEAI@Z PROC	; std::_Get_unwrapped<unsigned int * &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEAPEAI@std@@YA?A_TAEAPEAI@Z ENDP	; std::_Get_unwrapped<unsigned int * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$begin@M$0BI@@std@@YAPEAMAEAY0BI@M@Z
_TEXT	SEGMENT
_Array$ = 8
??$begin@M$0BI@@std@@YAPEAMAEAY0BI@M@Z PROC		; std::begin<float,24>, COMDAT

; 1805 :     return _Array;

	mov	rax, rcx

; 1806 : }

	ret	0
??$begin@M$0BI@@std@@YAPEAMAEAY0BI@M@Z ENDP		; std::begin<float,24>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$end@M$0BI@@std@@YAPEAMAEAY0BI@M@Z
_TEXT	SEGMENT
_Array$ = 8
??$end@M$0BI@@std@@YAPEAMAEAY0BI@M@Z PROC		; std::end<float,24>, COMDAT

; 1810 :     return _Array + _Size;

	lea	rax, QWORD PTR [rcx+96]

; 1811 : }

	ret	0
??$end@M$0BI@@std@@YAPEAMAEAY0BI@M@Z ENDP		; std::end<float,24>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z
_TEXT	SEGMENT
this$ = 80
_First$ = 88
_Last$ = 96
_Al$dead$ = 104
??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z PROC ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> ><float *,0>, COMDAT

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN53:
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbp, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	sub	rbp, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	mov	rsi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	sar	rsi, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	r14, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+16], rax

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rdi, rcx

; 2065 :         if (_Count != 0) {

	test	rbp, rbp
	je	SHORT $LN40@allocator

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rsi, rax
	ja	SHORT $LN51@allocator

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rsi
	mov	QWORD PTR [rsp+32], rbx
	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rbx, rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rax+rsi*4]
	mov	QWORD PTR [rdi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rcx, QWORD PTR [rbx+rsi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [rsp+32]
	mov	QWORD PTR [rdi+8], rcx
$LN40@allocator:

; 631  :         _Adl_verify_range(_First, _Last);
; 632  :         auto _UFirst = _Get_unwrapped(_First);
; 633  :         auto _ULast  = _Get_unwrapped(_Last);
; 634  :         if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
; 635  :             const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
; 636  :             const auto _Count  = _Convert_size<size_type>(_Length);
; 637  :             _Construct_n(_Count, _STD move(_UFirst), _STD move(_ULast));
; 638  : #ifdef __cpp_lib_concepts
; 639  :         } else if constexpr (forward_iterator<_Iter>) {
; 640  :             const auto _Length = _To_unsigned_like(_RANGES distance(_UFirst, _ULast));
; 641  :             const auto _Count  = _Convert_size<size_type>(_Length);
; 642  :             _Construct_n(_Count, _STD move(_UFirst), _STD move(_ULast));
; 643  : #endif // __cpp_lib_concepts
; 644  :         } else {
; 645  :             auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 646  :             _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 647  :             _Tidy_guard<vector> _Guard{this};
; 648  : 
; 649  :             _Append_uncounted_range(_STD move(_UFirst), _STD move(_ULast));
; 650  : 
; 651  :             _Guard._Target = nullptr;
; 652  :             _Proxy._Release();
; 653  :         }
; 654  :     }

	mov	rax, rdi
	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN51@allocator:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN49@allocator:
??$?0PEAM$0A@@?$vector@MV?$allocator@M@std@@@std@@QEAA@PEAM0AEBV?$allocator@M@1@@Z ENDP ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> ><float *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEAM@std@@YA?A_TAEAPEAM@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAPEAM@std@@YA?A_TAEAPEAM@Z PROC	; std::_Get_unwrapped<float * &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEAPEAM@std@@YA?A_TAEAPEAM@Z ENDP	; std::_Get_unwrapped<float * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$begin@M$0BA@@std@@YAPEAMAEAY0BA@M@Z
_TEXT	SEGMENT
_Array$ = 8
??$begin@M$0BA@@std@@YAPEAMAEAY0BA@M@Z PROC		; std::begin<float,16>, COMDAT

; 1805 :     return _Array;

	mov	rax, rcx

; 1806 : }

	ret	0
??$begin@M$0BA@@std@@YAPEAMAEAY0BA@M@Z ENDP		; std::begin<float,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$end@M$0BA@@std@@YAPEAMAEAY0BA@M@Z
_TEXT	SEGMENT
_Array$ = 8
??$end@M$0BA@@std@@YAPEAMAEAY0BA@M@Z PROC		; std::end<float,16>, COMDAT

; 1810 :     return _Array + _Size;

	lea	rax, QWORD PTR [rcx+64]

; 1811 : }

	ret	0
??$end@M$0BA@@std@@YAPEAMAEAY0BA@M@Z ENDP		; std::end<float,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,TextureToGo &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN7:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+32]
	mov	rdx, rbx
	call	??0TextureToGo@@QEAA@AEBV0@@Z
	npad	1

; 243  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,TextureToGo &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
?dtor$0@?0???$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z@4HA PROC ; `std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,TextureToGo &,0>'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVTextureToGo@@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEAVTextureToGo@@@Z@4HA ENDP ; `std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,TextureToGo &,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0TextureToGo@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0TextureToGo@@QEAA@AEBV0@@Z PROC			; TextureToGo::TextureToGo, COMDAT
$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rdx]
	mov	rbx, rdx
	mov	QWORD PTR [rcx], rax
	mov	rdi, rcx
	add	rcx, 8
	add	rdx, 8
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	movzx	eax, WORD PTR [rbx+32]
	mov	WORD PTR [rdi+32], ax
	movzx	eax, WORD PTR [rbx+34]
	mov	WORD PTR [rdi+34], ax
	movzx	eax, WORD PTR [rbx+36]
	mov	WORD PTR [rdi+36], ax
	movzx	eax, BYTE PTR [rbx+38]
	mov	BYTE PTR [rdi+38], al
	movzx	eax, WORD PTR [rbx+40]
	mov	WORD PTR [rdi+40], ax
	movzx	eax, BYTE PTR [rbx+42]
	mov	BYTE PTR [rdi+42], al
	movzx	eax, BYTE PTR [rbx+43]
	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [rdi+43], al
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0TextureToGo@@QEAA@AEBV0@@Z ENDP			; TextureToGo::TextureToGo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
_Val$ = 144
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::insert<0,0>, COMDAT

; 1230 :     pair<iterator, bool> insert(value_type&& _Val) {

$LN157:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rsi, r8
	mov	r14, rdx

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rbp, QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [rbp+8]
	mov	QWORD PTR $T3[rsp], rbx
	xor	r12d, r12d
	mov	DWORD PTR $T3[rsp+8], r12d
	mov	rdi, rbp

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	jne	SHORT $LN9@insert
	npad	3
$LL8@insert:

; 1616 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR $T3[rsp], rbx

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	test	al, al
	jns	SHORT $LN10@insert

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR $T3[rsp+8], r12d

; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]

; 1620 :             } else {

	jmp	SHORT $LN11@insert
$LN10@insert:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR $T3[rsp+8], 1

; 1622 :                 _Result._Bound           = _Trynode;

	mov	rdi, rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rbx, QWORD PTR [rbx]
$LN11@insert:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	je	SHORT $LL8@insert
$LN9@insert:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdi+25], r12b
	jne	SHORT $LN4@insert
	lea	rdx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	test	al, al
	js	SHORT $LN4@insert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	xor	al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1004 :                 return {_Loc._Bound, false};

	jmp	$LN138@insert
$LN4@insert:

; 1631 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 164703072086692425			; 0249249249249249H
	cmp	QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A+8, rax
	je	$LN155@insert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	r15, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
	mov	QWORD PTR $T2[rsp], r15

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], r12

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR $T2[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rdx, rsi
	lea	rcx, QWORD PTR [rax+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, QWORD PTR [rsi+32]
	mov	QWORD PTR [rdi+64], rcx

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rsi+56]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rsi+56], r12

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rsi+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rsi+48], r12

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rsi+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rsi+40], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdi+72], rax
	mov	QWORD PTR [rdi+80], rcx
	mov	QWORD PTR [rdi+88], rdx
	movzx	eax, WORD PTR [rsi+64]
	mov	WORD PTR [rdi+96], ax
	movzx	eax, WORD PTR [rsi+66]
	mov	WORD PTR [rdi+98], ax
	movzx	eax, WORD PTR [rsi+68]
	mov	WORD PTR [rdi+100], ax
	movzx	eax, BYTE PTR [rsi+70]
	mov	BYTE PTR [rdi+102], al
	movzx	eax, WORD PTR [rsi+72]
	mov	WORD PTR [rdi+104], ax
	movzx	eax, BYTE PTR [rsi+74]
	mov	BYTE PTR [rdi+106], al
	movzx	eax, BYTE PTR [rsi+75]
	mov	BYTE PTR [rdi+107], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rdi], rbp

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rdi+8], rbp

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rdi+16], rbp

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rdi+24], 0

; 1027 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	movups	xmm0, XMMWORD PTR $T3[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	mov	r8, rdi
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, r15
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Insert_node
	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	al, 1
$LN138@insert:
	mov	QWORD PTR [r14], rdi
	mov	BYTE PTR [r14+8], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1232 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

	mov	rax, r14

; 1233 :     }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN155@insert:

; 1632 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN153@insert:
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::insert<0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
_Val$ = 144
?dtor$2@?0???$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA PROC ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::insert<0,0>'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
?dtor$2@?0???$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA ENDP ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::insert<0,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
_Val$ = 144
?dtor$1@?0???$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA PROC ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::insert<0,0>'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0???$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA ENDP ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::insert<0,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0PEAVTextureToGo@@AEAY03$$CBD$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAPEAVTextureToGo@@AEAY03$$CBD@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$dead$ = 64
??$?0PEAVTextureToGo@@AEAY03$$CBD$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAPEAVTextureToGo@@AEAY03$$CBD@Z PROC ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><TextureToGo *,char const (&)[4],0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rdx]
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_03NLIGKIPD@_a0@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	add	rcx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+3]

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 243  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0PEAVTextureToGo@@AEAY03$$CBD$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAPEAVTextureToGo@@AEAY03$$CBD@Z ENDP ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><TextureToGo *,char const (&)[4],0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$ = 64
??$?0AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><TextureToGo * &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rdx]
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	mov	rdx, r8
	add	rcx, 8
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 243  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEAPEAVTextureToGo@@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><TextureToGo * &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@UVertexBuffer@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBuffer@BfresFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@UVertexBuffer@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBuffer@BfresFile@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1>::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1><std::allocator<BfresFile::VertexBuffer> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@UVertexBuffer@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBuffer@BfresFile@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1>::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1><std::allocator<BfresFile::VertexBuffer> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Construct_n<>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN95:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN89@Construct_
	push	rdi
	push	r14
	sub	rsp, 56					; 00000038H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 461168601842738790			; 0666666666666666H

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rdi, rdx
	mov	r14, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	$LN92@Construct_
	mov	QWORD PTR [rsp+96], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+48], rsi
	lea	rsi, QWORD PTR [rax*8]
	mov	QWORD PTR [rsp+40], r12

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	xor	r12d, r12d
	mov	QWORD PTR [rsp+32], r15
	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN18@Construct_

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN93@Construct_

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN27@Construct_

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, rbx
	mov	r8, rbx

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	lea	rax, QWORD PTR [rbx+rsi]
	jmp	SHORT $LN90@Construct_
$LN27@Construct_:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@Construct_:

; 244  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN19@Construct_

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	add	rax, rsi
	mov	rcx, rbx
	mov	r8, rbx
	jmp	SHORT $LN90@Construct_
$LN19@Construct_:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	mov	rbx, r12
	lea	rax, QWORD PTR [r12+rsi]
	mov	rcx, r12
	mov	r8, r12
$LN90@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], r8
	lea	rdx, QWORD PTR [r14+8]
	mov	QWORD PTR [rdx], rcx
	mov	QWORD PTR [r14+16], rax
	lea	rax, QWORD PTR [rbx+32]
	npad	6
$LL43@Construct_:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rax, QWORD PTR [rax+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rbx], xmm0
	xor	ecx, ecx
	movups	XMMWORD PTR [rbx+16], xmm0
	mov	QWORD PTR [rbx+32], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax-56], r12
	mov	QWORD PTR [rax-48], r12
	mov	QWORD PTR [rax-40], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdi, 1
	jne	SHORT $LL43@Construct_

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rbx
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::VertexBuffer> >
	mov	r12, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+104]
	mov	r15, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [r14+8], rbx
	mov	rbx, QWORD PTR [rsp+96]

; 2070 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2071 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2072 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2073 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rdi
$LN89@Construct_:
	ret	0
$LN93@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN92@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Xlength
	int	3
$LN88@Construct_:
??$_Construct_n@$$V@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Construct_n<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1>::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1><std::allocator<BfresFile::VertexBufferAttribute> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1>::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1><std::allocator<BfresFile::VertexBufferAttribute> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Construct_n<>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN122:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN117@Construct_
	push	rbx
	push	rsi
	sub	rsp, 56					; 00000038H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 461168601842738790			; 0666666666666666H

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rbx, rdx
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	$LN119@Construct_
	mov	QWORD PTR [rsp+96], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	mov	QWORD PTR [rsp+48], rdi

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	xor	ebp, ebp

; 75   :     return _Count * _Ty_size;

	lea	rdi, QWORD PTR [rax*8]
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], r15

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN18@Construct_

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN120@Construct_

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN27@Construct_

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rdx, rax

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	lea	rcx, QWORD PTR [rax+rdi]
	jmp	SHORT $LN104@Construct_
$LN27@Construct_:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@Construct_:

; 244  :     if (_Bytes != 0) {

	test	rdi, rdi
	je	SHORT $LN19@Construct_

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	mov	rdx, rax
	lea	rcx, QWORD PTR [rax+rdi]
	jmp	SHORT $LN104@Construct_
$LN19@Construct_:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	mov	rax, rbp
	lea	rcx, QWORD PTR [rdi+rbp]
	mov	rdx, rbp
$LN104@Construct_:
	mov	QWORD PTR [rsi], rdx
	mov	QWORD PTR [rsi+16], rcx
$LL43@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rax+32], rbp
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rbp

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], bpl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 40					; 00000028H

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rbx, 1
	jne	SHORT $LL43@Construct_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	r14, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+32]
	mov	QWORD PTR [rsi+8], rax

; 2070 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2071 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2072 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2073 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 56					; 00000038H
	pop	rsi
	pop	rbx
$LN117@Construct_:
	ret	0
$LN120@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN119@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Xlength
	int	3
$LN116@Construct_:
??$_Construct_n@$$V@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Construct_n<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@UVertexBufferSize@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@UVertexBufferSize@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1>::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1><std::allocator<BfresFile::VertexBufferSize> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@UVertexBufferSize@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1>::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1><std::allocator<BfresFile::VertexBufferSize> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Construct_n<>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN83:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN76@Construct_
	push	rbp
	push	rsi
	sub	rsp, 56					; 00000038H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rbp, rdx
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	$LN80@Construct_
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+48], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rdi, QWORD PTR [rdx*8]
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], r15

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN18@Construct_

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	SHORT $LN81@Construct_

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN27@Construct_

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN77@Construct_
$LN27@Construct_:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@Construct_:

; 244  :     if (_Bytes != 0) {

	test	rdi, rdi
	je	SHORT $LN19@Construct_

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	add	rax, rdi
	jmp	SHORT $LN78@Construct_
$LN19@Construct_:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	ebx, ebx
$LN77@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	lea	rax, QWORD PTR [rbx+rdi]
$LN78@Construct_:
	mov	QWORD PTR [rsi], rbx
	lea	r8, QWORD PTR [rbp*8]
	mov	rcx, rbx
	mov	QWORD PTR [rsi+16], rax
	xor	edx, edx
	call	memset
	mov	r14, QWORD PTR [rsp+40]
	add	rbx, rdi
	mov	rdi, QWORD PTR [rsp+48]
	mov	r15, QWORD PTR [rsp+32]

; 2066 :             _Buy_nonzero(_Count);
; 2067 :             _Tidy_guard<vector> _Guard{this};
; 2068 :             if constexpr (sizeof...(_Val) == 0) {
; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [rsi+8], rbx
	mov	rbx, QWORD PTR [rsp+96]

; 2070 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2071 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2072 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2073 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 56					; 00000038H
	pop	rsi
	pop	rbp
$LN76@Construct_:
	ret	0
$LN81@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN80@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Xlength
	int	3
$LN75@Construct_:
??$_Construct_n@$$V@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Construct_n<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z PROC ; std::move<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ENDP ; std::move<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU21@@Z PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_one_at_back<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	mov	r8, rdx
	mov	r9, rcx

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [r8]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+24], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+32], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8+8]
	movups	XMMWORD PTR [rdx+8], xmm0
	movups	xmm1, XMMWORD PTR [r8+24]
	movups	XMMWORD PTR [rdx+24], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r8+24], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r8+32], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r8+8], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+40]
	mov	QWORD PTR [r9+8], rcx

; 786  :     }

	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_reallocate<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
??$_Emplace_one_at_back@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU21@@Z ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_one_at_back<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
$T1 = 32
_Newnode$ = 32
this$dead$ = 96
__$ReturnUdt$ = 104
_Keyval_arg$ = 112
??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Try_emplace<TextureToGo * const &>, COMDAT

; 693  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval_arg, _Mappedty&&... _Mapval) {

$LN209:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r14, r8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	esi, BYTE PTR [r8]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	imul	rsi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+1]
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rsi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+2]
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rsi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+3]
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rsi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+4]
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rsi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+5]
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rsi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+6]
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rsi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+7]
	xor	rsi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
	and	rdx, rsi

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rdx, rdx
	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	mov	rax, QWORD PTR [rcx+rdx*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rbp, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8

; 1570 :         if (_Where == _End) {

	cmp	rax, rbp
	je	SHORT $LN2@Try_emplac

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdx, QWORD PTR [rcx+rdx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	rcx, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	rcx, QWORD PTR [rax+16]
	je	SHORT $LN178@Try_emplac
	npad	5
$LL22@Try_emplac:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rax, rdx
	je	SHORT $LN179@Try_emplac

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	rcx, QWORD PTR [rax+16]
	jne	SHORT $LL22@Try_emplac
$LN178@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rdi], rax
	mov	BYTE PTR [rdi+8], 0
$LN206@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 711  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN179@Try_emplac:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	rbp, rax
$LN2@Try_emplac:

; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 256204778801521550			; 038e38e38e38e38eH
	cmp	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16, rax
	jne	SHORT $LN36@Try_emplac

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN36@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	rax, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
	mov	QWORD PTR _Newnode$[rsp], rax

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	xor	r15d, r15d
	mov	QWORD PTR _Newnode$[rsp+8], r15

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [r15+72]
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR _Newnode$[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR [rbx+16], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+32], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+48], r15

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+56], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+32], r15b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16

; 1654 :         const auto _Newsize      = _Oldsize + 1;

	add	rcx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN203@Try_emplac
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN204@Try_emplac
$LN203@Try_emplac:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN204@Try_emplac:
	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+56
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN201@Try_emplac
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN202@Try_emplac
$LN201@Try_emplac:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN202@Try_emplac:
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A
	seta	al

; 694  :         const auto& _Keyval = _Keyval_arg;
; 695  :         const auto _Hashval = _Traitsobj(_Keyval);
; 696  :         auto _Target        = _Find_last(_Keyval, _Hashval);
; 697  :         if (_Target._Duplicate) {
; 698  :             return {_Target._Duplicate, false};
; 699  :         }
; 700  : 
; 701  :         _Check_max_size();
; 702  :         _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), piecewise_construct,
; 703  :             _STD forward_as_tuple(_STD forward<_Keyty>(_Keyval_arg)),
; 704  :             _STD forward_as_tuple(_STD forward<_Mappedty>(_Mapval)...));
; 705  :         if (_Check_rehash_required_1()) {

	test	al, al
	je	SHORT $LN3@Try_emplac

; 706  :             _Rehash_for_1();

	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Rehash_for_1

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
	and	rax, rsi

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rax, rax
	mov	r8, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	mov	rcx, QWORD PTR [r8+rax*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8

; 1570 :         if (_Where == _End) {

	cmp	rcx, rdx
	jne	SHORT $LN166@Try_emplac

; 1571 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rdx
	jmp	SHORT $LN164@Try_emplac
$LN166@Try_emplac:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdx, QWORD PTR [r8+rax*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	rax, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	rax, QWORD PTR [rcx+16]
	je	SHORT $LN180@Try_emplac
	npad	7
$LL163@Try_emplac:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rcx, rdx
	je	SHORT $LN181@Try_emplac

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rcx, QWORD PTR [rcx+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	rax, QWORD PTR [rcx+16]
	jne	SHORT $LL163@Try_emplac
$LN180@Try_emplac:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR $T1[rsp], rax
$LN164@Try_emplac:

; 707  :             _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	rbp, QWORD PTR $T1[rsp]
$LN3@Try_emplac:

; 710  :         return {_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()), true};

	mov	r9, rbx
	mov	r8, rbp
	mov	rdx, rsi
	call	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Insert_new_node_before
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rdi], rax
	mov	BYTE PTR [rdi+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 710  :         return {_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()), true};

	jmp	$LN206@Try_emplac
$LN181@Try_emplac:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rcx
	jmp	SHORT $LN164@Try_emplac
	int	3
$LN205@Try_emplac:
??$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Try_emplace<TextureToGo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$ = 32
this$dead$ = 96
__$ReturnUdt$ = 104
_Keyval_arg$ = 112
?dtor$1@?0???$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Try_emplace<TextureToGo * const &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
?dtor$1@?0???$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Try_emplace<TextureToGo * const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$ = 32
this$dead$ = 96
__$ReturnUdt$ = 104
_Keyval_arg$ = 112
?dtor$0@?0???$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Try_emplace<TextureToGo * const &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
?dtor$0@?0???$_Try_emplace@AEBQEAVTextureToGo@@$$V@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@1@AEBQEAVTextureToGo@@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Try_emplace<TextureToGo * const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YA$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YA$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z PROC ; std::move<std::pair<TextureToGo * const,Texture> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YA$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z ENDP ; std::move<std::pair<TextureToGo * const,Texture> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
_Newnode$2 = 32
this$dead$ = 96
__$ReturnUdt$ = 104
<_Vals_0>$ = 112
??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::emplace<std::pair<TextureToGo * const,Texture> >, COMDAT

; 589  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN238:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rsi, r8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ebp, BYTE PTR [r8]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rbp, rax

; 2346 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	imul	rbp, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+1]
	xor	rbp, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rbp, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+2]
	xor	rbp, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rbp, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+3]
	xor	rbp, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rbp, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+4]
	xor	rbp, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rbp, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+5]
	xor	rbp, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rbp, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+6]
	xor	rbp, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rbp, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+7]
	xor	rbp, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
	and	rdx, rbp

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rdx, rdx
	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	mov	rax, QWORD PTR [rcx+rdx*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	r14, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8

; 1570 :         if (_Where == _End) {

	cmp	rax, r14
	je	SHORT $LN2@emplace

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdx, QWORD PTR [rcx+rdx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	rcx, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	rcx, QWORD PTR [rax+16]
	je	SHORT $LN202@emplace
	npad	5
$LL22@emplace:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rax, rdx
	je	SHORT $LN203@emplace

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	rcx, QWORD PTR [rax+16]
	jne	SHORT $LL22@emplace
$LN202@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rdi], rax
	mov	BYTE PTR [rdi+8], 0
$LN235@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 639  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN203@emplace:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	r14, rax
$LN2@emplace:

; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 256204778801521550			; 038e38e38e38e38eH
	cmp	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16, rax
	jne	SHORT $LN44@emplace

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN44@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	rax, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
	mov	QWORD PTR _Newnode$2[rsp], rax

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	xor	r15d, r15d
	mov	QWORD PTR _Newnode$2[rsp+8], r15

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [r15+72]
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR _Newnode$2[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rbx+16], rax
	mov	eax, DWORD PTR [rsi+8]
	mov	DWORD PTR [rbx+24], eax
	mov	eax, DWORD PTR [rsi+12]
	mov	DWORD PTR [rbx+28], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+48], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+56], r15

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rsi+16]
	movups	XMMWORD PTR [rbx+32], xmm0
	movups	xmm1, XMMWORD PTR [rsi+32]
	movups	XMMWORD PTR [rbx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 587  :     }

	mov	QWORD PTR [rsi+32], r15
	mov	QWORD PTR [rsi+40], 15
	mov	BYTE PTR [rsi+16], r15b
	mov	eax, DWORD PTR [rsi+48]
	mov	DWORD PTR [rbx+64], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16

; 1654 :         const auto _Newsize      = _Oldsize + 1;

	add	rcx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN232@emplace
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN233@emplace
$LN232@emplace:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN233@emplace:
	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+56
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN230@emplace
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN231@emplace
$LN230@emplace:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN231@emplace:
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A
	seta	al

; 590  :         // try to insert value_type(_Vals...)
; 591  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 592  :         if constexpr (_Multi) {
; 593  :             _Check_max_size();
; 594  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 595  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 596  :             const auto _Hashval = _Traitsobj(_Keyval);
; 597  :             if (_Check_rehash_required_1()) {
; 598  :                 _Rehash_for_1();
; 599  :             }
; 600  : 
; 601  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 602  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 603  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 604  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);
; 605  :             const auto _Hashval = _Traitsobj(_Keyval);
; 606  :             auto _Target        = _Find_last(_Keyval, _Hashval);
; 607  :             if (_Target._Duplicate) {
; 608  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 609  :             }
; 610  : 
; 611  :             _Check_max_size();
; 612  :             // invalidates _Keyval:
; 613  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 614  :             if (_Check_rehash_required_1()) {

	test	al, al
	je	SHORT $LN3@emplace

; 615  :                 _Rehash_for_1();

	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Rehash_for_1

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
	and	rax, rbp

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rax, rax
	mov	r8, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	mov	rcx, QWORD PTR [r8+rax*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8

; 1570 :         if (_Where == _End) {

	cmp	rcx, rdx
	jne	SHORT $LN189@emplace

; 1571 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rdx
	jmp	SHORT $LN187@emplace
$LN189@emplace:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdx, QWORD PTR [r8+rax*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	rax, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	rax, QWORD PTR [rcx+16]
	je	SHORT $LN204@emplace
$LL186@emplace:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rcx, rdx
	je	SHORT $LN205@emplace

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rcx, QWORD PTR [rcx+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	rax, QWORD PTR [rcx+16]
	jne	SHORT $LL186@emplace
$LN204@emplace:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR $T1[rsp], rax
$LN187@emplace:

; 616  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	r14, QWORD PTR $T1[rsp]
$LN3@emplace:

; 619  :             return {

	mov	r9, rbx
	mov	r8, r14
	mov	rdx, rbp
	call	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Insert_new_node_before
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rdi], rax
	mov	BYTE PTR [rdi+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 619  :             return {

	jmp	$LN235@emplace
$LN205@emplace:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rcx
	jmp	SHORT $LN187@emplace
	int	3
$LN234@emplace:
??$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::emplace<std::pair<TextureToGo * const,Texture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$2 = 32
this$dead$ = 96
__$ReturnUdt$ = 104
<_Vals_0>$ = 112
?dtor$1@?0???$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::emplace<std::pair<TextureToGo * const,Texture> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
?dtor$1@?0???$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::emplace<std::pair<TextureToGo * const,Texture> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$2 = 32
this$dead$ = 96
__$ReturnUdt$ = 104
<_Vals_0>$ = 112
?dtor$0@?0???$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::emplace<std::pair<TextureToGo * const,Texture> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$2[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
?dtor$0@?0???$emplace@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::emplace<std::pair<TextureToGo * const,Texture> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
;	COMDAT ??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
_Loc$ = 48
$T3 = 72
this$dead$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 197  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval, _Mappedty&&... _Mapval) {

$LN159:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rbp, r8
	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	r14, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [r14+8]
	mov	QWORD PTR _Loc$[rsp], rbx
	xor	r12d, r12d
	mov	DWORD PTR _Loc$[rsp+8], r12d
	mov	rdi, r14

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	jne	SHORT $LN7@Try_emplac
	npad	3
$LL6@Try_emplac:

; 1616 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR _Loc$[rsp], rbx

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rbp
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	test	al, al
	jns	SHORT $LN8@Try_emplac

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR _Loc$[rsp+8], r12d

; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]

; 1620 :             } else {

	jmp	SHORT $LN9@Try_emplac
$LN8@Try_emplac:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR _Loc$[rsp+8], 1

; 1622 :                 _Result._Bound           = _Trynode;

	mov	rdi, rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rbx, QWORD PTR [rbx]
$LN9@Try_emplac:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	je	SHORT $LL6@Try_emplac
$LN7@Try_emplac:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdi+25], r12b
	jne	SHORT $LN2@Try_emplac
	lea	rdx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rbp
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	test	al, al
	js	SHORT $LN2@Try_emplac
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rsi], rdi
	mov	BYTE PTR [rsi+8], r12b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 200  :             return {_Loc._Bound, false};

	jmp	$LN155@Try_emplac
$LN2@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1631 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 104811045873349725			; 01745d1745d1745dH
	cmp	QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A+8, rax
	je	$LN157@Try_emplac
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	r15, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	mov	QWORD PTR $T2[rsp], r15

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], r12

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR $T2[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 806  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

	lea	rbx, QWORD PTR [rax+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T3[rsp], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, rbp
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	call	??0BfresFile@@QEAA@XZ			; BfresFile::BfresFile
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rdi], r14

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rdi+8], r14

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rdi+16], r14

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rdi+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 212  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	movups	xmm0, XMMWORD PTR _Loc$[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	mov	r8, rdi
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, r15
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Insert_node
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rsi], rax
	mov	BYTE PTR [rsi+8], 1
$LN155@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 213  :     }

	mov	rax, rsi
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN157@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1632 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN154@Try_emplac:
??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Loc$ = 48
$T3 = 72
this$dead$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
?dtor$2@?0???$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
?dtor$2@?0???$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Loc$ = 48
$T3 = 72
this$dead$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
?dtor$1@?0???$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0???$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Loc$ = 48
$T3 = 72
this$dead$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
?dtor$4@?0???$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$4
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$ = 56
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >, COMDAT

; 752  :     void _Erase_head(_Alnode& _Al) noexcept {

$LN49:
	push	rbx
	sub	rsp, 32					; 00000020H

; 753  :         this->_Orphan_all();
; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	r8, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	r8, QWORD PTR [r8+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rbx]
	mov	edx, 176				; 000000b0H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 756  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Unfancy_maybe_null@G@std@@YAPEAGPEAG@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@G@std@@YAPEAGPEAG@Z PROC		; std::_Unfancy_maybe_null<unsigned short>, COMDAT

; 434  :     return _Ptr;

	mov	rax, rcx

; 435  : }

	ret	0
??$_Unfancy_maybe_null@G@std@@YAPEAGPEAG@Z ENDP		; std::_Unfancy_maybe_null<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN36:
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rdi, rcx
	mov	r8, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, r8
	sar	rcx, 1

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r8+rdx*2]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	QWORD PTR [rdi+8], rax
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Resize:

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, r8
	sar	rax, 1

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rdi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	QWORD PTR [rsp+64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	rcx, rsi

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rdx+rdx]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8, rbx
	call	memset

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rbx, QWORD PTR [rsp+64]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	QWORD PTR [rdi+8], rax
$LN3@Resize:
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN8:
	sub	rsp, 40					; 00000028H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r10, QWORD PTR [rcx+8]
	mov	r8, rcx
	mov	r9, QWORD PTR [rcx]
	mov	r11, 7905747460161236407		; 6db6db6db6db6db7H
	mov	rcx, r10
	sub	rcx, r9
	sar	rcx, 3
	imul	rcx, r11

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rax, rdx, 56				; 00000038H
	add	rax, r9

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	QWORD PTR [r8+8], rax
	add	rsp, 40					; 00000028H
	ret	0
$LN2@Resize:

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r8+16]
	sub	rax, r9
	sar	rax, 3
	imul	rax, r11

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r8

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 40					; 00000028H

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, r10
	call	??$_Uninitialized_value_construct_n@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@PEAU12@_KAEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::SkeletonBone> >

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	QWORD PTR [r8+8], rax
$LN3@Resize:
	add	rsp, 40					; 00000028H
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@USkeletonBone@BfresFile@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@USkeletonBone@BfresFile@@@0@AEAV10@@Z PROC ; std::move<std::allocator<BfresFile::SkeletonBone> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@USkeletonBone@BfresFile@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<BfresFile::SkeletonBone> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAUSkeletonBone@BfresFile@@$$T@std@@YAPEAUSkeletonBone@BfresFile@@AEAPEAU12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAUSkeletonBone@BfresFile@@$$T@std@@YAPEAUSkeletonBone@BfresFile@@AEAPEAU12@$$QEA$$T@Z PROC ; std::exchange<BfresFile::SkeletonBone *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAUSkeletonBone@BfresFile@@$$T@std@@YAPEAUSkeletonBone@BfresFile@@AEAPEAU12@$$QEA$$T@Z ENDP ; std::exchange<BfresFile::SkeletonBone *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@USkeletonBone@BfresFile@@@std@@PEAUSkeletonBone@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@USkeletonBone@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@USkeletonBone@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@USkeletonBone@BfresFile@@@1@$$QEAPEAUSkeletonBone@BfresFile@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@USkeletonBone@BfresFile@@@std@@PEAUSkeletonBone@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@USkeletonBone@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@USkeletonBone@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@USkeletonBone@BfresFile@@@1@$$QEAPEAUSkeletonBone@BfresFile@@22@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::SkeletonBone>,std::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >,1>::_Compressed_pair<std::allocator<BfresFile::SkeletonBone>,std::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >,1><std::allocator<BfresFile::SkeletonBone>,BfresFile::SkeletonBone *,BfresFile::SkeletonBone *,BfresFile::SkeletonBone *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@USkeletonBone@BfresFile@@@std@@PEAUSkeletonBone@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@USkeletonBone@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@USkeletonBone@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@USkeletonBone@BfresFile@@@1@$$QEAPEAUSkeletonBone@BfresFile@@22@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::SkeletonBone>,std::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >,1>::_Compressed_pair<std::allocator<BfresFile::SkeletonBone>,std::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >,1><std::allocator<BfresFile::SkeletonBone>,BfresFile::SkeletonBone *,BfresFile::SkeletonBone *,BfresFile::SkeletonBone *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN39:
	mov	QWORD PTR [rsp+24], rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	rcx, QWORD PTR [rcx]
	mov	r8, rsi
	sub	r8, rcx
	mov	r9, 5675921253449092805			; 4ec4ec4ec4ec4ec5H
	sar	r8, 3
	imul	r8, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, r8
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+56], rdi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rdi, rdx, 104				; 00000068H
	add	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rsi
	je	SHORT $LN8@Resize
	mov	QWORD PTR [rsp+48], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbx, QWORD PTR [rdi+48]
	npad	4
$LL9@Resize:

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+24]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	mov	rcx, rbx
	call	?_Tidy@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Tidy
	lea	rcx, QWORD PTR [rbx-24]
	call	?_Tidy@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx-48]
	call	?_Tidy@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 104				; 00000068H
	lea	rax, QWORD PTR [rbx-48]
	cmp	rax, rsi
	jne	SHORT $LL9@Resize
	mov	rbx, QWORD PTR [rsp+48]
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [r14+8], rdi
	mov	rdi, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, r8
	mov	rcx, rsi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@PEAU12@_KAEAV?$allocator@UModel@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Model> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_one_at_back@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_one_at_back<BfresFile::Model const &>, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rcx+8]
	mov	rbx, rcx
	cmp	rax, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, rax
	call	??0Model@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+104]
	mov	QWORD PTR [rbx+8], rdx

; 786  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rax

; 786  :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_reallocate<BfresFile::Model const &>
??$_Emplace_one_at_back@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_one_at_back<BfresFile::Model const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@UModel@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UModel@BfresFile@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@UModel@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UModel@BfresFile@@@0@AEAV10@@Z PROC ; std::move<std::allocator<BfresFile::Model> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@UModel@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UModel@BfresFile@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<BfresFile::Model> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAUModel@BfresFile@@$$T@std@@YAPEAUModel@BfresFile@@AEAPEAU12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAUModel@BfresFile@@$$T@std@@YAPEAUModel@BfresFile@@AEAPEAU12@$$QEA$$T@Z PROC ; std::exchange<BfresFile::Model *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAUModel@BfresFile@@$$T@std@@YAPEAUModel@BfresFile@@AEAPEAU12@$$QEA$$T@Z ENDP ; std::exchange<BfresFile::Model *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@UModel@BfresFile@@@std@@PEAUModel@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UModel@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UModel@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UModel@BfresFile@@@1@$$QEAPEAUModel@BfresFile@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@UModel@BfresFile@@@std@@PEAUModel@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UModel@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UModel@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UModel@BfresFile@@@1@$$QEAPEAUModel@BfresFile@@22@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::Model>,std::_Vector_val<std::_Simple_types<BfresFile::Model> >,1>::_Compressed_pair<std::allocator<BfresFile::Model>,std::_Vector_val<std::_Simple_types<BfresFile::Model> >,1><std::allocator<BfresFile::Model>,BfresFile::Model *,BfresFile::Model *,BfresFile::Model *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@UModel@BfresFile@@@std@@PEAUModel@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UModel@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UModel@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UModel@BfresFile@@@1@$$QEAPEAUModel@BfresFile@@22@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::Model>,std::_Vector_val<std::_Simple_types<BfresFile::Model> >,1>::_Compressed_pair<std::allocator<BfresFile::Model>,std::_Vector_val<std::_Simple_types<BfresFile::Model> >,1><std::allocator<BfresFile::Model>,BfresFile::Model *,BfresFile::Model *,BfresFile::Model *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN36:
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	rdi, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, rdx
	sar	rcx, 6

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdi, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rdi, 6
	add	rdi, rdx
	mov	QWORD PTR [rsp+48], rbx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rsi
	je	SHORT $LN8@Resize
$LL9@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+40]
	call	?_Tidy@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	cmp	rbx, rsi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rdi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rdx
	sar	rax, 6

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdi, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rdi
	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdi, rcx
	mov	rcx, rsi
	mov	rdx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@PEAU12@_KAEAV?$allocator@UMaterial@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Material> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_one_at_back@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_one_at_back<BfresFile::Material const &>, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rcx+8]
	mov	rbx, rcx
	cmp	rax, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, rax
	call	??0Material@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+64]
	mov	QWORD PTR [rbx+8], rdx

; 786  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rax

; 786  :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_reallocate<BfresFile::Material const &>
??$_Emplace_one_at_back@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_one_at_back<BfresFile::Material const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@UMaterial@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UMaterial@BfresFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@UMaterial@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UMaterial@BfresFile@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1>::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1><std::allocator<BfresFile::Material> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@UMaterial@BfresFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UMaterial@BfresFile@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1>::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1><std::allocator<BfresFile::Material> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@$$V@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
??$_Construct_n@$$V@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Construct_n<>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN21:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN17@Construct_
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rbx, rdx
	mov	rdi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN19@Construct_

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@UMaterial@BfresFile@@@std@@QEAAPEAUMaterial@BfresFile@@_K@Z ; std::allocator<BfresFile::Material>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	rcx, rbx
	shl	rcx, 6

; 2066 :             _Buy_nonzero(_Count);
; 2067 :             _Tidy_guard<vector> _Guard{this};
; 2068 :             if constexpr (sizeof...(_Val) == 0) {
; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	rdx, rbx

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rcx, rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rcx

; 2066 :             _Buy_nonzero(_Count);
; 2067 :             _Tidy_guard<vector> _Guard{this};
; 2068 :             if constexpr (sizeof...(_Val) == 0) {
; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	rcx, rax
	call	??$_Uninitialized_value_construct_n@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@PEAU12@_KAEAV?$allocator@UMaterial@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Material> >

; 2070 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2071 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2072 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2073 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+8], rax
	add	rsp, 32					; 00000020H
	pop	rdi
$LN17@Construct_:
	ret	0
$LN19@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Xlength
	int	3
$LN16@Construct_:
??$_Construct_n@$$V@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Construct_n<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1>::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1>::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN41:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]
	mov	rsi, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rbx
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*2]
	mov	QWORD PTR [rsp+64], rdi
	lea	rdi, QWORD PTR [r8+rax*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??$_Destroy_range@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAXPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<float,std::allocator<float> > > >

; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rsi+8], rdi
	mov	rdi, QWORD PTR [rsp+64]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN8@Resize
	xor	eax, eax
	npad	4
$LL9@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL9@Resize
$LN8@Resize:

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rbx
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAXPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<float,std::allocator<float> > > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z PROC ; std::move<std::vector<float,std::allocator<float> > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z ENDP ; std::move<std::vector<float,std::allocator<float> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAAEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAAEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_one_at_back<std::vector<float,std::allocator<float> > >, COMDAT

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	r10, QWORD PTR [rcx+8]
	mov	r8, rdx
	mov	r9, rcx
	cmp	r10, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on

; 805  :         _Ty& _Result = *_Mylast;

	mov	rcx, QWORD PTR [r8+8]
	xor	r11d, r11d
	mov	rax, QWORD PTR [r8+16]
	mov	rdx, QWORD PTR [rdx]
	mov	QWORD PTR [r8+16], r11
	mov	QWORD PTR [r8+8], r11
	mov	QWORD PTR [r8], r11
	mov	QWORD PTR [r10], rdx
	mov	QWORD PTR [r10+8], rcx
	mov	QWORD PTR [r10+16], rax
	mov	rax, QWORD PTR [r9+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+24]
	mov	QWORD PTR [r9+8], rcx

; 786  :     }

	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rdx, r10
	jmp	??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_reallocate<std::vector<float,std::allocator<float> > >
??$_Emplace_one_at_back@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAAEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_one_at_back<std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1>::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1>::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN28:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 5
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rdx+rdx*2]
	shl	rsi, 5
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN8@Resize
	npad	1
$LL9@Resize:
	mov	rcx, rbx
	call	??1LOD@BfresFile@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 5
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@PEAU12@_KAEAV?$allocator@ULOD@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::LOD> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_one_at_back@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_one_at_back<BfresFile::LOD const &>, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rcx+8]
	mov	rbx, rcx
	cmp	rax, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, rax
	call	??0LOD@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+96]
	mov	QWORD PTR [rbx+8], rdx

; 786  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rax

; 786  :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_reallocate<BfresFile::LOD const &>
??$_Emplace_one_at_back@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_one_at_back<BfresFile::LOD const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@ULOD@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@ULOD@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1>::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@ULOD@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1>::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<Mesh,std::allocator<Mesh> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN28:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 5
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rdx+rdx*2]
	shl	rsi, 5
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN8@Resize
	npad	1
$LL9@Resize:
	mov	rcx, rbx
	call	??1Mesh@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 5
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<Mesh,std::allocator<Mesh> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@PEAV1@_KAEAV?$allocator@VMesh@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<Mesh> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<Mesh,std::allocator<Mesh> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@VMesh@@@std@@V?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@VMesh@@@std@@V?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1>::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@VMesh@@@std@@V?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1>::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN41:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]
	mov	rsi, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rcx, rbx
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*2]
	mov	QWORD PTR [rsp+64], rdi
	lea	rdi, QWORD PTR [r8+rax*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??$_Destroy_range@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAXPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >

; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rsi+8], rdi
	mov	rdi, QWORD PTR [rsp+64]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN8@Resize
	xor	eax, eax
	npad	4
$LL9@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL9@Resize
$LN8@Resize:

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rbx
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAXPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z PROC ; std::move<std::vector<unsigned int,std::allocator<unsigned int> > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z ENDP ; std::move<std::vector<unsigned int,std::allocator<unsigned int> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAAEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAAEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_one_at_back<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	r10, QWORD PTR [rcx+8]
	mov	r8, rdx
	mov	r9, rcx
	cmp	r10, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on

; 805  :         _Ty& _Result = *_Mylast;

	mov	rcx, QWORD PTR [r8+8]
	xor	r11d, r11d
	mov	rax, QWORD PTR [r8+16]
	mov	rdx, QWORD PTR [rdx]
	mov	QWORD PTR [r8+16], r11
	mov	QWORD PTR [r8+8], r11
	mov	QWORD PTR [r8], r11
	mov	QWORD PTR [r10], rdx
	mov	QWORD PTR [r10+8], rcx
	mov	QWORD PTR [r10+16], rax
	mov	rax, QWORD PTR [r9+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+24]
	mov	QWORD PTR [r9+8], rcx

; 786  :     }

	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rdx, r10
	jmp	??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_reallocate<std::vector<unsigned int,std::allocator<unsigned int> > >
??$_Emplace_one_at_back@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAAEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_one_at_back<std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1>::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1>::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN28:
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	rdi, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, rdx
	sar	rcx, 6

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdi, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rdi, 6
	add	rdi, rdx
	mov	QWORD PTR [rsp+48], rbx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rsi
	je	SHORT $LN8@Resize
$LL9@Resize:
	mov	rcx, rbx
	call	??1BfresTexture@BfresFile@@QEAA@XZ
	add	rbx, 64					; 00000040H
	cmp	rbx, rsi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rdi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rdx
	sar	rax, 6

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdi, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rdi
	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdi, rcx
	mov	r8, r14
	mov	rdx, rdi
	mov	rcx, rsi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::BfresTexture> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
<_Val_0>$ = 56
??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_one_at_back<BfresFile::BfresTexture const &>, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN16:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rbx, rcx

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdi, QWORD PTR [rcx+8]
	cmp	rdi, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdi
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdi], rax
	lea	rcx, QWORD PTR [rdi+8]
	add	rdx, 8
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rsi+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+64]
	mov	QWORD PTR [rbx+8], rcx

; 786  :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rsi
	mov	rdx, rdi

; 786  :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>
??$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_one_at_back<BfresFile::BfresTexture const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
<_Val_0>$ = 56
?dtor$0@?0???$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z@4HA PROC ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_one_at_back<BfresFile::BfresTexture const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Emplace_one_at_back@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z@4HA ENDP ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_one_at_back<BfresFile::BfresTexture const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UBfresTexture@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UBfresTexture@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1>::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UBfresTexture@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1>::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@@std@@YAPEAV?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@@std@@YAPEAV?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::vector<Texture *,std::allocator<Texture *> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@@std@@YAPEAV?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::vector<Texture *,std::allocator<Texture *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@PEAVTexture@@@std@@@std@@YAXAEAV?$allocator@PEAVTexture@@@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocma@V?$allocator@PEAVTexture@@@std@@@std@@YAXAEAV?$allocator@PEAVTexture@@@0@0@Z PROC ; std::_Pocma<std::allocator<Texture *> >, COMDAT

; 1067 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1068 :         _Left = _STD move(_Right);
; 1069 :     }
; 1070 : }

	ret	0
??$_Pocma@V?$allocator@PEAVTexture@@@std@@@std@@YAXAEAV?$allocator@PEAVTexture@@@0@0@Z ENDP ; std::_Pocma<std::allocator<Texture *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@PEAVTexture@@@std@@$$V@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEAVTexture@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@PEAVTexture@@@std@@$$V@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEAVTexture@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1>::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1><std::allocator<Texture *> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@PEAVTexture@@@std@@$$V@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEAVTexture@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1>::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1><std::allocator<Texture *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z PROC ; std::vector<Texture *,std::allocator<Texture *> >::_Construct_n<Texture * const *,Texture * const *>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN39:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN35@Construct_
	push	rbx
	push	rsi
	push	r14
	sub	rsp, 48					; 00000030H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r14, r9
	mov	rbx, r8
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN37@Construct_
	mov	QWORD PTR [rsp+40], rdi

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	call	?_Buy_raw@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K@Z ; std::vector<Texture *,std::allocator<Texture *> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+40]
	mov	QWORD PTR [rsi+8], rax

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbx
$LN35@Construct_:
	ret	0
$LN37@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@CAXXZ ; std::vector<Texture *,std::allocator<Texture *> >::_Xlength
	int	3
$LN34@Construct_:
??$_Construct_n@PEBQEAVTexture@@PEBQEAV1@@?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@AEAAX_K$$QEAPEBQEAVTexture@@1@Z ENDP ; std::vector<Texture *,std::allocator<Texture *> >::_Construct_n<Texture * const *,Texture * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1>::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1>::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$vector@IV?$allocator@I@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$vector@IV?$allocator@I@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z PROC ; std::addressof<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$vector@IV?$allocator@I@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@I@std@@@std@@YAXAEAV?$allocator@I@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocma@V?$allocator@I@std@@@std@@YAXAEAV?$allocator@I@0@0@Z PROC ; std::_Pocma<std::allocator<unsigned int> >, COMDAT

; 1067 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1068 :         _Left = _STD move(_Right);
; 1069 :     }
; 1070 : }

	ret	0
??$_Pocma@V?$allocator@I@std@@@std@@YAXAEAV?$allocator@I@0@0@Z ENDP ; std::_Pocma<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<float,std::allocator<float> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN36:
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rdi, rcx
	mov	r8, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, r8
	sar	rcx, 2

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r8+rdx*4]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	QWORD PTR [rdi+8], rax
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Resize:

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, r8
	sar	rax, 2

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rdi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<float,std::allocator<float> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	QWORD PTR [rsp+64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	rcx, rsi

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rdx*4]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8, rbx
	call	memset

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rbx, QWORD PTR [rsp+64]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	QWORD PTR [rdi+8], rax
$LN3@Resize:
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<float,std::allocator<float> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$vector@MV?$allocator@M@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$vector@MV?$allocator@M@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z PROC ; std::addressof<std::vector<float,std::allocator<float> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$vector@MV?$allocator@M@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@M@std@@@std@@YAXAEAV?$allocator@M@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocma@V?$allocator@M@std@@@std@@YAXAEAV?$allocator@M@0@0@Z PROC ; std::_Pocma<std::allocator<float> >, COMDAT

; 1067 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1068 :         _Left = _STD move(_Right);
; 1069 :     }
; 1070 : }

	ret	0
??$_Pocma@V?$allocator@M@std@@@std@@YAXAEAV?$allocator@M@0@0@Z ENDP ; std::_Pocma<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@M@std@@$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@M@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@M@std@@$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@M@1@@Z PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@M@std@@$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@M@1@@Z ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z PROC ; std::vector<float,std::allocator<float> >::_Construct_n<>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN45:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN41@Construct_
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rbx, rdx
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN43@Construct_
	mov	QWORD PTR [rsp+64], rdi

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rbx*4]
	mov	QWORD PTR [rsi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdi, rax

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rax]
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	rcx, rax
	call	memset

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	rdi, QWORD PTR [rsp+64]

; 2070 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2071 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2072 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2073 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	QWORD PTR [rsi+8], rax
	add	rsp, 32					; 00000020H
	pop	rsi
$LN41@Construct_:
	ret	0
$LN43@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN40@Construct_:
??$_Construct_n@$$V@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K@Z ENDP ; std::vector<float,std::allocator<float> >::_Construct_n<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEBE_K@Z
_TEXT	SEGMENT
this$ = 80
_First$ = 88
_Newsize$ = 96
??$_Assign_counted_range@PEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEBE_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char const *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN83:
	push	rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, r8
	mov	rax, QWORD PTR [rcx+16]
	mov	r14, rdx
	sub	rax, rbx
	mov	rsi, rcx

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rax
	jbe	SHORT $LN5@Assign_cou

; 1395 :             _Clear_and_reserve_geometric(_Newsize);

	mov	rdx, r8
	call	?_Clear_and_reserve_geometric@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Clear_and_reserve_geometric

; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rbx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdi
	mov	rcx, rbx
	mov	rdx, r14
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1441 :     }

	mov	QWORD PTR [rsi+8], rax
	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN5@Assign_cou:
	mov	QWORD PTR [rsp+32], rbp

; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1402 :             }
; 1403 :             return;
; 1404 :         }
; 1405 : 
; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbp, QWORD PTR [rcx+8]

; 1407 :         if (_Newsize > _Oldsize) {

	mov	rcx, rbx
	sub	rbp, rbx
	cmp	rdi, rbp
	jbe	SHORT $LN6@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbp
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1416 :                     _Copied = true;

	mov	rbx, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR [r14+rbp]

; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {
; 1422 :                     *_Mid = *_First;
; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rbx
	mov	r8, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1434 :         } else {

	jmp	SHORT $LN80@Assign_cou
$LN6@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rbx+rdi]
$LN80@Assign_cou:

; 1441 :     }

	mov	QWORD PTR [rsi+8], rax
	mov	rbp, QWORD PTR [rsp+32]
	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Assign_counted_range@PEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEBE_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z PROC ; std::_Destroy_range<std::allocator<BfresFile::VertexBuffer> >, COMDAT

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN62:

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN59@Destroy_ra
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rsp+56], rbx
	mov	rdi, rdx
	mov	QWORD PTR [rsp+64], rsi
	lea	rbx, QWORD PTR [rcx+32]
	xor	esi, esi
	npad	3
$LL4@Destroy_ra:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx-16]
	test	rcx, rcx
	je	SHORT $LN19@Destroy_ra

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN37@Destroy_ra

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN34@Destroy_ra

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN37@Destroy_ra:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx-16], rsi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx-8], rsi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx], rsi
$LN19@Destroy_ra:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	lea	rax, QWORD PTR [rbx-32]
	cmp	rax, rdi
	jne	SHORT $LL4@Destroy_ra
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]

; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	add	rsp, 32					; 00000020H
	pop	rdi
$LN59@Destroy_ra:
	ret	0
$LN34@Destroy_ra:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN58@Destroy_ra:
??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<BfresFile::VertexBuffer> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAXPEAUVertexBufferAttribute@BfresFile@@QEAU12@AEAV?$allocator@UVertexBufferAttribute@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAXPEAUVertexBufferAttribute@BfresFile@@QEAU12@AEAV?$allocator@UVertexBufferAttribute@BfresFile@@@0@@Z PROC ; std::_Destroy_range<std::allocator<BfresFile::VertexBufferAttribute> >, COMDAT

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN27:

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN24@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN24@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAXPEAUVertexBufferAttribute@BfresFile@@QEAU12@AEAV?$allocator@UVertexBufferAttribute@BfresFile@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<BfresFile::VertexBufferAttribute> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAXPEAUVertexBufferSize@BfresFile@@QEAU12@AEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAXPEAUVertexBufferSize@BfresFile@@QEAU12@AEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z PROC ; std::_Destroy_range<std::allocator<BfresFile::VertexBufferSize> >, COMDAT

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {
; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	ret	0
??$_Destroy_range@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAXPEAUVertexBufferSize@BfresFile@@QEAU12@AEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<BfresFile::VertexBufferSize> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN27:

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN24@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1082 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN24@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>, COMDAT

; 1094 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1095 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1096 :         for (; _First != _Last; ++_First) {
; 1097 :             _Destroy_in_place(*_First);
; 1098 :         }
; 1099 :     }
; 1100 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > ><std::allocator<std::pair<TextureToGo * const,Texture> > const &,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 267  :     }

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > ><std::allocator<std::pair<TextureToGo * const,Texture> > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Head$ = 56
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<TextureToGo * const,Texture>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >, COMDAT

; 324  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN76:
	push	rbx
	sub	rsp, 32					; 00000020H

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rbx, QWORD PTR [rdx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rbx, rbx
	je	SHORT $LN3@Free_non_h
	mov	QWORD PTR [rsp+48], rdi
	npad	2
$LL4@Free_non_h:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rdi, QWORD PTR [rbx]

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rbx, rdi
	test	rdi, rdi
	jne	SHORT $LL4@Free_non_h
	mov	rdi, QWORD PTR [rsp+48]
$LN3@Free_non_h:

; 330  :             _Freenode(_Al, _Pnode);
; 331  :         }
; 332  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<TextureToGo * const,Texture>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<TextureToGo * const,Texture>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >, COMDAT

; 308  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<TextureToGo * const,Texture>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@PEAVTextureToGo@@@std@@V?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$dead$ = 24
<_Val2_1>$ = 32
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@PEAVTextureToGo@@@std@@V?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z PROC ; std::_Compressed_pair<std::hash<TextureToGo *>,std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>,1>::_Compressed_pair<std::hash<TextureToGo *>,std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>,1><std::_Zero_then_variadic_args_t,float>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, DWORD PTR [r9]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@PEAVTextureToGo@@@std@@V?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ENDP ; std::_Compressed_pair<std::hash<TextureToGo *>,std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>,1>::_Compressed_pair<std::hash<TextureToGo *>,std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>,1><std::_Zero_then_variadic_args_t,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$dead$ = 32
??$?0AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Zero_then_variadic_args_t>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	xorps	xmm0, xmm0
	lea	rax, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	movdqa	XMMWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAXPEAU?$mat@$03$03M$0A@@glm@@QEAU12@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAXPEAU?$mat@$03$03M$0A@@glm@@QEAU12@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z PROC ; std::_Destroy_range<std::allocator<glm::mat<4,4,float,0> > >, COMDAT

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {
; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	ret	0
??$_Destroy_range@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAXPEAU?$mat@$03$03M$0A@@glm@@QEAU12@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >, COMDAT

; 1602 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rcx, rdx

; 1987 :     // copy _Val throughout raw [_First, _Last)
; 1988 :     _Adl_verify_range(_First, _Last);
; 1989 :     auto _UFirst      = _Get_unwrapped(_First);
; 1990 :     const auto _ULast = _Get_unwrapped(_Last);
; 1991 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1992 :         _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1993 :     } else {
; 1994 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1995 :             if (_Is_all_bits_zero(_Val)) {
; 1996 :                 _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1997 :                 return;
; 1998 :             }
; 1999 :         }
; 2000 : 
; 2001 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 2002 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN3@uninitiali
	npad	11
$LL2@uninitiali:

; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax

; 1617 :         ++_Last;

	add	rcx, 8

; 1987 :     // copy _Val throughout raw [_First, _Last)
; 1988 :     _Adl_verify_range(_First, _Last);
; 1989 :     auto _UFirst      = _Get_unwrapped(_First);
; 1990 :     const auto _ULast = _Get_unwrapped(_Last);
; 1991 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1992 :         _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1993 :     } else {
; 1994 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1995 :             if (_Is_all_bits_zero(_Val)) {
; 1996 :                 _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1997 :                 return;
; 1998 :             }
; 1999 :         }
; 2000 : 
; 2001 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 2002 :         while (_Backout._Last != _ULast) {

	cmp	rcx, rdx
	jne	SHORT $LL2@uninitiali
$LN3@uninitiali:

; 2003 :             _Backout._Emplace_back(_Val);
; 2004 :         }
; 2005 : 
; 2006 :         _Backout._Release();
; 2007 :     }
; 2008 : }

	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Val$ = 32
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >, COMDAT

; 5032 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN21:
	sub	rsp, 8
	mov	r10, rdx
	xor	eax, eax
	sub	rdx, rcx
	mov	r9, rcx
	add	rdx, 7
	shr	rdx, 3
	cmp	rcx, r10
	cmova	rdx, rax

; 5033 :     // copy _Val through [_First, _Last)
; 5034 :     _Adl_verify_range(_First, _Last);
; 5035 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5036 :         _Fill_vbool(_First, _Last, _Val);
; 5037 :     } else {
; 5038 :         auto _UFirst      = _Get_unwrapped(_First);
; 5039 :         const auto _ULast = _Get_unwrapped(_Last);
; 5040 : #if _HAS_CXX20
; 5041 :         if (!_STD is_constant_evaluated())
; 5042 : #endif // _HAS_CXX20
; 5043 :         {
; 5044 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5045 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5046 :                 return;
; 5047 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5048 :                 if (_Is_all_bits_zero(_Val)) {
; 5049 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5050 :                     return;
; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	test	rdx, rdx
	je	SHORT $LN10@fill
	cmp	rdx, 2
	jb	SHORT $LN10@fill

; 5056 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	add	rcx, -8
	lea	rcx, QWORD PTR [rcx+rdx*8]
	cmp	r9, r8
	ja	SHORT $LN11@fill

; 5032 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

	cmp	rcx, r8
	jae	SHORT $LN10@fill
$LN11@fill:
	mov	QWORD PTR [rsp], rdi
	and	rdx, -2
	mov	rdi, r9
	lea	rdx, QWORD PTR [rdx*8]
	mov	rcx, rdx
	shr	rcx, 3
	rep stosq
	add	r9, rdx
	mov	rdi, QWORD PTR [rsp]
$LN10@fill:

; 5033 :     // copy _Val through [_First, _Last)
; 5034 :     _Adl_verify_range(_First, _Last);
; 5035 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5036 :         _Fill_vbool(_First, _Last, _Val);
; 5037 :     } else {
; 5038 :         auto _UFirst      = _Get_unwrapped(_First);
; 5039 :         const auto _ULast = _Get_unwrapped(_Last);
; 5040 : #if _HAS_CXX20
; 5041 :         if (!_STD is_constant_evaluated())
; 5042 : #endif // _HAS_CXX20
; 5043 :         {
; 5044 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5045 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5046 :                 return;
; 5047 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5048 :                 if (_Is_all_bits_zero(_Val)) {
; 5049 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5050 :                     return;
; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r9, r10
	je	SHORT $LN3@fill
	npad	9
$LL9@fill:

; 5056 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [r9], rax
	add	r9, 8
	cmp	r9, r10
	jne	SHORT $LL9@fill
$LN3@fill:

; 5057 :         }
; 5058 :     }
; 5059 : }

	add	rsp, 8
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1><std::allocator<std::pair<TextureToGo * const,Texture> > const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1><std::allocator<std::pair<TextureToGo * const,Texture> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >, COMDAT

; 344  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

$LN29:
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 351  :         _Pnode->_Isnil = true;
; 352  :         return _Pnode;
; 353  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::_Release, COMDAT

; 1621 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1622 :         return _Last;
; 1623 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>, COMDAT

; 1610 :         _Destroy_range(_First, _Last);
; 1611 :     }

	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>, COMDAT

; 1602 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map@PEAVTextureToGo@@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@SAAEBQEAVTextureToGo@@AEBU?$pair@QEAVTextureToGo@@VTexture@@@2@@Z
_TEXT	SEGMENT
_Val$ = 8
?_Extract@?$_In_place_key_extract_map@PEAVTextureToGo@@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@SAAEBQEAVTextureToGo@@AEBU?$pair@QEAVTextureToGo@@VTexture@@@2@@Z PROC ; std::_In_place_key_extract_map<TextureToGo *,std::pair<TextureToGo * const,Texture> >::_Extract, COMDAT

; 2113 :         return _Val.first;

	mov	rax, rcx

; 2114 :     }

	ret	0
?_Extract@?$_In_place_key_extract_map@PEAVTextureToGo@@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@SAAEBQEAVTextureToGo@@AEBU?$pair@QEAVTextureToGo@@VTexture@@@2@@Z ENDP ; std::_In_place_key_extract_map<TextureToGo *,std::pair<TextureToGo * const,Texture> >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >, COMDAT

; 589  :     ~_List_node_emplace_op2() {

$LN48:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 590  :         if (this->_Ptr != pointer{}) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN9@List_node_

; 591  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

	add	rcx, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN9@List_node_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1156 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN27@List_node_

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 593  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN27@List_node_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 593  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_Release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1148 :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> > >::~_Tidy_guard<std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> > >::~_Tidy_guard<std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> > >::~_Tidy_guard<std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> > >::~_Tidy_guard<std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> > >::~_Tidy_guard<std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> > >::~_Tidy_guard<std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN45:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 461168601842738790			; 0666666666666666H
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN43@Buy_nonzer
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN14@Buy_nonzer

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN44@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN23@Buy_nonzer

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN23@Buy_nonzer:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@Buy_nonzer:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN15@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN15@Buy_nonzer:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN12@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax

; 2011 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN43@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Xlength
	int	3
$LN44@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN41@Buy_nonzer:
?_Buy_nonzero@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN45:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 461168601842738790			; 0666666666666666H
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN43@Buy_nonzer
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN14@Buy_nonzer

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN44@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN23@Buy_nonzer

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN23@Buy_nonzer:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@Buy_nonzer:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN15@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN15@Buy_nonzer:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN12@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax

; 2011 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN43@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Xlength
	int	3
$LN44@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN41@Buy_nonzer:
?_Buy_nonzero@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN45:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN43@Buy_nonzer
	mov	QWORD PTR [rsp+48], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN14@Buy_nonzer

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN44@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN23@Buy_nonzer

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN23@Buy_nonzer:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@Buy_nonzer:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN15@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN15@Buy_nonzer:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN12@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax

; 2011 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN43@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Xlength
	int	3
$LN44@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN41@Buy_nonzer:
?_Buy_nonzero@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,std::_Iterator_base0>, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx

; 39   :         this->_Adopt(_Plist);
; 40   :     }

	mov	rax, rcx
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_scary@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Get_scary, COMDAT

; 1969 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	rax, rcx

; 1970 :     }

	ret	0
?_Get_scary@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Rehash_for_1, COMDAT

; 1658 :     void _Rehash_for_1() {

$LN23:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1659 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;
; 1660 :         const auto _Newsize = _Oldsize + 1;

	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16

; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0

; 1659 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;
; 1660 :         const auto _Newsize = _Oldsize + 1;

	add	rcx, 1

; 1688 :         const size_type _Old_buckets = bucket_count();

	mov	rbx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+56

; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	js	SHORT $LN14@Rehash_for
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN15@Rehash_for
$LN14@Rehash_for:
	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN15@Rehash_for:
	divss	xmm0, DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	ecx, ecx
	comiss	xmm0, xmm1
	jb	SHORT $LN13@Rehash_for
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN13@Rehash_for
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN13@Rehash_for:
	cvttss2si rax, xmm0
	add	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 8
	cmp	rax, rcx
	cmova	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1690 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rbx, rcx
	jae	SHORT $LN3@Rehash_for

; 1691 :             // we already have enough buckets so there's no need to change the count
; 1692 :             return _Old_buckets;
; 1693 :         }
; 1694 : 
; 1695 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rbx, 512				; 00000200H
	jae	SHORT $LN5@Rehash_for
	lea	rbx, QWORD PTR [rbx*8]
	cmp	rbx, rcx
	jae	SHORT $LN3@Rehash_for
$LN5@Rehash_for:

; 1696 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1697 :             return _Old_buckets * 8;
; 1698 :         }
; 1699 : 
; 1700 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1701 :         return _Req_buckets;

	mov	rbx, rcx
$LN3@Rehash_for:

; 1661 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, rbx

; 1662 :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1661 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	jmp	?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Forced_rehash
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Check_rehash_required_1, COMDAT

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1654 :         const auto _Newsize      = _Oldsize + 1;

	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	add	rcx, 1
	js	SHORT $LN7@Check_reha
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN8@Check_reha
$LN7@Check_reha:
	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN8@Check_reha:
	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+56
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN5@Check_reha
	cvtsi2ss xmm1, rcx
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A
	seta	al

; 1656 :     }

	ret	0
$LN5@Check_reha:

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A
	seta	al

; 1656 :     }

	ret	0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Check_max_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Check_max_size, COMDAT

; 1645 :     void _Check_max_size() const {

$LN6:
	sub	rsp, 40					; 00000028H

; 1646 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 256204778801521550			; 038e38e38e38e38eH
	cmp	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16, rax
	jne	SHORT $LN2@Check_max_

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2@Check_max_:

; 1649 :         }
; 1650 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@Check_max_:
?_Check_max_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
this$dead$ = 8
_Hashval$ = 16
_Insert_before$ = 24
_Newnode$ = 32
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Insert_new_node_before, COMDAT

; 1615 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	r10, QWORD PTR [r8+8]
	mov	rax, r9

; 1616 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16
	mov	r9, rdx

; 1617 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rax], r8

; 1618 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rax+8], r10

; 1619 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [r10], rax

; 1620 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [r8+8], rax

; 1621 : 
; 1622 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1623 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;
; 1624 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
	mov	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	and	rcx, r9

; 1625 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rcx, rcx

; 1626 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1627 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r9, QWORD PTR [rdx+rcx*8]
	cmp	r9, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
	jne	SHORT $LN2@Insert_new

; 1628 :             // bucket is empty, set both
; 1629 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rdx+rcx*8], rax

; 1635 :             // new node is the highest element in the bucket
; 1636 :             _Bucket_hi._Ptr = _Newnode;
; 1637 :         }
; 1638 : 
; 1639 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1640 :         _Stl_internal_check_container_invariants();
; 1641 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1642 :         return _Newnode;
; 1643 :     }

	mov	QWORD PTR [rdx+rcx*8+8], rax
	ret	0
$LN2@Insert_new:

; 1630 :             _Bucket_hi._Ptr = _Newnode;
; 1631 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r9, r8
	jne	SHORT $LN4@Insert_new

; 1632 :             // new node is the lowest element in the bucket
; 1633 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rdx+rcx*8], rax

; 1635 :             // new node is the highest element in the bucket
; 1636 :             _Bucket_hi._Ptr = _Newnode;
; 1637 :         }
; 1638 : 
; 1639 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1640 :         _Stl_internal_check_container_invariants();
; 1641 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1642 :         return _Newnode;
; 1643 :     }

	ret	0
$LN4@Insert_new:

; 1634 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rdx+rcx*8+8], r10
	jne	SHORT $LN8@Insert_new

; 1635 :             // new node is the highest element in the bucket
; 1636 :             _Bucket_hi._Ptr = _Newnode;
; 1637 :         }
; 1638 : 
; 1639 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1640 :         _Stl_internal_check_container_invariants();
; 1641 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1642 :         return _Newnode;
; 1643 :     }

	mov	QWORD PTR [rdx+rcx*8+8], rax
$LN8@Insert_new:
	ret	0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >, COMDAT

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Make_iter, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], r8

; 1122 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, rdx

; 1123 :     }

	ret	0
?_Make_iter@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::deallocate, COMDAT

; 701  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USkeletonBone@BfresFile@@@std@@@std@@QEAA@PEAUSkeletonBone@BfresFile@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@USkeletonBone@BfresFile@@@std@@@std@@QEAA@PEAUSkeletonBone@BfresFile@@00@Z PROC ; std::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@USkeletonBone@BfresFile@@@std@@@std@@QEAA@PEAUSkeletonBone@BfresFile@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >::_Vector_val<std::_Simple_types<BfresFile::SkeletonBone> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEBAXPEAUSkeletonBone@BfresFile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEBAXPEAUSkeletonBone@BfresFile@@0@Z PROC ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEBAXPEAUSkeletonBone@BfresFile@@0@Z ENDP ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UModel@BfresFile@@@std@@@std@@QEAA@PEAUModel@BfresFile@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@UModel@BfresFile@@@std@@@std@@QEAA@PEAUModel@BfresFile@@00@Z PROC ; std::_Vector_val<std::_Simple_types<BfresFile::Model> >::_Vector_val<std::_Simple_types<BfresFile::Model> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@UModel@BfresFile@@@std@@@std@@QEAA@PEAUModel@BfresFile@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<BfresFile::Model> >::_Vector_val<std::_Simple_types<BfresFile::Model> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEBAXPEAUModel@BfresFile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEBAXPEAUModel@BfresFile@@0@Z PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEBAXPEAUModel@BfresFile@@0@Z ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEBAXPEAUMaterial@BfresFile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEBAXPEAUMaterial@BfresFile@@0@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEBAXPEAUMaterial@BfresFile@@0@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEBAXPEAV?$vector@MV?$allocator@M@std@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEBAXPEAV?$vector@MV?$allocator@M@std@@@2@0@Z PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEBAXPEAV?$vector@MV?$allocator@M@std@@@2@0@Z ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::vector<float,std::allocator<float> > >::allocator<std::vector<float,std::allocator<float> > >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::vector<float,std::allocator<float> > >::allocator<std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEBAXPEAULOD@BfresFile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEBAXPEAULOD@BfresFile@@0@Z PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEBAXPEAULOD@BfresFile@@0@Z ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@ULOD@BfresFile@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@ULOD@BfresFile@@@std@@QEAA@XZ PROC	; std::allocator<BfresFile::LOD>::allocator<BfresFile::LOD>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@ULOD@BfresFile@@@std@@QEAA@XZ ENDP	; std::allocator<BfresFile::LOD>::allocator<BfresFile::LOD>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEBAXPEAVMesh@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEBAXPEAVMesh@@0@Z PROC ; std::vector<Mesh,std::allocator<Mesh> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEBAXPEAVMesh@@0@Z ENDP ; std::vector<Mesh,std::allocator<Mesh> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@VMesh@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@VMesh@@@std@@QEAA@XZ PROC		; std::allocator<Mesh>::allocator<Mesh>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@VMesh@@@std@@QEAA@XZ ENDP		; std::allocator<Mesh>::allocator<Mesh>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEBAXPEAV?$vector@IV?$allocator@I@std@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEBAXPEAV?$vector@IV?$allocator@I@std@@@2@0@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEBAXPEAV?$vector@IV?$allocator@I@std@@@2@0@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEBAXPEAUBfresTexture@BfresFile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEBAXPEAUBfresTexture@BfresFile@@0@Z PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEBAXPEAUBfresTexture@BfresFile@@0@Z ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UBfresTexture@BfresFile@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UBfresTexture@BfresFile@@@std@@QEAA@XZ PROC ; std::allocator<BfresFile::BfresTexture>::allocator<BfresFile::BfresTexture>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UBfresTexture@BfresFile@@@std@@QEAA@XZ ENDP ; std::allocator<BfresFile::BfresTexture>::allocator<BfresFile::BfresTexture>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAA@XZ PROC ; std::allocator<glm::mat<4,4,float,0> >::allocator<glm::mat<4,4,float,0> >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAA@XZ ENDP ; std::allocator<glm::mat<4,4,float,0> >::allocator<glm::mat<4,4,float,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@AEBAXPEAM0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@AEBAXPEAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@AEBAXPEAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >, COMDAT

; 1156 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@Alloc_cons

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN8@Alloc_cons:

; 1157 :             _Al.deallocate(_Ptr, 1);
; 1158 :         }
; 1159 :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@CAXXZ PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@CAXXZ ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 461168601842738790			; 0666666666666666H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	cmp	rdx, rax
	ja	SHORT $LN31@Buy_raw

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	lea	rbx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN11@Buy_raw

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN31@Buy_raw

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@Buy_raw

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN20@Buy_raw:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@Buy_raw:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN12@Buy_raw

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN12@Buy_raw:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN9@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN31@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN38@Buy_raw:
?_Buy_raw@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 461168601842738790			; 0666666666666666H

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@CAXXZ PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@CAXXZ ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 461168601842738790			; 0666666666666666H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	cmp	rdx, rax
	ja	SHORT $LN31@Buy_raw

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	lea	rbx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN11@Buy_raw

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN31@Buy_raw

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@Buy_raw

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN20@Buy_raw:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@Buy_raw:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN12@Buy_raw

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN12@Buy_raw:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN9@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN31@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN38@Buy_raw:
?_Buy_raw@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 461168601842738790			; 0666666666666666H

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@CAXXZ PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@CAXXZ ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	cmp	rdx, rax
	ja	SHORT $LN31@Buy_raw

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN11@Buy_raw

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN31@Buy_raw

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@Buy_raw

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN20@Buy_raw:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@Buy_raw:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN12@Buy_raw

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN12@Buy_raw:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN9@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN31@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN38@Buy_raw:
?_Buy_raw@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Buckets$ = 56
?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Forced_rehash, COMDAT

; 1708 :     void _Forced_rehash(size_type _Buckets) {

$LN151:
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 42   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1716 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	edi, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 42   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1716 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	eax, edi
	shl	rax, cl

; 1717 :         if (_Buckets > _Max_storage_buckets) {

	cmp	rdx, rax
	jbe	SHORT $LN8@Forced_reh

; 1718 :             _Xlength_error("invalid hash bucket count");

	lea	rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN8@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	lea	rax, QWORD PTR [rdx-1]
	mov	QWORD PTR [rsp+48], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rbx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 26   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	rax, rdi

; 42   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1728 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	r8, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1725 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	shl	rdi, cl

; 1728 :         _Vec._Assign_grow(_Buckets << 1, _End);

	lea	rcx, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	lea	rdx, QWORD PTR [rdi+rdi]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Assign_grow
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1729 :         _Mask   = _Buckets - 1;

	lea	r9, QWORD PTR [rdi-1]
	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48, r9

; 1730 :         _Maxidx = _Buckets;

	mov	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+56, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	je	$LN146@Forced_reh
	mov	QWORD PTR [rsp+64], rsi
	mov	rdi, 1099511628211			; 00000100000001b3H
	mov	rsi, -3750763034362895579		; cbf29ce484222325H
$LL4@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	edx, BYTE PTR [rax+17]
	movzx	r11d, BYTE PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 51   :         _Ptr = _Ptr->_Next;

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	r11, rsi

; 2346 :         _Val *= _FNV_prime;

	imul	r11, rdi
	xor	r11, rdx
	movzx	edx, BYTE PTR [rax+18]
	imul	r11, rdi
	xor	r11, rdx
	movzx	edx, BYTE PTR [rax+19]
	imul	r11, rdi
	xor	r11, rdx
	movzx	edx, BYTE PTR [rax+20]
	imul	r11, rdi
	xor	r11, rdx
	movzx	edx, BYTE PTR [rax+21]
	imul	r11, rdi
	xor	r11, rdx
	movzx	edx, BYTE PTR [rax+22]
	imul	r11, rdi
	xor	r11, rdx
	movzx	edx, BYTE PTR [rax+23]
	imul	r11, rdi
	xor	r11, rdx
	imul	r11, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	r11, r9

; 1738 :             ++_Next_inserted;
; 1739 : 
; 1740 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);
; 1741 :             const size_type _Bucket = bucket(_Inserted_key);
; 1742 : 
; 1743 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1744 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1745 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	shl	r11, 4
	add	r11, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	mov	r9, QWORD PTR [r11]
	cmp	r9, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1748 :             if (_Bucket_lo == _End) {

	jne	SHORT $LN9@Forced_reh

; 1749 :                 // The bucket was empty, set it to the inserted element.
; 1750 :                 _Bucket_lo = _Inserted;

	mov	QWORD PTR [r11], rax

; 1751 :                 _Bucket_hi = _Inserted;

	mov	QWORD PTR [r11+8], rax

; 1752 :                 continue;

	jmp	SHORT $LN2@Forced_reh
$LN9@Forced_reh:

; 1753 :             }
; 1754 : 
; 1755 :             // Search the bucket for the insertion location and move element if necessary.
; 1756 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	mov	rdx, QWORD PTR [r11+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	r8, QWORD PTR [rax+16]
	cmp	r8, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1757 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	jne	SHORT $LN10@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 51   :         _Ptr = _Ptr->_Next;

	mov	r10, QWORD PTR [rdx]
	cmp	r10, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1761 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	je	SHORT $LN131@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r9, QWORD PTR [rax+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r9], rcx

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r8, QWORD PTR [rcx+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r8], r10

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	rdx, QWORD PTR [r10+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rdx], rax

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [r10+8], r8

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r9

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], rdx
$LN131@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1765 :                 _Bucket_hi = _Inserted;

	mov	QWORD PTR [r11+8], rax

; 1766 :                 continue;

	jmp	SHORT $LN2@Forced_reh
$LN10@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1772 :                 if (_Bucket_lo == _Insert_before) {

	je	SHORT $LN112@Forced_reh
	npad	2
$LL5@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 62   :         _Ptr = _Ptr->_Prev;

	mov	rdx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	r8, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1782 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

	je	SHORT $LN113@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1772 :                 if (_Bucket_lo == _Insert_before) {

	jne	SHORT $LL5@Forced_reh
$LN112@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r10, QWORD PTR [rax+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r10], rcx

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r9, QWORD PTR [rcx+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r9], rdx

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	r8, QWORD PTR [rdx+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [r8], rax

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rdx+8], r9

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r10

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1778 :                     _Bucket_lo = _Inserted;

	mov	QWORD PTR [r11], rax
$LN2@Forced_reh:

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	je	SHORT $LN147@Forced_reh
	mov	r9, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
	jmp	$LL4@Forced_reh
$LN113@Forced_reh:

; 1783 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1784 :                     ++_Insert_before;
; 1785 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1786 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1787 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r10, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r9, QWORD PTR [rax+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r9], rcx

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r8, QWORD PTR [rcx+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r8], r10

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	rdx, QWORD PTR [r10+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rdx], rax

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [r10+8], r8

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r9

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], rdx
	jmp	SHORT $LN2@Forced_reh
$LN147@Forced_reh:
	mov	rsi, QWORD PTR [rsp+64]
$LN146@Forced_reh:
	mov	rbx, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1798 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN148@Forced_reh:
?_Forced_rehash@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_For_size$ = 56
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Desired_grow_bucket_count, COMDAT

; 1687 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN21:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1688 :         const size_type _Old_buckets = bucket_count();

	mov	rbx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+56

; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN12@Desired_gr
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN13@Desired_gr
$LN12@Desired_gr:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN13@Desired_gr:
	divss	xmm0, DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	eax, eax
	comiss	xmm0, xmm1
	jb	SHORT $LN11@Desired_gr
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN11@Desired_gr
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	rax, rcx
$LN11@Desired_gr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	edx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	cvttss2si rcx, xmm0
	add	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmp	rcx, rdx
	cmova	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1690 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rbx, rdx
	jb	SHORT $LN2@Desired_gr

; 1691 :             // we already have enough buckets so there's no need to change the count
; 1692 :             return _Old_buckets;

	mov	rax, rbx

; 1696 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1697 :             return _Old_buckets * 8;
; 1698 :         }
; 1699 : 
; 1700 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1701 :         return _Req_buckets;
; 1702 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Desired_gr:

; 1693 :         }
; 1694 : 
; 1695 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rbx, 512				; 00000200H
	jae	SHORT $LN3@Desired_gr
	lea	rax, QWORD PTR [rbx*8]
	cmp	rax, rdx
	cmovae	rdx, rax
$LN3@Desired_gr:

; 1696 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1697 :             return _Old_buckets * 8;
; 1698 :         }
; 1699 : 
; 1700 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1701 :         return _Req_buckets;
; 1702 :     }

	mov	rax, rdx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_load_factor@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::max_load_factor, COMDAT

; 911  :         return _Max_bucket_size();

	movss	xmm0, DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A

; 912  :     }

	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::bucket_count, COMDAT

; 846  :         return _Maxidx;

	mov	rax, QWORD PTR [rcx+56]

; 847  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?max_size@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::max_size, COMDAT

; 1193 :         return (_STD min)(

	mov	rax, 256204778801521550			; 038e38e38e38e38eH

; 1194 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1195 :     }

	ret	0
?max_size@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Clear_guard@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 483  :             if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::clear

; 484  :                 _Target->clear();
; 485  :             }
; 486  :         }

	ret	0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Target_$dead$ = 16
??0_Clear_guard@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 477  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	lea	rax, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBuffer@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBuffer@BfresFile@@@2@XZ PROC ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UVertexBuffer@BfresFile@@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBuffer@BfresFile@@@2@XZ ENDP ; std::vector<BfresFile::VertexBuffer,std::allocator<BfresFile::VertexBuffer> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBuffer@BfresFile@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBuffer@BfresFile@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBuffer> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 461168601842738790			; 0666666666666666H

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBuffer@BfresFile@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBuffer> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAPEAUVertexBuffer@BfresFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAPEAUVertexBuffer@BfresFile@@_K@Z PROC ; std::allocator<BfresFile::VertexBuffer>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 461168601842738790			; 0666666666666666H
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	lea	rcx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UVertexBuffer@BfresFile@@@std@@QEAAPEAUVertexBuffer@BfresFile@@_K@Z ENDP ; std::allocator<BfresFile::VertexBuffer>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ PROC ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UVertexBufferAttribute@BfresFile@@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ ENDP ; std::vector<BfresFile::VertexBufferAttribute,std::allocator<BfresFile::VertexBufferAttribute> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferAttribute> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 461168601842738790			; 0666666666666666H

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferAttribute> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@_K@Z PROC ; std::allocator<BfresFile::VertexBufferAttribute>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 461168601842738790			; 0666666666666666H
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	lea	rcx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UVertexBufferAttribute@BfresFile@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@_K@Z ENDP ; std::allocator<BfresFile::VertexBufferAttribute>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ PROC ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UVertexBufferSize@BfresFile@@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@AEBAAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ ENDP ; std::vector<BfresFile::VertexBufferSize,std::allocator<BfresFile::VertexBufferSize> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferSize> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@SA_KAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferSize> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAPEAUVertexBufferSize@BfresFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAPEAUVertexBufferSize@BfresFile@@_K@Z PROC ; std::allocator<BfresFile::VertexBufferSize>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UVertexBufferSize@BfresFile@@@std@@QEAAPEAUVertexBufferSize@BfresFile@@_K@Z ENDP ; std::allocator<BfresFile::VertexBufferSize>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator--, COMDAT

; 62   :         _Ptr = _Ptr->_Prev;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax+8]

; 63   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 64   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::max_size, COMDAT

; 277  :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 278  :             _Aliter_traits::max_size(_Mypair._Get_first()));
; 279  :     }

	ret	0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Max_bucket_size, COMDAT

; 1805 :         return _Traitsobj._Get_max_bucket_size();

	lea	rax, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures

; 1806 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_For_size$ = 56
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Min_load_factor_buckets, COMDAT

; 1682 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN10:
	sub	rsp, 40					; 00000028H

; 1683 :         // returns the minimum number of buckets necessary for the elements in _List
; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN6@Min_load_f
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN7@Min_load_f
$LN6@Min_load_f:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN7@Min_load_f:
	divss	xmm0, DWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	ecx, ecx
	comiss	xmm0, xmm1
	jb	SHORT $LN5@Min_load_f
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN5@Min_load_f
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN5@Min_load_f:
	cvttss2si rax, xmm0
	add	rax, rcx

; 1685 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KAEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
this$ = 8
_Keyval$ = 16
?bucket@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KAEBQEAVTextureToGo@@@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::bucket, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]

; 2346 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+4]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+5]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+6]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+7]
	imul	r8, r9
	xor	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR [rcx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	imul	r8, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	rax, r8

; 856  :     }

	ret	0
?bucket@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEBA_KAEBQEAVTextureToGo@@@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_Before$ = 8
_First$ = 16
_Last$ = 24
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_Unchecked_splice, COMDAT

; 470  :         // splice [_First, _Last) before _Before; returns _Last
; 471  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 472  :         // 3 reads and 6 writes
; 473  : 
; 474  :         // fixup the _Next values
; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r10, QWORD PTR [rdx+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r10], r8

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r9, QWORD PTR [r8+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r9], rcx

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR [rcx+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rax], rdx

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rcx+8], r9

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [r8+8], r10

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rdx+8], rax

; 486  : 
; 487  :         return _Last;

	mov	rax, r8

; 488  :     }

	ret	0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Getal@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Getal, COMDAT

; 1852 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1853 :     }

	ret	0
?_Getal@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 256204778801521550			; 038e38e38e38e38eH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBuffer@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBuffer@BfresFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBuffer@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBuffer@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBuffer@BfresFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<BfresFile::VertexBuffer>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBuffer> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferAttribute@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferAttribute>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferAttribute> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UVertexBufferSize@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UVertexBufferSize@BfresFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UVertexBufferSize@BfresFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<BfresFile::VertexBufferSize>,std::_Vector_val<std::_Simple_types<BfresFile::VertexBufferSize> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::clear, COMDAT

; 1150 :     void clear() noexcept {

$LN94:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 1151 :         // TRANSITION, ABI:
; 1152 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1153 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1154 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1155 :         //   (2) The hash function operator() may throw exceptions, and
; 1156 :         //   (3) clear() is a noexcept function.
; 1157 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1158 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 1159 :         if (_Oldsize == 0) {

	test	rcx, rcx
	je	$LN1@clear

; 1160 :             return;
; 1161 :         }
; 1162 : 
; 1163 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1164 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1165 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1166 :             // as many buckets as elements, remove element-by-element.
; 1167 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rax, QWORD PTR [rdi+56]
	shr	rax, 3
	cmp	rax, rcx
	jbe	SHORT $LN3@clear

; 1168 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	rdx, QWORD PTR [rdi+8]

; 1169 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	rcx, rdi
	mov	r8, rdx
	mov	rdx, QWORD PTR [rdx]

; 1177 :     }

	add	rsp, 48					; 00000030H
	pop	rdi

; 1169 :                 _Unchecked_erase(_Head->_Next, _Head);

	jmp	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Unchecked_erase
$LN3@clear:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1490 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rcx, QWORD PTR [rdi+8]
	mov	QWORD PTR [rsp+80], rsi

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rsi, QWORD PTR [rcx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rsi, rsi
	je	SHORT $LN9@clear
	mov	QWORD PTR [rsp+72], rbx
	npad	5
$LL10@clear:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rsi]

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rsi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rsi, rbx
	test	rbx, rbx
	jne	SHORT $LL10@clear
	mov	rbx, QWORD PTR [rsp+72]
$LN9@clear:

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	r8, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	QWORD PTR [rax], rax

; 1492 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rax+8], rax

; 1493 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rdi+16], 0

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	mov	rdx, QWORD PTR [rdi+32]
	mov	rcx, QWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR $T1[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >
	mov	rsi, QWORD PTR [rsp+80]
$LN1@clear:

; 1177 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?clear@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >,std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBAAEBMXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBAAEBMXZ PROC ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::_Get_max_bucket_size, COMDAT

; 162  :         return _Mypair._Myval2._Myval2;

	lea	rax, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures

; 163  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBAAEBMXZ ENDP ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
_Bucket_lo$1$ = 32
tv1246 = 40
_Eraser$$sroa$612$1$ = 48
tv1250 = 56
_Bucket_bounds$1$ = 64
this$ = 128
_First$ = 136
_Last$ = 144
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Unchecked_erase, COMDAT

; 1026 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN248:
	mov	rax, rsp
	push	rbp
	push	r12
	push	r14
	sub	rsp, 96					; 00000060H
	mov	r14, r8
	mov	r12, rdx
	mov	rbp, rcx

; 1027 :         if (_First == _Last) {

	cmp	rdx, r8
	je	$LN245@Unchecked_

; 1032 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	rdx, QWORD PTR [rcx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	mov	r8, 1099511628211			; 00000100000001b3H
	mov	QWORD PTR [rax+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1006 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	rbx, r12
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-32], r13

; 1028 :             return _Last;
; 1029 :         }
; 1030 : 
; 1031 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	r13, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [r12+16]
	mov	QWORD PTR [rax-40], r15
	mov	rax, -3750763034362895579		; cbf29ce484222325H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1006 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	r15, QWORD PTR [r12+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rcx, rax
	movzx	eax, BYTE PTR [r12+17]

; 2346 :         _Val *= _FNV_prime;

	imul	rcx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1032 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	QWORD PTR _Bucket_bounds$1$[rsp], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1006 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR _Eraser$$sroa$612$1$[rsp], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r12+18]

; 2346 :         _Val *= _FNV_prime;

	imul	rcx, r8
	xor	rcx, rax
	movzx	eax, BYTE PTR [r12+19]
	imul	rcx, r8
	xor	rcx, rax
	movzx	eax, BYTE PTR [r12+20]
	imul	rcx, r8
	xor	rcx, rax
	movzx	eax, BYTE PTR [r12+21]
	imul	rcx, r8
	xor	rcx, rax
	movzx	eax, BYTE PTR [r12+22]
	imul	rcx, r8
	xor	rcx, rax
	movzx	eax, BYTE PTR [r12+23]
	imul	rcx, r8
	xor	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR [rbp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	imul	rcx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	rax, rcx

; 1033 :         _Range_eraser _Eraser{_List, _First};
; 1034 :         {
; 1035 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1036 :             const auto _Predecessor = _First->_Prev;
; 1037 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws
; 1038 :             // nothrow hereafter this block
; 1039 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	rax, 4
	add	rax, rdx
	mov	QWORD PTR _Bucket_lo$1$[rsp], rax

; 1040 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1041 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

	mov	rcx, QWORD PTR [rax]

; 1042 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv1250[rsp], rax
	mov	QWORD PTR tv1246[rsp], rcx
	npad	4
$LL2@Unchecked_:

; 1009 :             const auto _Oldnext = _Next;

	mov	rdi, rbx

; 1043 :             for (;;) { // remove elements until we hit the end of the bucket
; 1044 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rsi, rbx

; 1010 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1012 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [rbp+16]

; 1045 :                 _Eraser._Bump_erased();
; 1046 :                 if (_At_bucket_back) {

	cmp	rdi, QWORD PTR tv1250[rsp]
	je	SHORT $LN199@Unchecked_

; 1047 :                     break;
; 1048 :                 }
; 1049 : 
; 1050 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, r14
	jne	SHORT $LL2@Unchecked_

; 1051 :                     if (_Update_lo) {

	cmp	QWORD PTR tv1246[rsp], r12
	jne	$LN229@Unchecked_

; 1052 :                         // erased the bucket's prefix
; 1053 :                         _Bucket_lo = _Eraser._Next;

	mov	rcx, QWORD PTR _Bucket_lo$1$[rsp]
	mov	QWORD PTR [rcx], rbx

; 1054 :                     }
; 1055 : 
; 1056 :                     return _Last;

	jmp	$LN229@Unchecked_
$LN199@Unchecked_:

; 1057 :                 }
; 1058 :             }
; 1059 : 
; 1060 :             if (_Update_lo) {

	mov	rcx, QWORD PTR _Bucket_lo$1$[rsp]
	cmp	QWORD PTR tv1246[rsp], r12
	jne	SHORT $LN14@Unchecked_

; 1061 :                 // emptied the bucket
; 1062 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rcx], r13

; 1063 :                 _Bucket_hi = _End;

	mov	rax, r13

; 1064 :             } else {

	jmp	SHORT $LN195@Unchecked_
$LN14@Unchecked_:

; 1065 :                 _Bucket_hi = _Predecessor;

	mov	rax, r15
$LN195@Unchecked_:

; 1066 :             }
; 1067 :         }
; 1068 : 
; 1069 :         // hereafter we are always erasing buckets' prefixes
; 1070 :         while (_Eraser._Next != _Last) {

	mov	QWORD PTR [rcx+8], rax
	cmp	rbx, r14
	je	$LN229@Unchecked_
	npad	5
$LL5@Unchecked_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rbx+16]

; 2346 :         _Val *= _FNV_prime;

	mov	rdx, 1099511628211			; 00000100000001b3H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r12, QWORD PTR [rbp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+17]

; 2346 :         _Val *= _FNV_prime;

	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+18]
	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+19]
	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+20]
	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+21]
	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+22]
	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+23]
	imul	rcx, rdx
	xor	rcx, rax
	imul	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	r12, rcx

; 1071 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws
; 1072 :             // nothrow hereafter this block
; 1073 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	r12, 4
	add	r12, QWORD PTR _Bucket_bounds$1$[rsp]

; 1074 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1075 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	r15, QWORD PTR [r12+8]
$LL7@Unchecked_:

; 1009 :             const auto _Oldnext = _Next;

	mov	rdi, rbx

; 1076 :             for (;;) { // remove elements until we hit the end of the bucket
; 1077 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rsi, rbx

; 1010 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1012 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [rbp+16]

; 1078 :                 _Eraser._Bump_erased();
; 1079 :                 if (_At_bucket_back) {

	cmp	rdi, r15
	je	SHORT $LN201@Unchecked_

; 1080 :                     break;
; 1081 :                 }
; 1082 : 
; 1083 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, r14
	jne	SHORT $LL7@Unchecked_

; 1016 :             _Predecessor->_Next = _Next;

	mov	rax, QWORD PTR _Eraser$$sroa$612$1$[rsp]

; 1084 :                     // erased the bucket's prefix
; 1085 :                     _Bucket_lo = _Eraser._Next;

	mov	QWORD PTR [r12], rbx

; 1016 :             _Predecessor->_Next = _Next;

	mov	QWORD PTR [rax], rbx

; 1017 :             _Next->_Prev        = _Predecessor;

	mov	QWORD PTR [rbx+8], rax

; 1086 :                     return _Last;

	jmp	SHORT $LN244@Unchecked_
$LN201@Unchecked_:

; 1087 :                 }
; 1088 :             }
; 1089 : 
; 1090 :             // emptied the bucket
; 1091 :             _Bucket_lo = _End;

	mov	QWORD PTR [r12], r13

; 1092 :             _Bucket_hi = _End;

	mov	QWORD PTR [r12+8], r13
	cmp	rbx, r14
	jne	$LL5@Unchecked_

; 1066 :             }
; 1067 :         }
; 1068 : 
; 1069 :         // hereafter we are always erasing buckets' prefixes
; 1070 :         while (_Eraser._Next != _Last) {

	mov	r15, QWORD PTR _Eraser$$sroa$612$1$[rsp]
$LN229@Unchecked_:

; 1016 :             _Predecessor->_Next = _Next;

	mov	QWORD PTR [r15], rbx

; 1017 :             _Next->_Prev        = _Predecessor;

	mov	QWORD PTR [rbx+8], r15
$LN244@Unchecked_:
	mov	r13, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+152]
	mov	rsi, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [rsp+136]
	mov	r15, QWORD PTR [rsp+80]
$LN245@Unchecked_:

; 1093 :         }
; 1094 : 
; 1095 :         return _Last;
; 1096 :     }

	mov	rax, r14
	add	rsp, 96					; 00000060H
	pop	r14
	pop	r12
	pop	rbp
	ret	0
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::clear, COMDAT

; 1487 :     void clear() noexcept { // erase all

$LN79:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1488 :         auto& _My_data = _Mypair._Myval2;
; 1489 :         _My_data._Orphan_non_end();
; 1490 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]
	mov	rsi, rcx

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rdi, QWORD PTR [rdx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rdi, rdi
	je	SHORT $LN5@clear
	mov	QWORD PTR [rsp+56], rbx
	npad	8
$LL6@clear:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rdi]

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rdi, rbx
	test	rbx, rbx
	jne	SHORT $LL6@clear
	mov	rbx, QWORD PTR [rsp+56]
$LN5@clear:

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rax], rax

; 1492 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rax+8], rax

; 1493 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rsi+8], 0

; 1494 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?clear@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 1016 :             _Predecessor->_Next = _Next;

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rdx], rax

; 1017 :             _Next->_Prev        = _Predecessor;

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+8], rax

; 1018 :         }

	ret	0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 1008 :         void _Bump_erased() noexcept {

$LN68:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1009 :             const auto _Oldnext = _Next;

	mov	rbx, QWORD PTR [rcx+16]
	mov	rdi, rcx

; 1010 :             _Next               = _Oldnext->_Next;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1012 :             --_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rdi]

; 1013 :         }

	mov	rbx, QWORD PTR [rsp+56]
	dec	QWORD PTR [rax+8]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@2@QEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_List_$ = 16
_First_$ = 24
??0_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@2@QEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 1006 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@2@QEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_Orphan_non_end, COMDAT

; 378  : #if _ITERATOR_DEBUG_LEVEL == 2
; 379  :         _Lockit _Lock(_LOCK_DEBUG);
; 380  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 381  :         const auto _Head          = _Myhead;
; 382  :         while (*_Pnext) {
; 383  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 384  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 385  :                 _Pnext = _Pnextnext;
; 386  :             } else { // orphan the iterator
; 387  :                 (*_Pnext)->_Myproxy = nullptr;
; 388  :                 *_Pnext             = *_Pnextnext;
; 389  :             }
; 390  :         }
; 391  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 392  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0M@?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0M@?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z PROC ; std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>::_Compressed_pair<std::equal_to<TextureToGo *>,float,1><float>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??$?0M@?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ENDP ; std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>::_Compressed_pair<std::equal_to<TextureToGo *>,float,1><float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1><>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	xorps	xmm0, xmm0
	lea	rax, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	movdqa	XMMWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> ><std::pair<TextureToGo * const,Texture> >, COMDAT

; 962  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> >::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> ><std::pair<TextureToGo * const,Texture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAY04$$CBD@std@@YAAEAY04$$CBDAEAY04$$CBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAY04$$CBD@std@@YAAEAY04$$CBDAEAY04$$CBD@Z PROC ; std::forward<char const (&)[5]>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAY04$$CBD@std@@YAAEAY04$$CBDAEAY04$$CBD@Z ENDP ; std::forward<char const (&)[5]>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@VBfresFile@@@std@@YA$$QEAVBfresFile@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@VBfresFile@@@std@@YA$$QEAVBfresFile@@AEAV1@@Z PROC ; std::forward<BfresFile>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@VBfresFile@@@std@@YA$$QEAVBfresFile@@AEAV1@@Z ENDP ; std::forward<BfresFile>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@AEAU10@@Z PROC ; std::move<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@AEAU10@@Z ENDP ; std::move<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >, COMDAT

; 995  :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

$LN146:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rsi, r8
	mov	r14, rdx

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rbp, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [rbp+8]
	mov	QWORD PTR $T3[rsp], rbx
	xor	r12d, r12d
	mov	DWORD PTR $T3[rsp+8], r12d
	mov	rdi, rbp

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	jne	SHORT $LN7@Emplace
	npad	3
$LL6@Emplace:

; 1616 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR $T3[rsp], rbx

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	test	al, al
	jns	SHORT $LN8@Emplace

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR $T3[rsp+8], r12d

; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]

; 1620 :             } else {

	jmp	SHORT $LN9@Emplace
$LN8@Emplace:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR $T3[rsp+8], 1

; 1622 :                 _Result._Bound           = _Trynode;

	mov	rdi, rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rbx, QWORD PTR [rbx]
$LN9@Emplace:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	je	SHORT $LL6@Emplace
$LN7@Emplace:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdi+25], r12b
	jne	SHORT $LN2@Emplace
	lea	rdx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	test	al, al
	js	SHORT $LN2@Emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rdi
	mov	BYTE PTR [r14+8], r12b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1004 :                 return {_Loc._Bound, false};

	jmp	$LN142@Emplace
$LN2@Emplace:

; 1631 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 104811045873349725			; 01745d1745d1745dH
	cmp	QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A+8, rax
	je	$LN144@Emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	r15, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	mov	QWORD PTR $T2[rsp], r15

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], r12

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR $T2[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rdx, rsi
	lea	rcx, QWORD PTR [rax+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, QWORD PTR [rdi+64]
	lea	rdx, QWORD PTR [rsi+32]
	call	??0BfresFile@@QEAA@$$QEAV0@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rdi], rbp

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rdi+8], rbp

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rdi+16], rbp

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rdi+24], 0

; 1005 :             }
; 1006 : 
; 1007 :             _Check_grow_by_1();
; 1008 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();
; 1009 :             // nothrow hereafter
; 1010 :         } else {
; 1011 :             _Tree_temp_node<_Alnode> _Newnode(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...);
; 1012 :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 1013 :             if constexpr (_Multi) { // duplicate check if unique
; 1014 :                 _Loc = _Find_upper_bound(_Keyval);
; 1015 :             } else {
; 1016 :                 _Loc = _Find_lower_bound(_Keyval);
; 1017 :                 if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
; 1018 :                     return {_Loc._Bound, false};
; 1019 :                 }
; 1020 :             }
; 1021 : 
; 1022 :             _Check_grow_by_1();
; 1023 :             // nothrow hereafter
; 1024 :             _Inserted = _Newnode._Release();
; 1025 :         }
; 1026 : 
; 1027 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	movups	xmm0, XMMWORD PTR $T3[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	mov	r8, rdi
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, r15
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Insert_node
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rax
	mov	BYTE PTR [r14+8], 1
$LN142@Emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1028 :     }

	mov	rax, r14
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN144@Emplace:

; 1632 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN141@Emplace:
??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
?dtor$2@?0???$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA PROC ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
?dtor$2@?0???$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA ENDP ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
?dtor$1@?0???$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA PROC ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0???$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA ENDP ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@AEB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@1@AEB_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@AEB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@1@AEB_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,bool const &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@AEB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@1@AEB_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,bool const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAY07$$CBD@std@@YAAEAY07$$CBDAEAY07$$CBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAY07$$CBD@std@@YAAEAY07$$CBDAEAY07$$CBD@Z PROC ; std::forward<char const (&)[8]>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAY07$$CBD@std@@YAAEAY07$$CBDAEAY07$$CBD@Z ENDP ; std::forward<char const (&)[8]>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$?RPEAVTextureToGo@@@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBA_KAEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Keyval$ = 16
??$?RPEAVTextureToGo@@@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBA_KAEBQEAVTextureToGo@@@Z PROC ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::operator()<TextureToGo *>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]

; 2346 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	movzx	ecx, BYTE PTR [rdx+6]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+4]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+5]
	imul	r8, r9
	xor	rax, r8
	imul	rax, r9
	xor	rax, rcx
	movzx	ecx, BYTE PTR [rdx+7]
	imul	rax, r9
	xor	rax, rcx
	imul	rax, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 148  :     }

	ret	0
??$?RPEAVTextureToGo@@@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBA_KAEBQEAVTextureToGo@@@Z ENDP ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::operator()<TextureToGo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$_Find_last@PEAVTextureToGo@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBQEAVTextureToGo@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Keyval$ = 24
_Hashval$ = 32
??$_Find_last@PEAVTextureToGo@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBQEAVTextureToGo@@_K@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Find_last<TextureToGo *>, COMDAT

; 1566 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1567 :         const size_type _Bucket = _Hashval & _Mask;
; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
	mov	r10, r8
	mov	r8, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
	and	r8, r9
	shl	r8, 4
	add	r8, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	mov	rax, QWORD PTR [r8+8]

; 1570 :         if (_Where == _End) {

	cmp	rax, rcx
	jne	SHORT $LN5@Find_last

; 1571 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR [rdx+8], 0

; 1592 :         }
; 1593 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx], rcx
	ret	0
$LN5@Find_last:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	rcx, QWORD PTR [r10]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r8, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	rcx, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN15@Find_last
$LL2@Find_last:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rax, r8
	je	SHORT $LN16@Find_last

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	rcx, QWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL2@Find_last
$LN15@Find_last:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rdx+8], rax

; 1592 :         }
; 1593 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx], rcx
	ret	0
$LN16@Find_last:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR [rdx], rax

; 1592 :         }
; 1593 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx+8], 0
	ret	0
??$_Find_last@PEAVTextureToGo@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBQEAVTextureToGo@@_K@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Find_last<TextureToGo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAVTextureToGo@@@std@@YAAEAPEAVTextureToGo@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVTextureToGo@@@std@@YAAEAPEAVTextureToGo@@AEAPEAV1@@Z PROC ; std::forward<TextureToGo * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAVTextureToGo@@@std@@YAAEAPEAVTextureToGo@@AEAPEAV1@@Z ENDP ; std::forward<TextureToGo * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@VTexture@@@std@@YA$$QEAVTexture@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@VTexture@@@std@@YA$$QEAVTexture@@AEAV1@@Z PROC ; std::forward<Texture>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@VTexture@@@std@@YA$$QEAVTexture@@AEAV1@@Z ENDP ; std::forward<Texture>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAVTextureToGo@@@std@@YA$$QEAPEAVTextureToGo@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVTextureToGo@@@std@@YA$$QEAPEAVTextureToGo@@AEAPEAV1@@Z PROC ; std::forward<TextureToGo *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAVTextureToGo@@@std@@YA$$QEAPEAVTextureToGo@@AEAPEAV1@@Z ENDP ; std::forward<TextureToGo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAIPEAI@std@@YAXAEBQEAI0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEAIPEAI@std@@YAXAEBQEAI0@Z PROC	; std::_Adl_verify_range<unsigned int *,unsigned int *>, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@PEAIPEAI@std@@YAXAEBQEAI0@Z ENDP	; std::_Adl_verify_range<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$distance@PEAI@std@@YA_JPEAI0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$distance@PEAI@std@@YA_JPEAI0@Z PROC			; std::distance<unsigned int *>, COMDAT

; 1421 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	sub	rdx, rcx
	sar	rdx, 2
	mov	rax, rdx

; 1423 :     } else {
; 1424 :         _Adl_verify_range(_First, _Last);
; 1425 :         auto _UFirst             = _Get_unwrapped(_First);
; 1426 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1427 :         _Iter_diff_t<_InIt> _Off = 0;
; 1428 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1429 :             ++_Off;
; 1430 :         }
; 1431 : 
; 1432 :         return _Off;
; 1433 :     }
; 1434 : }

	ret	0
??$distance@PEAI@std@@YA_JPEAI0@Z ENDP			; std::distance<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n<unsigned int *,unsigned int *>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN41:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN37@Construct_
	push	rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r15, r9
	mov	r14, r8
	mov	rbx, rdx
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN39@Construct_
	mov	QWORD PTR [rsp+32], rdi

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@I@std@@QEAAPEAI_K@Z ; std::allocator<unsigned int>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax
	mov	rdi, rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rax+rbx*4]
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 2
	lea	rax, QWORD PTR [rdi+rbx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+32]
	mov	QWORD PTR [rsi+8], rax

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
$LN37@Construct_:
	ret	0
$LN39@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength
	int	3
$LN36@Construct_:
??$_Construct_n@PEAIPEAI@?$vector@IV?$allocator@I@std@@@std@@AEAAX_K$$QEAPEAI1@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAMPEAM@std@@YAXAEBQEAM0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEAMPEAM@std@@YAXAEBQEAM0@Z PROC	; std::_Adl_verify_range<float *,float *>, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@PEAMPEAM@std@@YAXAEBQEAM0@Z ENDP	; std::_Adl_verify_range<float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$distance@PEAM@std@@YA_JPEAM0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$distance@PEAM@std@@YA_JPEAM0@Z PROC			; std::distance<float *>, COMDAT

; 1421 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	sub	rdx, rcx
	sar	rdx, 2
	mov	rax, rdx

; 1423 :     } else {
; 1424 :         _Adl_verify_range(_First, _Last);
; 1425 :         auto _UFirst             = _Get_unwrapped(_First);
; 1426 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1427 :         _Iter_diff_t<_InIt> _Off = 0;
; 1428 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1429 :             ++_Off;
; 1430 :         }
; 1431 : 
; 1432 :         return _Off;
; 1433 :     }
; 1434 : }

	ret	0
??$distance@PEAM@std@@YA_JPEAM0@Z ENDP			; std::distance<float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z PROC ; std::vector<float,std::allocator<float> >::_Construct_n<float *,float *>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN45:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN41@Construct_
	push	rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r15, r9
	mov	r14, r8
	mov	rbx, rdx
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN43@Construct_
	mov	QWORD PTR [rsp+32], rdi

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax
	mov	rdi, rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rax+rbx*4]
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 2
	lea	rax, QWORD PTR [rdi+rbx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+32]
	mov	QWORD PTR [rsi+8], rax

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
$LN41@Construct_:
	ret	0
$LN43@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN40@Construct_:
??$_Construct_n@PEAMPEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAX_K$$QEAPEAM1@Z ENDP ; std::vector<float,std::allocator<float> >::_Construct_n<float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAVTextureToGo@@@std@@YAAEAVTextureToGo@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAVTextureToGo@@@std@@YAAEAVTextureToGo@@AEAV1@@Z PROC ; std::forward<TextureToGo &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAVTextureToGo@@@std@@YAAEAVTextureToGo@@AEAV1@@Z ENDP ; std::forward<TextureToGo &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z PROC ; std::move<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z ENDP ; std::move<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >, COMDAT

; 995  :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

$LN147:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rsi, r8
	mov	r14, rdx

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rbp, QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [rbp+8]
	mov	QWORD PTR $T3[rsp], rbx
	xor	r12d, r12d
	mov	DWORD PTR $T3[rsp+8], r12d
	mov	rdi, rbp

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	jne	SHORT $LN7@Emplace
	npad	3
$LL6@Emplace:

; 1616 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR $T3[rsp], rbx

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	test	al, al
	jns	SHORT $LN8@Emplace

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR $T3[rsp+8], r12d

; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]

; 1620 :             } else {

	jmp	SHORT $LN9@Emplace
$LN8@Emplace:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR $T3[rsp+8], 1

; 1622 :                 _Result._Bound           = _Trynode;

	mov	rdi, rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rbx, QWORD PTR [rbx]
$LN9@Emplace:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	je	SHORT $LL6@Emplace
$LN7@Emplace:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdi+25], r12b
	jne	SHORT $LN2@Emplace
	lea	rdx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	test	al, al
	js	SHORT $LN2@Emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rdi
	mov	BYTE PTR [r14+8], r12b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1004 :                 return {_Loc._Bound, false};

	jmp	$LN143@Emplace
$LN2@Emplace:

; 1631 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 164703072086692425			; 0249249249249249H
	cmp	QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A+8, rax
	je	$LN145@Emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	r15, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
	mov	QWORD PTR $T2[rsp], r15

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], r12

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR $T2[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rdx, rsi
	lea	rcx, QWORD PTR [rax+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, QWORD PTR [rsi+32]
	mov	QWORD PTR [rdi+64], rcx

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rsi+56]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rsi+56], r12

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rsi+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rsi+48], r12

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rsi+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rsi+40], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdi+72], rax
	mov	QWORD PTR [rdi+80], rcx
	mov	QWORD PTR [rdi+88], rdx
	movzx	eax, WORD PTR [rsi+64]
	mov	WORD PTR [rdi+96], ax
	movzx	eax, WORD PTR [rsi+66]
	mov	WORD PTR [rdi+98], ax
	movzx	eax, WORD PTR [rsi+68]
	mov	WORD PTR [rdi+100], ax
	movzx	eax, BYTE PTR [rsi+70]
	mov	BYTE PTR [rdi+102], al
	movzx	eax, WORD PTR [rsi+72]
	mov	WORD PTR [rdi+104], ax
	movzx	eax, BYTE PTR [rsi+74]
	mov	BYTE PTR [rdi+106], al
	movzx	eax, BYTE PTR [rsi+75]
	mov	BYTE PTR [rdi+107], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rdi], rbp

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rdi+8], rbp

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rdi+16], rbp

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rdi+24], 0

; 1005 :             }
; 1006 : 
; 1007 :             _Check_grow_by_1();
; 1008 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();
; 1009 :             // nothrow hereafter
; 1010 :         } else {
; 1011 :             _Tree_temp_node<_Alnode> _Newnode(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...);
; 1012 :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 1013 :             if constexpr (_Multi) { // duplicate check if unique
; 1014 :                 _Loc = _Find_upper_bound(_Keyval);
; 1015 :             } else {
; 1016 :                 _Loc = _Find_lower_bound(_Keyval);
; 1017 :                 if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
; 1018 :                     return {_Loc._Bound, false};
; 1019 :                 }
; 1020 :             }
; 1021 : 
; 1022 :             _Check_grow_by_1();
; 1023 :             // nothrow hereafter
; 1024 :             _Inserted = _Newnode._Release();
; 1025 :         }
; 1026 : 
; 1027 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	movups	xmm0, XMMWORD PTR $T3[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	mov	r8, rdi
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, r15
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Insert_node
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rax
	mov	BYTE PTR [r14+8], 1
$LN143@Emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1028 :     }

	mov	rax, r14
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN145@Emplace:

; 1632 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN142@Emplace:
??$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
?dtor$2@?0???$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA PROC ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
?dtor$2@?0???$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA ENDP ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$dead$ = 128
__$ReturnUdt$ = 136
<_Vals_0>$ = 144
?dtor$1@?0???$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA PROC ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0???$_Emplace@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA ENDP ; `std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@AEB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@1@AEB_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@AEB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@1@AEB_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >,bool const &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@AEB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@1@AEB_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >,bool const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAY03$$CBD@std@@YAAEAY03$$CBDAEAY03$$CBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAY03$$CBD@std@@YAAEAY03$$CBDAEAY03$$CBD@Z PROC ; std::forward<char const (&)[4]>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAY03$$CBD@std@@YAAEAY03$$CBDAEAY03$$CBD@Z ENDP ; std::forward<char const (&)[4]>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBuffer@BfresFile@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBuffer@BfresFile@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<BfresFile::VertexBuffer> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBuffer@BfresFile@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<BfresFile::VertexBuffer> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAPEAUVertexBuffer@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAPEAUVertexBuffer@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::VertexBuffer> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN36:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN3@Uninitiali
	lea	rax, QWORD PTR [rcx+32]
	xor	r8d, r8d
	npad	11
$LL4@Uninitiali:
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	lea	rax, QWORD PTR [rax+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rbx], xmm0
	xor	ecx, ecx
	movups	XMMWORD PTR [rbx+16], xmm0
	mov	QWORD PTR [rbx+32], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax-56], r8
	mov	QWORD PTR [rax-48], r8
	mov	QWORD PTR [rax-40], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rbx
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::VertexBuffer> >

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();

	mov	rax, rbx

; 2046 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAPEAUVertexBuffer@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::VertexBuffer> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<BfresFile::VertexBufferAttribute> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBufferAttribute@BfresFile@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<BfresFile::VertexBufferAttribute> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAPEAUVertexBufferAttribute@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAPEAUVertexBufferAttribute@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::VertexBufferAttribute> >, COMDAT

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN62@Uninitiali
	xor	eax, eax
	npad	9
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+32], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 40					; 00000028H

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN62@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rcx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@YAPEAUVertexBufferAttribute@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::VertexBufferAttribute> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBufferSize@BfresFile@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBufferSize@BfresFile@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<BfresFile::VertexBufferSize> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAAEBV?$allocator@UVertexBufferSize@BfresFile@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<BfresFile::VertexBufferSize> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::VertexBufferSize> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN26:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN22@Uninitiali
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rdx*8]
	mov	r8, rbx
	xor	edx, edx
	call	memset
	lea	rax, QWORD PTR [rbx+rdi]

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();

	mov	rbx, QWORD PTR [rsp+48]

; 2046 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();

	mov	rax, rdi

; 2046 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@_KAEAV?$allocator@UVertexBufferSize@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::VertexBufferSize> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z PROC ; std::forward<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ENDP ; std::forward<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU21@@Z PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_back_with_unused_capacity<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 790  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 791  :         auto& _My_data   = _Mypair._Myval2;
; 792  :         pointer& _Mylast = _My_data._Mylast;
; 793  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 794  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 795  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 796  :             _ASAN_VECTOR_MODIFY(1);
; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, QWORD PTR [rcx+8]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 789  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	mov	r9, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	QWORD PTR [r8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r8+24], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+32], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+8]
	movups	XMMWORD PTR [r8+8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+24]
	movups	XMMWORD PTR [r8+24], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+24], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+32], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx+8], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+40]
	mov	QWORD PTR [r9+8], rcx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU21@@Z ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_back_with_unused_capacity<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z
_TEXT	SEGMENT
this$ = 96
_Whereptr$ = 104
<_Val_0>$ = 112
??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_reallocate<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN156:
	push	rbx
	push	rbp
	push	rsi
	push	r12
	sub	rsp, 56					; 00000038H

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	r9, QWORD PTR [rcx]
	mov	rbx, rdx
	sub	rdx, r9
	mov	rax, 7378697629483820647		; 6666666666666667H
	imul	rdx
	mov	rbp, r8
	mov	rsi, rcx
	mov	r12, rdx

; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);
; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	r8, 461168601842738790			; 0666666666666666H
	sar	r12, 4
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	mov	rax, r12
	shr	rax, 63					; 0000003fH
	add	r12, rax
	mov	rax, QWORD PTR [rcx+8]
	sub	rax, r9
	sar	rax, 3
	imul	rax, rdx
	cmp	rax, r8
	je	$LN154@Emplace_re

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, r9
	mov	QWORD PTR [rsp+48], rdi
	sar	rcx, 3
	imul	rcx, rdx
	mov	QWORD PTR [rsp+40], r14

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+32], r15

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r15, QWORD PTR [rax+1]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	mov	rax, r8
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN134@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rcx, r15
	cmp	rax, r15
	cmovae	rcx, rax
	cmp	rcx, r8
	ja	$LN134@Emplace_re

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rcx+rcx*4]
	lea	r14, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r14, 4096				; 00001000H
	jb	SHORT $LN25@Emplace_re

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [r14+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, r14
	jbe	$LN134@Emplace_re

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN116@Emplace_re

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	r14, r14
	je	SHORT $LN26@Emplace_re

; 87   :         return ::operator new(_Bytes);

	mov	rcx, r14
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN26@Emplace_re:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN23@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	rax, QWORD PTR [r12+r12*4]
	xorps	xmm0, xmm0
	lea	r12, QWORD PTR [rdi+rax*8]

; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	r8, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [rbp]
	mov	QWORD PTR [r12], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r12+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r12+24], 0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r12+32], 0

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbp+8]
	movups	XMMWORD PTR [r12+8], xmm0
	movups	xmm1, XMMWORD PTR [rbp+24]
	movups	XMMWORD PTR [r12+24], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	QWORD PTR [rbp+24], 0
	mov	QWORD PTR [rbp+32], 15
	mov	BYTE PTR [rbp+8], 0
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	cmp	rbx, rdx
	je	SHORT $LN152@Emplace_re

; 840  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 841  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             } else {
; 843  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 844  :             }
; 845  :         } else { // provide basic guarantee
; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	rdx, rbx
	call	??$_Uninitialized_move@PEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 847  :             _Constructed_first = _Newvec;
; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	lea	r8, QWORD PTR [r12+40]
	mov	rcx, rbx
$LN152@Emplace_re:
	call	??$_Uninitialized_move@PEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rsi]
	test	rbx, rbx
	je	SHORT $LN107@Emplace_re

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN87@Emplace_re
	npad	1
$LL88@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rbp
	jne	SHORT $LL88@Emplace_re
$LN87@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	mov	rax, QWORD PTR [rsi+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN119@Emplace_re

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN116@Emplace_re

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN119@Emplace_re:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN107@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [r15+r15*4]
	mov	QWORD PTR [rsi], rdi
	mov	r15, QWORD PTR [rsp+32]
	lea	rdx, QWORD PTR [rdi+rcx*8]

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r14+rdi]
	mov	QWORD PTR [rsi+8], rdx
	mov	r14, QWORD PTR [rsp+40]

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 857  :         return _Newvec + _Whereoff;

	mov	rax, r12
	mov	rdi, QWORD PTR [rsp+48]

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [rsi+16], rcx

; 858  :     }

	add	rsp, 56					; 00000038H
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN116@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN154@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 825  :             _Xlength();

	call	?_Xlength@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlength
	int	3
$LN134@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN151@Emplace_re:
??$_Emplace_reallocate@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QEAU21@$$QEAU21@@Z ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_reallocate<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAVTextureToGo@@@std@@YAAEBQEAVTextureToGo@@AEBQEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAVTextureToGo@@@std@@YAAEBQEAVTextureToGo@@AEBQEAV1@@Z PROC ; std::forward<TextureToGo * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAVTextureToGo@@@std@@YAAEBQEAVTextureToGo@@AEBQEAV1@@Z ENDP ; std::forward<TextureToGo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$forward_as_tuple@AEBQEAVTextureToGo@@@std@@YA?AV?$tuple@AEBQEAVTextureToGo@@@0@AEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
<_Args_0>$ = 16
??$forward_as_tuple@AEBQEAVTextureToGo@@@std@@YA?AV?$tuple@AEBQEAVTextureToGo@@@0@AEBQEAVTextureToGo@@@Z PROC ; std::forward_as_tuple<TextureToGo * const &>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx

; 1026 :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 1027 : }

	ret	0
??$forward_as_tuple@AEBQEAVTextureToGo@@@std@@YA?AV?$tuple@AEBQEAVTextureToGo@@@0@AEBQEAVTextureToGo@@@Z ENDP ; std::forward_as_tuple<TextureToGo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > ><std::piecewise_construct_t const &,std::tuple<TextureToGo * const &>,std::tuple<> >, COMDAT

; 584  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN65:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r9
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], 0

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 72					; 00000048H
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+16], rdx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax+32], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+48], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+56], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 587  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > ><std::piecewise_construct_t const &,std::tuple<TextureToGo * const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > ><std::piecewise_construct_t const &,std::tuple<TextureToGo * const &>,std::tuple<> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > ><std::piecewise_construct_t const &,std::tuple<TextureToGo * const &>,std::tuple<> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??$_Kfn@QEAVTextureToGo@@VTexture@@@?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@SAAEBQEAVTextureToGo@@AEBU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@QEAVTextureToGo@@VTexture@@@?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@SAAEBQEAVTextureToGo@@AEBU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z PROC ; std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0>::_Kfn<TextureToGo * const,Texture>, COMDAT

; 56   :         return _Val.first;

	mov	rax, rcx

; 57   :     }

	ret	0
??$_Kfn@QEAVTextureToGo@@VTexture@@@?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@SAAEBQEAVTextureToGo@@AEBU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z ENDP ; std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0>::_Kfn<TextureToGo * const,Texture>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool>::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool><std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool>::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool><std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool>::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool><std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool>::pair<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool><std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YA$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YA$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z PROC ; std::forward<std::pair<TextureToGo * const,Texture> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YA$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z ENDP ; std::forward<std::pair<TextureToGo * const,Texture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > ><std::pair<TextureToGo * const,Texture> >, COMDAT

; 584  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN86:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	esi, esi

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rsi

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rsi+72]
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdx, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rax+16], rcx
	mov	ecx, DWORD PTR [rbx+8]
	mov	DWORD PTR [rax+24], ecx
	mov	ecx, DWORD PTR [rbx+12]
	mov	DWORD PTR [rax+28], ecx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rax+48], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rax+56], rsi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbx+16]
	movups	XMMWORD PTR [rax+32], xmm0
	movups	xmm1, XMMWORD PTR [rbx+32]
	movups	XMMWORD PTR [rax+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 587  :     }

	mov	QWORD PTR [rbx+32], rsi
	mov	QWORD PTR [rbx+40], 15
	mov	BYTE PTR [rbx+16], sil
	mov	eax, DWORD PTR [rbx+48]
	mov	DWORD PTR [rdx+64], eax
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > ><std::pair<TextureToGo * const,Texture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
?dtor$0@?0???$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > ><std::pair<TextureToGo * const,Texture> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
?dtor$0@?0???$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@$$QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > ><std::pair<TextureToGo * const,Texture> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@$$QEA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@$$QEA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
$T1 = 40
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$dead$ = 88
<_Vals_1>$ = 96
<_Vals_2>$dead$ = 104
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >, COMDAT

; 806  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

$LN59:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, r8
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rsi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rbx, QWORD PTR [rax+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rdx, QWORD PTR <_Vals_1>$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [rdx]
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	call	??0BfresFile@@QEAA@XZ			; BfresFile::BfresFile
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx], rdi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx+8], rdi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx+16], rdi

; 811  :         this->_Ptr->_Color = _Red;

	mov	rcx, QWORD PTR [rsi+8]
	mov	BYTE PTR [rcx+24], 0
	mov	rcx, QWORD PTR [rsi+8]
	mov	BYTE PTR [rcx+25], 0

; 812  :         this->_Ptr->_Isnil = false;
; 813  :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
$T1 = 40
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$dead$ = 88
<_Vals_1>$ = 96
<_Vals_2>$dead$ = 104
?dtor$1@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
?dtor$1@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
$T1 = 40
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$dead$ = 88
<_Vals_1>$ = 96
<_Vals_2>$dead$ = 104
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
$T1 = 40
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$dead$ = 88
<_Vals_1>$ = 96
<_Vals_2>$dead$ = 104
?dtor$3@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z
_TEXT	SEGMENT
this$ = 80
_Al$ = 88
_Rootnode$ = 96
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >, COMDAT

; 744  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

$LN85:
	push	rbx
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [r8+25], 0
	mov	rbx, r8
	mov	r15, rdx
	mov	r14, rcx
	jne	SHORT $LN3@Erase_tree
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+40], rsi
	mov	QWORD PTR [rsp+32], rdi
	npad	7
$LL2@Erase_tree:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	mov	rdx, r15
	mov	rcx, r14
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rbp, rbx

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rbp+144]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR [rbp+112]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR [rbp+88]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR [rbp+64]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbp+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 176				; 000000b0H
	mov	rcx, rbp
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL2@Erase_tree
	mov	rdi, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+104]
$LN3@Erase_tree:

; 747  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 748  :         }
; 749  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rbx
	ret	0
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >, COMDAT

; 371  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 176				; 000000b0H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN65:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN63@Resize_rea
	mov	QWORD PTR [rsp+80], rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbp, QWORD PTR [rcx+8]
	sub	rbp, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 1

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rbp, 1

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	sub	rax, rdx
	mov	QWORD PTR [rsp+88], r14
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@G@std@@QEAAPEAG_K@Z ; std::allocator<unsigned short>::allocate

; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r8, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	sub	r8, rbp
	mov	r14, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	add	r8, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	rcx, QWORD PTR [rax+rbp*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
	mov	rbp, QWORD PTR [rsp+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, r14
	mov	rcx, rsi
	mov	r14, QWORD PTR [rsp+88]

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@GV?$allocator@G@std@@@std@@AEAAXQEAG_K1@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Change_array
$LN63@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@GV?$allocator@G@std@@@std@@CAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlength
	int	3
$LN61@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@GV?$allocator@G@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@G@std@@@std@@YAPEAGPEAG_KAEAV?$allocator@G@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@G@std@@@std@@YAPEAGPEAG_KAEAV?$allocator@G@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<unsigned short> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN27:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rdx+rdx]
	mov	rdi, rcx

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	xor	edx, edx
	call	memset

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rdi]

; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {
; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@G@std@@@std@@YAPEAGPEAG_KAEAV?$allocator@G@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 80
_Newsize$ = 88
_Val$dead$ = 96
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN98:
	push	rbx
	push	rbp
	push	rdi
	sub	rsp, 48					; 00000030H

; 1512 :         if (_Newsize > max_size()) {

	mov	rdi, 329406144173384850			; 0492492492492492H
	mov	rbp, rdx
	mov	rbx, rcx
	cmp	rdx, rdi
	ja	$LN96@Resize_rea
	mov	QWORD PTR [rsp+96], rsi

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rdi
	mov	QWORD PTR [rsp+40], r14

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r14, QWORD PTR [rcx+8]
	sub	r14, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rbx]
	sar	rcx, 3

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	r14, 3
	mov	QWORD PTR [rsp+32], r15
	mov	r15, 7905747460161236407		; 6db6db6db6db6db7H

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	rcx, r15

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	imul	r14, r15

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rdi, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rdi, rbp
	cmovb	rdi, rbp
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rdi
	call	?allocate@?$allocator@USkeletonBone@BfresFile@@@std@@QEAAPEAUSkeletonBone@BfresFile@@_K@Z ; std::allocator<BfresFile::SkeletonBone>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	imul	rcx, r14, 56				; 00000038H

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, rbp
	mov	rsi, rax
	add	rcx, rax
	sub	rdx, r14
	mov	r14, QWORD PTR [rsp+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN17@Resize_rea
	xor	eax, eax
	npad	11
$LL18@Resize_rea:
	mov	QWORD PTR [rcx], -65536			; ffffffffffff0000H
	mov	QWORD PTR [rcx+8], 65535		; 0000ffffH
	mov	DWORD PTR [rcx+16], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+20], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+24], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+48], rax

; 1803 :         ++_Last;

	lea	rcx, QWORD PTR [rcx+56]

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL18@Resize_rea
$LN17@Resize_rea:

; 1931 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	rdx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN61@Resize_rea

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR [rbx+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 56				; 00000038H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN73@Resize_rea

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN70@Resize_rea

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN73@Resize_rea:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN61@Resize_rea:
	mov	r15, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rbx], rsi

; 2030 :         _Mylast  = _Newvec + _Newsize;

	imul	rax, rbp, 56				; 00000038H
	add	rax, rsi
	mov	QWORD PTR [rbx+8], rax

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	imul	rax, rdi, 56				; 00000038H
	add	rax, rsi
	mov	rsi, QWORD PTR [rsp+96]
	mov	QWORD PTR [rbx+16], rax

; 1534 :         }
; 1535 : 
; 1536 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1548 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN70@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN96@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Xlength
	int	3
$LN94@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@PEAU12@_KAEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@PEAU12@_KAEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::SkeletonBone> >, COMDAT

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN24@Uninitiali
	xor	eax, eax
	npad	9
$LL4@Uninitiali:
	mov	QWORD PTR [rcx], -65536			; ffffffffffff0000H
	mov	QWORD PTR [rcx+8], 65535		; 0000ffffH
	mov	DWORD PTR [rcx+16], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+20], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+24], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+48], rax

; 1803 :         ++_Last;

	add	rcx, 56					; 00000038H

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN24@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rcx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@PEAU12@_KAEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::SkeletonBone> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@USkeletonBone@BfresFile@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@USkeletonBone@BfresFile@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<BfresFile::SkeletonBone> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@USkeletonBone@BfresFile@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<BfresFile::SkeletonBone> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAUSkeletonBone@BfresFile@@@std@@YA$$QEAPEAUSkeletonBone@BfresFile@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUSkeletonBone@BfresFile@@@std@@YA$$QEAPEAUSkeletonBone@BfresFile@@AEAPEAU12@@Z PROC ; std::forward<BfresFile::SkeletonBone *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAUSkeletonBone@BfresFile@@@std@@YA$$QEAPEAUSkeletonBone@BfresFile@@AEAPEAU12@@Z ENDP ; std::forward<BfresFile::SkeletonBone *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN21:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 177372539170284150			; 0276276276276276H
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN19@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	QWORD PTR [rsp+48], rbp
	mov	rdx, 5675921253449092805		; 4ec4ec4ec4ec4ec5H
	mov	rbp, QWORD PTR [rcx+8]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sub	rbp, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 3
	imul	rcx, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rbp, 3
	imul	rbp, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+56], r14
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UModel@BfresFile@@@std@@QEAAPEAUModel@BfresFile@@_K@Z ; std::allocator<BfresFile::Model>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	imul	rcx, rbp, 104				; 00000068H

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, rdi
	mov	r14, rax
	add	rcx, rax
	sub	rdx, rbp
	call	??$_Uninitialized_value_construct_n@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@PEAU12@_KAEAV?$allocator@UModel@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Model> >

; 1534 :         }
; 1535 : 
; 1536 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	mov	r8, r14
	mov	rcx, QWORD PTR [rsi]
	call	??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::Model *,std::allocator<BfresFile::Model> >
	mov	rbp, QWORD PTR [rsp+48]

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, r14
	mov	rcx, rsi
	mov	r14, QWORD PTR [rsp+56]

; 1548 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Change_array
$LN19@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Xlength
	int	3
$LN17@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@PEAU12@_KAEAV?$allocator@UModel@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@PEAU12@_KAEAV?$allocator@UModel@BfresFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Model> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	mov	rax, rcx

; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN78@Uninitiali
	add	rcx, 40					; 00000028H
	xor	r8d, r8d
	npad	1
$LL4@Uninitiali:
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	lea	rcx, QWORD PTR [rcx+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax+8], xmm0
	movups	XMMWORD PTR [rax+24], xmm0
	movups	XMMWORD PTR [rax+40], xmm0
	movups	XMMWORD PTR [rax+56], xmm0
	movups	XMMWORD PTR [rax+72], xmm0
	movups	XMMWORD PTR [rax+88], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 104				; 00000068H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx-136], r8
	mov	QWORD PTR [rcx-128], r8
	mov	QWORD PTR [rcx-120], r8
	mov	QWORD PTR [rcx-112], r8
	mov	QWORD PTR [rcx-104], r8
	mov	QWORD PTR [rcx-96], r8
	mov	QWORD PTR [rcx-88], r8
	mov	QWORD PTR [rcx-80], r8
	mov	QWORD PTR [rcx-72], r8
	mov	QWORD PTR [rcx-64], r8
	mov	QWORD PTR [rcx-56], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN78@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@PEAU12@_KAEAV?$allocator@UModel@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Model> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBUModel@BfresFile@@@std@@YAAEBUModel@BfresFile@@AEBU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUModel@BfresFile@@@std@@YAAEBUModel@BfresFile@@AEBU12@@Z PROC ; std::forward<BfresFile::Model const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBUModel@BfresFile@@@std@@YAAEBUModel@BfresFile@@AEBU12@@Z ENDP ; std::forward<BfresFile::Model const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_back_with_unused_capacity@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_back_with_unused_capacity<BfresFile::Model const &>, COMDAT

; 789  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
	call	??0Model@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+104]
	mov	QWORD PTR [rbx+8], rdx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Emplace_back_with_unused_capacity@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAAEAUModel@BfresFile@@AEBU23@@Z ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_back_with_unused_capacity<BfresFile::Model const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_reallocate<BfresFile::Model const &>, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN26:
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r13, rdx
	mov	rsi, rcx

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	r10, QWORD PTR [rcx]
	mov	r9, rdx
	sub	r9, r10
	mov	r8, 5675921253449092805			; 4ec4ec4ec4ec4ec5H
	mov	rax, r8
	imul	r9
	mov	r14, rdx
	sar	r14, 5
	mov	rax, r14
	shr	rax, 63					; 0000003fH
	add	r14, rax

; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r12, QWORD PTR [rcx+8]
	sub	r12, r10
	sar	r12, 3
	imul	r12, r8

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 177372539170284150			; 0276276276276276H
	cmp	r12, rbx
	je	$LN25@Emplace_re

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	inc	r12

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, r10
	sar	rcx, 3
	imul	rcx, r8

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN22@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, r12
	cmovb	rbx, r12
$LN22@Emplace_re:

; 829  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 830  : 
; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	call	?allocate@?$allocator@UModel@BfresFile@@@std@@QEAAPEAUModel@BfresFile@@_K@Z ; std::allocator<BfresFile::Model>::allocate
	mov	rdi, rax
	mov	QWORD PTR _Newvec$[rsp], rax

; 832  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	imul	r14, r14, 104				; 00000068H
	add	r14, rax
	lea	r15, QWORD PTR [r14+104]
	mov	QWORD PTR _Constructed_last$[rsp], r15

; 833  :         pointer _Constructed_first      = _Constructed_last;

	mov	QWORD PTR _Constructed_first$[rsp], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR <_Val_0>$[rsp]
	mov	rcx, r14
	call	??0Model@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 837  :         _Constructed_first = _Newvec + _Whereoff;

	mov	QWORD PTR _Constructed_first$[rsp], r14

; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	mov	r8, rdi
	cmp	r13, rdx
	je	SHORT $LN23@Emplace_re

; 840  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 841  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             } else {
; 843  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 844  :             }
; 845  :         } else { // provide basic guarantee
; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	rdx, r13
	call	??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::Model *,std::allocator<BfresFile::Model> >

; 847  :             _Constructed_first = _Newvec;

	mov	QWORD PTR _Constructed_first$[rsp], rdi

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	r8, r15
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, r13
$LN23@Emplace_re:
	call	??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::Model *,std::allocator<BfresFile::Model> >
	npad	1

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, r12
	mov	rdx, rdi
	mov	rcx, rsi
	call	?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Change_array

; 857  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 858  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN25@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Xlength
	int	3
$LN21@Emplace_re:
??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_reallocate<BfresFile::Model const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?catch$0@?0???$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z@4HA PROC ; `std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_reallocate<BfresFile::Model const &>'::`1'::catch$0

; 850  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z$0:

; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rdx, QWORD PTR _Constructed_last$[rbp]
	mov	rcx, QWORD PTR _Constructed_first$[rbp]
	call	??$_Destroy_range@V?$allocator@UModel@BfresFile@@@std@@@std@@YAXPEAUModel@BfresFile@@QEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::Model> >

; 852  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	call	?deallocate@?$allocator@UModel@BfresFile@@@std@@QEAAXQEAUModel@BfresFile@@_K@Z ; std::allocator<BfresFile::Model>::deallocate

; 853  :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Emplace_reallocate@AEBUModel@BfresFile@@@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAPEAUModel@BfresFile@@QEAU23@AEBU23@@Z@4HA ENDP ; `std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Emplace_reallocate<BfresFile::Model const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@UModel@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UModel@BfresFile@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@UModel@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UModel@BfresFile@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<BfresFile::Model> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@UModel@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UModel@BfresFile@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<BfresFile::Model> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAUModel@BfresFile@@@std@@YA$$QEAPEAUModel@BfresFile@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUModel@BfresFile@@@std@@YA$$QEAPEAUModel@BfresFile@@AEAPEAU12@@Z PROC ; std::forward<BfresFile::Model *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAUModel@BfresFile@@@std@@YA$$QEAPEAUModel@BfresFile@@AEAPEAU12@@Z ENDP ; std::forward<BfresFile::Model *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN21:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 288230376151711743			; 03ffffffffffffffH
	mov	rdi, rdx
	mov	r14, rcx
	cmp	rdx, rbx
	ja	$LN19@Resize_rea
	mov	QWORD PTR [rsp+48], rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx
	mov	QWORD PTR [rsp+56], rsi

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	sub	rsi, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [r14]
	sar	rcx, 6

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rsi, 6

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UMaterial@BfresFile@@@std@@QEAAPEAUMaterial@BfresFile@@_K@Z ; std::allocator<BfresFile::Material>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;
; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, rdi
	mov	rbp, rax
	sub	rdx, rsi
	shl	rsi, 6
	lea	rcx, QWORD PTR [rsi+rax]
	call	??$_Uninitialized_value_construct_n@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@PEAU12@_KAEAV?$allocator@UMaterial@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Material> >

; 1534 :         }
; 1535 : 
; 1536 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [r14+8]
	mov	r8, rbp
	mov	rcx, QWORD PTR [r14]
	call	??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::Material *,std::allocator<BfresFile::Material> >
	mov	rsi, QWORD PTR [rsp+56]

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, rbp
	mov	rcx, r14
	mov	rbp, QWORD PTR [rsp+48]

; 1548 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Change_array
$LN19@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Xlength
	int	3
$LN17@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@PEAU12@_KAEAV?$allocator@UMaterial@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@PEAU12@_KAEAV?$allocator@UMaterial@BfresFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Material> >, COMDAT

; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN70@Uninitiali
	lea	rax, QWORD PTR [rcx+56]
	xor	r8d, r8d
	npad	4
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rax, QWORD PTR [rax+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+24], r8
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx+32], r8
	mov	QWORD PTR [rcx+40], r8
	mov	QWORD PTR [rcx+48], r8
	mov	QWORD PTR [rcx+56], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax-104], r8

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax-96], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 64					; 00000040H
	mov	BYTE PTR [rax-88], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax-80], r8
	mov	QWORD PTR [rax-72], r8
	mov	QWORD PTR [rax-64], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN70@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rcx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@PEAU12@_KAEAV?$allocator@UMaterial@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::Material> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBUMaterial@BfresFile@@@std@@YAAEBUMaterial@BfresFile@@AEBU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUMaterial@BfresFile@@@std@@YAAEBUMaterial@BfresFile@@AEBU12@@Z PROC ; std::forward<BfresFile::Material const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBUMaterial@BfresFile@@@std@@YAAEBUMaterial@BfresFile@@AEBU12@@Z ENDP ; std::forward<BfresFile::Material const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_back_with_unused_capacity@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_back_with_unused_capacity<BfresFile::Material const &>, COMDAT

; 789  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
	call	??0Material@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+64]
	mov	QWORD PTR [rbx+8], rdx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Emplace_back_with_unused_capacity@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAAEAUMaterial@BfresFile@@AEBU23@@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_back_with_unused_capacity<BfresFile::Material const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_reallocate<BfresFile::Material const &>, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN26:
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r12, rdx
	mov	rsi, rcx

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rdx, QWORD PTR [rcx]
	mov	r14, r12
	sub	r14, rdx

; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, rdx
	sar	rax, 6

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 288230376151711743			; 03ffffffffffffffH
	cmp	rax, rbx
	je	$LN25@Emplace_re

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r15, QWORD PTR [rax+1]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	sar	rcx, 6

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN22@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, r15
	cmovb	rbx, r15
$LN22@Emplace_re:

; 829  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 830  : 
; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	call	?allocate@?$allocator@UMaterial@BfresFile@@@std@@QEAAPEAUMaterial@BfresFile@@_K@Z ; std::allocator<BfresFile::Material>::allocate
	mov	rdi, rax
	mov	QWORD PTR _Newvec$[rsp], rax

; 832  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	and	r14, -64				; ffffffffffffffc0H
	add	r14, rax
	lea	r13, QWORD PTR [r14+64]
	mov	QWORD PTR _Constructed_last$[rsp], r13

; 833  :         pointer _Constructed_first      = _Constructed_last;

	mov	QWORD PTR _Constructed_first$[rsp], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR <_Val_0>$[rsp]
	mov	rcx, r14
	call	??0Material@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 837  :         _Constructed_first = _Newvec + _Whereoff;

	mov	QWORD PTR _Constructed_first$[rsp], r14

; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	mov	r8, rdi
	cmp	r12, rdx
	je	SHORT $LN23@Emplace_re

; 840  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 841  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             } else {
; 843  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 844  :             }
; 845  :         } else { // provide basic guarantee
; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	rdx, r12
	call	??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::Material *,std::allocator<BfresFile::Material> >

; 847  :             _Constructed_first = _Newvec;

	mov	QWORD PTR _Constructed_first$[rsp], rdi

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	r8, r13
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, r12
$LN23@Emplace_re:
	call	??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::Material *,std::allocator<BfresFile::Material> >
	npad	1

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, r15
	mov	rdx, rdi
	mov	rcx, rsi
	call	?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Change_array

; 857  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 858  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN25@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Xlength
	int	3
$LN21@Emplace_re:
??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_reallocate<BfresFile::Material const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?catch$0@?0???$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z@4HA PROC ; `std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_reallocate<BfresFile::Material const &>'::`1'::catch$0

; 850  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z$0:

; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rdx, QWORD PTR _Constructed_last$[rbp]
	mov	rcx, QWORD PTR _Constructed_first$[rbp]
	call	??$_Destroy_range@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAXPEAUMaterial@BfresFile@@QEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::Material> >

; 852  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	call	?deallocate@?$allocator@UMaterial@BfresFile@@@std@@QEAAXQEAUMaterial@BfresFile@@_K@Z ; std::allocator<BfresFile::Material>::deallocate

; 853  :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Emplace_reallocate@AEBUMaterial@BfresFile@@@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAPEAUMaterial@BfresFile@@QEAU23@AEBU23@@Z@4HA ENDP ; `std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Emplace_reallocate<BfresFile::Material const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@UMaterial@BfresFile@@@std@@@std@@YAAEBV?$allocator@UMaterial@BfresFile@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@UMaterial@BfresFile@@@std@@@std@@YAAEBV?$allocator@UMaterial@BfresFile@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<BfresFile::Material> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@UMaterial@BfresFile@@@std@@@std@@YAAEBV?$allocator@UMaterial@BfresFile@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<BfresFile::Material> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN51:
	push	rbx
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	rdi, rdx
	mov	r14, rcx
	cmp	rdx, rbx
	ja	$LN49@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	QWORD PTR [rsp+80], rsi
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rsi, QWORD PTR [rcx+8]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sub	rsi, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [r14]
	sar	rcx, 3
	imul	rcx, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rsi, 3
	imul	rsi, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+88], r15
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAAPEAV?$vector@MV?$allocator@M@std@@@2@_K@Z ; std::allocator<std::vector<float,std::allocator<float> > >::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	rcx, QWORD PTR [rsi+rsi*2]

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, rdi
	sub	rdx, rsi
	mov	r15, rax
	mov	rsi, QWORD PTR [rsp+80]
	lea	rcx, QWORD PTR [rax+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN17@Resize_rea
	xor	eax, eax
	npad	14
$LL18@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 24

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL18@Resize_rea
$LN17@Resize_rea:

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rcx
	call	??$_Destroy_range@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAXPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<float,std::allocator<float> > > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [r14+8]
	mov	r8, r15
	mov	rcx, QWORD PTR [r14]
	call	??$_Uninitialized_move@PEAV?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<float,std::allocator<float> > *,std::allocator<std::vector<float,std::allocator<float> > > >

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, r15
	mov	rcx, r14
	mov	r15, QWORD PTR [rsp+88]

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rbx

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXQEAV?$vector@MV?$allocator@M@std@@@2@_K1@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Change_array
$LN49@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Xlength
	int	3
$LN47@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<float,std::allocator<float> > > >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN3@Uninitiali
	xor	eax, eax
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rbx
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAXPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<float,std::allocator<float> > > >

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();

	mov	rax, rbx

; 2046 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<float,std::allocator<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z PROC ; std::forward<std::vector<float,std::allocator<float> > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z ENDP ; std::forward<std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAAEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAAEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_back_with_unused_capacity<std::vector<float,std::allocator<float> > >, COMDAT

; 790  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 791  :         auto& _My_data   = _Mypair._Myval2;
; 792  :         pointer& _Mylast = _My_data._Mylast;
; 793  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 794  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 795  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 796  :             _ASAN_VECTOR_MODIFY(1);
; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r10, QWORD PTR [rcx+8]
	mov	r11, rcx

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rdx+16]
	xor	ecx, ecx
	mov	r9, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rdx+8]
	mov	QWORD PTR [rdx+16], rcx
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx], rcx
	mov	QWORD PTR [r10], r9
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], rax
	mov	rax, QWORD PTR [r11+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+24]
	mov	QWORD PTR [r11+8], rcx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAAEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_back_with_unused_capacity<std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 64
_Whereptr$ = 72
<_Val_0>$ = 80
??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_reallocate<std::vector<float,std::allocator<float> > >, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN41:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbp, QWORD PTR [rcx+8]
	mov	r9, rdx
	mov	r14, r8
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	r8, QWORD PTR [rcx]
	mov	r15, rdx
	sub	rbp, r8
	sub	r9, r8
	imul	r9
	sar	rbp, 3

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	r12, rdx
	mov	rsi, rcx
	sar	r12, 2
	mov	rax, r12
	shr	rax, 63					; 0000003fH
	add	r12, rax
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rbp, rax
	cmp	rbp, rbx
	je	$LN39@Emplace_re

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	inc	rbp

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, r8
	mov	QWORD PTR [rsp+64], rdi
	sar	rcx, 3
	imul	rcx, rax

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx
	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN13@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rbp
	cmovb	rbx, rbp
$LN13@Emplace_re:

; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@QEAAPEAV?$vector@MV?$allocator@M@std@@@2@_K@Z ; std::allocator<std::vector<float,std::allocator<float> > >::allocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	rcx, QWORD PTR [r12+r12*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [r14+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	eax, eax
	mov	QWORD PTR [r14+16], rax
	mov	QWORD PTR [r14+8], rax
	mov	QWORD PTR [r14], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	r14, QWORD PTR [rdi+rcx*8]

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r14+8], r8

; 837  :         _Constructed_first = _Newvec + _Whereoff;
; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	r8, rdi

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r14], rdx
	mov	QWORD PTR [r14+16], r9

; 837  :         _Constructed_first = _Newvec + _Whereoff;
; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	cmp	r15, rdx
	je	SHORT $LN37@Emplace_re

; 840  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 841  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             } else {
; 843  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 844  :             }
; 845  :         } else { // provide basic guarantee
; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	rdx, r15
	call	??$_Uninitialized_move@PEAV?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<float,std::allocator<float> > *,std::allocator<std::vector<float,std::allocator<float> > > >

; 847  :             _Constructed_first = _Newvec;
; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	lea	r8, QWORD PTR [r14+24]
	mov	rcx, r15
$LN37@Emplace_re:
	call	??$_Uninitialized_move@PEAV?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<float,std::allocator<float> > *,std::allocator<std::vector<float,std::allocator<float> > > >

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rbp
	mov	rdx, rdi
	mov	rcx, rsi
	call	?_Change_array@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXQEAV?$vector@MV?$allocator@M@std@@@2@_K1@Z ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Change_array

; 857  :         return _Newvec + _Whereoff;

	mov	rdi, QWORD PTR [rsp+64]
	mov	rax, r14

; 858  :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN39@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Xlength
	int	3
$LN36@Emplace_re:
??$_Emplace_reallocate@V?$vector@MV?$allocator@M@std@@@std@@@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAPEAV?$vector@MV?$allocator@M@std@@@1@QEAV21@$$QEAV21@@Z ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_reallocate<std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN21:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 192153584101141162			; 02aaaaaaaaaaaaaaH
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN19@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], r14

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r14, QWORD PTR [rcx+8]
	sub	r14, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 5
	imul	rcx, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	r14, 5
	imul	r14, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@ULOD@BfresFile@@@std@@QEAAPEAULOD@BfresFile@@_K@Z ; std::allocator<BfresFile::LOD>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	rcx, QWORD PTR [r14+r14*2]

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, rdi
	shl	rcx, 5
	sub	rdx, r14
	add	rcx, rax
	mov	rbp, rax
	call	??$_Uninitialized_value_construct_n@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@PEAU12@_KAEAV?$allocator@ULOD@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::LOD> >

; 1534 :         }
; 1535 : 
; 1536 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	mov	r8, rbp
	mov	rcx, QWORD PTR [rsi]
	call	??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::LOD *,std::allocator<BfresFile::LOD> >
	mov	r14, QWORD PTR [rsp+56]

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, rbp
	mov	rcx, rsi
	mov	rbp, QWORD PTR [rsp+48]

; 1548 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Change_array
$LN19@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Xlength
	int	3
$LN17@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@PEAU12@_KAEAV?$allocator@ULOD@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@PEAU12@_KAEAV?$allocator@ULOD@BfresFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::LOD> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	mov	rax, rcx

; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN67@Uninitiali
	add	rcx, 40					; 00000028H
	xor	r9d, r9d
	npad	1
$LL4@Uninitiali:
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	lea	rcx, QWORD PTR [rcx+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax+8], xmm0
	xor	r8d, r8d
	movups	XMMWORD PTR [rax+24], xmm0
	movups	XMMWORD PTR [rax+40], xmm0
	movups	XMMWORD PTR [rax+56], xmm0
	movups	XMMWORD PTR [rax+72], xmm0
	mov	QWORD PTR [rax+88], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 96					; 00000060H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx-128], r9
	mov	QWORD PTR [rcx-120], r9
	mov	QWORD PTR [rcx-112], r9
	mov	QWORD PTR [rcx-104], r9
	mov	QWORD PTR [rcx-96], r9
	mov	QWORD PTR [rcx-88], r9
	mov	QWORD PTR [rcx-80], r9
	mov	QWORD PTR [rcx-72], r9
	mov	QWORD PTR [rcx-64], r9
	mov	QWORD PTR [rcx-56], r9
	mov	QWORD PTR [rcx-48], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN67@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@PEAU12@_KAEAV?$allocator@ULOD@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::LOD> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBULOD@BfresFile@@@std@@YAAEBULOD@BfresFile@@AEBU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBULOD@BfresFile@@@std@@YAAEBULOD@BfresFile@@AEBU12@@Z PROC ; std::forward<BfresFile::LOD const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBULOD@BfresFile@@@std@@YAAEBULOD@BfresFile@@AEBU12@@Z ENDP ; std::forward<BfresFile::LOD const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_back_with_unused_capacity@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_back_with_unused_capacity<BfresFile::LOD const &>, COMDAT

; 789  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
	call	??0LOD@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+96]
	mov	QWORD PTR [rbx+8], rdx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Emplace_back_with_unused_capacity@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAAEAULOD@BfresFile@@AEBU23@@Z ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_back_with_unused_capacity<BfresFile::LOD const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_reallocate<BfresFile::LOD const &>, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN26:
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r13, rdx
	mov	rsi, rcx

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	r10, QWORD PTR [rcx]
	mov	r9, rdx
	sub	r9, r10
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	r9
	mov	r14, rdx
	sar	r14, 4
	mov	rax, r14
	shr	rax, 63					; 0000003fH
	add	r14, rax

; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r15, QWORD PTR [rcx+8]
	sub	r15, r10
	sar	r15, 5
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	r15, rax

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 192153584101141162			; 02aaaaaaaaaaaaaaH
	cmp	r15, rbx
	je	$LN25@Emplace_re

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	inc	r15

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, r10
	sar	rcx, 5
	imul	rcx, rax

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN22@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, r15
	cmovb	rbx, r15
$LN22@Emplace_re:

; 829  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 830  : 
; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	call	?allocate@?$allocator@ULOD@BfresFile@@@std@@QEAAPEAULOD@BfresFile@@_K@Z ; std::allocator<BfresFile::LOD>::allocate
	mov	rdi, rax
	mov	QWORD PTR _Newvec$[rsp], rax

; 832  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	lea	r14, QWORD PTR [r14+r14*2]
	shl	r14, 5
	add	r14, rax
	lea	r12, QWORD PTR [r14+96]
	mov	QWORD PTR _Constructed_last$[rsp], r12

; 833  :         pointer _Constructed_first      = _Constructed_last;

	mov	QWORD PTR _Constructed_first$[rsp], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR <_Val_0>$[rsp]
	mov	rcx, r14
	call	??0LOD@BfresFile@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 837  :         _Constructed_first = _Newvec + _Whereoff;

	mov	QWORD PTR _Constructed_first$[rsp], r14

; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	mov	r8, rdi
	cmp	r13, rdx
	je	SHORT $LN23@Emplace_re

; 840  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 841  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             } else {
; 843  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 844  :             }
; 845  :         } else { // provide basic guarantee
; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	rdx, r13
	call	??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::LOD *,std::allocator<BfresFile::LOD> >

; 847  :             _Constructed_first = _Newvec;

	mov	QWORD PTR _Constructed_first$[rsp], rdi

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	r8, r12
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, r13
$LN23@Emplace_re:
	call	??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::LOD *,std::allocator<BfresFile::LOD> >
	npad	1

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, r15
	mov	rdx, rdi
	mov	rcx, rsi
	call	?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Change_array

; 857  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 858  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN25@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Xlength
	int	3
$LN21@Emplace_re:
??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_reallocate<BfresFile::LOD const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?catch$0@?0???$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z@4HA PROC ; `std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_reallocate<BfresFile::LOD const &>'::`1'::catch$0

; 850  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z$0:

; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rdx, QWORD PTR _Constructed_last$[rbp]
	mov	rcx, QWORD PTR _Constructed_first$[rbp]
	call	??$_Destroy_range@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAXPEAULOD@BfresFile@@QEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::LOD> >

; 852  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	call	?deallocate@?$allocator@ULOD@BfresFile@@@std@@QEAAXQEAULOD@BfresFile@@_K@Z ; std::allocator<BfresFile::LOD>::deallocate

; 853  :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Emplace_reallocate@AEBULOD@BfresFile@@@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAPEAULOD@BfresFile@@QEAU23@AEBU23@@Z@4HA ENDP ; `std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Emplace_reallocate<BfresFile::LOD const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 80
_Newsize$ = 88
_Val$dead$ = 96
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<Mesh,std::allocator<Mesh> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN208:
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 1512 :         if (_Newsize > max_size()) {

	mov	rsi, 192153584101141162			; 02aaaaaaaaaaaaaaH
	mov	r14, rdx
	mov	rdi, rcx
	cmp	rdx, rsi
	ja	$LN206@Resize_rea
	mov	QWORD PTR [rsp+96], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rsi

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbx, QWORD PTR [rcx+8]
	sub	rbx, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rdi]
	mov	QWORD PTR [rsp+40], r12

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r12, -6148914691236517205		; aaaaaaaaaaaaaaabH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	rcx, 5
	imul	rcx, r12

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rbx, 5

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+32], r15
	shr	rdx, 1
	sub	rax, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	imul	rbx, r12

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rsi, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rsi, r14
	cmovb	rsi, r14
$LN11@Resize_rea:

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rsi
	call	?allocate@?$allocator@VMesh@@@std@@QEAAPEAVMesh@@_K@Z ; std::allocator<Mesh>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	rdx, QWORD PTR [rbx+rbx*2]

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r8, r14
	shl	rdx, 5
	xor	r11d, r11d
	add	rdx, rax
	mov	r15, rax
	sub	r8, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN17@Resize_rea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	lea	rcx, QWORD PTR [rdx+40]
	npad	6
$LL18@Resize_rea:

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx-32], r11
	mov	QWORD PTR [rcx-24], r11
	mov	QWORD PTR [rcx-16], r11
	mov	QWORD PTR [rcx-8], r11
	mov	QWORD PTR [rcx], r11
	mov	QWORD PTR [rcx+8], r11
	mov	QWORD PTR [rcx+16], r11
	mov	QWORD PTR [rcx+24], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rcx, QWORD PTR [rcx+96]

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	r8, 1
	jne	SHORT $LL18@Resize_rea
$LN17@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rbx, QWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r10, QWORD PTR [rdi+8]

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, r10
	je	$LN68@Resize_rea

; 1804 :     }
; 1805 : 
; 1806 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last
; 1807 :         _First = _Last;
; 1808 :         return _Last;
; 1809 :     }
; 1810 : 
; 1811 : private:
; 1812 :     pointer _First;
; 1813 :     pointer _Last;
; 1814 :     _Alloc& _Al;
; 1815 : };
; 1816 : 
; 1817 : template <class _InIt, class _Se, class _Alloc>
; 1818 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1820 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1821 :     // note: only called internally from elsewhere in the STL
; 1822 :     using _Ptrval = typename _Alloc::value_type*;
; 1823 : 
; 1824 : #ifdef __cpp_lib_concepts
; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;
; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }
; 1861 : 
; 1862 : template <class _InIt, class _Alloc>
; 1863 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy_n(
; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {
; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }
; 1893 : 
; 1894 : template <class _InIt, class _NoThrowFwdIt>
; 1895 : _CONSTEXPR20 _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1896 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1897 :     if constexpr (_Iter_copy_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {
; 1898 : #if _HAS_CXX20
; 1899 :         if (!_STD is_constant_evaluated())
; 1900 : #endif // _HAS_CXX20
; 1901 :         {
; 1902 :             return _Copy_memmove(_First, _Last, _Dest);
; 1903 :         }
; 1904 :     }
; 1905 : 
; 1906 :     _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
; 1907 :     for (; _First != _Last; ++_First) {
; 1908 :         _Backout._Emplace_back(*_First);
; 1909 :     }
; 1910 : 
; 1911 :     return _Backout._Release();
; 1912 : }
; 1913 : 
; 1914 : _EXPORT_STD template <class _InIt, class _NoThrowFwdIt>
; 1915 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
; 1916 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1917 :     _Adl_verify_range(_First, _Last);
; 1918 :     auto _UFirst      = _Get_unwrapped(_First);
; 1919 :     const auto _ULast = _Get_unwrapped(_Last);
; 1920 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 1921 :     _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
; 1922 :     return _Dest;
; 1923 : }
; 1924 : 
; 1925 : template <class _InIt, class _Alloc>
; 1926 : _CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_move(
; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	lea	r9, QWORD PTR [rax+40]
	lea	r8, QWORD PTR [rbx+32]
	npad	8
$LL69@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8-16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r9, QWORD PTR [r9+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-24]
	mov	rax, QWORD PTR [rbx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-16], r11
	mov	QWORD PTR [r8-24], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	r8, QWORD PTR [r8+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 96					; 00000060H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9-136], rax
	mov	QWORD PTR [r9-128], rcx
	mov	QWORD PTR [r9-120], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8-88]
	mov	rcx, QWORD PTR [r8-96]
	mov	rax, QWORD PTR [r8-104]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-88], r11
	mov	QWORD PTR [r8-96], r11
	mov	QWORD PTR [r8-104], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9-112], rax
	mov	QWORD PTR [r9-104], rcx
	mov	QWORD PTR [r9-96], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8-80]
	mov	rdx, QWORD PTR [r8-64]
	mov	rcx, QWORD PTR [r8-72]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-64], r11
	mov	QWORD PTR [r8-72], r11
	mov	QWORD PTR [r8-80], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9-88], rax
	mov	QWORD PTR [r9-80], rcx
	mov	QWORD PTR [r9-72], rdx
	mov	eax, DWORD PTR [r8-56]
	mov	DWORD PTR [r9-64], eax
	mov	eax, DWORD PTR [r8-52]
	mov	DWORD PTR [r9-60], eax
	mov	eax, DWORD PTR [r8-48]
	mov	DWORD PTR [r9-56], eax
	mov	eax, DWORD PTR [r8-44]
	mov	DWORD PTR [r9-52], eax
	mov	eax, DWORD PTR [r8-40]
	mov	DWORD PTR [r9-48], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, r10
	jne	$LL69@Resize_rea
	mov	rbx, QWORD PTR [rdi]
$LN68@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN155@Resize_rea
	mov	QWORD PTR [rsp+104], rbp

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN141@Resize_rea
$LL142@Resize_rea:
	mov	rcx, rbx
	call	??1Mesh@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rbp
	jne	SHORT $LL142@Resize_rea
$LN141@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rbp, QWORD PTR [rsp+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 5
	imul	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 5

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN167@Resize_rea

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN164@Resize_rea

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN167@Resize_rea:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN155@Resize_rea:
	mov	r12, QWORD PTR [rsp+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [r14+r14*2]
	mov	rbx, QWORD PTR [rsp+96]
	shl	rax, 5
	add	rax, r15
	mov	QWORD PTR [rdi], r15
	mov	QWORD PTR [rdi+8], rax

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rsi+rsi*2]
	shl	rax, 5
	add	rax, r15
	mov	r15, QWORD PTR [rsp+32]
	mov	QWORD PTR [rdi+16], rax

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1548 :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN164@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN206@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@CAXXZ ; std::vector<Mesh,std::allocator<Mesh> >::_Xlength
	int	3
$LN204@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<Mesh,std::allocator<Mesh> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@PEAV1@_KAEAV?$allocator@VMesh@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@PEAV1@_KAEAV?$allocator@VMesh@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<Mesh> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

	mov	rax, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN60@Uninitiali
	add	rcx, 40					; 00000028H
	xor	r8d, r8d
	npad	1
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 96					; 00000060H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx-32], r8
	mov	QWORD PTR [rcx-24], r8
	mov	QWORD PTR [rcx-16], r8
	mov	QWORD PTR [rcx-8], r8
	mov	QWORD PTR [rcx], r8
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r8
	mov	QWORD PTR [rcx+24], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rcx, QWORD PTR [rcx+96]

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN60@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@PEAV1@_KAEAV?$allocator@VMesh@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<Mesh> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN51:
	push	rbx
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	rdi, rdx
	mov	r14, rcx
	cmp	rdx, rbx
	ja	$LN49@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	QWORD PTR [rsp+80], rsi
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rsi, QWORD PTR [rcx+8]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sub	rsi, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [r14]
	sar	rcx, 3
	imul	rcx, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rsi, 3
	imul	rsi, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+88], r15
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QEAAPEAV?$vector@IV?$allocator@I@std@@@2@_K@Z ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	rcx, QWORD PTR [rsi+rsi*2]

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, rdi
	sub	rdx, rsi
	mov	r15, rax
	mov	rsi, QWORD PTR [rsp+80]
	lea	rcx, QWORD PTR [rax+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN17@Resize_rea
	xor	eax, eax
	npad	14
$LL18@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 24

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL18@Resize_rea
$LN17@Resize_rea:

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rcx
	call	??$_Destroy_range@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAXPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [r14+8]
	mov	r8, r15
	mov	rcx, QWORD PTR [r14]
	call	??$_Uninitialized_move@PEAV?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<unsigned int,std::allocator<unsigned int> > *,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, r15
	mov	rcx, r14
	mov	r15, QWORD PTR [rsp+88]

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rbx

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAXQEAV?$vector@IV?$allocator@I@std@@@2@_K1@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Change_array
$LN49@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Xlength
	int	3
$LN47@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN3@Uninitiali
	xor	eax, eax
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rbx
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAXPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();

	mov	rax, rbx

; 2046 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@PEAV10@_KAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z PROC ; std::forward<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAV?$vector@IV?$allocator@I@std@@@0@AEAV10@@Z ENDP ; std::forward<std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAAEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAAEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_back_with_unused_capacity<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 790  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 791  :         auto& _My_data   = _Mypair._Myval2;
; 792  :         pointer& _Mylast = _My_data._Mylast;
; 793  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 794  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 795  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 796  :             _ASAN_VECTOR_MODIFY(1);
; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r10, QWORD PTR [rcx+8]
	mov	r11, rcx

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rdx+16]
	xor	ecx, ecx
	mov	r9, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rdx+8]
	mov	QWORD PTR [rdx+16], rcx
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx], rcx
	mov	QWORD PTR [r10], r9
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], rax
	mov	rax, QWORD PTR [r11+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+24]
	mov	QWORD PTR [r11+8], rcx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAAEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_back_with_unused_capacity<std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 64
_Whereptr$ = 72
<_Val_0>$ = 80
??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_reallocate<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN41:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbp, QWORD PTR [rcx+8]
	mov	r9, rdx
	mov	r14, r8
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	r8, QWORD PTR [rcx]
	mov	r15, rdx
	sub	rbp, r8
	sub	r9, r8
	imul	r9
	sar	rbp, 3

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	r12, rdx
	mov	rsi, rcx
	sar	r12, 2
	mov	rax, r12
	shr	rax, 63					; 0000003fH
	add	r12, rax
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rbp, rax
	cmp	rbp, rbx
	je	$LN39@Emplace_re

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	inc	rbp

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, r8
	mov	QWORD PTR [rsp+64], rdi
	sar	rcx, 3
	imul	rcx, rax

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx
	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN13@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rbp
	cmovb	rbx, rbp
$LN13@Emplace_re:

; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@QEAAPEAV?$vector@IV?$allocator@I@std@@@2@_K@Z ; std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >::allocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	rcx, QWORD PTR [r12+r12*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [r14+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	eax, eax
	mov	QWORD PTR [r14+16], rax
	mov	QWORD PTR [r14+8], rax
	mov	QWORD PTR [r14], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	r14, QWORD PTR [rdi+rcx*8]

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r14+8], r8

; 837  :         _Constructed_first = _Newvec + _Whereoff;
; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	r8, rdi

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r14], rdx
	mov	QWORD PTR [r14+16], r9

; 837  :         _Constructed_first = _Newvec + _Whereoff;
; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	cmp	r15, rdx
	je	SHORT $LN37@Emplace_re

; 840  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 841  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             } else {
; 843  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 844  :             }
; 845  :         } else { // provide basic guarantee
; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	rdx, r15
	call	??$_Uninitialized_move@PEAV?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<unsigned int,std::allocator<unsigned int> > *,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >

; 847  :             _Constructed_first = _Newvec;
; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	lea	r8, QWORD PTR [r14+24]
	mov	rcx, r15
$LN37@Emplace_re:
	call	??$_Uninitialized_move@PEAV?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<unsigned int,std::allocator<unsigned int> > *,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rbp
	mov	rdx, rdi
	mov	rcx, rsi
	call	?_Change_array@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAXQEAV?$vector@IV?$allocator@I@std@@@2@_K1@Z ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Change_array

; 857  :         return _Newvec + _Whereoff;

	mov	rdi, QWORD PTR [rsp+64]
	mov	rax, r14

; 858  :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN39@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Xlength
	int	3
$LN36@Emplace_re:
??$_Emplace_reallocate@V?$vector@IV?$allocator@I@std@@@std@@@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAPEAV?$vector@IV?$allocator@I@std@@@1@QEAV21@$$QEAV21@@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_reallocate<std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_Newvec$ = 32
this$ = 96
_Newcapacity$ = 104
_Newsize$ = 104
_Val$dead$ = 112
_Appended_last$ = 112
_Appended_first$ = 120
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN19:
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rsi, rdx
	mov	rdi, rcx

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 288230376151711743			; 03ffffffffffffffH
	cmp	rdx, rbx
	ja	$LN18@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r15, QWORD PTR [rcx+8]
	sub	r15, QWORD PTR [rcx]
	sar	r15, 6

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rdi]
	sar	rcx, 6

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rsi
	cmovb	rbx, rsi
$LN16@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	call	?allocate@?$allocator@UBfresTexture@BfresFile@@@std@@QEAAPEAUBfresTexture@BfresFile@@_K@Z ; std::allocator<BfresFile::BfresTexture>::allocate
	mov	r14, rax
	mov	QWORD PTR _Newvec$[rsp], rax

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	rcx, r15
	shl	rcx, 6
	add	rcx, rax
	mov	QWORD PTR _Appended_first$[rsp], rcx

; 1526 :         pointer _Appended_last        = _Appended_first;

	mov	QWORD PTR _Appended_last$[rsp], rcx

; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, rsi
	sub	rdx, r15
	mov	r8, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::BfresTexture> >
	mov	QWORD PTR _Appended_last$[rsp], rax

; 1534 :         }
; 1535 : 
; 1536 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r8, r14
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rdi]
	call	??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::BfresTexture *,std::allocator<BfresFile::BfresTexture> >
	npad	1

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, rdi

; 1548 :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Change_array
$LN18@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Xlength
	int	3
$LN15@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
this$ = 96
_Newcapacity$ = 104
_Newsize$ = 104
_Val$dead$ = 112
_Appended_last$ = 112
_Appended_first$ = 120
?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA PROC ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Resize_reallocate<std::_Value_init_tag>'::`1'::catch$0

; 1541 :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z$0:

; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);

	mov	rdx, QWORD PTR _Appended_last$[rbp]
	mov	rcx, QWORD PTR _Appended_first$[rbp]
	call	??$_Destroy_range@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAXPEAUBfresTexture@BfresFile@@QEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::BfresTexture> >

; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	call	?deallocate@?$allocator@UBfresTexture@BfresFile@@@std@@QEAAXQEAUBfresTexture@BfresFile@@_K@Z ; std::allocator<BfresFile::BfresTexture>::deallocate

; 1544 :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA ENDP ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Resize_reallocate<std::_Value_init_tag>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Al$ = 112
??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::BfresTexture> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN66:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], rcx
	mov	QWORD PTR _Backout$[rsp+8], rcx
	mov	QWORD PTR _Backout$[rsp+16], r8

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN63@Uninitiali
	xor	esi, esi
	npad	14
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rbx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rbx], xmm0
	movups	XMMWORD PTR [rbx+16], xmm0
	movups	XMMWORD PTR [rbx+32], xmm0
	movups	XMMWORD PTR [rbx+48], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+8], rsi
	mov	QWORD PTR [rbx+16], rsi
	mov	QWORD PTR [rbx+24], rsi
	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 64					; 00000040H
	mov	QWORD PTR _Backout$[rsp+8], rbx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdi, 1
	jne	SHORT $LL4@Uninitiali
$LN63@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<BfresFile::BfresTexture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Al$ = 112
?dtor$0@?0???$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z@4HA PROC ; `std::_Uninitialized_value_construct_n<std::allocator<BfresFile::BfresTexture> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<BfresFile::BfresTexture> >::~_Uninitialized_backout_al<std::allocator<BfresFile::BfresTexture> >
?dtor$0@?0???$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z@4HA ENDP ; `std::_Uninitialized_value_construct_n<std::allocator<BfresFile::BfresTexture> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Al$ = 112
?dtor$1@?0???$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z@4HA PROC ; `std::_Uninitialized_value_construct_n<std::allocator<BfresFile::BfresTexture> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$_Uninitialized_value_construct_n@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@PEAU12@_KAEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z@4HA ENDP ; `std::_Uninitialized_value_construct_n<std::allocator<BfresFile::BfresTexture> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBUBfresTexture@BfresFile@@@std@@YAAEBUBfresTexture@BfresFile@@AEBU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUBfresTexture@BfresFile@@@std@@YAAEBUBfresTexture@BfresFile@@AEBU12@@Z PROC ; std::forward<BfresFile::BfresTexture const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBUBfresTexture@BfresFile@@@std@@YAAEBUBfresTexture@BfresFile@@AEBU12@@Z ENDP ; std::forward<BfresFile::BfresTexture const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
<_Val_0>$ = 56
??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_back_with_unused_capacity<BfresFile::BfresTexture const &>, COMDAT

; 789  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN13:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rbx, QWORD PTR [rcx+8]
	mov	QWORD PTR $T1[rsp], rbx
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rbx], rax
	lea	rcx, QWORD PTR [rbx+8]
	add	rdx, 8
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR [rdi+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rsi+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+64]
	mov	QWORD PTR [rsi+8], rcx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_back_with_unused_capacity<BfresFile::BfresTexture const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
<_Val_0>$ = 56
?dtor$0@?0???$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z@4HA PROC ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_back_with_unused_capacity<BfresFile::BfresTexture const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Emplace_back_with_unused_capacity@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAAEAUBfresTexture@BfresFile@@AEBU23@@Z@4HA ENDP ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_back_with_unused_capacity<BfresFile::BfresTexture const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z
_TEXT	SEGMENT
_Newvec$ = 32
$T1 = 40
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN30:
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r13, r8
	mov	r12, rdx
	mov	rsi, rcx

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rdx, QWORD PTR [rcx]
	mov	rdi, r12
	sub	rdi, rdx

; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, rdx
	sar	rax, 6

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 288230376151711743			; 03ffffffffffffffH
	cmp	rax, rbx
	je	$LN29@Emplace_re

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r15, QWORD PTR [rax+1]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	sar	rcx, 6

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN26@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, r15
	cmovb	rbx, r15
$LN26@Emplace_re:

; 829  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 830  : 
; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	call	?allocate@?$allocator@UBfresTexture@BfresFile@@@std@@QEAAPEAUBfresTexture@BfresFile@@_K@Z ; std::allocator<BfresFile::BfresTexture>::allocate
	mov	r14, rax
	mov	QWORD PTR _Newvec$[rsp], rax

; 832  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	and	rdi, -64				; ffffffffffffffc0H
	add	rdi, rax
	lea	rax, QWORD PTR [rdi+64]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 833  :         pointer _Constructed_first      = _Constructed_last;

	mov	QWORD PTR _Constructed_first$[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdi
	mov	rax, QWORD PTR [r13]
	mov	QWORD PTR [rdi], rax
	lea	rcx, QWORD PTR [rdi+8]
	lea	rdx, QWORD PTR [r13+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [r13+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 837  :         _Constructed_first = _Newvec + _Whereoff;

	mov	QWORD PTR _Constructed_first$[rsp], rdi

; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	mov	r8, r14
	cmp	r12, rdx
	je	SHORT $LN27@Emplace_re

; 840  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 841  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             } else {
; 843  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 844  :             }
; 845  :         } else { // provide basic guarantee
; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	rdx, r12
	call	??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::BfresTexture *,std::allocator<BfresFile::BfresTexture> >

; 847  :             _Constructed_first = _Newvec;

	mov	QWORD PTR _Constructed_first$[rsp], r14

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	lea	r8, QWORD PTR [rdi+64]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, r12
$LN27@Emplace_re:
	call	??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ; std::_Uninitialized_move<BfresFile::BfresTexture *,std::allocator<BfresFile::BfresTexture> >
	npad	1

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, r15
	mov	rdx, r14
	mov	rcx, rsi
	call	?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Change_array

; 857  :         return _Newvec + _Whereoff;

	mov	rax, rdi

; 858  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN29@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@CAXXZ ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Xlength
	int	3
$LN25@Emplace_re:
??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
$T1 = 40
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?dtor$0@?0???$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z@4HA PROC ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z@4HA ENDP ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
$T1 = 40
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?catch$2@?0???$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z@4HA PROC ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>'::`1'::catch$2

; 850  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z$0:

; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rdx, QWORD PTR _Constructed_last$[rbp]
	mov	rcx, QWORD PTR _Constructed_first$[rbp]
	call	??$_Destroy_range@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAXPEAUBfresTexture@BfresFile@@QEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::BfresTexture> >

; 852  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	call	?deallocate@?$allocator@UBfresTexture@BfresFile@@@std@@QEAAXQEAUBfresTexture@BfresFile@@_K@Z ; std::allocator<BfresFile::BfresTexture>::deallocate

; 853  :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$2@?0???$_Emplace_reallocate@AEBUBfresTexture@BfresFile@@@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAPEAUBfresTexture@BfresFile@@QEAU23@AEBU23@@Z@4HA ENDP ; `std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Emplace_reallocate<BfresFile::BfresTexture const &>'::`1'::catch$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@PEAVTexture@@@std@@@std@@YA$$QEAV?$allocator@PEAVTexture@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@PEAVTexture@@@std@@@std@@YA$$QEAV?$allocator@PEAVTexture@@@0@AEAV10@@Z PROC ; std::move<std::allocator<Texture *> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@PEAVTexture@@@std@@@std@@YA$$QEAV?$allocator@PEAVTexture@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<Texture *> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@PEAVTexture@@@std@@@std@@YAAEBV?$allocator@PEAVTexture@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@PEAVTexture@@@std@@@std@@YAAEBV?$allocator@PEAVTexture@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<Texture *> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@PEAVTexture@@@std@@@std@@YAAEBV?$allocator@PEAVTexture@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<Texture *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEBQEAVTexture@@@std@@YA$$QEAPEBQEAVTexture@@AEAPEBQEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEBQEAVTexture@@@std@@YA$$QEAPEBQEAVTexture@@AEAPEBQEAV1@@Z PROC ; std::forward<Texture * const *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEBQEAVTexture@@@std@@YA$$QEAPEBQEAVTexture@@AEAPEBQEAV1@@Z ENDP ; std::forward<Texture * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_iter@PEBQEAVTexture@@PEBQEAV1@@ranges@std@@YA?A_T$$QEAPEBQEAVTexture@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEBQEAVTexture@@PEBQEAV1@@ranges@std@@YA?A_T$$QEAPEBQEAVTexture@@@Z PROC ; std::ranges::_Unwrap_iter<Texture * const *,Texture * const *>, COMDAT

; 2488 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2489 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2490 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2491 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2492 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2493 :         } else {
; 2494 :             return static_cast<_Iter&&>(_It);
; 2495 :         }
; 2496 :     }

	ret	0
??$_Unwrap_iter@PEBQEAVTexture@@PEBQEAV1@@ranges@std@@YA?A_T$$QEAPEBQEAVTexture@@@Z ENDP ; std::ranges::_Unwrap_iter<Texture * const *,Texture * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_sent@PEBQEAVTexture@@PEBQEAV1@@ranges@std@@YA?A_T$$QEAPEBQEAVTexture@@@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEBQEAVTexture@@PEBQEAV1@@ranges@std@@YA?A_T$$QEAPEBQEAVTexture@@@Z PROC ; std::ranges::_Unwrap_sent<Texture * const *,Texture * const *>, COMDAT

; 2501 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2502 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2503 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2504 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2505 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2506 :         } else {
; 2507 :             return static_cast<_Sent&&>(_Se);
; 2508 :         }
; 2509 :     }

	ret	0
??$_Unwrap_sent@PEBQEAVTexture@@PEBQEAV1@@ranges@std@@YA?A_T$$QEAPEBQEAVTexture@@@Z ENDP ; std::ranges::_Unwrap_sent<Texture * const *,Texture * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEBQEAVTexture@@PEBQEAV1@V?$allocator@PEAVTexture@@@std@@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@AEAV?$allocator@PEAVTexture@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy@PEBQEAVTexture@@PEBQEAV1@V?$allocator@PEAVTexture@@@std@@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@AEAV?$allocator@PEAVTexture@@@0@@Z PROC ; std::_Uninitialized_copy<Texture * const *,Texture * const *,std::allocator<Texture *> >, COMDAT

; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN23:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy@PEBQEAVTexture@@PEBQEAV1@V?$allocator@PEAVTexture@@@std@@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@AEAV?$allocator@PEAVTexture@@@0@@Z ENDP ; std::_Uninitialized_copy<Texture * const *,Texture * const *,std::allocator<Texture *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEBQEAVTexture@@@std@@YA?A_PAEBQEBQEAVTexture@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEBQEAVTexture@@@std@@YA?A_PAEBQEBQEAVTexture@@@Z PROC ; std::_To_address<Texture * const *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEBQEAVTexture@@@std@@YA?A_PAEBQEBQEAVTexture@@@Z ENDP ; std::_To_address<Texture * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@I@std@@@std@@YA$$QEAV?$allocator@I@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@I@std@@@std@@YA$$QEAV?$allocator@I@0@AEAV10@@Z PROC ; std::move<std::allocator<unsigned int> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@I@std@@@std@@YA$$QEAV?$allocator@I@0@AEAV10@@Z ENDP ; std::move<std::allocator<unsigned int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<float,std::allocator<float> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN69:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 4611686018427387903		; 3fffffffffffffffH
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN67@Resize_rea
	mov	QWORD PTR [rsp+80], rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbp, QWORD PTR [rcx+8]
	sub	rbp, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 2

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rbp, 2

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	sub	rax, rdx
	mov	QWORD PTR [rsp+88], r14
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate

; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r8, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	sub	r8, rbp
	mov	r14, rax
	lea	rcx, QWORD PTR [rax+rbp*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	r8, QWORD PTR [r8*4]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
	mov	rbp, QWORD PTR [rsp+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, r14
	mov	rcx, rsi
	mov	r14, QWORD PTR [rsp+88]

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx

; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z ; std::vector<float,std::allocator<float> >::_Change_array
$LN67@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN65@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@MV?$allocator@M@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<float,std::allocator<float> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<float> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN27:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rdx*4]
	mov	rdi, rcx

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	xor	edx, edx
	call	memset

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rdi]

; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {
; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@M@std@@@std@@YAPEAMPEAM_KAEAV?$allocator@M@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z PROC ; std::move<std::allocator<float> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z ENDP ; std::move<std::allocator<float> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@M@std@@@std@@YAAEBV?$allocator@M@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@M@std@@@std@@YAAEBV?$allocator@M@0@AEBV10@@Z PROC ; std::forward<std::allocator<float> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@M@std@@@std@@YAAEBV?$allocator@M@0@AEBV10@@Z ENDP ; std::forward<std::allocator<float> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEBE@std@@YA?A_T$$QEAPEBE@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEBE@std@@YA?A_T$$QEAPEBE@Z PROC	; std::_Get_unwrapped<unsigned char const *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEBE@std@@YA?A_T$$QEAPEBE@Z ENDP	; std::_Get_unwrapped<unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEBEV?$allocator@E@std@@@std@@YAPEAEPEBE_KPEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy_n@PEBEV?$allocator@E@std@@@std@@YAPEAEPEBE_KPEAEAEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_copy_n<unsigned char const *,std::allocator<unsigned char> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN25:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rdi+rbx]

; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {
; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEBEV?$allocator@E@std@@@std@@YAPEAEPEBE_KPEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_copy_n<unsigned char const *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove_n@PEBEPEAE@std@@YAPEAEPEBE_KPEAE@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_memmove_n@PEBEPEAE@std@@YAPEAEPEBE_KPEAE@Z PROC ; std::_Copy_memmove_n<unsigned char const *,unsigned char *>, COMDAT

; 4543 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {

$LN6:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4544 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);
; 4545 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4546 :         return _Result;
; 4547 :     } else { // _Result is unused so the compiler can optimize it away
; 4548 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
; 4549 :     }
; 4550 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove_n@PEBEPEAE@std@@YAPEAEPEBE_KPEAE@Z ENDP ; std::_Copy_memmove_n<unsigned char const *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEBE_KPEAE@std@@YAPEAEPEBE_KPEAE@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEBE_KPEAE@std@@YAPEAEPEBE_KPEAE@Z PROC ; std::_Copy_n_unchecked4<unsigned char const *,unsigned __int64,unsigned char *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN16:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4557 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4558 :     // note: has callers outside the copy family
; 4559 : #ifdef __cpp_lib_concepts
; 4560 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4561 : #endif // __cpp_lib_concepts
; 4562 : 
; 4563 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4564 : #if _HAS_CXX20
; 4565 :         if (!_STD is_constant_evaluated())
; 4566 : #endif // _HAS_CXX20
; 4567 :         {
; 4568 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4569 :         }
; 4570 :     }
; 4571 : 
; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEBE_KPEAE@std@@YAPEAEPEBE_KPEAE@Z ENDP ; std::_Copy_n_unchecked4<unsigned char const *,unsigned __int64,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UVertexBuffer@BfresFile@@@std@@YAPEAUVertexBuffer@BfresFile@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UVertexBuffer@BfresFile@@@std@@YAPEAUVertexBuffer@BfresFile@@PEAU12@@Z PROC ; std::_Unfancy<BfresFile::VertexBuffer>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UVertexBuffer@BfresFile@@@std@@YAPEAUVertexBuffer@BfresFile@@PEAU12@@Z ENDP ; std::_Unfancy<BfresFile::VertexBuffer>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@UVertexBuffer@BfresFile@@@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBuffer@BfresFile@@@1@QEAUVertexBuffer@BfresFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
??$destroy@UVertexBuffer@BfresFile@@@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBuffer@BfresFile@@@1@QEAUVertexBuffer@BfresFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBuffer> >::destroy<BfresFile::VertexBuffer>, COMDAT

; 724  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN47:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 724  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN14@destroy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdx+32]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@destroy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@destroy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@destroy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+24], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+32], rax
$LN14@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 730  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN29@destroy:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@destroy:
??$destroy@UVertexBuffer@BfresFile@@@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBuffer@BfresFile@@@1@QEAUVertexBuffer@BfresFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBuffer> >::destroy<BfresFile::VertexBuffer>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UVertexBufferAttribute@BfresFile@@@std@@YAPEAUVertexBufferAttribute@BfresFile@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UVertexBufferAttribute@BfresFile@@@std@@YAPEAUVertexBufferAttribute@BfresFile@@PEAU12@@Z PROC ; std::_Unfancy<BfresFile::VertexBufferAttribute>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UVertexBufferAttribute@BfresFile@@@std@@YAPEAUVertexBufferAttribute@BfresFile@@PEAU12@@Z ENDP ; std::_Unfancy<BfresFile::VertexBufferAttribute>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@UVertexBufferAttribute@BfresFile@@@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@QEAUVertexBufferAttribute@BfresFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@UVertexBufferAttribute@BfresFile@@@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@QEAUVertexBufferAttribute@BfresFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferAttribute> >::destroy<BfresFile::VertexBufferAttribute>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdx
	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??$destroy@UVertexBufferAttribute@BfresFile@@@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@QEAUVertexBufferAttribute@BfresFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferAttribute> >::destroy<BfresFile::VertexBufferAttribute>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@PEAU10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@PEAU10@@Z PROC ; std::_Unfancy<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@PEAU10@@Z ENDP ; std::_Unfancy<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::destroy<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 724  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	lea	rcx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??$destroy@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::destroy<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<TextureToGo * const,Texture> > const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<TextureToGo * const,Texture> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1><std::allocator<std::pair<TextureToGo * const,Texture> > const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >,1><std::allocator<std::pair<TextureToGo * const,Texture> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<TextureToGo * const,Texture>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >, COMDAT

; 317  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN65:
	push	rbx
	sub	rsp, 32					; 00000020H

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rdx+32]
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 320  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<TextureToGo * const,Texture>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *>, COMDAT

; 305  :     if constexpr (is_array_v<_Ty>) {
; 306  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 307  :     } else {
; 308  :         _Obj.~_Ty();
; 309  :     }
; 310  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &>, COMDAT

; 1615 :         // construct a new element at *_Last and increment
; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1617 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1618 :     }

	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * const &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<TextureToGo * const,Texture> >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<TextureToGo * const,Texture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::destroy<std::pair<TextureToGo * const,Texture> >, COMDAT

; 724  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	lea	rcx, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??$destroy@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::destroy<std::pair<TextureToGo * const,Texture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * const &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$?RPEAVTextureToGo@@PEAV0@@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBA_NAEBQEAVTextureToGo@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_Keyval1$ = 16
_Keyval2$ = 24
??$?RPEAVTextureToGo@@PEAV0@@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBA_NAEBQEAVTextureToGo@@0@Z PROC ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::operator()<TextureToGo *,TextureToGo *>, COMDAT

; 153  :         // test if _Keyval1 NOT equal to _Keyval2
; 154  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	mov	rax, QWORD PTR [r8]
	cmp	QWORD PTR [rdx], rax
	setne	al

; 155  :     }

	ret	0
??$?RPEAVTextureToGo@@PEAV0@@?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@QEBA_NAEBQEAVTextureToGo@@0@Z ENDP ; std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >::operator()<TextureToGo *,TextureToGo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferSize@BfresFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferSize@BfresFile@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferSize@BfresFile@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::~_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::~_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@PEAUVertexBufferSize@BfresFile@@AEAV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@PEAUVertexBufferSize@BfresFile@@AEAV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAA@PEAUVertexBufferSize@BfresFile@@AEAV?$allocator@UVertexBufferSize@BfresFile@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAPEAUVertexBufferAttribute@BfresFile@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::~_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::~_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@PEAUVertexBufferAttribute@BfresFile@@AEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@PEAUVertexBufferAttribute@BfresFile@@AEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAA@PEAUVertexBufferAttribute@BfresFile@@AEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAPEAUVertexBuffer@BfresFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAPEAUVertexBuffer@BfresFile@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAPEAUVertexBuffer@BfresFile@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::~_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx]
	jmp	??$_Destroy_range@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@YAXPEAUVertexBuffer@BfresFile@@QEAU12@AEAV?$allocator@UVertexBuffer@BfresFile@@@0@@Z ; std::_Destroy_range<std::allocator<BfresFile::VertexBuffer> >
??1?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::~_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@PEAUVertexBuffer@BfresFile@@AEAV?$allocator@UVertexBuffer@BfresFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@PEAUVertexBuffer@BfresFile@@AEAV?$allocator@UVertexBuffer@BfresFile@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAA@PEAUVertexBuffer@BfresFile@@AEAV?$allocator@UVertexBuffer@BfresFile@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >, COMDAT

; 818  :     ~_Tree_temp_node() {

$LN43:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 819  :         if (this->_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN9@Tree_temp_

; 820  :             _Destroy_in_place(this->_Ptr->_Left);
; 821  :             _Destroy_in_place(this->_Ptr->_Parent);
; 822  :             _Destroy_in_place(this->_Ptr->_Right);
; 823  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

	add	rcx, 32					; 00000020H
	call	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
$LN9@Tree_temp_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1156 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN21@Tree_temp_

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 112				; 00000070H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 825  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN21@Tree_temp_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 825  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1148 :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@2@@Z
_TEXT	SEGMENT
_Val$ = 8
?_Extract@?$_In_place_key_extract_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@2@@Z PROC ; std::_In_place_key_extract_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >::_Extract, COMDAT

; 2113 :         return _Val.first;

	mov	rax, rcx

; 2114 :     }

	ret	0
?_Extract@?$_In_place_key_extract_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@2@@Z ENDP ; std::_In_place_key_extract_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@@Z
_TEXT	SEGMENT
_Val$ = 8
?_Extract@?$_In_place_key_extract_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@@Z PROC ; std::_In_place_key_extract_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >::_Extract, COMDAT

; 2113 :         return _Val.first;

	mov	rax, rcx

; 2114 :     }

	ret	0
?_Extract@?$_In_place_key_extract_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@@Z ENDP ; std::_In_place_key_extract_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_Allocate, COMDAT

; 1150 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 72					; 00000048H
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rbx+8], rax

; 1153 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >, COMDAT

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 0
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAXPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAXPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@0@Z PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAXPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@0@Z ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN53:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r15, r9
	mov	r12, r8
	mov	r14, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN26@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN38@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN35@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN38@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [r12+r12*4]
	lea	rcx, QWORD PTR [r14+rax*8]
	mov	QWORD PTR [rsi], r14
	mov	QWORD PTR [rsi+8], rcx
	lea	rax, QWORD PTR [r15+r15*4]
	lea	rcx, QWORD PTR [r14+rax*8]
	mov	QWORD PTR [rsi+16], rcx
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN35@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN50@Change_arr:
?_Change_array@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEAAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K1@Z ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	sub	r8, QWORD PTR [rcx]
	sar	r8, 3
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 461168601842738790			; 0666666666666666H
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 461168601842738790			; 0666666666666666H

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z PROC ; std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 461168601842738790			; 0666666666666666H
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	lea	rcx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@_K@Z ENDP ; std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@QEAU32@@Z
_TEXT	SEGMENT
this$ = 8
_Loc$ = 16
_Newnode$ = 24
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@QEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Insert_node, COMDAT

; 647  :         ++_Mysize;

	inc	QWORD PTR [rcx+8]
	mov	r9, r8

; 648  :         const auto _Head  = _Myhead;

	mov	r11, QWORD PTR [rcx]
	mov	r10, rcx

; 649  :         _Newnode->_Parent = _Loc._Parent;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8+8], rax

; 650  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

	cmp	rax, r11
	jne	SHORT $LN5@Insert_nod

; 651  :             _Head->_Left     = _Newnode;

	mov	QWORD PTR [r11], r8

; 712  :         return _Newnode;
; 713  :     }

	mov	rax, r8
	mov	QWORD PTR [r11+8], r8
	mov	QWORD PTR [r11+16], r8
	mov	BYTE PTR [r8+24], 1
	ret	0
$LN5@Insert_nod:

; 652  :             _Head->_Parent   = _Newnode;
; 653  :             _Head->_Right    = _Newnode;
; 654  :             _Newnode->_Color = _Black; // the root is black
; 655  :             return _Newnode;
; 656  :         }
; 657  : 
; 658  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 659  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

	cmp	DWORD PTR [rdx+8], 0
	jne	SHORT $LN6@Insert_nod

; 660  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 661  :             _Loc._Parent->_Right = _Newnode;

	mov	QWORD PTR [rax+16], r9

; 662  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

	cmp	rax, QWORD PTR [r11+16]
	jne	SHORT $LN9@Insert_nod

; 663  :                 _Head->_Right = _Newnode;

	mov	QWORD PTR [r11+16], r9

; 664  :             }
; 665  :         } else { // add to left of _Loc._Parent

	jmp	SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 666  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 667  :             _Loc._Parent->_Left = _Newnode;

	mov	QWORD PTR [rax], r9

; 668  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

	cmp	rax, QWORD PTR [r11]
	jne	SHORT $LN9@Insert_nod

; 669  :                 _Head->_Left = _Newnode;

	mov	QWORD PTR [r11], r9
$LN9@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	rcx, QWORD PTR [r8+8]
	mov	rax, r9
	cmp	BYTE PTR [rcx+24], 0
	jne	$LN3@Insert_nod
	npad	1
$LL2@Insert_nod:

; 674  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

	mov	rdx, QWORD PTR [rax+8]
	mov	r8, QWORD PTR [rdx+8]
	mov	rcx, QWORD PTR [r8]
	cmp	rdx, rcx
	jne	$LN10@Insert_nod

; 675  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

	mov	rcx, QWORD PTR [r8+16]

; 676  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	cmp	BYTE PTR [rcx+24], 0
	jne	SHORT $LN12@Insert_nod

; 677  :                     _Pnode->_Parent->_Color          = _Black;

	mov	BYTE PTR [rdx+24], 1

; 678  :                     _Parent_sibling->_Color          = _Black;

	mov	BYTE PTR [rcx+24], 1

; 679  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 680  :                     _Pnode                           = _Pnode->_Parent->_Parent;

	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rcx+8]

; 681  :                 } else { // parent's sibling has red and black children

	jmp	$LN46@Insert_nod
$LN12@Insert_nod:

; 682  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

	mov	r8, QWORD PTR [rdx+16]
	cmp	rax, r8
	jne	SHORT $LN51@Insert_nod

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rcx, QWORD PTR [r8]

; 683  :                         _Pnode = _Pnode->_Parent;

	mov	rax, rdx

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	QWORD PTR [rdx+16], rcx

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [r8]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN20@Insert_nod

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN20@Insert_nod:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN21@Insert_nod

; 471  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8
	jmp	SHORT $LN24@Insert_nod
$LN21@Insert_nod:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx]
	jne	SHORT $LN23@Insert_nod

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8

; 474  :         } else {

	jmp	SHORT $LN24@Insert_nod
$LN23@Insert_nod:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8
$LN24@Insert_nod:

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

	mov	QWORD PTR [r8], rdx

; 479  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rdx+8], r8
$LN51@Insert_nod:

; 684  :                         _Lrotate(_Pnode);
; 685  :                     }
; 686  : 
; 687  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	rcx, QWORD PTR [rax+8]
	mov	BYTE PTR [rcx+24], 1

; 688  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 689  :                     _Rrotate(_Pnode->_Parent->_Parent);

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]

; 483  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	r8, QWORD PTR [rdx]

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rcx, QWORD PTR [r8+16]
	mov	QWORD PTR [rdx], rcx

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

	mov	rcx, QWORD PTR [r8+16]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN27@Insert_nod

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN27@Insert_nod:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN28@Insert_nod

; 493  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN28@Insert_nod:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	jne	SHORT $LN30@Insert_nod

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN30@Insert_nod:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN10@Insert_nod:

; 692  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 693  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	cmp	BYTE PTR [rcx+24], 0
	jne	SHORT $LN15@Insert_nod

; 694  :                     _Pnode->_Parent->_Color          = _Black;

	mov	BYTE PTR [rdx+24], 1

; 695  :                     _Parent_sibling->_Color          = _Black;

	mov	BYTE PTR [rcx+24], 1

; 696  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 697  :                     _Pnode                           = _Pnode->_Parent->_Parent;

	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rcx+8]

; 698  :                 } else { // parent's sibling has red and black children

	jmp	$LN46@Insert_nod
$LN15@Insert_nod:

; 699  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

	mov	r8, QWORD PTR [rdx]
	cmp	rax, r8
	jne	SHORT $LN39@Insert_nod

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rcx, QWORD PTR [r8+16]

; 700  :                         _Pnode = _Pnode->_Parent;

	mov	rax, rdx

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	QWORD PTR [rdx], rcx

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

	mov	rcx, QWORD PTR [r8+16]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN34@Insert_nod

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN34@Insert_nod:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN35@Insert_nod

; 493  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8
	jmp	SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	jne	SHORT $LN37@Insert_nod

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8

; 496  :         } else {

	jmp	SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8
$LN38@Insert_nod:

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 501  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rdx+8], r8
$LN39@Insert_nod:

; 701  :                         _Rrotate(_Pnode);
; 702  :                     }
; 703  : 
; 704  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	rcx, QWORD PTR [rax+8]
	mov	BYTE PTR [rcx+24], 1

; 705  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 706  :                     _Lrotate(_Pnode->_Parent->_Parent);

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]

; 461  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	r8, QWORD PTR [rdx+16]

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rcx, QWORD PTR [r8]
	mov	QWORD PTR [rdx+16], rcx

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [r8]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN41@Insert_nod

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN41@Insert_nod:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN42@Insert_nod

; 471  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8
	jmp	SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx]
	jne	SHORT $LN44@Insert_nod

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8

; 474  :         } else {

	jmp	SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8
$LN45@Insert_nod:

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

	mov	QWORD PTR [r8], rdx
$LN53@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	QWORD PTR [rdx+8], r8
$LN46@Insert_nod:
	mov	rcx, QWORD PTR [rax+8]
	cmp	BYTE PTR [rcx+24], 0
	je	$LL2@Insert_nod
$LN3@Insert_nod:

; 707  :                 }
; 708  :             }
; 709  :         }
; 710  : 
; 711  :         _Head->_Parent->_Color = _Black; // root is always black

	mov	rax, QWORD PTR [r11+8]
	mov	BYTE PTR [rax+24], 1

; 712  :         return _Newnode;
; 713  :     }

	mov	rax, r9
	ret	0
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@QEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Getal, COMDAT

; 1961 :         return _Mypair._Myval2._Get_first();

	mov	rax, rcx

; 1962 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Check_grow_by_1, COMDAT

; 1630 :     void _Check_grow_by_1() {

$LN7:
	sub	rsp, 40					; 00000028H

; 1631 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 164703072086692425			; 0249249249249249H
	cmp	QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A+8, rax
	je	SHORT $LN6@Check_grow

; 1633 :         }
; 1634 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Check_grow:

; 1632 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN4@Check_grow:
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@PEAVTextureToGo@@@std@@V?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@PEAVTextureToGo@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$hash@PEAVTextureToGo@@@std@@V?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@PEAVTextureToGo@@@2@XZ PROC ; std::_Compressed_pair<std::hash<TextureToGo *>,std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@PEAVTextureToGo@@@std@@V?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@PEAVTextureToGo@@@2@XZ ENDP ; std::_Compressed_pair<std::hash<TextureToGo *>,std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@std@@QEBAAEBU?$equal_to@PEAVTextureToGo@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Get_first@?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@std@@QEBAAEBU?$equal_to@PEAVTextureToGo@@@2@XZ PROC ; std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>::_Get_first, COMDAT

; 1527 :         return *this;

	lea	rax, OFFSET FLAT:?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A ; GLTextureLibrary::Textures

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@PEAVTextureToGo@@@std@@M$00@std@@QEBAAEBU?$equal_to@PEAVTextureToGo@@@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<TextureToGo *>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??R?$equal_to@PEAVTextureToGo@@@std@@QEBA_NAEBQEAVTextureToGo@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_Left$ = 16
_Right$ = 24
??R?$equal_to@PEAVTextureToGo@@@std@@QEBA_NAEBQEAVTextureToGo@@0@Z PROC ; std::equal_to<TextureToGo *>::operator(), COMDAT

; 392  :         return _Left == _Right;

	mov	rax, QWORD PTR [r8]
	cmp	QWORD PTR [rdx], rax
	sete	al

; 393  :     }

	ret	0
??R?$equal_to@PEAVTextureToGo@@@std@@QEBA_NAEBQEAVTextureToGo@@0@Z ENDP ; std::equal_to<TextureToGo *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@PEAVTextureToGo@@$00@std@@QEBA_KAEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Keyval$ = 16
??R?$_Conditionally_enabled_hash@PEAVTextureToGo@@$00@std@@QEBA_KAEBQEAVTextureToGo@@@Z PROC ; std::_Conditionally_enabled_hash<TextureToGo *,1>::operator(), COMDAT

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]

; 2346 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	movzx	ecx, BYTE PTR [rdx+6]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+4]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+5]
	imul	r8, r9
	xor	rax, r8
	imul	rax, r9
	xor	rax, rcx
	movzx	ecx, BYTE PTR [rdx+7]
	imul	rax, r9
	xor	rax, rcx
	imul	rax, r9

; 2391 :         return hash<_Kty>::_Do_hash(_Keyval);
; 2392 :     }

	ret	0
??R?$_Conditionally_enabled_hash@PEAVTextureToGo@@$00@std@@QEBA_KAEBQEAVTextureToGo@@@Z ENDP ; std::_Conditionally_enabled_hash<TextureToGo *,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >, COMDAT

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xorps	xmm0, xmm0
	lea	rax, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	movdqa	XMMWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A, xmm0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::deallocate, COMDAT

; 701  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 176				; 000000b0H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	lea	rax, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXQEAUSkeletonBone@BfresFile@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXQEAUSkeletonBone@BfresFile@@_K1@Z PROC ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR [rbx+16]
	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 56				; 00000038H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2030 :         _Mylast  = _Newvec + _Newsize;

	imul	rax, rbp, 56				; 00000038H

; 2033 :     }

	mov	rbp, QWORD PTR [rsp+64]
	add	rax, rdi
	mov	QWORD PTR [rbx], rdi
	mov	QWORD PTR [rbx+8], rax
	imul	rax, rsi, 56				; 00000038H
	mov	rsi, QWORD PTR [rsp+72]
	add	rax, rdi
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXQEAUSkeletonBone@BfresFile@@_K1@Z ENDP ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z PROC ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN58:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r14, r9
	mov	r15, r8
	mov	rbp, rdx
	mov	rdi, rcx
	test	rbx, rbx
	je	$LN31@Change_arr
	mov	QWORD PTR [rsp+72], rsi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN6@Change_arr
	npad	7
$LL7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+72]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	lea	rcx, QWORD PTR [rbx+48]
	call	?_Tidy@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Tidy
	lea	rcx, QWORD PTR [rbx+24]
	call	?_Tidy@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Tidy
	mov	rcx, rbx
	call	?_Tidy@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 104				; 00000068H
	cmp	rbx, rsi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, 5675921253449092805		; 4ec4ec4ec4ec4ec5H
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 104				; 00000068H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN43@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN40@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN43@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN31@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	QWORD PTR [rdi], rbp
	imul	rax, r15, 104				; 00000068H
	add	rax, rbp
	mov	QWORD PTR [rdi+8], rax
	imul	rax, r14, 104				; 00000068H
	add	rax, rbp
	mov	rbp, QWORD PTR [rsp+88]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN40@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN55@Change_arr:
?_Change_array@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXQEAUModel@BfresFile@@_K1@Z ENDP ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN55:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rbp, r9
	mov	r14, r8
	mov	r15, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN28@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+40]
	call	?_Tidy@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN40@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN37@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN40@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN28@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	shl	r14, 6
	add	r14, r15
	shl	rbp, 6
	add	rbp, r15
	mov	QWORD PTR [rsi], r15
	mov	QWORD PTR [rsi+8], r14
	mov	QWORD PTR [rsi+16], rbp
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN37@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN52@Change_arr:
?_Change_array@?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@AEAAXQEAUMaterial@BfresFile@@_K1@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXQEAV?$vector@MV?$allocator@M@std@@@2@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXQEAV?$vector@MV?$allocator@M@std@@@2@_K1@Z PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	r14, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, QWORD PTR [rbx+8]
	call	??$_Destroy_range@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAXPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<float,std::allocator<float> > > >

; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rbx]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rax, QWORD PTR [rbx+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rbx], rdi

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [r14+r14*2]
	lea	rcx, QWORD PTR [rdi+rax*8]
	mov	QWORD PTR [rbx+8], rcx

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rsi+rsi*2]

; 2033 :     }

	mov	rsi, QWORD PTR [rsp+64]
	lea	rcx, QWORD PTR [rdi+rax*8]
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rcx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@AEAAXQEAV?$vector@MV?$allocator@M@std@@@2@_K1@Z ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r14, r9
	mov	r15, r8
	mov	rbp, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN20@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
	mov	rcx, rbx
	call	??1LOD@BfresFile@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 5
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 5

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [r15+r15*2]
	shl	rax, 5
	add	rax, rbp
	mov	QWORD PTR [rsi], rbp
	mov	QWORD PTR [rsi+8], rax
	lea	rax, QWORD PTR [r14+r14*2]
	shl	rax, 5
	add	rax, rbp
	mov	rbp, QWORD PTR [rsp+88]
	mov	QWORD PTR [rsi+16], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN29@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@Change_arr:
?_Change_array@?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@AEAAXQEAULOD@BfresFile@@_K1@Z ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z PROC ; std::vector<Mesh,std::allocator<Mesh> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r14, r9
	mov	r15, r8
	mov	rbp, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN20@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
	mov	rcx, rbx
	call	??1Mesh@@QEAA@XZ
	add	rbx, 96					; 00000060H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 5
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 5

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [r15+r15*2]
	shl	rax, 5
	add	rax, rbp
	mov	QWORD PTR [rsi], rbp
	mov	QWORD PTR [rsi+8], rax
	lea	rax, QWORD PTR [r14+r14*2]
	shl	rax, 5
	add	rax, rbp
	mov	rbp, QWORD PTR [rsp+88]
	mov	QWORD PTR [rsi+16], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN29@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@Change_arr:
?_Change_array@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@AEAAXQEAVMesh@@_K1@Z ENDP ; std::vector<Mesh,std::allocator<Mesh> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAXQEAV?$vector@IV?$allocator@I@std@@@2@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAXQEAV?$vector@IV?$allocator@I@std@@@2@_K1@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	r14, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, QWORD PTR [rbx+8]
	call	??$_Destroy_range@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAXPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >

; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rbx]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rax, QWORD PTR [rbx+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rbx], rdi

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [r14+r14*2]
	lea	rcx, QWORD PTR [rdi+rax*8]
	mov	QWORD PTR [rbx+8], rcx

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rsi+rsi*2]

; 2033 :     }

	mov	rsi, QWORD PTR [rsp+64]
	lea	rcx, QWORD PTR [rdi+rax*8]
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rcx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@AEAAXQEAV?$vector@IV?$allocator@I@std@@@2@_K1@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rbp, r9
	mov	r14, r8
	mov	r15, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN20@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
	mov	rcx, rbx
	call	??1BfresTexture@BfresFile@@QEAA@XZ
	add	rbx, 64					; 00000040H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	shl	r14, 6
	add	r14, r15
	shl	rbp, 6
	add	rbp, r15
	mov	QWORD PTR [rsi], r15
	mov	QWORD PTR [rsi+8], r14
	mov	QWORD PTR [rsi+16], rbp
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN29@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@Change_arr:
?_Change_array@?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@AEAAXQEAUBfresTexture@BfresFile@@_K1@Z ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z PROC ; std::vector<float,std::allocator<float> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*4]
	mov	QWORD PTR [rbx], rdi

; 2033 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*4]
	mov	rsi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z ENDP ; std::vector<float,std::allocator<float> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >, COMDAT

; 1156 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN10@Tree_temp_

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 112				; 00000070H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN10@Tree_temp_:
	ret	0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >, COMDAT

; 1156 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@Alloc_cons

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 112				; 00000070H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN8@Alloc_cons:

; 1157 :             _Al.deallocate(_Ptr, 1);
; 1158 :         }
; 1159 :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -3689348814741910323		; cccccccccccccccdH
	sar	rax, 3
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 461168601842738790			; 0666666666666666H

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_Wherenode$ = 16
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Rrotate, COMDAT

; 483  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	r8, QWORD PTR [rdx]

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rax, QWORD PTR [r8+16]
	mov	QWORD PTR [rdx], rax

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR [r8+16]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN2@Rrotate

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	QWORD PTR [rax+8], rdx
$LN2@Rrotate:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rax

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR [rcx]
	cmp	rdx, QWORD PTR [rax+8]
	jne	SHORT $LN3@Rrotate

; 493  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rax+8], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

	mov	QWORD PTR [r8+16], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN3@Rrotate:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rax, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rax+16]
	jne	SHORT $LN5@Rrotate

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rax+16], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

	mov	QWORD PTR [r8+16], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN5@Rrotate:

; 496  :         } else {
; 497  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rax], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

	mov	QWORD PTR [r8+16], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_Wherenode$ = 16
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Lrotate, COMDAT

; 461  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	r8, QWORD PTR [rdx+16]

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx+16], rax

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [r8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN2@Lrotate

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	QWORD PTR [rax+8], rdx
$LN2@Lrotate:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rax

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR [rcx]
	cmp	rdx, QWORD PTR [rax+8]
	jne	SHORT $LN3@Lrotate

; 471  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rax+8], r8

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

	mov	QWORD PTR [r8], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN3@Lrotate:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rax, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rax]
	jne	SHORT $LN5@Lrotate

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rax], r8

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

	mov	QWORD PTR [r8], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN5@Lrotate:

; 474  :         } else {
; 475  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rax+16], r8

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

	mov	QWORD PTR [r8], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::max_size, COMDAT

; 1198 :         return (_STD min)(

	mov	rax, 164703072086692425			; 0249249249249249H

; 1199 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1200 :     }

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ?_Do_hash@?$hash@PEAVTextureToGo@@@std@@SA_KAEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
_Keyval$ = 8
?_Do_hash@?$hash@PEAVTextureToGo@@@std@@SA_KAEBQEAVTextureToGo@@@Z PROC ; std::hash<TextureToGo *>::_Do_hash, COMDAT

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rcx]

; 2346 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2408 :     static size_t _Do_hash(const _Kty& _Keyval) noexcept {

	mov	rdx, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+1]

; 2346 :         _Val *= _FNV_prime;

	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+2]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+3]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+4]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+5]
	movzx	ecx, BYTE PTR [rcx+6]
	imul	r8, r9
	xor	rax, r8
	imul	rax, r9
	xor	rax, rcx
	movzx	ecx, BYTE PTR [rdx+7]
	imul	rax, r9
	xor	rax, rcx
	imul	rax, r9

; 2409 :         return _Hash_representation(_Keyval);
; 2410 :     }

	ret	0
?_Do_hash@?$hash@PEAVTextureToGo@@@std@@SA_KAEBQEAVTextureToGo@@@Z ENDP ; std::hash<TextureToGo *>::_Do_hash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Vector_val<std::_Simple_types<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Getal@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Getal, COMDAT

; 1965 :         return _Mypair._Myval2._Get_first();

	lea	rax, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures

; 1966 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 164703072086692425			; 0249249249249249H

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 112				; 00000070H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	lea	rax, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > ><std::pair<TextureToGo * const,Texture> >, COMDAT

; 962  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0U?$pair@QEAVTextureToGo@@VTexture@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > ><std::pair<TextureToGo * const,Texture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@AEAU10@@Z PROC ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@AEAU10@@Z ENDP ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 80
_Al_$ = 88
_Myhead$ = 96
<_Vals_0>$ = 104
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >, COMDAT

; 806  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

$LN54:
	mov	QWORD PTR [rsp+16], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rdi, r9
	mov	rsi, r8
	mov	r14, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 176				; 000000b0H
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [r14+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rbx, QWORD PTR [rax+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rdx, rdi
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rcx, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR [rdi+32]
	call	??0BfresFile@@QEAA@$$QEAV0@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	rcx, QWORD PTR [r14+8]
	mov	QWORD PTR [rcx], rsi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	rcx, QWORD PTR [r14+8]
	mov	QWORD PTR [rcx+8], rsi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	rcx, QWORD PTR [r14+8]
	mov	QWORD PTR [rcx+16], rsi

; 811  :         this->_Ptr->_Color = _Red;

	mov	rcx, QWORD PTR [r14+8]
	mov	BYTE PTR [rcx+24], 0
	mov	rcx, QWORD PTR [r14+8]
	mov	BYTE PTR [rcx+25], 0

; 812  :         this->_Ptr->_Isnil = false;
; 813  :     }

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 80
_Al_$ = 88
_Myhead$ = 96
<_Vals_0>$ = 104
?dtor$1@?0???$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
?dtor$1@?0???$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 80
_Al_$ = 88
_Myhead$ = 96
<_Vals_0>$ = 104
?dtor$0@?0???$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0???$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * &,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAI@std@@YA$$QEAPEAIAEAPEAI@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAI@std@@YA$$QEAPEAIAEAPEAI@Z PROC		; std::forward<unsigned int *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAI@std@@YA$$QEAPEAIAEAPEAI@Z ENDP		; std::forward<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAM@std@@YA$$QEAPEAMAEAPEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAM@std@@YA$$QEAPEAMAEAPEAM@Z PROC		; std::forward<float *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAM@std@@YA$$QEAPEAMAEAPEAM@Z ENDP		; std::forward<float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
__$ReturnUdt$ = 56
_Keyval$ = 64
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1611 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1612 :         const auto _Scary = _Get_scary();
; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rax, QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A
	mov	rsi, r8
	mov	rdi, rdx
	mov	DWORD PTR [rdx+8], 0
	mov	QWORD PTR [rdx+16], rax
	mov	rbx, QWORD PTR [rax+8]
	mov	QWORD PTR [rdx], rbx

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN14@Find_lower
	npad	12
$LL2@Find_lower:

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	jns	SHORT $LN4@Find_lower

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;
; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]
	xor	eax, eax

; 1620 :             } else {

	jmp	SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;
; 1622 :                 _Result._Bound           = _Trynode;

	mov	QWORD PTR [rdi+16], rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	eax, 1
	mov	rbx, QWORD PTR [rbx]
$LN5@Find_lower:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	mov	DWORD PTR [rdi+8], eax
	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL2@Find_lower
$LN14@Find_lower:

; 1624 :             }
; 1625 :         }
; 1626 : 
; 1627 :         return _Result;
; 1628 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Bound$ = 56
_Keyval$ = 64
??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1606 :     bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {

$LN11:
	sub	rsp, 40					; 00000028H

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN3@Lower_boun
	add	rdx, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, r8
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	js	SHORT $LN3@Lower_boun
	mov	al, 1

; 1608 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@Lower_boun:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	xor	al, al

; 1608 :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z PROC ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YA$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z ENDP ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 80
_Al_$ = 88
_Myhead$ = 96
<_Vals_0>$ = 104
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >, COMDAT

; 806  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

$LN73:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rdi, r9
	mov	rsi, r8
	mov	r14, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	ebp, ebp

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rbp

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rbp+112]
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [r14+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rbx, QWORD PTR [rax+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rdx, rdi
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR [rdi+32]
	mov	QWORD PTR [rbx+32], rax

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdi+56]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdi+56], rbp

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rdi+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdi+48], rbp

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdi+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdi+40], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rbx+40], rax
	mov	QWORD PTR [rbx+48], rcx
	mov	QWORD PTR [rbx+56], rdx
	movzx	eax, WORD PTR [rdi+64]
	mov	WORD PTR [rbx+64], ax
	movzx	eax, WORD PTR [rdi+66]
	mov	WORD PTR [rbx+66], ax
	movzx	eax, WORD PTR [rdi+68]
	mov	WORD PTR [rbx+68], ax
	movzx	eax, BYTE PTR [rdi+70]
	mov	BYTE PTR [rbx+70], al
	movzx	eax, WORD PTR [rdi+72]
	mov	WORD PTR [rbx+72], ax
	movzx	ecx, BYTE PTR [rdi+74]
	mov	BYTE PTR [rbx+74], cl
	movzx	ecx, BYTE PTR [rdi+75]
	mov	BYTE PTR [rbx+75], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	rcx, QWORD PTR [r14+8]
	mov	QWORD PTR [rcx], rsi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	rcx, QWORD PTR [r14+8]
	mov	QWORD PTR [rcx+8], rsi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	rcx, QWORD PTR [r14+8]
	mov	QWORD PTR [rcx+16], rsi

; 811  :         this->_Ptr->_Color = _Red;

	mov	rcx, QWORD PTR [r14+8]
	mov	BYTE PTR [rcx+24], bpl
	mov	rcx, QWORD PTR [r14+8]
	mov	BYTE PTR [rcx+25], bpl

; 812  :         this->_Ptr->_Isnil = false;
; 813  :     }

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 80
_Al_$ = 88
_Myhead$ = 96
<_Vals_0>$ = 104
?dtor$1@?0???$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
?dtor$1@?0???$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 80
_Al_$ = 88
_Myhead$ = 96
<_Vals_0>$ = 104
?dtor$0@?0???$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0???$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+16], rdx
	mov	QWORD PTR [rax+24], rdx
	mov	QWORD PTR [rax+32], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 40			; 00000028H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBuffer> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	xorps	xmm0, xmm0
	mov	QWORD PTR [rax+32], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 40			; 00000028H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferAttribute> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	QWORD PTR [rax], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::VertexBufferSize> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@@std@@YAXAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@@std@@YAXAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU10@@Z PROC ; std::_Construct_in_place<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [rdx]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+24], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+32], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+8]
	movups	XMMWORD PTR [rcx+8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+24]
	movups	XMMWORD PTR [rcx+24], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+24], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+32], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx+8], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 256  : }

	ret	0
??$_Construct_in_place@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@@std@@YAXAEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU10@@Z ENDP ; std::_Construct_in_place<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::construct<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [r8]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+24], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+32], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8+8]
	movups	XMMWORD PTR [rdx+8], xmm0
	movups	xmm1, XMMWORD PTR [r8+24]
	movups	XMMWORD PTR [rdx+24], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	QWORD PTR [r8+24], rax
	mov	QWORD PTR [r8+32], 15
	mov	BYTE PTR [r8+8], al
	ret	0
??$construct@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::construct<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_TAEBQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_TAEBQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_TAEBQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$dead$ = 32
??$_Uninitialized_move@PEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	r9, r8

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN88@Uninitiali

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	r10, r9
	lea	r8, QWORD PTR [rcx+8]
	sub	r10, rcx
	xor	r11d, r11d
	npad	11
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [r8-8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	QWORD PTR [r9], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-8]
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	add	r9, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8+r10-40], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+r8-24], r11

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+r8-16], r11

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8-40]
	movups	XMMWORD PTR [r8+r10-40], xmm0
	movups	xmm1, XMMWORD PTR [r8-24]
	movups	XMMWORD PTR [r8+r10-24], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [r8-24], r11
	mov	QWORD PTR [r8-16], 15
	mov	BYTE PTR [r8-40], r11b

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	jne	SHORT $LL4@Uninitiali
$LN88@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, r9
	ret	0
??$_Uninitialized_move@PEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@0PEAU10@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0AEBQEAVTextureToGo@@$0A@@?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@AEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
this$ = 8
_This_arg$ = 16
??$?0AEBQEAVTextureToGo@@$0A@@?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@AEBQEAVTextureToGo@@@Z PROC ; std::tuple<TextureToGo * const &>::tuple<TextureToGo * const &><TextureToGo * const &,0>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx

; 355  :         : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}

	mov	rax, rcx
	ret	0
??$?0AEBQEAVTextureToGo@@$0A@@?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@AEBQEAVTextureToGo@@@Z ENDP ; std::tuple<TextureToGo * const &>::tuple<TextureToGo * const &><TextureToGo * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$tuple@AEBQEAVTextureToGo@@@std@@@std@@YA$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@AEBQEAVTextureToGo@@@std@@@std@@YA$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@AEAV10@@Z PROC ; std::forward<std::tuple<TextureToGo * const &> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$tuple@AEBQEAVTextureToGo@@@std@@@std@@YA$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@AEAV10@@Z ENDP ; std::forward<std::tuple<TextureToGo * const &> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@QEAVTextureToGo@@VTexture@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBQEAVTextureToGo@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$dead$ = 24
<_Args_1>$ = 32
<_Args_2>$dead$ = 40
??$construct@U?$pair@QEAVTextureToGo@@VTexture@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBQEAVTextureToGo@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::construct<std::pair<TextureToGo * const,Texture>,std::piecewise_construct_t const &,std::tuple<TextureToGo * const &>,std::tuple<> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [r9]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rdx], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+16], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+32], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+40], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@U?$pair@QEAVTextureToGo@@VTexture@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBQEAVTextureToGo@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBQEAVTextureToGo@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::construct<std::pair<TextureToGo * const,Texture>,std::piecewise_construct_t const &,std::tuple<TextureToGo * const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@QEAVTextureToGo@@VTexture@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@$$QEAU31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$pair@QEAVTextureToGo@@VTexture@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@$$QEAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::construct<std::pair<TextureToGo * const,Texture>,std::pair<TextureToGo * const,Texture> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [r8]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx], rax
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rdx+8], eax
	mov	eax, DWORD PTR [r8+12]
	mov	DWORD PTR [rdx+12], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+16], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+32], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+40], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm0
	movups	xmm1, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	QWORD PTR [r8+32], rax
	mov	QWORD PTR [r8+40], 15
	mov	BYTE PTR [r8+16], al
	mov	eax, DWORD PTR [r8+48]
	mov	DWORD PTR [rdx+48], eax
	ret	0
??$construct@U?$pair@QEAVTextureToGo@@VTexture@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@1@QEAU?$pair@QEAVTextureToGo@@VTexture@@@1@$$QEAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> > >::construct<std::pair<TextureToGo * const,Texture>,std::pair<TextureToGo * const,Texture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
$T1 = 64
<_Args_0>$dead$ = 64
<_Args_1>$ = 72
<_Args_2>$dead$ = 80
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN16:
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [r9]
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	call	??0BfresFile@@QEAA@XZ			; BfresFile::BfresFile
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
$T1 = 64
<_Args_0>$dead$ = 64
<_Args_1>$ = 72
<_Args_2>$dead$ = 80
?dtor$1@?0???$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@AEAPEAU10@0@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@AEAPEAU10@0@Z PROC ; std::exchange<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * &>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@AEAPEAU10@0@Z ENDP ; std::exchange<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >, COMDAT

; 380  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

$LN74:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rcx, QWORD PTR [rdx+144]
	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR [rsi+112]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR [rsi+88]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR [rsi+64]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rsi+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 176				; 000000b0H
	mov	rcx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 384  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Zero_range@PEAG@std@@YAPEAGQEAG0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Zero_range@PEAG@std@@YAPEAGQEAG0@Z PROC		; std::_Zero_range<unsigned short *>, COMDAT

; 2017 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2018 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 2019 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	mov	rbx, rdx
	sub	r8, rcx
	xor	edx, edx
	call	memset

; 2021 :     return _Last;

	mov	rax, rbx

; 2022 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Zero_range@PEAG@std@@YAPEAGQEAG0@Z ENDP		; std::_Zero_range<unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@G@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@G@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned short> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	WORD PTR [rax], dx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 2

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@G@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned short> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUSkeletonBone@BfresFile@@@std@@YA?A_TAEBQEAUSkeletonBone@BfresFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUSkeletonBone@BfresFile@@@std@@YA?A_TAEBQEAUSkeletonBone@BfresFile@@@Z PROC ; std::_Get_unwrapped<BfresFile::SkeletonBone * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUSkeletonBone@BfresFile@@@std@@YA?A_TAEBQEAUSkeletonBone@BfresFile@@@Z ENDP ; std::_Get_unwrapped<BfresFile::SkeletonBone * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUSkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAUSkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z PROC ; std::_Uninitialized_move<BfresFile::SkeletonBone *,std::allocator<BfresFile::SkeletonBone> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN27:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1940 :             return _Dest + (_ULast - _UFirst);

	mov	rax, 5270498306774157605		; 4924924924924925H
	imul	rbx

; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rbx, QWORD PTR [rsp+72]
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	imul	rax, rdx, 56				; 00000038H
	add	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAUSkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@USkeletonBone@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_move<BfresFile::SkeletonBone *,std::allocator<BfresFile::SkeletonBone> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::SkeletonBone> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	r8d, r8d
	mov	QWORD PTR [rax], -65536			; ffffffffffff0000H
	mov	QWORD PTR [rax+8], 65535		; 0000ffffH
	mov	DWORD PTR [rax+16], 1065353216		; 3f800000H
	mov	DWORD PTR [rax+20], 1065353216		; 3f800000H
	mov	QWORD PTR [rax+24], 1065353216		; 3f800000H
	mov	QWORD PTR [rax+32], r8
	mov	QWORD PTR [rax+40], 1065353216		; 3f800000H
	mov	QWORD PTR [rax+48], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 56			; 00000038H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::SkeletonBone> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUModel@BfresFile@@@std@@YA?A_TAEBQEAUModel@BfresFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUModel@BfresFile@@@std@@YA?A_TAEBQEAUModel@BfresFile@@@Z PROC ; std::_Get_unwrapped<BfresFile::Model * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUModel@BfresFile@@@std@@YA?A_TAEBQEAUModel@BfresFile@@@Z ENDP ; std::_Get_unwrapped<BfresFile::Model * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z PROC ; std::_Uninitialized_move<BfresFile::Model *,std::allocator<BfresFile::Model> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN107:
	push	rbx
	mov	r11, r8
	mov	rbx, rdx

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	$LN102@Uninitiali
	mov	r10, r8
	mov	QWORD PTR [rsp+24], rdi
	sub	r10, rcx
	lea	r9, QWORD PTR [rcx+32]
	xor	edi, edi
	npad	14
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r9-16]
	mov	rcx, QWORD PTR [r9-24]
	mov	rax, QWORD PTR [r9-32]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9-16], rdi
	mov	QWORD PTR [r9-24], rdi
	mov	QWORD PTR [r9-32], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+r10-24], rcx
	mov	QWORD PTR [r11], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	r11, 104				; 00000068H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+r10-16], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r9+8]
	mov	rcx, QWORD PTR [r9]
	mov	rax, QWORD PTR [r9-8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+8], rdi
	mov	QWORD PTR [r9], rdi
	mov	QWORD PTR [r9-8], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+r10], rcx
	mov	QWORD PTR [r9+r10-8], rax
	mov	QWORD PTR [r9+r10+8], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r9+32]
	mov	rcx, QWORD PTR [r9+24]
	mov	rax, QWORD PTR [r9+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+32], rdi
	mov	QWORD PTR [r9+24], rdi
	mov	QWORD PTR [r9+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+r10+24], rcx
	mov	QWORD PTR [r9+r10+16], rax
	mov	QWORD PTR [r9+r10+32], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r9+40]
	mov	r8, QWORD PTR [r9+56]
	mov	rdx, QWORD PTR [r9+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+56], rdi
	mov	QWORD PTR [r9+48], rdi
	mov	QWORD PTR [r9+40], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+r10+40], rcx
	mov	ecx, DWORD PTR [r9+64]
	mov	DWORD PTR [r9+r10+64], ecx
	mov	QWORD PTR [r9+r10+48], rdx
	mov	QWORD PTR [r9+r10+56], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r9, QWORD PTR [r9+104]

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r9-32]
	cmp	rcx, rbx
	jne	$LL4@Uninitiali
	mov	rdi, QWORD PTR [rsp+24]
$LN102@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, r11
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAUModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@YAPEAUModel@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UModel@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_move<BfresFile::Model *,std::allocator<BfresFile::Model> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Model> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm0
	movups	XMMWORD PTR [rax+32], xmm0
	movups	XMMWORD PTR [rax+48], xmm0
	movups	XMMWORD PTR [rax+64], xmm0
	movups	XMMWORD PTR [rax+80], xmm0
	mov	QWORD PTR [rax+96], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+32], rdx
	mov	QWORD PTR [rax+40], rdx
	mov	QWORD PTR [rax+48], rdx
	mov	QWORD PTR [rax+56], rdx
	mov	QWORD PTR [rax+64], rdx
	mov	QWORD PTR [rax+72], rdx
	mov	QWORD PTR [rax+80], rdx
	mov	QWORD PTR [rax+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 104			; 00000068H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Model> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UModel@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@AEBU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UModel@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@AEBU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::Model> >::construct<BfresFile::Model,BfresFile::Model const &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, r8
	jmp	??0Model@BfresFile@@QEAA@AEBU01@@Z
??$construct@UModel@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@AEBU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::Model> >::construct<BfresFile::Model,BfresFile::Model const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUMaterial@BfresFile@@@std@@YA?A_TAEBQEAUMaterial@BfresFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUMaterial@BfresFile@@@std@@YA?A_TAEBQEAUMaterial@BfresFile@@@Z PROC ; std::_Get_unwrapped<BfresFile::Material * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUMaterial@BfresFile@@@std@@YA?A_TAEBQEAUMaterial@BfresFile@@@Z ENDP ; std::_Get_unwrapped<BfresFile::Material * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z PROC ; std::_Uninitialized_move<BfresFile::Material *,std::allocator<BfresFile::Material> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN107:
	push	rbx
	mov	r10, r8
	mov	rbx, rdx

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	$LN102@Uninitiali
	mov	r11, r10
	mov	QWORD PTR [rsp+24], rdi
	sub	r11, rcx
	lea	r8, QWORD PTR [rcx+48]
	xor	edi, edi
	npad	14
$LL4@Uninitiali:
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r10], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r11+r8-96], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r11+r8-88], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8-112]
	movups	XMMWORD PTR [r10], xmm0
	movups	xmm1, XMMWORD PTR [r8-96]
	movups	XMMWORD PTR [r10+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8-96], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	r10, 64					; 00000040H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8-88], 15
	mov	BYTE PTR [r8-112], dil
	movzx	eax, BYTE PTR [r8-80]
	mov	BYTE PTR [r11+r8-80], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-72]
	mov	r9, QWORD PTR [r8-56]
	mov	rdx, QWORD PTR [r8-64]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-56], rdi
	mov	QWORD PTR [r8-64], rdi
	mov	QWORD PTR [r8-72], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+r8-72], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r11-64], rdx
	mov	QWORD PTR [r11+r8-56], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rbx
	jne	SHORT $LL4@Uninitiali
	mov	rdi, QWORD PTR [rsp+24]
$LN102@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, r10
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAUMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@YAPEAUMaterial@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UMaterial@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_move<BfresFile::Material *,std::allocator<BfresFile::Material> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Material> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	xorps	xmm0, xmm0
	mov	DWORD PTR [rax+33], edx
	mov	WORD PTR [rax+37], dx
	mov	BYTE PTR [rax+39], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], dl
	mov	BYTE PTR [rax+32], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+40], rdx
	mov	QWORD PTR [rax+48], rdx
	mov	QWORD PTR [rax+56], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 64			; 00000040H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Material> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UMaterial@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@AEBU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UMaterial@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@AEBU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::Material> >::construct<BfresFile::Material,BfresFile::Material const &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, r8
	jmp	??0Material@BfresFile@@QEAA@AEBU01@@Z
??$construct@UMaterial@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@AEBU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::Material> >::construct<BfresFile::Material,BfresFile::Material const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@MV?$allocator@M@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@MV?$allocator@M@std@@@0@@Z PROC ; std::_Get_unwrapped<std::vector<float,std::allocator<float> > * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@MV?$allocator@M@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::vector<float,std::allocator<float> > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAV?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::vector<float,std::allocator<float> > *,std::allocator<std::vector<float,std::allocator<float> > > >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN39:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	r10, rdx

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN3@Uninitiali

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rax, rbx
	lea	r8, QWORD PTR [rcx+8]
	sub	rax, rcx
	xor	r11d, r11d
	npad	2
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-8]
	mov	r9, QWORD PTR [r8+8]
	mov	rdx, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+8], r11
	mov	QWORD PTR [r8], r11
	mov	QWORD PTR [r8-8], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rbx], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+rax], rdx
	mov	QWORD PTR [rax+r8+8], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+24]

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-8]
	cmp	rcx, r10
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rbx
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YAXPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<float,std::allocator<float> > > >

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();

	mov	rax, rbx

; 1950 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAV?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::vector<float,std::allocator<float> > *,std::allocator<std::vector<float,std::allocator<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_back<>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	edx, edx
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 24

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@V?$vector@MV?$allocator@M@std@@@std@@V12@@std@@YAXAEAV?$vector@MV?$allocator@M@std@@@0@$$QEAV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$vector@MV?$allocator@M@std@@@std@@V12@@std@@YAXAEAV?$vector@MV?$allocator@M@std@@@0@$$QEAV10@@Z PROC ; std::_Construct_in_place<std::vector<float,std::allocator<float> >,std::vector<float,std::allocator<float> > >, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	r9, QWORD PTR [rdx]
	xor	r10d, r10d
	mov	r8, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
	mov	QWORD PTR [rcx], r9
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], rax
	ret	0
??$_Construct_in_place@V?$vector@MV?$allocator@M@std@@@std@@V12@@std@@YAXAEAV?$vector@MV?$allocator@M@std@@@0@$$QEAV10@@Z ENDP ; std::_Construct_in_place<std::vector<float,std::allocator<float> >,std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@V?$vector@MV?$allocator@M@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@QEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@V?$vector@MV?$allocator@M@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@QEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<float,std::allocator<float> > > >::construct<std::vector<float,std::allocator<float> >,std::vector<float,std::allocator<float> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [r8+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8+8]
	mov	rax, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+16], r10
	mov	QWORD PTR [r8+8], r10
	mov	QWORD PTR [r8], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@V?$vector@MV?$allocator@M@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@QEAV?$vector@MV?$allocator@M@std@@@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<float,std::allocator<float> > > >::construct<std::vector<float,std::allocator<float> >,std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAULOD@BfresFile@@@std@@YA?A_TAEBQEAULOD@BfresFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAULOD@BfresFile@@@std@@YA?A_TAEBQEAULOD@BfresFile@@@Z PROC ; std::_Get_unwrapped<BfresFile::LOD * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAULOD@BfresFile@@@std@@YA?A_TAEBQEAULOD@BfresFile@@@Z ENDP ; std::_Get_unwrapped<BfresFile::LOD * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z PROC ; std::_Uninitialized_move<BfresFile::LOD *,std::allocator<BfresFile::LOD> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN96:
	push	rbx
	mov	r11, r8
	mov	rbx, rdx

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	$LN91@Uninitiali
	mov	r10, r11
	mov	QWORD PTR [rsp+24], rdi
	sub	r10, rcx
	lea	r8, QWORD PTR [rcx+32]
	xor	edi, edi
	npad	14
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8-16]
	mov	rcx, QWORD PTR [r8-24]
	mov	rax, QWORD PTR [r8-32]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-16], rdi
	mov	QWORD PTR [r8-24], rdi
	mov	QWORD PTR [r8-32], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10-24], rcx
	mov	QWORD PTR [r11], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	r11, 96					; 00000060H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10-16], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [r8]
	mov	rax, QWORD PTR [r8-8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+8], rdi
	mov	QWORD PTR [r8], rdi
	mov	QWORD PTR [r8-8], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10], rcx
	mov	QWORD PTR [r8+r10-8], rax
	mov	QWORD PTR [r10+r8+8], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+32]
	mov	rcx, QWORD PTR [r8+24]
	mov	rax, QWORD PTR [r8+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+32], rdi
	mov	QWORD PTR [r8+24], rdi
	mov	QWORD PTR [r8+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+r8+24], rcx
	mov	QWORD PTR [r8+r10+16], rax
	mov	QWORD PTR [r8+r10+32], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8+40]
	mov	r9, QWORD PTR [r8+56]
	mov	rdx, QWORD PTR [r8+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+56], rdi
	mov	QWORD PTR [r8+48], rdi
	mov	QWORD PTR [r8+40], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10+40], rcx
	mov	QWORD PTR [r8+r10+48], rdx
	mov	QWORD PTR [r8+r10+56], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+96]

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-32]
	cmp	rcx, rbx
	jne	$LL4@Uninitiali
	mov	rdi, QWORD PTR [rsp+24]
$LN91@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, r11
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@YAPEAULOD@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@ULOD@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_move<BfresFile::LOD *,std::allocator<BfresFile::LOD> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::LOD> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	edx, edx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm0
	movups	XMMWORD PTR [rax+32], xmm0
	movups	XMMWORD PTR [rax+48], xmm0
	movups	XMMWORD PTR [rax+64], xmm0
	movups	XMMWORD PTR [rax+80], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+32], rdx
	mov	QWORD PTR [rax+40], rdx
	mov	QWORD PTR [rax+48], rdx
	mov	QWORD PTR [rax+56], rdx
	mov	QWORD PTR [rax+64], rdx
	mov	QWORD PTR [rax+72], rdx
	mov	QWORD PTR [rax+80], rdx
	mov	QWORD PTR [rax+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 96			; 00000060H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::LOD> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@ULOD@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@AEBU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@ULOD@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@AEBU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::LOD> >::construct<BfresFile::LOD,BfresFile::LOD const &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, r8
	jmp	??0LOD@BfresFile@@QEAA@AEBU01@@Z
??$construct@ULOD@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@AEBU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::LOD> >::construct<BfresFile::LOD,BfresFile::LOD const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAVMesh@@@std@@YA?A_TAEBQEAVMesh@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAVMesh@@@std@@YA?A_TAEBQEAVMesh@@@Z PROC ; std::_Get_unwrapped<Mesh * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAVMesh@@@std@@YA?A_TAEBQEAVMesh@@@Z ENDP ; std::_Get_unwrapped<Mesh * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z PROC ; std::_Uninitialized_move<Mesh *,std::allocator<Mesh> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN84:
	sub	rsp, 8
	mov	r10, r8
	mov	r11, rdx

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	$LN79@Uninitiali
	mov	r9, r10
	mov	QWORD PTR [rsp], rbx
	sub	r9, rcx
	lea	r8, QWORD PTR [rcx+32]
	xor	ebx, ebx
	npad	13
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8-16]
	mov	rcx, QWORD PTR [r8-24]
	mov	rax, QWORD PTR [r8-32]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-16], rbx
	mov	QWORD PTR [r8-24], rbx
	mov	QWORD PTR [r8-32], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r9-24], rcx
	mov	QWORD PTR [r10], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	r10, 96					; 00000060H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r9-16], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+8]
	mov	rcx, QWORD PTR [r8]
	mov	rax, QWORD PTR [r8-8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+8], rbx
	mov	QWORD PTR [r8], rbx
	mov	QWORD PTR [r8-8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r9], rcx
	mov	QWORD PTR [r8+r9-8], rax
	mov	QWORD PTR [r9+r8+8], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8+24]
	mov	rax, QWORD PTR [r8+16]
	mov	rdx, QWORD PTR [r8+32]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+32], rbx
	mov	QWORD PTR [r8+24], rbx
	mov	QWORD PTR [r8+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r9+24], rcx
	mov	QWORD PTR [r8+r9+16], rax
	mov	QWORD PTR [r8+r9+32], rdx
	mov	eax, DWORD PTR [r8+40]
	mov	DWORD PTR [r8+r9+40], eax
	mov	ecx, DWORD PTR [r8+44]
	mov	DWORD PTR [r8+r9+44], ecx
	mov	ecx, DWORD PTR [r8+48]
	mov	DWORD PTR [r8+r9+48], ecx
	mov	ecx, DWORD PTR [r8+52]
	mov	DWORD PTR [r8+r9+52], ecx
	mov	ecx, DWORD PTR [r8+56]
	mov	DWORD PTR [r8+r9+56], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+96]

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-32]
	cmp	rcx, r11
	jne	$LL4@Uninitiali
	mov	rbx, QWORD PTR [rsp]
$LN79@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, r10
	add	rsp, 8
	ret	0
??$_Uninitialized_move@PEAVMesh@@V?$allocator@VMesh@@@std@@@std@@YAPEAVMesh@@QEAV1@0PEAV1@AEAV?$allocator@VMesh@@@0@@Z ENDP ; std::_Uninitialized_move<Mesh *,std::allocator<Mesh> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@VMesh@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@VMesh@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<Mesh> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	edx, edx
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
	mov	QWORD PTR [rax+24], rdx
	mov	QWORD PTR [rax+32], rdx
	mov	QWORD PTR [rax+40], rdx
	mov	QWORD PTR [rax+48], rdx
	mov	QWORD PTR [rax+56], rdx
	mov	QWORD PTR [rax+64], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 96			; 00000060H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@VMesh@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<Mesh> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@IV?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@IV?$allocator@I@std@@@0@@Z PROC ; std::_Get_unwrapped<std::vector<unsigned int,std::allocator<unsigned int> > * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@IV?$allocator@I@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::vector<unsigned int,std::allocator<unsigned int> > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAV?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::vector<unsigned int,std::allocator<unsigned int> > *,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN39:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	r10, rdx

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN3@Uninitiali

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rax, rbx
	lea	r8, QWORD PTR [rcx+8]
	sub	rax, rcx
	xor	r11d, r11d
	npad	2
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-8]
	mov	r9, QWORD PTR [r8+8]
	mov	rdx, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+8], r11
	mov	QWORD PTR [r8], r11
	mov	QWORD PTR [r8-8], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rbx], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+rax], rdx
	mov	QWORD PTR [rax+r8+8], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+24]

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-8]
	cmp	rcx, r10
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rbx
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YAXPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();

	mov	rax, rbx

; 1950 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAV?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::vector<unsigned int,std::allocator<unsigned int> > *,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_back<>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	edx, edx
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 24

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXAEAV?$vector@IV?$allocator@I@std@@@0@$$QEAV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXAEAV?$vector@IV?$allocator@I@std@@@0@$$QEAV10@@Z PROC ; std::_Construct_in_place<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	r9, QWORD PTR [rdx]
	xor	r10d, r10d
	mov	r8, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
	mov	QWORD PTR [rcx], r9
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], rax
	ret	0
??$_Construct_in_place@V?$vector@IV?$allocator@I@std@@@std@@V12@@std@@YAXAEAV?$vector@IV?$allocator@I@std@@@0@$$QEAV10@@Z ENDP ; std::_Construct_in_place<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@QEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@QEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::construct<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [r8+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8+8]
	mov	rax, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+16], r10
	mov	QWORD PTR [r8+8], r10
	mov	QWORD PTR [r8], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@V?$vector@IV?$allocator@I@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@QEAV?$vector@IV?$allocator@I@std@@@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::construct<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUBfresTexture@BfresFile@@@std@@YA?A_TAEBQEAUBfresTexture@BfresFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUBfresTexture@BfresFile@@@std@@YA?A_TAEBQEAUBfresTexture@BfresFile@@@Z PROC ; std::_Get_unwrapped<BfresFile::BfresTexture * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUBfresTexture@BfresFile@@@std@@YA?A_TAEBQEAUBfresTexture@BfresFile@@@Z ENDP ; std::_Get_unwrapped<BfresFile::BfresTexture * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z PROC ; std::_Uninitialized_move<BfresFile::BfresTexture *,std::allocator<BfresFile::BfresTexture> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN99:
	sub	rsp, 8
	mov	r9, r8
	mov	r11, rdx

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	$LN94@Uninitiali
	mov	r10, r9
	mov	QWORD PTR [rsp], rbx
	sub	r10, rcx
	lea	r8, QWORD PTR [rcx+16]
	xor	ebx, ebx
	npad	13
$LL4@Uninitiali:
	mov	rax, QWORD PTR [r8-16]

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+64]
	mov	QWORD PTR [r9], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	r9, 64					; 00000040H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8-56]
	mov	rax, QWORD PTR [r8-72]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-56], rbx
	mov	QWORD PTR [r8-64], rbx
	mov	QWORD PTR [r8-72], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10-64], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+r8-72], rax
	mov	QWORD PTR [r10+r8-56], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r10+r8-48], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+r8-32], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+r8-24], rbx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8-48]
	movups	XMMWORD PTR [r10+r8-48], xmm0
	movups	xmm1, XMMWORD PTR [r8-32]
	movups	XMMWORD PTR [r10+r8-32], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [r8-32], rbx
	mov	QWORD PTR [r8-24], 15
	mov	BYTE PTR [r8-48], bl

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, r11
	jne	SHORT $LL4@Uninitiali
	mov	rbx, QWORD PTR [rsp]
$LN94@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, r9
	add	rsp, 8
	ret	0
??$_Uninitialized_move@PEAUBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@0PEAU12@AEAV?$allocator@UBfresTexture@BfresFile@@@0@@Z ENDP ; std::_Uninitialized_move<BfresFile::BfresTexture *,std::allocator<BfresFile::BfresTexture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 48
this$ = 48
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::BfresTexture> >::_Emplace_back<>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR $T1[rsp], rcx
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+48], rax
	mov	QWORD PTR [rcx+56], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	add	rcx, 32					; 00000020H
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rbx+8], 64			; 00000040H

; 1804 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::BfresTexture> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 48
?dtor$0@?0???$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ@4HA PROC ; `std::_Uninitialized_backout_al<std::allocator<BfresFile::BfresTexture> >::_Emplace_back<>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAXXZ@4HA ENDP ; `std::_Uninitialized_backout_al<std::allocator<BfresFile::BfresTexture> >::_Emplace_back<>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z
_TEXT	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture,BfresFile::BfresTexture const &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN11:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdx
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
	lea	rcx, QWORD PTR [rdx+8]
	lea	rdx, QWORD PTR [r8+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	lea	rdx, QWORD PTR [rdi+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture,BfresFile::BfresTexture const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
?dtor$0@?0???$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture,BfresFile::BfresTexture const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@UBfresTexture@BfresFile@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@AEBU34@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture,BfresFile::BfresTexture const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEBQEAVTexture@@@std@@YA$$QEAPEBQEAVTexture@@AEAPEBQEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEBQEAVTexture@@@std@@YA$$QEAPEBQEAVTexture@@AEAPEBQEAV1@@Z PROC ; std::move<Texture * const * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEBQEAVTexture@@@std@@YA$$QEAPEBQEAVTexture@@AEAPEBQEAV1@@Z ENDP ; std::move<Texture * const * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@QEAVTexture@@@std@@YAPEBQEAVTexture@@QEBQEAV1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@QEAVTexture@@@std@@YAPEBQEAVTexture@@QEBQEAV1@@Z PROC ; std::to_address<Texture * const>, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@QEAVTexture@@@std@@YAPEBQEAVTexture@@QEBQEAV1@@Z ENDP ; std::to_address<Texture * const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PEBQEAVTexture@@PEAPEAV1@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEBQEAVTexture@@PEAPEAV1@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@@Z PROC ; std::_Copy_memmove<Texture * const *,Texture * *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEBQEAVTexture@@PEAPEAV1@@std@@YAPEAPEAVTexture@@PEBQEAV1@0PEAPEAV1@@Z ENDP ; std::_Copy_memmove<Texture * const *,Texture * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEBQEAVTexture@@@?$_Uninitialized_backout_al@V?$allocator@PEAVTexture@@@std@@@std@@QEAAXAEBQEAVTexture@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEBQEAVTexture@@@?$_Uninitialized_backout_al@V?$allocator@PEAVTexture@@@std@@@std@@QEAAXAEBQEAVTexture@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Texture *> >::_Emplace_back<Texture * const &>, COMDAT

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1804 :     }

	ret	0
??$_Emplace_back@AEBQEAVTexture@@@?$_Uninitialized_backout_al@V?$allocator@PEAVTexture@@@std@@@std@@QEAAXAEBQEAVTexture@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Texture *> >::_Emplace_back<Texture * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAM@std@@YA?A_TAEBQEAM@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAM@std@@YA?A_TAEBQEAM@Z PROC	; std::_Get_unwrapped<float * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAM@std@@YA?A_TAEBQEAM@Z ENDP	; std::_Get_unwrapped<float * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z PROC ; std::_Uninitialized_move<float *,std::allocator<float> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN27:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1940 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 2
	lea	rax, QWORD PTR [rdi+rbx*4]

; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z ENDP ; std::_Uninitialized_move<float *,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z PROC		; std::_Zero_range<float *>, COMDAT

; 2017 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2018 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 2019 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	mov	rbx, rdx
	sub	r8, rcx
	xor	edx, edx
	call	memset

; 2021 :     return _Last;

	mov	rax, rbx

; 2022 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Zero_range@PEAM@std@@YAPEAMQEAM0@Z ENDP		; std::_Zero_range<float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<float> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	DWORD PTR [rax], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 4

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<float> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char const &>, COMDAT

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 1803 :         ++_Last;

	inc	QWORD PTR [rcx+8]

; 1804 :     }

	ret	0
??$_Emplace_back@AEBE@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAXAEBE@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z PROC	; std::_Copy_memmove<unsigned char const *,unsigned char *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEBEPEAE@std@@YAPEAEPEBE0PEAE@Z ENDP	; std::_Copy_memmove<unsigned char const *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@UVertexBuffer@BfresFile@@@std@@YAXQEAUVertexBuffer@BfresFile@@@Z
_TEXT	SEGMENT
_Location$ = 48
??$destroy_at@UVertexBuffer@BfresFile@@@std@@YAXQEAUVertexBuffer@BfresFile@@@Z PROC ; std::destroy_at<BfresFile::VertexBuffer>, COMDAT

; 314  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN44:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx+16]
	test	rcx, rcx
	je	SHORT $LN12@destroy_at

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+32]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN30@destroy_at

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN27@destroy_at

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN30@destroy_at:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+24], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+32], rax
$LN12@destroy_at:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 323  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN27@destroy_at:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN41@destroy_at:
??$destroy_at@UVertexBuffer@BfresFile@@@std@@YAXQEAUVertexBuffer@BfresFile@@@Z ENDP ; std::destroy_at<BfresFile::VertexBuffer>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1VertexBuffer@BfresFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1VertexBuffer@BfresFile@@QEAA@XZ PROC			; BfresFile::VertexBuffer::~VertexBuffer, COMDAT
$LN36:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx+16]
	test	rcx, rcx
	je	SHORT $LN6@VertexBuff

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+32]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@VertexBuff

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@VertexBuff

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@VertexBuff:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+24], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+32], rax
$LN6@VertexBuff:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@VertexBuff:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN33@VertexBuff:
??1VertexBuffer@BfresFile@@QEAA@XZ ENDP			; BfresFile::VertexBuffer::~VertexBuffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@UVertexBufferAttribute@BfresFile@@@std@@YAXQEAUVertexBufferAttribute@BfresFile@@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@UVertexBufferAttribute@BfresFile@@@std@@YAXQEAUVertexBufferAttribute@BfresFile@@@Z PROC ; std::destroy_at<BfresFile::VertexBufferAttribute>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??$destroy_at@UVertexBufferAttribute@BfresFile@@@std@@YAXQEAUVertexBufferAttribute@BfresFile@@@Z ENDP ; std::destroy_at<BfresFile::VertexBufferAttribute>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??1VertexBufferAttribute@BfresFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1VertexBufferAttribute@BfresFile@@QEAA@XZ PROC	; BfresFile::VertexBufferAttribute::~VertexBufferAttribute, COMDAT

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??1VertexBufferAttribute@BfresFile@@QEAA@XZ ENDP	; BfresFile::VertexBufferAttribute::~VertexBufferAttribute
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::destroy_at<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 314  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

	add	rcx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??$destroy_at@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXQEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::destroy_at<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z PROC ; std::construct_at<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ENDP ; std::construct_at<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YAXQEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YAXQEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z PROC ; std::destroy_at<std::pair<TextureToGo * const,Texture> >, COMDAT

; 314  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

	add	rcx, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
??$destroy_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@YAXQEAU?$pair@QEAVTextureToGo@@VTexture@@@0@@Z ENDP ; std::destroy_at<std::pair<TextureToGo * const,Texture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<TextureToGo * const,Texture>,void *> *,std::_List_node<std::pair<TextureToGo * const,Texture>,void *> * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *>, COMDAT

; 305  :     if constexpr (is_array_v<_Ty>) {
; 306  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 307  :     } else {
; 308  :         _Obj.~_Ty();
; 309  :     }
; 310  : }

	ret	0
??$_Destroy_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >, COMDAT

; 724  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	rcx, rdx
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$_Hash_representation@PEAVTextureToGo@@@std@@YA_KAEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
_Keyval$ = 8
??$_Hash_representation@PEAVTextureToGo@@@std@@YA_KAEBQEAVTextureToGo@@@Z PROC ; std::_Hash_representation<TextureToGo *>, COMDAT

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rcx]

; 2346 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2369 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

	mov	rdx, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+1]

; 2346 :         _Val *= _FNV_prime;

	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+2]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+3]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+4]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rcx+5]
	movzx	ecx, BYTE PTR [rcx+6]
	imul	r8, r9
	xor	rax, r8
	imul	rax, r9
	xor	rax, rcx
	movzx	ecx, BYTE PTR [rdx+7]
	imul	rax, r9
	xor	rax, rcx
	imul	rax, r9

; 2370 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
; 2371 : }

	ret	0
??$_Hash_representation@PEAVTextureToGo@@@std@@YA_KAEBQEAVTextureToGo@@@Z ENDP ; std::_Hash_representation<TextureToGo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??0?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAU01@@Z PROC ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [rdx]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+24], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+32], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+8]
	movups	XMMWORD PTR [rcx+8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+24]
	movups	XMMWORD PTR [rcx+24], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], 15
	mov	BYTE PTR [rdx+8], al
	mov	rax, rcx
	ret	0
??0?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAU01@@Z ENDP ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??_GVertexBuffer@BfresFile@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GVertexBuffer@BfresFile@@QEAAPEAXI@Z PROC		; BfresFile::VertexBuffer::`scalar deleting destructor', COMDAT
$LN41:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx+16]
	test	rcx, rcx
	je	SHORT $LN10@scalar

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+32]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN28@scalar

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN25@scalar

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN28@scalar:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+24], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+32], rax
$LN10@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN25@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN38@scalar:
??_GVertexBuffer@BfresFile@@QEAAPEAXI@Z ENDP		; BfresFile::VertexBuffer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??_GVertexBufferAttribute@BfresFile@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GVertexBufferAttribute@BfresFile@@QEAAPEAXI@Z PROC	; BfresFile::VertexBufferAttribute::`scalar deleting destructor', COMDAT
$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GVertexBufferAttribute@BfresFile@@QEAAPEAXI@Z ENDP	; BfresFile::VertexBufferAttribute::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??_G?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z PROC ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor', COMDAT
$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	add	rcx, 8

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAPEAXI@Z ENDP ; std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??_G?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAAPEAXI@Z PROC ; std::pair<TextureToGo * const,Texture>::`scalar deleting destructor', COMDAT
$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	add	rcx, 16

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAAPEAXI@Z ENDP ; std::pair<TextureToGo * const,Texture>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >, COMDAT

; 785  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN40:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+112]
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rbx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 787  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z@4HA PROC ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z@4HA ENDP ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Get_scary@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Get_scary, COMDAT

; 1973 :         return _STD addressof(_Mypair._Myval2._Myval2);

	lea	rax, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures

; 1974 :     }

	ret	0
?_Get_scary@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Getcomp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Getcomp, COMDAT

; 1957 :         return _Mypair._Get_first();

	lea	rax, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures

; 1958 :     }

	ret	0
?_Getcomp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@IV?$allocator@I@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@IV?$allocator@I@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Allocate, COMDAT

; 1150 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rbx+8], rax

; 1153 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >, COMDAT

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 0
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>,1>::_Get_first, COMDAT

; 1527 :         return *this;

	lea	rax, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$dead$ = 16
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >::allocate, COMDAT

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	jmp	??2@YAPEAX_K@Z				; operator new
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@$$QEAU31@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@$$QEAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rcx, rdi
	mov	rdx, r8
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rdx, QWORD PTR [rbx+32]
	lea	rcx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	jmp	??0BfresFile@@QEAA@$$QEAV0@@Z
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@$$QEAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
;	COMDAT ??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z PROC ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>, COMDAT

; 68   :         return _Val.first;

	mov	rax, rcx

; 69   :     }

	ret	0
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ENDP ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@$$QEAU31@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@$$QEAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rcx, rdi
	mov	rdx, r8
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR [rbx+32]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	edx, edx
	mov	QWORD PTR [rdi+32], rax

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rbx+40]
	mov	r9, QWORD PTR [rbx+56]
	mov	rcx, QWORD PTR [rbx+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx+56], rdx
	mov	QWORD PTR [rbx+48], rdx
	mov	QWORD PTR [rbx+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdi+40], rax
	mov	QWORD PTR [rdi+48], rcx
	mov	QWORD PTR [rdi+56], r9
	movzx	eax, WORD PTR [rbx+64]
	mov	WORD PTR [rdi+64], ax
	movzx	eax, WORD PTR [rbx+66]
	mov	WORD PTR [rdi+66], ax
	movzx	eax, WORD PTR [rbx+68]
	mov	WORD PTR [rdi+68], ax
	movzx	eax, BYTE PTR [rbx+70]
	mov	BYTE PTR [rdi+70], al
	movzx	eax, WORD PTR [rbx+72]
	mov	WORD PTR [rdi+72], ax
	movzx	eax, BYTE PTR [rbx+74]
	mov	BYTE PTR [rdi+74], al
	movzx	eax, BYTE PTR [rbx+75]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [rdi+75], al
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@$$QEAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UVertexBuffer@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBuffer@BfresFile@@@1@QEAUVertexBuffer@BfresFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UVertexBuffer@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBuffer@BfresFile@@@1@QEAUVertexBuffer@BfresFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBuffer> >::construct<BfresFile::VertexBuffer>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UVertexBuffer@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBuffer@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBuffer@BfresFile@@@1@QEAUVertexBuffer@BfresFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBuffer> >::construct<BfresFile::VertexBuffer>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UVertexBufferAttribute@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@QEAUVertexBufferAttribute@BfresFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UVertexBufferAttribute@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@QEAUVertexBufferAttribute@BfresFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferAttribute> >::construct<BfresFile::VertexBufferAttribute>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UVertexBufferAttribute@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBufferAttribute@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferAttribute@BfresFile@@@1@QEAUVertexBufferAttribute@BfresFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferAttribute> >::construct<BfresFile::VertexBufferAttribute>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UVertexBufferSize@BfresFile@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UVertexBufferSize@BfresFile@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@@Z PROC ; std::_Unfancy<BfresFile::VertexBufferSize>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UVertexBufferSize@BfresFile@@@std@@YAPEAUVertexBufferSize@BfresFile@@PEAU12@@Z ENDP ; std::_Unfancy<BfresFile::VertexBufferSize>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UVertexBufferSize@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferSize@BfresFile@@@1@QEAUVertexBufferSize@BfresFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UVertexBufferSize@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferSize@BfresFile@@@1@QEAUVertexBufferSize@BfresFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferSize> >::construct<BfresFile::VertexBufferSize>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UVertexBufferSize@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UVertexBufferSize@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UVertexBufferSize@BfresFile@@@1@QEAUVertexBufferSize@BfresFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::VertexBufferSize> >::construct<BfresFile::VertexBufferSize>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@$0A@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@$$QEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@$0A@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@$$QEAU10@@Z PROC ; std::construct_at<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [rdx]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+24], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+32], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+8]
	movups	XMMWORD PTR [rcx+8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+24]
	movups	XMMWORD PTR [rcx+24], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], 15
	mov	BYTE PTR [rdx+8], al
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U12@$0A@@std@@YAPEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAU10@$$QEAU10@@Z ENDP ; std::construct_at<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_back<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [rdx]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	QWORD PTR [r8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8+8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r8+24], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+32], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+8]
	movups	XMMWORD PTR [r8+8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+24]
	movups	XMMWORD PTR [r8+24], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], 15
	mov	BYTE PTR [rdx+8], al
	add	QWORD PTR [rcx+8], 40			; 00000028H

; 1804 :     }

	ret	0
??$_Emplace_back@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@U?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QEAAX$$QEAU?$pair@PEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Emplace_back<std::pair<TextureToGo *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AEBQEAVTextureToGo@@$$V$0A@@?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@U_Exact_args_t@1@AEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_This_arg$ = 24
??$?0U_Exact_args_t@std@@AEBQEAVTextureToGo@@$$V$0A@@?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@U_Exact_args_t@1@AEBQEAVTextureToGo@@@Z PROC ; std::tuple<TextureToGo * const &>::tuple<TextureToGo * const &><std::_Exact_args_t,TextureToGo * const &,0>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], r8

; 317  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

	mov	rax, rcx
	ret	0
??$?0U_Exact_args_t@std@@AEBQEAVTextureToGo@@$$V$0A@@?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@U_Exact_args_t@1@AEBQEAVTextureToGo@@@Z ENDP ; std::tuple<TextureToGo * const &>::tuple<TextureToGo * const &><std::_Exact_args_t,TextureToGo * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBQEAVTextureToGo@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@$$QEAV?$tuple@$$V@0@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
<_Args_2>$dead$ = 32
??$construct_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBQEAVTextureToGo@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@$$QEAV?$tuple@$$V@0@@Z PROC ; std::construct_at<std::pair<TextureToGo * const,Texture>,std::piecewise_construct_t const &,std::tuple<TextureToGo * const &>,std::tuple<>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [r8]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+16], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+32], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+40], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBQEAVTextureToGo@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@$$QEAV?$tuple@$$V@0@@Z ENDP ; std::construct_at<std::pair<TextureToGo * const,Texture>,std::piecewise_construct_t const &,std::tuple<TextureToGo * const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@U12@$0A@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@QEAU10@$$QEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@U12@$0A@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@QEAU10@$$QEAU10@@Z PROC ; std::construct_at<std::pair<TextureToGo * const,Texture>,std::pair<TextureToGo * const,Texture>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [rdx]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx], rax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+12], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+16], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+32], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+40], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	xmm1, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], 15
	mov	BYTE PTR [rdx+16], al
	mov	eax, DWORD PTR [rdx+48]
	mov	DWORD PTR [rcx+48], eax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@U?$pair@QEAVTextureToGo@@VTexture@@@std@@U12@$0A@@std@@YAPEAU?$pair@QEAVTextureToGo@@VTexture@@@0@QEAU10@$$QEAU10@@Z ENDP ; std::construct_at<std::pair<TextureToGo * const,Texture>,std::pair<TextureToGo * const,Texture>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$dead$ = 56
<_Args_1>$ = 64
<_Args_2>$dead$ = 72
$T1 = 72
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z PROC ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN14:
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [r8]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	call	??0BfresFile@@QEAA@XZ			; BfresFile::BfresFile
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rbx

; 242  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z ENDP ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Location$ = 48
<_Args_0>$dead$ = 56
<_Args_1>$ = 64
<_Args_2>$dead$ = 72
$T1 = 72
?dtor$1@?0???$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z@4HA PROC ; `std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z@4HA ENDP ; `std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@G$$V@?$_Default_allocator_traits@V?$allocator@G@std@@@std@@SAXAEAV?$allocator@G@1@QEAG@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@G$$V@?$_Default_allocator_traits@V?$allocator@G@std@@@std@@SAXAEAV?$allocator@G@1@QEAG@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned short> >::construct<unsigned short>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	WORD PTR [rdx], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@G$$V@?$_Default_allocator_traits@V?$allocator@G@std@@@std@@SAXAEAV?$allocator@G@1@QEAG@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned short> >::construct<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUSkeletonBone@BfresFile@@@std@@YA$$QEAUSkeletonBone@BfresFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUSkeletonBone@BfresFile@@@std@@YA$$QEAUSkeletonBone@BfresFile@@AEAU12@@Z PROC ; std::move<BfresFile::SkeletonBone &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUSkeletonBone@BfresFile@@@std@@YA$$QEAUSkeletonBone@BfresFile@@AEAU12@@Z ENDP ; std::move<BfresFile::SkeletonBone &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@USkeletonBone@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX$$QEAUSkeletonBone@BfresFile@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@USkeletonBone@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX$$QEAUSkeletonBone@BfresFile@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::SkeletonBone> >::_Emplace_back<BfresFile::SkeletonBone>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rax+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rax+32], xmm0
	movsd	xmm1, QWORD PTR [rdx+48]
	movsd	QWORD PTR [rax+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 56			; 00000038H

; 1804 :     }

	ret	0
??$_Emplace_back@USkeletonBone@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@QEAAX$$QEAUSkeletonBone@BfresFile@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::SkeletonBone> >::_Emplace_back<BfresFile::SkeletonBone>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@USkeletonBone@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@SAXAEAV?$allocator@USkeletonBone@BfresFile@@@1@QEAUSkeletonBone@BfresFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@USkeletonBone@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@SAXAEAV?$allocator@USkeletonBone@BfresFile@@@1@QEAUSkeletonBone@BfresFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::SkeletonBone> >::construct<BfresFile::SkeletonBone>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	xor	ecx, ecx
	mov	QWORD PTR [rdx], -65536			; ffffffffffff0000H
	mov	QWORD PTR [rdx+32], rcx
	mov	QWORD PTR [rdx+48], rcx
	mov	QWORD PTR [rdx+8], 65535		; 0000ffffH
	mov	DWORD PTR [rdx+16], 1065353216		; 3f800000H
	mov	DWORD PTR [rdx+20], 1065353216		; 3f800000H
	mov	QWORD PTR [rdx+24], 1065353216		; 3f800000H
	mov	QWORD PTR [rdx+40], 1065353216		; 3f800000H

; 716  : #if _HAS_CXX20
; 717  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 718  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 719  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 720  : #endif // ^^^ !_HAS_CXX20 ^^^
; 721  :     }

	ret	0
??$construct@USkeletonBone@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@SAXAEAV?$allocator@USkeletonBone@BfresFile@@@1@QEAUSkeletonBone@BfresFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::SkeletonBone> >::construct<BfresFile::SkeletonBone>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0SkeletonBone@BfresFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0SkeletonBone@BfresFile@@QEAA@XZ PROC			; BfresFile::SkeletonBone::SkeletonBone, COMDAT
	xor	edx, edx
	mov	QWORD PTR [rcx], -65536			; ffffffffffff0000H
	mov	QWORD PTR [rcx+32], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+48], rdx
	mov	QWORD PTR [rcx+8], 65535		; 0000ffffH
	mov	DWORD PTR [rcx+16], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+20], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+24], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+40], 1065353216		; 3f800000H
	ret	0
??0SkeletonBone@BfresFile@@QEAA@XZ ENDP			; BfresFile::SkeletonBone::SkeletonBone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUModel@BfresFile@@@std@@YA$$QEAUModel@BfresFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUModel@BfresFile@@@std@@YA$$QEAUModel@BfresFile@@AEAU12@@Z PROC ; std::move<BfresFile::Model &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUModel@BfresFile@@@std@@YA$$QEAUModel@BfresFile@@AEAU12@@Z ENDP ; std::move<BfresFile::Model &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UModel@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX$$QEAUModel@BfresFile@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UModel@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX$$QEAUModel@BfresFile@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Model> >::_Emplace_back<BfresFile::Model>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN60:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r10, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	r11, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	edi, edi
	mov	r9, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], rdi
	mov	QWORD PTR [rdx+8], rdi
	mov	QWORD PTR [rdx], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+40]
	mov	rcx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [r11+24]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r11+40], rdi
	mov	QWORD PTR [r11+32], rdi
	mov	QWORD PTR [r11+24], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+24], rax
	mov	QWORD PTR [r10+32], rcx
	mov	QWORD PTR [r10+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r11+64]
	mov	rcx, QWORD PTR [r11+56]
	mov	rax, QWORD PTR [r11+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r11+64], rdi
	mov	QWORD PTR [r11+56], rdi
	mov	QWORD PTR [r11+48], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+48], rax
	mov	QWORD PTR [r10+56], rcx
	mov	QWORD PTR [r10+64], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r11+72]
	mov	rdx, QWORD PTR [r11+88]
	mov	rcx, QWORD PTR [r11+80]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r11+88], rdi
	mov	QWORD PTR [r11+80], rdi
	mov	QWORD PTR [r11+72], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1804 :     }

	mov	rdi, QWORD PTR [rsp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+72], rax
	mov	eax, DWORD PTR [r11+96]
	mov	QWORD PTR [r10+80], rcx
	mov	QWORD PTR [r10+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rbx+8], 104			; 00000068H

; 1804 :     }

	mov	rbx, QWORD PTR [rsp+8]
	mov	DWORD PTR [r10+96], eax
	ret	0
??$_Emplace_back@UModel@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UModel@BfresFile@@@std@@@std@@QEAAX$$QEAUModel@BfresFile@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Model> >::_Emplace_back<BfresFile::Model>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UModel@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UModel@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::Model> >::construct<BfresFile::Model>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rdx], xmm0
	movups	XMMWORD PTR [rdx+16], xmm0
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	XMMWORD PTR [rdx+48], xmm0
	movups	XMMWORD PTR [rdx+64], xmm0
	movups	XMMWORD PTR [rdx+80], xmm0
	mov	QWORD PTR [rdx+96], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
	mov	QWORD PTR [rdx+56], rax
	mov	QWORD PTR [rdx+64], rax
	mov	QWORD PTR [rdx+72], rax
	mov	QWORD PTR [rdx+80], rax
	mov	QWORD PTR [rdx+88], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UModel@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::Model> >::construct<BfresFile::Model>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UModel@BfresFile@@AEBU12@$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@AEBU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UModel@BfresFile@@AEBU12@$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@AEBU12@@Z PROC ; std::construct_at<BfresFile::Model,BfresFile::Model const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	jmp	??0Model@BfresFile@@QEAA@AEBU01@@Z
??$construct_at@UModel@BfresFile@@AEBU12@$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@AEBU12@@Z ENDP ; std::construct_at<BfresFile::Model,BfresFile::Model const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUMaterial@BfresFile@@@std@@YA$$QEAUMaterial@BfresFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUMaterial@BfresFile@@@std@@YA$$QEAUMaterial@BfresFile@@AEAU12@@Z PROC ; std::move<BfresFile::Material &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUMaterial@BfresFile@@@std@@YA$$QEAUMaterial@BfresFile@@AEAU12@@Z ENDP ; std::move<BfresFile::Material &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UMaterial@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX$$QEAUMaterial@BfresFile@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UMaterial@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX$$QEAUMaterial@BfresFile@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Material> >::_Emplace_back<BfresFile::Material>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r11d, r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	r9, rdx
	xorps	xmm0, xmm0
	mov	r10, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r8+16], r11

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+24], r11

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [r8+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r11b
	movzx	eax, BYTE PTR [rdx+32]
	mov	BYTE PTR [r8+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+56]
	mov	rcx, QWORD PTR [r9+48]
	mov	rax, QWORD PTR [r9+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+56], r11
	mov	QWORD PTR [r9+48], r11
	mov	QWORD PTR [r9+40], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+40], rax
	mov	QWORD PTR [r8+48], rcx
	mov	QWORD PTR [r8+56], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [r10+8], 64			; 00000040H

; 1804 :     }

	ret	0
??$_Emplace_back@UMaterial@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAAX$$QEAUMaterial@BfresFile@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::Material> >::_Emplace_back<BfresFile::Material>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UMaterial@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UMaterial@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::Material> >::construct<BfresFile::Material>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	DWORD PTR [rdx+33], eax
	mov	WORD PTR [rdx+37], ax
	mov	BYTE PTR [rdx+39], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
	mov	BYTE PTR [rdx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
	mov	QWORD PTR [rdx+56], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UMaterial@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::Material> >::construct<BfresFile::Material>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UMaterial@BfresFile@@AEBU12@$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@AEBU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UMaterial@BfresFile@@AEBU12@$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@AEBU12@@Z PROC ; std::construct_at<BfresFile::Material,BfresFile::Material const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	jmp	??0Material@BfresFile@@QEAA@AEBU01@@Z
??$construct_at@UMaterial@BfresFile@@AEBU12@$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@AEBU12@@Z ENDP ; std::construct_at<BfresFile::Material,BfresFile::Material const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@V?$vector@MV?$allocator@M@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@MV?$allocator@M@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@V?$vector@MV?$allocator@M@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@MV?$allocator@M@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_back<std::vector<float,std::allocator<float> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	r10, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+8], r11
	mov	QWORD PTR [rdx], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 24

; 1804 :     }

	ret	0
??$_Emplace_back@V?$vector@MV?$allocator@M@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@MV?$allocator@M@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<float,std::allocator<float> > > >::_Emplace_back<std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@V?$vector@MV?$allocator@M@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@QEAV?$vector@MV?$allocator@M@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@V?$vector@MV?$allocator@M@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@QEAV?$vector@MV?$allocator@M@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<float,std::allocator<float> > > >::construct<std::vector<float,std::allocator<float> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@V?$vector@MV?$allocator@M@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@QEAV?$vector@MV?$allocator@M@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<float,std::allocator<float> > > >::construct<std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$vector@MV?$allocator@M@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@$$QEAV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$vector@MV?$allocator@M@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@$$QEAV10@@Z PROC ; std::construct_at<std::vector<float,std::allocator<float> >,std::vector<float,std::allocator<float> >,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@V?$vector@MV?$allocator@M@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@$$QEAV10@@Z ENDP ; std::construct_at<std::vector<float,std::allocator<float> >,std::vector<float,std::allocator<float> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAULOD@BfresFile@@@std@@YA$$QEAULOD@BfresFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAULOD@BfresFile@@@std@@YA$$QEAULOD@BfresFile@@AEAU12@@Z PROC ; std::move<BfresFile::LOD &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAULOD@BfresFile@@@std@@YA$$QEAULOD@BfresFile@@AEAU12@@Z ENDP ; std::move<BfresFile::LOD &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@ULOD@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX$$QEAULOD@BfresFile@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@ULOD@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX$$QEAULOD@BfresFile@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::LOD> >::_Emplace_back<BfresFile::LOD>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN60:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r10, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	r11, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	edi, edi
	mov	r9, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], rdi
	mov	QWORD PTR [rdx+8], rdi
	mov	QWORD PTR [rdx], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+40]
	mov	rcx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [r11+24]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r11+40], rdi
	mov	QWORD PTR [r11+32], rdi
	mov	QWORD PTR [r11+24], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+24], rax
	mov	QWORD PTR [r10+32], rcx
	mov	QWORD PTR [r10+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r11+64]
	mov	rcx, QWORD PTR [r11+56]
	mov	rax, QWORD PTR [r11+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r11+64], rdi
	mov	QWORD PTR [r11+56], rdi
	mov	QWORD PTR [r11+48], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+48], rax
	mov	QWORD PTR [r10+56], rcx
	mov	QWORD PTR [r10+64], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r11+88]
	mov	rcx, QWORD PTR [r11+80]
	mov	rax, QWORD PTR [r11+72]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r11+88], rdi
	mov	QWORD PTR [r11+80], rdi
	mov	QWORD PTR [r11+72], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1804 :     }

	mov	rdi, QWORD PTR [rsp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+72], rax
	mov	QWORD PTR [r10+80], rcx
	mov	QWORD PTR [r10+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rbx+8], 96			; 00000060H

; 1804 :     }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
??$_Emplace_back@ULOD@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAAX$$QEAULOD@BfresFile@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::LOD> >::_Emplace_back<BfresFile::LOD>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@ULOD@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@ULOD@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::LOD> >::construct<BfresFile::LOD>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rdx], xmm0
	movups	XMMWORD PTR [rdx+16], xmm0
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	XMMWORD PTR [rdx+48], xmm0
	movups	XMMWORD PTR [rdx+64], xmm0
	movups	XMMWORD PTR [rdx+80], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
	mov	QWORD PTR [rdx+56], rax
	mov	QWORD PTR [rdx+64], rax
	mov	QWORD PTR [rdx+72], rax
	mov	QWORD PTR [rdx+80], rax
	mov	QWORD PTR [rdx+88], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@ULOD@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::LOD> >::construct<BfresFile::LOD>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@ULOD@BfresFile@@AEBU12@$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@AEBU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@ULOD@BfresFile@@AEBU12@$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@AEBU12@@Z PROC ; std::construct_at<BfresFile::LOD,BfresFile::LOD const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	jmp	??0LOD@BfresFile@@QEAA@AEBU01@@Z
??$construct_at@ULOD@BfresFile@@AEBU12@$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@AEBU12@@Z ENDP ; std::construct_at<BfresFile::LOD,BfresFile::LOD const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAVMesh@@@std@@YA$$QEAVMesh@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAVMesh@@@std@@YA$$QEAVMesh@@AEAV1@@Z PROC	; std::move<Mesh &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAVMesh@@@std@@YA$$QEAVMesh@@AEAV1@@Z ENDP	; std::move<Mesh &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@VMesh@@@?$_Uninitialized_backout_al@V?$allocator@VMesh@@@std@@@std@@QEAAX$$QEAVMesh@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@VMesh@@@?$_Uninitialized_backout_al@V?$allocator@VMesh@@@std@@@std@@QEAAX$$QEAVMesh@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Mesh> >::_Emplace_back<Mesh>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN48:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r10, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	r11, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	edi, edi
	mov	r9, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], rdi
	mov	QWORD PTR [rdx+8], rdi
	mov	QWORD PTR [rdx], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+40]
	mov	rcx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [r11+24]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r11+40], rdi
	mov	QWORD PTR [r11+32], rdi
	mov	QWORD PTR [r11+24], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+24], rax
	mov	QWORD PTR [r10+32], rcx
	mov	QWORD PTR [r10+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r11+48]
	mov	rdx, QWORD PTR [r11+64]
	mov	rcx, QWORD PTR [r11+56]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r11+64], rdi
	mov	QWORD PTR [r11+56], rdi
	mov	QWORD PTR [r11+48], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1804 :     }

	mov	rdi, QWORD PTR [rsp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+48], rax
	mov	QWORD PTR [r10+56], rcx
	mov	QWORD PTR [r10+64], rdx
	mov	eax, DWORD PTR [r11+72]
	mov	DWORD PTR [r10+72], eax
	mov	eax, DWORD PTR [r11+76]
	mov	DWORD PTR [r10+76], eax
	mov	eax, DWORD PTR [r11+80]
	mov	DWORD PTR [r10+80], eax
	mov	eax, DWORD PTR [r11+84]
	mov	DWORD PTR [r10+84], eax
	mov	eax, DWORD PTR [r11+88]
	mov	DWORD PTR [r10+88], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rbx+8], 96			; 00000060H

; 1804 :     }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
??$_Emplace_back@VMesh@@@?$_Uninitialized_backout_al@V?$allocator@VMesh@@@std@@@std@@QEAAX$$QEAVMesh@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Mesh> >::_Emplace_back<Mesh>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@VMesh@@$$V@?$_Default_allocator_traits@V?$allocator@VMesh@@@std@@@std@@SAXAEAV?$allocator@VMesh@@@1@QEAVMesh@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@VMesh@@$$V@?$_Default_allocator_traits@V?$allocator@VMesh@@@std@@@std@@SAXAEAV?$allocator@VMesh@@@1@QEAVMesh@@@Z PROC ; std::_Default_allocator_traits<std::allocator<Mesh> >::construct<Mesh>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
	mov	QWORD PTR [rdx+56], rax
	mov	QWORD PTR [rdx+64], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@VMesh@@$$V@?$_Default_allocator_traits@V?$allocator@VMesh@@@std@@@std@@SAXAEAV?$allocator@VMesh@@@1@QEAVMesh@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Mesh> >::construct<Mesh>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@V?$vector@IV?$allocator@I@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@IV?$allocator@I@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@V?$vector@IV?$allocator@I@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@IV?$allocator@I@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_back<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	r10, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+8], r11
	mov	QWORD PTR [rdx], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 24

; 1804 :     }

	ret	0
??$_Emplace_back@V?$vector@IV?$allocator@I@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@IV?$allocator@I@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Emplace_back<std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@V?$vector@IV?$allocator@I@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@QEAV?$vector@IV?$allocator@I@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@V?$vector@IV?$allocator@I@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@QEAV?$vector@IV?$allocator@I@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::construct<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@V?$vector@IV?$allocator@I@std@@@std@@$$V@?$_Default_allocator_traits@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@QEAV?$vector@IV?$allocator@I@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::construct<std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$vector@IV?$allocator@I@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@$$QEAV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$vector@IV?$allocator@I@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@$$QEAV10@@Z PROC ; std::construct_at<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> >,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@V?$vector@IV?$allocator@I@std@@@std@@V12@$0A@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@$$QEAV10@@Z ENDP ; std::construct_at<std::vector<unsigned int,std::allocator<unsigned int> >,std::vector<unsigned int,std::allocator<unsigned int> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUBfresTexture@BfresFile@@@std@@YA$$QEAUBfresTexture@BfresFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUBfresTexture@BfresFile@@@std@@YA$$QEAUBfresTexture@BfresFile@@AEAU12@@Z PROC ; std::move<BfresFile::BfresTexture &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUBfresTexture@BfresFile@@@std@@YA$$QEAUBfresTexture@BfresFile@@AEAU12@@Z ENDP ; std::move<BfresFile::BfresTexture &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UBfresTexture@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX$$QEAUBfresTexture@BfresFile@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UBfresTexture@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX$$QEAUBfresTexture@BfresFile@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<BfresFile::BfresTexture> >::_Emplace_back<BfresFile::BfresTexture>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r10, QWORD PTR [rcx+8]
	xorps	xmm0, xmm0
	mov	QWORD PTR [r10], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [rdx+24]
	mov	r8, QWORD PTR [rdx+16]
	mov	rax, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+24], r11
	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+8], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+8], rax
	mov	QWORD PTR [r10+16], r8
	mov	QWORD PTR [r10+24], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r10+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+48], r11

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+56], r11

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [r10+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [r10+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [rdx+48], r11
	mov	QWORD PTR [rdx+56], 15
	mov	BYTE PTR [rdx+32], r11b
	add	QWORD PTR [rcx+8], 64			; 00000040H

; 1804 :     }

	ret	0
??$_Emplace_back@UBfresTexture@BfresFile@@@?$_Uninitialized_backout_al@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAAX$$QEAUBfresTexture@BfresFile@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<BfresFile::BfresTexture> >::_Emplace_back<BfresFile::BfresTexture>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z
_TEXT	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN29:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdx
	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+48], rax
	mov	QWORD PTR [rdx+56], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], rax
	lea	rcx, QWORD PTR [rdx+32]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
__formal$dead$ = 48
_Ptr$ = 56
?dtor$0@?0???$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@UBfresTexture@BfresFile@@$$V@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z
_TEXT	SEGMENT
$T1 = 48
_Location$ = 48
<_Args_0>$ = 56
??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z PROC ; std::construct_at<BfresFile::BfresTexture,BfresFile::BfresTexture const &,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN9:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rcx
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	add	rcx, 8
	add	rdx, 8
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	lea	rcx, QWORD PTR [rdi+32]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, rdi

; 242  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z ENDP ; std::construct_at<BfresFile::BfresTexture,BfresFile::BfresTexture const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
_Location$ = 48
<_Args_0>$ = 56
?dtor$0@?0???$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z@4HA PROC ; `std::construct_at<BfresFile::BfresTexture,BfresFile::BfresTexture const &,0>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct_at@UBfresTexture@BfresFile@@AEBU12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@AEBU12@@Z@4HA ENDP ; `std::construct_at<BfresFile::BfresTexture,BfresFile::BfresTexture const &,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAVTexture@@@std@@YAAEBQEAVTexture@@AEBQEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAVTexture@@@std@@YAAEBQEAVTexture@@AEBQEAV1@@Z PROC ; std::forward<Texture * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAVTexture@@@std@@YAAEBQEAVTexture@@AEBQEAV1@@Z ENDP ; std::forward<Texture * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@PEAVTexture@@AEBQEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVTexture@@@std@@@std@@SAXAEAV?$allocator@PEAVTexture@@@1@QEAPEAVTexture@@AEBQEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVTexture@@AEBQEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVTexture@@@std@@@std@@SAXAEAV?$allocator@PEAVTexture@@@1@QEAPEAVTexture@@AEBQEAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<Texture *> >::construct<Texture *,Texture * const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@PEAVTexture@@AEBQEAV1@@?$_Default_allocator_traits@V?$allocator@PEAVTexture@@@std@@@std@@SAXAEAV?$allocator@PEAVTexture@@@1@QEAPEAVTexture@@AEBQEAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Texture *> >::construct<Texture *,Texture * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@M@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAX$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@M@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAX$$QEAM@Z PROC ; std::_Uninitialized_backout_al<std::allocator<float> >::_Emplace_back<float>, COMDAT

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rax, QWORD PTR [r8+4]
	mov	QWORD PTR [rcx+8], rax

; 1804 :     }

	ret	0
??$_Emplace_back@M@?$_Uninitialized_backout_al@V?$allocator@M@std@@@std@@QEAAX$$QEAM@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<float> >::_Emplace_back<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@M$$V@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@M$$V@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM@Z PROC ; std::_Default_allocator_traits<std::allocator<float> >::construct<float>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@M$$V@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM@Z ENDP ; std::_Default_allocator_traits<std::allocator<float> >::construct<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBE@std@@YAAEBEAEBE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBE@std@@YAAEBEAEBE@Z PROC			; std::forward<unsigned char const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBE@std@@YAAEBEAEBE@Z ENDP			; std::forward<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z PROC ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ENDP ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > > > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@@Z PROC ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >, COMDAT

; 314  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@@Z ENDP ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@PEAVTextureToGo@@@std@@YA_K_KAEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
_Val$dead$ = 8
_Keyval$ = 16
??$_Fnv1a_append_value@PEAVTextureToGo@@@std@@YA_K_KAEBQEAVTextureToGo@@@Z PROC ; std::_Fnv1a_append_value<TextureToGo *>, COMDAT

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]

; 2346 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	movzx	ecx, BYTE PTR [rdx+6]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+4]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+5]
	imul	r8, r9
	xor	rax, r8
	imul	rax, r9
	xor	rax, rcx
	movzx	ecx, BYTE PTR [rdx+7]
	imul	rax, r9
	xor	rax, rcx
	imul	rax, r9

; 2364 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2365 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
; 2366 : }

	ret	0
??$_Fnv1a_append_value@PEAVTextureToGo@@@std@@YA_K_KAEBQEAVTextureToGo@@@Z ENDP ; std::_Fnv1a_append_value<TextureToGo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$dead$ = 8
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	lea	rax, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures

; 1608 : }

	ret	0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAI$$T@std@@YAPEAIAEAPEAI$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAI$$T@std@@YAPEAIAEAPEAI$$QEA$$T@Z PROC	; std::exchange<unsigned int *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAI$$T@std@@YAPEAIAEAPEAI$$QEA$$T@Z ENDP	; std::exchange<unsigned int *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@I@std@@PEAIPEAIPEAI@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@I@1@$$QEAPEAI22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@I@std@@PEAIPEAIPEAI@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@I@1@$$QEAPEAI22@Z PROC ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int>,unsigned int *,unsigned int *,unsigned int *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@I@std@@PEAIPEAIPEAI@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@I@1@$$QEAPEAI22@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int>,unsigned int *,unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAM$$T@std@@YAPEAMAEAPEAM$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAM$$T@std@@YAPEAMAEAPEAM$$QEA$$T@Z PROC	; std::exchange<float *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAM$$T@std@@YAPEAMAEAPEAM$$QEA$$T@Z ENDP	; std::exchange<float *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@M@std@@PEAMPEAMPEAM@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@M@1@$$QEAPEAM22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@M@std@@PEAMPEAMPEAM@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@M@1@$$QEAPEAM22@Z PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float>,float *,float *,float *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@M@std@@PEAMPEAMPEAM@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@M@1@$$QEAPEAM22@Z ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float>,float *,float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??0?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@$$QEAV01@@Z PROC ; std::tuple<TextureToGo * const &>::tuple<TextureToGo * const &>, COMDAT

; 366  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0?$tuple@AEBQEAVTextureToGo@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::tuple<TextureToGo * const &>::tuple<TextureToGo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??0?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@$$QEAU01@@Z PROC ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture>, COMDAT

; 246  :     pair(pair&&)      = default;

	mov	rax, QWORD PTR [rdx]
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx], rax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+12], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+16], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+32], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+40], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	xmm1, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], 15
	mov	BYTE PTR [rdx+16], al
	mov	eax, DWORD PTR [rdx+48]
	mov	DWORD PTR [rcx+48], eax
	mov	rax, rcx
	ret	0
??0?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@$$QEAU01@@Z ENDP ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAAPEAXI@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::`scalar deleting destructor', COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAAPEAXI@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAA@PEAI00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAA@PEAI00@Z PROC ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAA@PEAI00@Z ENDP ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@PEAM00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@PEAM00@Z PROC ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@PEAM00@Z ENDP ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEBQEAVTextureToGo@@$$Z$$V@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$ = 24
_Val2$dead$ = 32
??$?0AEBQEAVTextureToGo@@$$Z$$V@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture><TextureToGo * const &>, COMDAT

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, QWORD PTR [r8]
	xorps	xmm0, xmm0
	mov	rdx, QWORD PTR [rax]

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	mov	rax, rcx

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+16], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+32], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+40], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	ret	0
??$?0AEBQEAVTextureToGo@@$$Z$$V@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBQEAVTextureToGo@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture><TextureToGo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
_Val1$ = 64
_Val2$dead$ = 72
??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [r8]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	call	??0BfresFile@@QEAA@XZ			; BfresFile::BfresFile
	npad	1

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__formal$dead$ = 56
_Val1$ = 64
_Val2$dead$ = 72
?dtor$1@?0???$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z@4HA PROC ; `std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z@4HA ENDP ; `std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@$$QEAU10@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$ = 56
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@$$QEAU10@@Z PROC ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rdx, QWORD PTR [rbx+32]
	lea	rcx, QWORD PTR [rdi+32]
	call	??0BfresFile@@QEAA@$$QEAV0@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@0@QEAU10@$$QEAU10@@Z ENDP ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@$$QEAU10@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$ = 56
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@$$QEAU10@@Z PROC ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR [rbx+32]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	edx, edx
	mov	QWORD PTR [rdi+32], rax

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rbx+40]
	mov	r8, QWORD PTR [rbx+56]
	mov	rcx, QWORD PTR [rbx+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx+56], rdx
	mov	QWORD PTR [rbx+48], rdx
	mov	QWORD PTR [rbx+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdi+40], rax
	mov	QWORD PTR [rdi+48], rcx
	mov	QWORD PTR [rdi+56], r8
	movzx	eax, WORD PTR [rbx+64]
	mov	WORD PTR [rdi+64], ax
	movzx	eax, WORD PTR [rbx+66]
	mov	WORD PTR [rdi+66], ax
	movzx	eax, WORD PTR [rbx+68]
	mov	WORD PTR [rdi+68], ax
	movzx	eax, BYTE PTR [rbx+70]
	mov	BYTE PTR [rdi+70], al
	movzx	eax, WORD PTR [rbx+72]
	mov	WORD PTR [rdi+72], ax
	movzx	eax, BYTE PTR [rbx+74]
	mov	BYTE PTR [rdi+74], al
	movzx	eax, BYTE PTR [rbx+75]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [rdi+75], al
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@$$QEAU10@@Z ENDP ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z PROC ; std::construct_at<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ENDP ; std::construct_at<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UVertexBuffer@BfresFile@@$$V$0A@@std@@YAPEAUVertexBuffer@BfresFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UVertexBuffer@BfresFile@@$$V$0A@@std@@YAPEAUVertexBuffer@BfresFile@@QEAU12@@Z PROC ; std::construct_at<BfresFile::VertexBuffer,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UVertexBuffer@BfresFile@@$$V$0A@@std@@YAPEAUVertexBuffer@BfresFile@@QEAU12@@Z ENDP ; std::construct_at<BfresFile::VertexBuffer,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UVertexBufferAttribute@BfresFile@@$$V$0A@@std@@YAPEAUVertexBufferAttribute@BfresFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UVertexBufferAttribute@BfresFile@@$$V$0A@@std@@YAPEAUVertexBufferAttribute@BfresFile@@QEAU12@@Z PROC ; std::construct_at<BfresFile::VertexBufferAttribute,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UVertexBufferAttribute@BfresFile@@$$V$0A@@std@@YAPEAUVertexBufferAttribute@BfresFile@@QEAU12@@Z ENDP ; std::construct_at<BfresFile::VertexBufferAttribute,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UVertexBufferSize@BfresFile@@$$V$0A@@std@@YAPEAUVertexBufferSize@BfresFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UVertexBufferSize@BfresFile@@$$V$0A@@std@@YAPEAUVertexBufferSize@BfresFile@@QEAU12@@Z PROC ; std::construct_at<BfresFile::VertexBufferSize,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UVertexBufferSize@BfresFile@@$$V$0A@@std@@YAPEAUVertexBufferSize@BfresFile@@QEAU12@@Z ENDP ; std::construct_at<BfresFile::VertexBufferSize,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$?0AEBQEAVTextureToGo@@@?$_Tuple_val@AEBQEAVTextureToGo@@@std@@QEAA@AEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
this$ = 8
_Arg$ = 16
??$?0AEBQEAVTextureToGo@@@?$_Tuple_val@AEBQEAVTextureToGo@@@std@@QEAA@AEBQEAVTextureToGo@@@Z PROC ; std::_Tuple_val<TextureToGo * const &>::_Tuple_val<TextureToGo * const &><TextureToGo * const &>, COMDAT

; 144  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??$?0AEBQEAVTextureToGo@@@?$_Tuple_val@AEBQEAVTextureToGo@@@std@@QEAA@AEBQEAVTextureToGo@@@Z ENDP ; std::_Tuple_val<TextureToGo * const &>::_Tuple_val<TextureToGo * const &><TextureToGo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@G$$V$0A@@std@@YAPEAGQEAG@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@G$$V$0A@@std@@YAPEAGQEAG@Z PROC		; std::construct_at<unsigned short,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	WORD PTR [rcx], ax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@G$$V$0A@@std@@YAPEAGQEAG@Z ENDP		; std::construct_at<unsigned short,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@USkeletonBone@BfresFile@@@std@@YA$$QEAUSkeletonBone@BfresFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@USkeletonBone@BfresFile@@@std@@YA$$QEAUSkeletonBone@BfresFile@@AEAU12@@Z PROC ; std::forward<BfresFile::SkeletonBone>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@USkeletonBone@BfresFile@@@std@@YA$$QEAUSkeletonBone@BfresFile@@AEAU12@@Z ENDP ; std::forward<BfresFile::SkeletonBone>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@USkeletonBone@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@SAXAEAV?$allocator@USkeletonBone@BfresFile@@@1@QEAUSkeletonBone@BfresFile@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@USkeletonBone@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@SAXAEAV?$allocator@USkeletonBone@BfresFile@@@1@QEAUSkeletonBone@BfresFile@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::SkeletonBone> >::construct<BfresFile::SkeletonBone,BfresFile::SkeletonBone>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movsd	xmm1, QWORD PTR [r8+48]
	movsd	QWORD PTR [rdx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@USkeletonBone@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@SAXAEAV?$allocator@USkeletonBone@BfresFile@@@1@QEAUSkeletonBone@BfresFile@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::SkeletonBone> >::construct<BfresFile::SkeletonBone,BfresFile::SkeletonBone>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@USkeletonBone@BfresFile@@$$V$0A@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@USkeletonBone@BfresFile@@$$V$0A@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@@Z PROC ; std::construct_at<BfresFile::SkeletonBone,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	xor	edx, edx
	mov	QWORD PTR [rcx], -65536			; ffffffffffff0000H
	mov	QWORD PTR [rcx+32], rdx

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
	mov	QWORD PTR [rcx+48], rdx
	mov	QWORD PTR [rcx+8], 65535		; 0000ffffH
	mov	DWORD PTR [rcx+16], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+20], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+24], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+40], 1065353216		; 3f800000H

; 242  : }

	ret	0
??$construct_at@USkeletonBone@BfresFile@@$$V$0A@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@@Z ENDP ; std::construct_at<BfresFile::SkeletonBone,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UModel@BfresFile@@@std@@YA$$QEAUModel@BfresFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UModel@BfresFile@@@std@@YA$$QEAUModel@BfresFile@@AEAU12@@Z PROC ; std::forward<BfresFile::Model>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UModel@BfresFile@@@std@@YA$$QEAUModel@BfresFile@@AEAU12@@Z ENDP ; std::forward<BfresFile::Model>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UModel@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UModel@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::Model> >::construct<BfresFile::Model,BfresFile::Model>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d
	mov	r9, QWORD PTR [r8+16]
	mov	QWORD PTR [r8+16], r11
	mov	QWORD PTR [r8+8], r11
	mov	QWORD PTR [r8], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+40]
	mov	rcx, QWORD PTR [r8+32]
	mov	rax, QWORD PTR [r8+24]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+40], r11
	mov	QWORD PTR [r8+32], r11
	mov	QWORD PTR [r8+24], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+24], rax
	mov	QWORD PTR [r10+32], rcx
	mov	QWORD PTR [r10+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+64]
	mov	rcx, QWORD PTR [r8+56]
	mov	rax, QWORD PTR [r8+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+64], r11
	mov	QWORD PTR [r8+56], r11
	mov	QWORD PTR [r8+48], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+48], rax
	mov	QWORD PTR [r10+56], rcx
	mov	QWORD PTR [r10+64], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8+72]
	mov	rdx, QWORD PTR [r8+88]
	mov	rcx, QWORD PTR [r8+80]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+88], r11
	mov	QWORD PTR [r8+80], r11
	mov	QWORD PTR [r8+72], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+72], rax
	mov	eax, DWORD PTR [r8+96]
	mov	DWORD PTR [r10+96], eax
	mov	QWORD PTR [r10+80], rcx
	mov	QWORD PTR [r10+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UModel@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UModel@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UModel@BfresFile@@@1@QEAUModel@BfresFile@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::Model> >::construct<BfresFile::Model,BfresFile::Model>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UModel@BfresFile@@$$V$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UModel@BfresFile@@$$V$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@@Z PROC ; std::construct_at<BfresFile::Model,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	mov	QWORD PTR [rcx+96], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
	mov	QWORD PTR [rcx+56], rax
	mov	QWORD PTR [rcx+64], rax
	mov	QWORD PTR [rcx+72], rax
	mov	QWORD PTR [rcx+80], rax
	mov	QWORD PTR [rcx+88], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UModel@BfresFile@@$$V$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@@Z ENDP ; std::construct_at<BfresFile::Model,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UMaterial@BfresFile@@@std@@YA$$QEAUMaterial@BfresFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UMaterial@BfresFile@@@std@@YA$$QEAUMaterial@BfresFile@@AEAU12@@Z PROC ; std::forward<BfresFile::Material>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UMaterial@BfresFile@@@std@@YA$$QEAUMaterial@BfresFile@@AEAU12@@Z ENDP ; std::forward<BfresFile::Material>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UMaterial@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UMaterial@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::Material> >::construct<BfresFile::Material,BfresFile::Material>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	r9, rdx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8+16], r10
	mov	QWORD PTR [r8+24], 15
	mov	BYTE PTR [r8], r10b
	movzx	eax, BYTE PTR [r8+32]
	mov	BYTE PTR [rdx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+56]
	mov	rcx, QWORD PTR [r8+48]
	mov	rax, QWORD PTR [r8+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+56], r10
	mov	QWORD PTR [r8+48], r10
	mov	QWORD PTR [r8+40], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+40], rax
	mov	QWORD PTR [r9+48], rcx
	mov	QWORD PTR [r9+56], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UMaterial@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UMaterial@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UMaterial@BfresFile@@@1@QEAUMaterial@BfresFile@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::Material> >::construct<BfresFile::Material,BfresFile::Material>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UMaterial@BfresFile@@$$V$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UMaterial@BfresFile@@$$V$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@@Z PROC ; std::construct_at<BfresFile::Material,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
	mov	DWORD PTR [rcx+33], eax
	mov	WORD PTR [rcx+37], ax
	mov	BYTE PTR [rcx+39], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
	mov	BYTE PTR [rcx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
	mov	QWORD PTR [rcx+56], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UMaterial@BfresFile@@$$V$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@@Z ENDP ; std::construct_at<BfresFile::Material,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$vector@MV?$allocator@M@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@V?$vector@MV?$allocator@M@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@@Z PROC ; std::construct_at<std::vector<float,std::allocator<float> >,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$vector@MV?$allocator@M@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@QEAV10@@Z ENDP ; std::construct_at<std::vector<float,std::allocator<float> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@ULOD@BfresFile@@@std@@YA$$QEAULOD@BfresFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@ULOD@BfresFile@@@std@@YA$$QEAULOD@BfresFile@@AEAU12@@Z PROC ; std::forward<BfresFile::LOD>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@ULOD@BfresFile@@@std@@YA$$QEAULOD@BfresFile@@AEAU12@@Z ENDP ; std::forward<BfresFile::LOD>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@ULOD@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@ULOD@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::LOD> >::construct<BfresFile::LOD,BfresFile::LOD>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [r8+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+16], r11
	mov	QWORD PTR [r8+8], r11
	mov	QWORD PTR [r8], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+40]
	mov	rcx, QWORD PTR [r8+32]
	mov	rax, QWORD PTR [r8+24]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+40], r11
	mov	QWORD PTR [r8+32], r11
	mov	QWORD PTR [r8+24], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+24], rax
	mov	QWORD PTR [r10+32], rcx
	mov	QWORD PTR [r10+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+64]
	mov	rcx, QWORD PTR [r8+56]
	mov	rax, QWORD PTR [r8+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+64], r11
	mov	QWORD PTR [r8+56], r11
	mov	QWORD PTR [r8+48], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+48], rax
	mov	QWORD PTR [r10+56], rcx
	mov	QWORD PTR [r10+64], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+88]
	mov	rcx, QWORD PTR [r8+80]
	mov	rax, QWORD PTR [r8+72]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+88], r11
	mov	QWORD PTR [r8+80], r11
	mov	QWORD PTR [r8+72], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+72], rax
	mov	QWORD PTR [r10+80], rcx
	mov	QWORD PTR [r10+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@ULOD@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@ULOD@BfresFile@@@std@@@std@@SAXAEAV?$allocator@ULOD@BfresFile@@@1@QEAULOD@BfresFile@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::LOD> >::construct<BfresFile::LOD,BfresFile::LOD>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@ULOD@BfresFile@@$$V$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@ULOD@BfresFile@@$$V$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@@Z PROC ; std::construct_at<BfresFile::LOD,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
	mov	QWORD PTR [rcx+56], rax
	mov	QWORD PTR [rcx+64], rax
	mov	QWORD PTR [rcx+72], rax
	mov	QWORD PTR [rcx+80], rax
	mov	QWORD PTR [rcx+88], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@ULOD@BfresFile@@$$V$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@@Z ENDP ; std::construct_at<BfresFile::LOD,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@VMesh@@@std@@YA$$QEAVMesh@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@VMesh@@@std@@YA$$QEAVMesh@@AEAV1@@Z PROC	; std::forward<Mesh>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@VMesh@@@std@@YA$$QEAVMesh@@AEAV1@@Z ENDP	; std::forward<Mesh>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@VMesh@@V1@@?$_Default_allocator_traits@V?$allocator@VMesh@@@std@@@std@@SAXAEAV?$allocator@VMesh@@@1@QEAVMesh@@$$QEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VMesh@@V1@@?$_Default_allocator_traits@V?$allocator@VMesh@@@std@@@std@@SAXAEAV?$allocator@VMesh@@@1@QEAVMesh@@$$QEAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<Mesh> >::construct<Mesh,Mesh>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d
	mov	r9, QWORD PTR [r8+16]
	mov	QWORD PTR [r8+16], r11
	mov	QWORD PTR [r8+8], r11
	mov	QWORD PTR [r8], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+40]
	mov	rcx, QWORD PTR [r8+32]
	mov	rax, QWORD PTR [r8+24]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+40], r11
	mov	QWORD PTR [r8+32], r11
	mov	QWORD PTR [r8+24], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+24], rax
	mov	QWORD PTR [r10+32], rcx
	mov	QWORD PTR [r10+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8+48]
	mov	rdx, QWORD PTR [r8+64]
	mov	rcx, QWORD PTR [r8+56]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+64], r11
	mov	QWORD PTR [r8+56], r11
	mov	QWORD PTR [r8+48], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+48], rax
	mov	QWORD PTR [r10+56], rcx
	mov	QWORD PTR [r10+64], rdx
	mov	eax, DWORD PTR [r8+72]
	mov	DWORD PTR [r10+72], eax
	mov	eax, DWORD PTR [r8+76]
	mov	DWORD PTR [r10+76], eax
	mov	eax, DWORD PTR [r8+80]
	mov	DWORD PTR [r10+80], eax
	mov	eax, DWORD PTR [r8+84]
	mov	DWORD PTR [r10+84], eax
	mov	eax, DWORD PTR [r8+88]
	mov	DWORD PTR [r10+88], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@VMesh@@V1@@?$_Default_allocator_traits@V?$allocator@VMesh@@@std@@@std@@SAXAEAV?$allocator@VMesh@@@1@QEAVMesh@@$$QEAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Mesh> >::construct<Mesh,Mesh>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@VMesh@@$$V$0A@@std@@YAPEAVMesh@@QEAV1@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@VMesh@@$$V$0A@@std@@YAPEAVMesh@@QEAV1@@Z PROC ; std::construct_at<Mesh,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
	mov	QWORD PTR [rcx+56], rax
	mov	QWORD PTR [rcx+64], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@VMesh@@$$V$0A@@std@@YAPEAVMesh@@QEAV1@@Z ENDP ; std::construct_at<Mesh,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$vector@IV?$allocator@I@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@V?$vector@IV?$allocator@I@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@@Z PROC ; std::construct_at<std::vector<unsigned int,std::allocator<unsigned int> >,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$vector@IV?$allocator@I@std@@@std@@$$V$0A@@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@QEAV10@@Z ENDP ; std::construct_at<std::vector<unsigned int,std::allocator<unsigned int> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UBfresTexture@BfresFile@@@std@@YA$$QEAUBfresTexture@BfresFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UBfresTexture@BfresFile@@@std@@YA$$QEAUBfresTexture@BfresFile@@AEAU12@@Z PROC ; std::forward<BfresFile::BfresTexture>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UBfresTexture@BfresFile@@@std@@YA$$QEAUBfresTexture@BfresFile@@AEAU12@@Z ENDP ; std::forward<BfresFile::BfresTexture>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UBfresTexture@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UBfresTexture@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture,BfresFile::BfresTexture>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rax, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	QWORD PTR [rdx], rax
	xorps	xmm0, xmm0

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [r8+24]
	mov	rcx, QWORD PTR [r8+16]
	mov	rax, QWORD PTR [r8+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+24], r10
	mov	QWORD PTR [r8+16], r10
	mov	QWORD PTR [r8+8], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rcx
	mov	QWORD PTR [rdx+24], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+48], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+56], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rdx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	QWORD PTR [r8+48], r10
	mov	QWORD PTR [r8+56], 15
	mov	BYTE PTR [r8+32], r10b
	ret	0
??$construct@UBfresTexture@BfresFile@@U12@@?$_Default_allocator_traits@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@SAXAEAV?$allocator@UBfresTexture@BfresFile@@@1@QEAUBfresTexture@BfresFile@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BfresFile::BfresTexture> >::construct<BfresFile::BfresTexture,BfresFile::BfresTexture>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z
_TEXT	SEGMENT
$T1 = 48
_Location$ = 48
??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z PROC ; std::construct_at<BfresFile::BfresTexture,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN27:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rcx
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+48], rax
	mov	QWORD PTR [rcx+56], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	add	rcx, 32					; 00000020H
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rbx

; 242  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z ENDP ; std::construct_at<BfresFile::BfresTexture,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
_Location$ = 48
?dtor$0@?0???$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z@4HA PROC ; `std::construct_at<BfresFile::BfresTexture,0>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct_at@UBfresTexture@BfresFile@@$$V$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@@Z@4HA ENDP ; `std::construct_at<BfresFile::BfresTexture,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEAVTexture@@AEBQEAV1@$0A@@std@@YAPEAPEAVTexture@@QEAPEAV1@AEBQEAV1@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAVTexture@@AEBQEAV1@$0A@@std@@YAPEAPEAVTexture@@QEAPEAV1@AEBQEAV1@@Z PROC ; std::construct_at<Texture *,Texture * const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEAVTexture@@AEBQEAV1@$0A@@std@@YAPEAPEAVTexture@@QEAPEAV1@AEBQEAV1@@Z ENDP ; std::construct_at<Texture *,Texture * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@MM@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM$$QEAM@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MM@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM$$QEAM@Z PROC ; std::_Default_allocator_traits<std::allocator<float> >::construct<float,float>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@MM@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM$$QEAM@Z ENDP ; std::_Default_allocator_traits<std::allocator<float> >::construct<float,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@M$$V$0A@@std@@YAPEAMQEAM@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@M$$V$0A@@std@@YAPEAMQEAM@Z PROC		; std::construct_at<float,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@M$$V$0A@@std@@YAPEAMQEAM@Z ENDP		; std::construct_at<float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z PROC	; std::construct_at<unsigned char,unsigned char const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@EAEBE$0A@@std@@YAPEAEQEAEAEBE@Z ENDP	; std::construct_at<unsigned char,unsigned char const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@$$QEAU01@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>, COMDAT

; 246  :     pair(pair&&)      = default;

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	rdx, QWORD PTR [rbx+32]
	lea	rcx, QWORD PTR [rdi+32]
	call	??0BfresFile@@QEAA@$$QEAV0@@Z
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@$$QEAU01@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@$$QEAU01@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>, COMDAT

; 246  :     pair(pair&&)      = default;

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR [rbx+32]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	edx, edx
	mov	QWORD PTR [rdi+32], rax

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rbx+40]
	mov	r8, QWORD PTR [rbx+56]
	mov	rcx, QWORD PTR [rbx+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx+56], rdx
	mov	QWORD PTR [rbx+48], rdx
	mov	QWORD PTR [rbx+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdi+40], rax
	mov	QWORD PTR [rdi+48], rcx
	mov	QWORD PTR [rdi+56], r8
	movzx	eax, WORD PTR [rbx+64]
	mov	WORD PTR [rdi+64], ax
	movzx	eax, WORD PTR [rbx+66]
	mov	WORD PTR [rdi+66], ax
	movzx	eax, WORD PTR [rbx+68]
	mov	WORD PTR [rdi+68], ax
	movzx	eax, BYTE PTR [rbx+70]
	mov	BYTE PTR [rdi+70], al
	movzx	eax, WORD PTR [rbx+72]
	mov	WORD PTR [rdi+72], ax
	movzx	eax, BYTE PTR [rbx+74]
	mov	BYTE PTR [rdi+74], al
	movzx	eax, BYTE PTR [rbx+75]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 246  :     pair(pair&&)      = default;

	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [rdi+75], al
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@$$QEAU01@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0TextureToGo@@QEAA@$$QEAV0@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0TextureToGo@@QEAA@$$QEAV0@@Z PROC			; TextureToGo::TextureToGo, COMDAT
	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	QWORD PTR [rcx], rax

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx+8]
	mov	r9, QWORD PTR [rdx+24]
	mov	r8, QWORD PTR [rdx+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+24], r10
	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], r8
	mov	QWORD PTR [rcx+24], r9
	movzx	eax, WORD PTR [rdx+32]
	mov	WORD PTR [rcx+32], ax
	movzx	eax, WORD PTR [rdx+34]
	mov	WORD PTR [rcx+34], ax
	movzx	eax, WORD PTR [rdx+36]
	mov	WORD PTR [rcx+36], ax
	movzx	eax, BYTE PTR [rdx+38]
	mov	BYTE PTR [rcx+38], al
	movzx	eax, WORD PTR [rdx+40]
	mov	WORD PTR [rcx+40], ax
	movzx	eax, BYTE PTR [rdx+42]
	mov	BYTE PTR [rcx+42], al
	movzx	eax, BYTE PTR [rdx+43]
	mov	BYTE PTR [rcx+43], al
	mov	rax, rcx
	ret	0
??0TextureToGo@@QEAA@$$QEAV0@@Z ENDP			; TextureToGo::TextureToGo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0VertexBuffer@BfresFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0VertexBuffer@BfresFile@@QEAA@XZ PROC			; BfresFile::VertexBuffer::VertexBuffer, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	rax, rcx
	ret	0
??0VertexBuffer@BfresFile@@QEAA@XZ ENDP			; BfresFile::VertexBuffer::VertexBuffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0VertexBufferAttribute@BfresFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0VertexBufferAttribute@BfresFile@@QEAA@XZ PROC	; BfresFile::VertexBufferAttribute::VertexBufferAttribute, COMDAT
	xorps	xmm0, xmm0
	mov	rax, rcx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0
	ret	0
??0VertexBufferAttribute@BfresFile@@QEAA@XZ ENDP	; BfresFile::VertexBufferAttribute::VertexBufferAttribute
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$tuple@AEBQEAVTextureToGo@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@AEAV?$tuple@AEBQEAVTextureToGo@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$dead$ = 24
__formal$dead$ = 32
__formal$dead$ = 40
??$?0V?$tuple@AEBQEAVTextureToGo@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@AEAV?$tuple@AEBQEAVTextureToGo@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z PROC ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture><std::tuple<TextureToGo * const &>,std::tuple<>,0>, COMDAT

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, QWORD PTR [rdx]
	xorps	xmm0, xmm0
	mov	rdx, QWORD PTR [rax]
	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+16], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+32], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+40], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	ret	0
??$?0V?$tuple@AEBQEAVTextureToGo@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@QEAVTextureToGo@@VTexture@@@std@@QEAA@AEAV?$tuple@AEBQEAVTextureToGo@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ENDP ; std::pair<TextureToGo * const,Texture>::pair<TextureToGo * const,Texture><std::tuple<TextureToGo * const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
;	COMDAT ??$_Tuple_get@$0A@AEBQEAVTextureToGo@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$_Tuple_get@$0A@AEBQEAVTextureToGo@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@@Z PROC ; std::_Tuple_get<0,TextureToGo * const &>, COMDAT

; 971  :     // used by pair's piecewise constructor
; 972  :     using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
; 973  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 974  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

	mov	rax, QWORD PTR [rcx]

; 975  : }

	ret	0
??$_Tuple_get@$0A@AEBQEAVTextureToGo@@@std@@YA$$QEA_P$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@@Z ENDP ; std::_Tuple_get<0,TextureToGo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$dead$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>, COMDAT

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rdx, QWORD PTR [rdx]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rbx+32]
	call	??0BfresFile@@QEAA@XZ			; BfresFile::BfresFile
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$dead$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
?dtor$0@?0???$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA PROC ; `std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z@4HA ENDP ; `std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile><std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@USkeletonBone@BfresFile@@U12@$0A@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@USkeletonBone@BfresFile@@U12@$0A@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<BfresFile::SkeletonBone,BfresFile::SkeletonBone,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movsd	xmm1, QWORD PTR [rdx+48]
	movsd	QWORD PTR [rcx+48], xmm1

; 242  : }

	ret	0
??$construct_at@USkeletonBone@BfresFile@@U12@$0A@@std@@YAPEAUSkeletonBone@BfresFile@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<BfresFile::SkeletonBone,BfresFile::SkeletonBone,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UModel@BfresFile@@U12@$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UModel@BfresFile@@U12@$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<BfresFile::Model,BfresFile::Model,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN56:
	mov	QWORD PTR [rsp+8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r11, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	ebx, ebx
	mov	QWORD PTR [rdx+16], rbx
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+40]
	mov	rcx, QWORD PTR [r10+32]
	mov	rax, QWORD PTR [r10+24]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+32], rbx
	mov	QWORD PTR [r10+24], rbx
	mov	QWORD PTR [r10+40], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+24], rax
	mov	QWORD PTR [r11+32], rcx
	mov	QWORD PTR [r11+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r10+64]
	mov	rcx, QWORD PTR [r10+56]
	mov	rax, QWORD PTR [r10+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+64], rbx
	mov	QWORD PTR [r10+56], rbx
	mov	QWORD PTR [r10+48], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+48], rax
	mov	QWORD PTR [r11+56], rcx
	mov	QWORD PTR [r11+64], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r10+72]
	mov	rdx, QWORD PTR [r10+88]
	mov	rcx, QWORD PTR [r10+80]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+88], rbx
	mov	QWORD PTR [r10+80], rbx
	mov	QWORD PTR [r10+72], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	mov	rbx, QWORD PTR [rsp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+72], rax
	mov	eax, DWORD PTR [r10+96]
	mov	DWORD PTR [r11+96], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+80], rcx
	mov	QWORD PTR [r11+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@UModel@BfresFile@@U12@$0A@@std@@YAPEAUModel@BfresFile@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<BfresFile::Model,BfresFile::Model,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UMaterial@BfresFile@@U12@$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UMaterial@BfresFile@@U12@$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<BfresFile::Material,BfresFile::Material,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r8, rdx
	mov	r9, rcx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r10b
	movzx	eax, BYTE PTR [rdx+32]
	mov	BYTE PTR [rcx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8+40]
	mov	rdx, QWORD PTR [rdx+56]
	mov	rcx, QWORD PTR [r8+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+56], r10
	mov	QWORD PTR [r8+48], r10
	mov	QWORD PTR [r8+40], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+40], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+48], rcx
	mov	QWORD PTR [r9+56], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@UMaterial@BfresFile@@U12@$0A@@std@@YAPEAUMaterial@BfresFile@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<BfresFile::Material,BfresFile::Material,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@ULOD@BfresFile@@U12@$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@ULOD@BfresFile@@U12@$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<BfresFile::LOD,BfresFile::LOD,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN56:
	mov	QWORD PTR [rsp+8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [rdx+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	ebx, ebx

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r11, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], rbx
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+40]
	mov	rcx, QWORD PTR [r10+32]
	mov	rax, QWORD PTR [r10+24]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+32], rbx
	mov	QWORD PTR [r10+24], rbx
	mov	QWORD PTR [r10+40], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+24], rax
	mov	QWORD PTR [r11+32], rcx
	mov	QWORD PTR [r11+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r10+64]
	mov	rcx, QWORD PTR [r10+56]
	mov	rax, QWORD PTR [r10+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+64], rbx
	mov	QWORD PTR [r10+56], rbx
	mov	QWORD PTR [r10+48], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+48], rax
	mov	QWORD PTR [r11+56], rcx
	mov	QWORD PTR [r11+64], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r10+72]
	mov	rdx, QWORD PTR [r10+88]
	mov	rcx, QWORD PTR [r10+80]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+88], rbx
	mov	QWORD PTR [r10+80], rbx
	mov	QWORD PTR [r10+72], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	mov	rbx, QWORD PTR [rsp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+72], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+80], rcx
	mov	QWORD PTR [r11+88], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@ULOD@BfresFile@@U12@$0A@@std@@YAPEAULOD@BfresFile@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<BfresFile::LOD,BfresFile::LOD,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@VMesh@@V1@$0A@@std@@YAPEAVMesh@@QEAV1@$$QEAV1@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@VMesh@@V1@$0A@@std@@YAPEAVMesh@@QEAV1@$$QEAV1@@Z PROC ; std::construct_at<Mesh,Mesh,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN44:
	mov	QWORD PTR [rsp+8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r11, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	ebx, ebx
	mov	QWORD PTR [rdx+16], rbx
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r10+32]
	mov	rax, QWORD PTR [r10+24]
	mov	rdx, QWORD PTR [rdx+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+32], rbx
	mov	QWORD PTR [r10+24], rbx
	mov	QWORD PTR [r10+40], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+24], rax
	mov	QWORD PTR [r11+32], rcx
	mov	QWORD PTR [r11+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r10+48]
	mov	rdx, QWORD PTR [r10+64]
	mov	rcx, QWORD PTR [r10+56]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+64], rbx
	mov	QWORD PTR [r10+56], rbx
	mov	QWORD PTR [r10+48], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	mov	rbx, QWORD PTR [rsp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+48], rax
	mov	QWORD PTR [r11+56], rcx
	mov	QWORD PTR [r11+64], rdx
	mov	eax, DWORD PTR [r10+72]
	mov	DWORD PTR [r11+72], eax
	mov	eax, DWORD PTR [r10+76]
	mov	DWORD PTR [r11+76], eax
	mov	eax, DWORD PTR [r10+80]
	mov	DWORD PTR [r11+80], eax
	mov	eax, DWORD PTR [r10+84]
	mov	DWORD PTR [r11+84], eax
	mov	eax, DWORD PTR [r10+88]
	mov	DWORD PTR [r11+88], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, r11

; 242  : }

	ret	0
??$construct_at@VMesh@@V1@$0A@@std@@YAPEAVMesh@@QEAV1@$$QEAV1@@Z ENDP ; std::construct_at<Mesh,Mesh,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UBfresTexture@BfresFile@@U12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UBfresTexture@BfresFile@@U12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<BfresFile::BfresTexture,BfresFile::BfresTexture,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	QWORD PTR [rcx], rax
	xorps	xmm0, xmm0

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx+8]
	mov	r9, QWORD PTR [rdx+24]
	mov	r8, QWORD PTR [rdx+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+24], r10
	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+16], r8
	mov	QWORD PTR [rcx+24], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+48], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+56], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rdx+48], r10
	mov	QWORD PTR [rdx+56], 15
	mov	BYTE PTR [rdx+32], r10b

; 242  : }

	ret	0
??$construct_at@UBfresTexture@BfresFile@@U12@$0A@@std@@YAPEAUBfresTexture@BfresFile@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<BfresFile::BfresTexture,BfresFile::BfresTexture,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@MM$0A@@std@@YAPEAMQEAM$$QEAM@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@MM$0A@@std@@YAPEAMQEAM$$QEAM@Z PROC	; std::construct_at<float,float,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@MM$0A@@std@@YAPEAMQEAM$$QEAM@Z ENDP	; std::construct_at<float,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0Model@BfresFile@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0Model@BfresFile@@QEAA@$$QEAU01@@Z PROC		; BfresFile::Model::Model, COMDAT
$LN53:
	mov	QWORD PTR [rsp+8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]
	mov	r10, rdx
	mov	r9, QWORD PTR [rdx+16]
	mov	r11, rcx
	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	ebx, ebx
	mov	QWORD PTR [rdx+16], rbx
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+40]
	mov	rcx, QWORD PTR [r10+32]
	mov	rax, QWORD PTR [r10+24]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+32], rbx
	mov	QWORD PTR [r10+24], rbx
	mov	QWORD PTR [r10+40], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+24], rax
	mov	QWORD PTR [r11+32], rcx
	mov	QWORD PTR [r11+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r10+64]
	mov	rcx, QWORD PTR [r10+56]
	mov	rax, QWORD PTR [r10+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+64], rbx
	mov	QWORD PTR [r10+56], rbx
	mov	QWORD PTR [r10+48], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+48], rax
	mov	QWORD PTR [r11+56], rcx
	mov	QWORD PTR [r11+64], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r10+72]
	mov	rdx, QWORD PTR [r10+88]
	mov	rcx, QWORD PTR [r10+80]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+88], rbx
	mov	QWORD PTR [r10+80], rbx
	mov	QWORD PTR [r10+72], rbx
	mov	rbx, QWORD PTR [rsp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+72], rax
	mov	eax, DWORD PTR [r10+96]
	mov	DWORD PTR [r11+96], eax
	mov	rax, r11
	mov	QWORD PTR [r11+80], rcx
	mov	QWORD PTR [r11+88], rdx
	ret	0
??0Model@BfresFile@@QEAA@$$QEAU01@@Z ENDP		; BfresFile::Model::Model
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0Material@BfresFile@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0Material@BfresFile@@QEAA@$$QEAU01@@Z PROC		; BfresFile::Material::Material, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
	mov	r8, rdx
	mov	r9, rcx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r10b
	movzx	eax, BYTE PTR [rdx+32]
	mov	BYTE PTR [rcx+32], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8+40]
	mov	rdx, QWORD PTR [rdx+56]
	mov	rcx, QWORD PTR [r8+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+56], r10
	mov	QWORD PTR [r8+48], r10
	mov	QWORD PTR [r8+40], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+40], rax
	mov	rax, r9
	mov	QWORD PTR [r9+48], rcx
	mov	QWORD PTR [r9+56], rdx
	ret	0
??0Material@BfresFile@@QEAA@$$QEAU01@@Z ENDP		; BfresFile::Material::Material
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0LOD@BfresFile@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0LOD@BfresFile@@QEAA@$$QEAU01@@Z PROC			; BfresFile::LOD::LOD, COMDAT
$LN53:
	mov	QWORD PTR [rsp+8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]
	mov	r10, rdx
	mov	r9, QWORD PTR [rdx+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	ebx, ebx

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]
	mov	r11, rcx

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], rbx
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+40]
	mov	rcx, QWORD PTR [r10+32]
	mov	rax, QWORD PTR [r10+24]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+32], rbx
	mov	QWORD PTR [r10+24], rbx
	mov	QWORD PTR [r10+40], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+24], rax
	mov	QWORD PTR [r11+32], rcx
	mov	QWORD PTR [r11+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r10+64]
	mov	rcx, QWORD PTR [r10+56]
	mov	rax, QWORD PTR [r10+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+64], rbx
	mov	QWORD PTR [r10+56], rbx
	mov	QWORD PTR [r10+48], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+48], rax
	mov	QWORD PTR [r11+56], rcx
	mov	QWORD PTR [r11+64], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r10+72]
	mov	rdx, QWORD PTR [r10+88]
	mov	rcx, QWORD PTR [r10+80]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+88], rbx
	mov	QWORD PTR [r10+80], rbx
	mov	QWORD PTR [r10+72], rbx
	mov	rbx, QWORD PTR [rsp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+72], rax
	mov	rax, r11
	mov	QWORD PTR [r11+80], rcx
	mov	QWORD PTR [r11+88], rdx
	ret	0
??0LOD@BfresFile@@QEAA@$$QEAU01@@Z ENDP			; BfresFile::LOD::LOD
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0Mesh@@QEAA@$$QEAV0@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0Mesh@@QEAA@$$QEAV0@@Z PROC				; Mesh::Mesh, COMDAT
$LN41:
	mov	QWORD PTR [rsp+8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]
	mov	r10, rdx
	mov	r9, QWORD PTR [rdx+16]
	mov	r11, rcx
	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	ebx, ebx
	mov	QWORD PTR [rdx+16], rbx
	mov	QWORD PTR [rdx+8], rbx
	mov	QWORD PTR [rdx], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r10+32]
	mov	rax, QWORD PTR [r10+24]
	mov	rdx, QWORD PTR [rdx+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+32], rbx
	mov	QWORD PTR [r10+24], rbx
	mov	QWORD PTR [r10+40], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+24], rax
	mov	QWORD PTR [r11+32], rcx
	mov	QWORD PTR [r11+40], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r10+48]
	mov	rdx, QWORD PTR [r10+64]
	mov	rcx, QWORD PTR [r10+56]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r10+64], rbx
	mov	QWORD PTR [r10+56], rbx
	mov	QWORD PTR [r10+48], rbx
	mov	rbx, QWORD PTR [rsp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+48], rax
	mov	QWORD PTR [r11+56], rcx
	mov	QWORD PTR [r11+64], rdx
	mov	eax, DWORD PTR [r10+72]
	mov	DWORD PTR [r11+72], eax
	mov	eax, DWORD PTR [r10+76]
	mov	DWORD PTR [r11+76], eax
	mov	eax, DWORD PTR [r10+80]
	mov	DWORD PTR [r11+80], eax
	mov	eax, DWORD PTR [r10+84]
	mov	DWORD PTR [r11+84], eax
	mov	eax, DWORD PTR [r10+88]
	mov	DWORD PTR [r11+88], eax
	mov	rax, r11
	ret	0
??0Mesh@@QEAA@$$QEAV0@@Z ENDP				; Mesh::Mesh
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0BfresTexture@BfresFile@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0BfresTexture@BfresFile@@QEAA@$$QEAU01@@Z PROC	; BfresFile::BfresTexture::BfresTexture, COMDAT
	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	QWORD PTR [rcx], rax
	xorps	xmm0, xmm0

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx+8]
	mov	r9, QWORD PTR [rdx+24]
	mov	r8, QWORD PTR [rdx+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+24], r10
	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	mov	QWORD PTR [rcx+16], r8
	mov	QWORD PTR [rcx+24], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx+32], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+48], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+56], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1
	mov	QWORD PTR [rdx+48], r10
	mov	QWORD PTR [rdx+56], 15
	mov	BYTE PTR [rdx+32], r10b
	ret	0
??0BfresTexture@BfresFile@@QEAA@$$QEAU01@@Z ENDP	; BfresFile::BfresTexture::BfresTexture
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::vector<BfresFile::Material,std::allocator<BfresFile::Material> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@UMaterial@BfresFile@@V?$allocator@UMaterial@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<BfresFile::Material,std::allocator<BfresFile::Material> >::vector<BfresFile::Material,std::allocator<BfresFile::Material> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@V?$vector@MV?$allocator@M@std@@@std@@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >::vector<std::vector<float,std::allocator<float> >,std::allocator<std::vector<float,std::allocator<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@ULOD@BfresFile@@V?$allocator@ULOD@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >::vector<BfresFile::LOD,std::allocator<BfresFile::LOD> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<Mesh,std::allocator<Mesh> >::vector<Mesh,std::allocator<Mesh> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<Mesh,std::allocator<Mesh> >::vector<Mesh,std::allocator<Mesh> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@V?$vector@IV?$allocator@I@std@@@std@@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >::vector<std::vector<unsigned int,std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@UBfresTexture@BfresFile@@V?$allocator@UBfresTexture@BfresFile@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >::vector<BfresFile::BfresTexture,std::allocator<BfresFile::BfresTexture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<Texture *,std::allocator<Texture *> >::vector<Texture *,std::allocator<Texture *> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@PEAVTexture@@V?$allocator@PEAVTexture@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<Texture *,std::allocator<Texture *> >::vector<Texture *,std::allocator<Texture *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$tuple@AEBQEAVTextureToGo@@@std@@@std@@YA$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$tuple@AEBQEAVTextureToGo@@@std@@@std@@YA$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@AEAV10@@Z PROC ; std::move<std::tuple<TextureToGo * const &> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$tuple@AEBQEAVTextureToGo@@@std@@@std@@YA$$QEAV?$tuple@AEBQEAVTextureToGo@@@0@AEAV10@@Z ENDP ; std::move<std::tuple<TextureToGo * const &> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@UMaterial@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UMaterial@BfresFile@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@UMaterial@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UMaterial@BfresFile@@@0@AEAV10@@Z PROC ; std::move<std::allocator<BfresFile::Material> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@UMaterial@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UMaterial@BfresFile@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<BfresFile::Material> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAUMaterial@BfresFile@@$$T@std@@YAPEAUMaterial@BfresFile@@AEAPEAU12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAUMaterial@BfresFile@@$$T@std@@YAPEAUMaterial@BfresFile@@AEAPEAU12@$$QEA$$T@Z PROC ; std::exchange<BfresFile::Material *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAUMaterial@BfresFile@@$$T@std@@YAPEAUMaterial@BfresFile@@AEAPEAU12@$$QEA$$T@Z ENDP ; std::exchange<BfresFile::Material *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@UMaterial@BfresFile@@@std@@PEAUMaterial@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UMaterial@BfresFile@@@1@$$QEAPEAUMaterial@BfresFile@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@UMaterial@BfresFile@@@std@@PEAUMaterial@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UMaterial@BfresFile@@@1@$$QEAPEAUMaterial@BfresFile@@22@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1>::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1><std::allocator<BfresFile::Material>,BfresFile::Material *,BfresFile::Material *,BfresFile::Material *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@UMaterial@BfresFile@@@std@@PEAUMaterial@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UMaterial@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UMaterial@BfresFile@@@1@$$QEAPEAUMaterial@BfresFile@@22@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1>::_Compressed_pair<std::allocator<BfresFile::Material>,std::_Vector_val<std::_Simple_types<BfresFile::Material> >,1><std::allocator<BfresFile::Material>,BfresFile::Material *,BfresFile::Material *,BfresFile::Material *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@AEAV10@@Z PROC ; std::move<std::allocator<std::vector<float,std::allocator<float> > > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<std::vector<float,std::allocator<float> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAV?$vector@MV?$allocator@M@std@@@std@@$$T@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAV?$vector@MV?$allocator@M@std@@@std@@$$T@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::vector<float,std::allocator<float> > *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAV?$vector@MV?$allocator@M@std@@@std@@$$T@std@@YAPEAV?$vector@MV?$allocator@M@std@@@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::vector<float,std::allocator<float> > *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@PEAV?$vector@MV?$allocator@M@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@$$QEAPEAV?$vector@MV?$allocator@M@std@@@1@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@PEAV?$vector@MV?$allocator@M@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@$$QEAPEAV?$vector@MV?$allocator@M@std@@@1@22@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1>::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1><std::allocator<std::vector<float,std::allocator<float> > >,std::vector<float,std::allocator<float> > *,std::vector<float,std::allocator<float> > *,std::vector<float,std::allocator<float> > *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@PEAV?$vector@MV?$allocator@M@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@MV?$allocator@M@std@@@std@@@1@$$QEAPEAV?$vector@MV?$allocator@M@std@@@1@22@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1>::_Compressed_pair<std::allocator<std::vector<float,std::allocator<float> > >,std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >,1><std::allocator<std::vector<float,std::allocator<float> > >,std::vector<float,std::allocator<float> > *,std::vector<float,std::allocator<float> > *,std::vector<float,std::allocator<float> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@ULOD@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@ULOD@BfresFile@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@ULOD@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@ULOD@BfresFile@@@0@AEAV10@@Z PROC ; std::move<std::allocator<BfresFile::LOD> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@ULOD@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@ULOD@BfresFile@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<BfresFile::LOD> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAULOD@BfresFile@@$$T@std@@YAPEAULOD@BfresFile@@AEAPEAU12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAULOD@BfresFile@@$$T@std@@YAPEAULOD@BfresFile@@AEAPEAU12@$$QEA$$T@Z PROC ; std::exchange<BfresFile::LOD *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAULOD@BfresFile@@$$T@std@@YAPEAULOD@BfresFile@@AEAPEAU12@$$QEA$$T@Z ENDP ; std::exchange<BfresFile::LOD *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@ULOD@BfresFile@@@std@@PEAULOD@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@ULOD@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@ULOD@BfresFile@@@1@$$QEAPEAULOD@BfresFile@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@ULOD@BfresFile@@@std@@PEAULOD@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@ULOD@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@ULOD@BfresFile@@@1@$$QEAPEAULOD@BfresFile@@22@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1>::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1><std::allocator<BfresFile::LOD>,BfresFile::LOD *,BfresFile::LOD *,BfresFile::LOD *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@ULOD@BfresFile@@@std@@PEAULOD@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@ULOD@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@ULOD@BfresFile@@@1@$$QEAPEAULOD@BfresFile@@22@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1>::_Compressed_pair<std::allocator<BfresFile::LOD>,std::_Vector_val<std::_Simple_types<BfresFile::LOD> >,1><std::allocator<BfresFile::LOD>,BfresFile::LOD *,BfresFile::LOD *,BfresFile::LOD *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@VMesh@@@std@@@std@@YA$$QEAV?$allocator@VMesh@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@VMesh@@@std@@@std@@YA$$QEAV?$allocator@VMesh@@@0@AEAV10@@Z PROC ; std::move<std::allocator<Mesh> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@VMesh@@@std@@@std@@YA$$QEAV?$allocator@VMesh@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<Mesh> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAVMesh@@$$T@std@@YAPEAVMesh@@AEAPEAV1@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVMesh@@$$T@std@@YAPEAVMesh@@AEAPEAV1@$$QEA$$T@Z PROC ; std::exchange<Mesh *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAVMesh@@$$T@std@@YAPEAVMesh@@AEAPEAV1@$$QEA$$T@Z ENDP ; std::exchange<Mesh *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@VMesh@@@std@@PEAVMesh@@PEAV2@PEAV2@@?$_Compressed_pair@V?$allocator@VMesh@@@std@@V?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VMesh@@@1@$$QEAPEAVMesh@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@VMesh@@@std@@PEAVMesh@@PEAV2@PEAV2@@?$_Compressed_pair@V?$allocator@VMesh@@@std@@V?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VMesh@@@1@$$QEAPEAVMesh@@22@Z PROC ; std::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1>::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1><std::allocator<Mesh>,Mesh *,Mesh *,Mesh *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@VMesh@@@std@@PEAVMesh@@PEAV2@PEAV2@@?$_Compressed_pair@V?$allocator@VMesh@@@std@@V?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@VMesh@@@1@$$QEAPEAVMesh@@22@Z ENDP ; std::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1>::_Compressed_pair<std::allocator<Mesh>,std::_Vector_val<std::_Simple_types<Mesh> >,1><std::allocator<Mesh>,Mesh *,Mesh *,Mesh *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@AEAV10@@Z PROC ; std::move<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAV?$vector@IV?$allocator@I@std@@@std@@$$T@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAV?$vector@IV?$allocator@I@std@@@std@@$$T@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::vector<unsigned int,std::allocator<unsigned int> > *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAV?$vector@IV?$allocator@I@std@@@std@@$$T@std@@YAPEAV?$vector@IV?$allocator@I@std@@@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::vector<unsigned int,std::allocator<unsigned int> > *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@PEAV?$vector@IV?$allocator@I@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@$$QEAPEAV?$vector@IV?$allocator@I@std@@@1@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@PEAV?$vector@IV?$allocator@I@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@$$QEAPEAV?$vector@IV?$allocator@I@std@@@1@22@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1>::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1><std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::vector<unsigned int,std::allocator<unsigned int> > *,std::vector<unsigned int,std::allocator<unsigned int> > *,std::vector<unsigned int,std::allocator<unsigned int> > *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@PEAV?$vector@IV?$allocator@I@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@IV?$allocator@I@std@@@std@@@1@$$QEAPEAV?$vector@IV?$allocator@I@std@@@1@22@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1>::_Compressed_pair<std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >,1><std::allocator<std::vector<unsigned int,std::allocator<unsigned int> > >,std::vector<unsigned int,std::allocator<unsigned int> > *,std::vector<unsigned int,std::allocator<unsigned int> > *,std::vector<unsigned int,std::allocator<unsigned int> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UBfresTexture@BfresFile@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UBfresTexture@BfresFile@@@0@AEAV10@@Z PROC ; std::move<std::allocator<BfresFile::BfresTexture> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@UBfresTexture@BfresFile@@@std@@@std@@YA$$QEAV?$allocator@UBfresTexture@BfresFile@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<BfresFile::BfresTexture> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAUBfresTexture@BfresFile@@$$T@std@@YAPEAUBfresTexture@BfresFile@@AEAPEAU12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAUBfresTexture@BfresFile@@$$T@std@@YAPEAUBfresTexture@BfresFile@@AEAPEAU12@$$QEA$$T@Z PROC ; std::exchange<BfresFile::BfresTexture *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAUBfresTexture@BfresFile@@$$T@std@@YAPEAUBfresTexture@BfresFile@@AEAPEAU12@$$QEA$$T@Z ENDP ; std::exchange<BfresFile::BfresTexture *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@UBfresTexture@BfresFile@@@std@@PEAUBfresTexture@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UBfresTexture@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UBfresTexture@BfresFile@@@1@$$QEAPEAUBfresTexture@BfresFile@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@UBfresTexture@BfresFile@@@std@@PEAUBfresTexture@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UBfresTexture@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UBfresTexture@BfresFile@@@1@$$QEAPEAUBfresTexture@BfresFile@@22@Z PROC ; std::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1>::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1><std::allocator<BfresFile::BfresTexture>,BfresFile::BfresTexture *,BfresFile::BfresTexture *,BfresFile::BfresTexture *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@UBfresTexture@BfresFile@@@std@@PEAUBfresTexture@BfresFile@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UBfresTexture@BfresFile@@@std@@V?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UBfresTexture@BfresFile@@@1@$$QEAPEAUBfresTexture@BfresFile@@22@Z ENDP ; std::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1>::_Compressed_pair<std::allocator<BfresFile::BfresTexture>,std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >,1><std::allocator<BfresFile::BfresTexture>,BfresFile::BfresTexture *,BfresFile::BfresTexture *,BfresFile::BfresTexture *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAPEAVTexture@@$$T@std@@YAPEAPEAVTexture@@AEAPEAPEAV1@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAPEAVTexture@@$$T@std@@YAPEAPEAVTexture@@AEAPEAPEAV1@$$QEA$$T@Z PROC ; std::exchange<Texture * *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAPEAVTexture@@$$T@std@@YAPEAPEAVTexture@@AEAPEAPEAV1@$$QEA$$T@Z ENDP ; std::exchange<Texture * *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@PEAVTexture@@@std@@PEAPEAVTexture@@PEAPEAV2@PEAPEAV2@@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@PEAVTexture@@@1@$$QEAPEAPEAVTexture@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@PEAVTexture@@@std@@PEAPEAVTexture@@PEAPEAV2@PEAPEAV2@@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@PEAVTexture@@@1@$$QEAPEAPEAVTexture@@22@Z PROC ; std::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1>::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1><std::allocator<Texture *>,Texture * *,Texture * *,Texture * *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@PEAVTexture@@@std@@PEAPEAVTexture@@PEAPEAV2@PEAPEAV2@@?$_Compressed_pair@V?$allocator@PEAVTexture@@@std@@V?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@PEAVTexture@@@1@$$QEAPEAPEAVTexture@@22@Z ENDP ; std::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1>::_Compressed_pair<std::allocator<Texture *>,std::_Vector_val<std::_Simple_types<Texture *> >,1><std::allocator<Texture *>,Texture * *,Texture * *,Texture * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@std@@QEAA@PEAUMaterial@BfresFile@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@std@@QEAA@PEAUMaterial@BfresFile@@00@Z PROC ; std::_Vector_val<std::_Simple_types<BfresFile::Material> >::_Vector_val<std::_Simple_types<BfresFile::Material> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@UMaterial@BfresFile@@@std@@@std@@QEAA@PEAUMaterial@BfresFile@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<BfresFile::Material> >::_Vector_val<std::_Simple_types<BfresFile::Material> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@MV?$allocator@M@std@@@1@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@MV?$allocator@M@std@@@1@00@Z PROC ; std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$vector@MV?$allocator@M@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@MV?$allocator@M@std@@@1@00@Z ENDP ; std::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >::_Vector_val<std::_Simple_types<std::vector<float,std::allocator<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@std@@QEAA@PEAULOD@BfresFile@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@std@@QEAA@PEAULOD@BfresFile@@00@Z PROC ; std::_Vector_val<std::_Simple_types<BfresFile::LOD> >::_Vector_val<std::_Simple_types<BfresFile::LOD> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@ULOD@BfresFile@@@std@@@std@@QEAA@PEAULOD@BfresFile@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<BfresFile::LOD> >::_Vector_val<std::_Simple_types<BfresFile::LOD> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@std@@QEAA@PEAVMesh@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@std@@QEAA@PEAVMesh@@00@Z PROC ; std::_Vector_val<std::_Simple_types<Mesh> >::_Vector_val<std::_Simple_types<Mesh> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@VMesh@@@std@@@std@@QEAA@PEAVMesh@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<Mesh> >::_Vector_val<std::_Simple_types<Mesh> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@IV?$allocator@I@std@@@1@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@IV?$allocator@I@std@@@1@00@Z PROC ; std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$vector@IV?$allocator@I@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@IV?$allocator@I@std@@@1@00@Z ENDP ; std::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >::_Vector_val<std::_Simple_types<std::vector<unsigned int,std::allocator<unsigned int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@std@@QEAA@PEAUBfresTexture@BfresFile@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@std@@QEAA@PEAUBfresTexture@BfresFile@@00@Z PROC ; std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@UBfresTexture@BfresFile@@@std@@@std@@QEAA@PEAUBfresTexture@BfresFile@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >::_Vector_val<std::_Simple_types<BfresFile::BfresTexture> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@std@@QEAA@PEAPEAVTexture@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@std@@QEAA@PEAPEAVTexture@@00@Z PROC ; std::_Vector_val<std::_Simple_types<Texture *> >::_Vector_val<std::_Simple_types<Texture *> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEAVTexture@@@std@@@std@@QEAA@PEAPEAVTexture@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<Texture *> >::_Vector_val<std::_Simple_types<Texture *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAUMaterial@BfresFile@@@std@@YA$$QEAPEAUMaterial@BfresFile@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUMaterial@BfresFile@@@std@@YA$$QEAPEAUMaterial@BfresFile@@AEAPEAU12@@Z PROC ; std::forward<BfresFile::Material *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAUMaterial@BfresFile@@@std@@YA$$QEAPEAUMaterial@BfresFile@@AEAPEAU12@@Z ENDP ; std::forward<BfresFile::Material *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAPEAV?$vector@MV?$allocator@M@std@@@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAPEAV?$vector@MV?$allocator@M@std@@@0@AEAPEAV10@@Z PROC ; std::forward<std::vector<float,std::allocator<float> > *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAPEAV?$vector@MV?$allocator@M@std@@@0@AEAPEAV10@@Z ENDP ; std::forward<std::vector<float,std::allocator<float> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAULOD@BfresFile@@@std@@YA$$QEAPEAULOD@BfresFile@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAULOD@BfresFile@@@std@@YA$$QEAPEAULOD@BfresFile@@AEAPEAU12@@Z PROC ; std::forward<BfresFile::LOD *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAULOD@BfresFile@@@std@@YA$$QEAPEAULOD@BfresFile@@AEAPEAU12@@Z ENDP ; std::forward<BfresFile::LOD *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAVMesh@@@std@@YA$$QEAPEAVMesh@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVMesh@@@std@@YA$$QEAPEAVMesh@@AEAPEAV1@@Z PROC ; std::forward<Mesh *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAVMesh@@@std@@YA$$QEAPEAVMesh@@AEAPEAV1@@Z ENDP ; std::forward<Mesh *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAPEAV?$vector@IV?$allocator@I@std@@@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAPEAV?$vector@IV?$allocator@I@std@@@0@AEAPEAV10@@Z PROC ; std::forward<std::vector<unsigned int,std::allocator<unsigned int> > *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAV?$vector@IV?$allocator@I@std@@@std@@@std@@YA$$QEAPEAV?$vector@IV?$allocator@I@std@@@0@AEAPEAV10@@Z ENDP ; std::forward<std::vector<unsigned int,std::allocator<unsigned int> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAUBfresTexture@BfresFile@@@std@@YA$$QEAPEAUBfresTexture@BfresFile@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUBfresTexture@BfresFile@@@std@@YA$$QEAPEAUBfresTexture@BfresFile@@AEAPEAU12@@Z PROC ; std::forward<BfresFile::BfresTexture *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAUBfresTexture@BfresFile@@@std@@YA$$QEAPEAUBfresTexture@BfresFile@@AEAPEAU12@@Z ENDP ; std::forward<BfresFile::BfresTexture *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAPEAVTexture@@@std@@YA$$QEAPEAPEAVTexture@@AEAPEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAPEAVTexture@@@std@@YA$$QEAPEAPEAVTexture@@AEAPEAPEAV1@@Z PROC ; std::forward<Texture * *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAPEAVTexture@@@std@@YA$$QEAPEAPEAVTexture@@AEAPEAPEAV1@@Z ENDP ; std::forward<Texture * *>
_TEXT	ENDS
END
