; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?Open@UIMapView@@3_NA				; UIMapView::Open
PUBLIC	?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A ; UIMapView::RenderSettings
PUBLIC	??_C@_07NBLJNJCC@MapView@			; `string'
PUBLIC	??_C@_07JPIMECAN@Picking@			; `string'
PUBLIC	??_C@_09FDDHGJMI@Instanced@			; `string'
PUBLIC	??_C@_06GCNPBLOP@Mode?3?5@			; `string'
PUBLIC	??_C@_0P@DMOEPKE@TranslateGizmo@		; `string'
PUBLIC	??_C@_0BE@MGGNGPDH@Translate?5Gizmo?5?$CIG?$CJ@	; `string'
PUBLIC	??_C@_0M@PCPPJDNL@RotateGizmo@			; `string'
PUBLIC	??_C@_04IBBNLEM@Game@				; `string'
PUBLIC	??_C@_0BK@DFAEGNNF@FPS?3?5?$CF?41f?5?$CI?$CF?43f?5ms?1frame?$CJ@ ; `string'
PUBLIC	??_C@_05MFLOHCHP@World@				; `string'
PUBLIC	??_C@_05IEALKJIG@Local@				; `string'
PUBLIC	??_C@_0N@GKKHGHLK@PickingColor@			; `string'
PUBLIC	??_C@_0BB@ODIOCAMI@Rotate?5Gizmo?5?$CIR?$CJ@	; `string'
PUBLIC	??_C@_0L@HKLBEJBP@ScaleGizmo@			; `string'
PUBLIC	??_C@_0BA@DOGOOPJA@Scale?5Gizmo?5?$CIS?$CJ@	; `string'
PUBLIC	??_C@_04MCJDHKLE@Npc_@				; `string'
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Min_buckets
PUBLIC	?Focused@UIMapView@@3_NA			; UIMapView::Focused
PUBLIC	?DefaultShader@UIMapView@@3PEAVShader@@EA	; UIMapView::DefaultShader
PUBLIC	?PickingShader@UIMapView@@3PEAVShader@@EA	; UIMapView::PickingShader
PUBLIC	?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A ; UIMapView::ImGuizmoOperation
PUBLIC	?Window@UIMapView@@3PEAUGLFWwindow@@EA		; UIMapView::Window
PUBLIC	?ImGuizmoMode@UIMapView@@3W4MODE@ImGuizmo@@A	; UIMapView::ImGuizmoMode
PUBLIC	?InstancedShader@UIMapView@@3PEAVShader@@EA	; UIMapView::InstancedShader
PUBLIC	?ObjectMatrix@UIMapView@@3PAMA			; UIMapView::ObjectMatrix
PUBLIC	?ClearColor@UIMapView@@3UImVec4@@A		; UIMapView::ClearColor
PUBLIC	?MapViewFramebuffer@UIMapView@@3PEAVFramebuffer@@EA ; UIMapView::MapViewFramebuffer
PUBLIC	?SelectedShader@UIMapView@@3PEAVShader@@EA	; UIMapView::SelectedShader
?Focused@UIMapView@@3_NA DB 01H DUP (?)			; UIMapView::Focused
	ALIGN	8

?DefaultShader@UIMapView@@3PEAVShader@@EA DQ 01H DUP (?) ; UIMapView::DefaultShader
?PickingShader@UIMapView@@3PEAVShader@@EA DQ 01H DUP (?) ; UIMapView::PickingShader
?Window@UIMapView@@3PEAUGLFWwindow@@EA DQ 01H DUP (?)	; UIMapView::Window
?InstancedShader@UIMapView@@3PEAVShader@@EA DQ 01H DUP (?) ; UIMapView::InstancedShader
?MapViewFramebuffer@UIMapView@@3PEAVFramebuffer@@EA DQ 01H DUP (?) ; UIMapView::MapViewFramebuffer
?SelectedShader@UIMapView@@3PEAVShader@@EA DQ 01H DUP (?) ; UIMapView::SelectedShader
_BSS	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ??_C@_04MCJDHKLE@Npc_@
CONST	SEGMENT
??_C@_04MCJDHKLE@Npc_@ DB 'Npc_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DOGOOPJA@Scale?5Gizmo?5?$CIS?$CJ@
CONST	SEGMENT
??_C@_0BA@DOGOOPJA@Scale?5Gizmo?5?$CIS?$CJ@ DB 'Scale Gizmo (S)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HKLBEJBP@ScaleGizmo@
CONST	SEGMENT
??_C@_0L@HKLBEJBP@ScaleGizmo@ DB 'ScaleGizmo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ODIOCAMI@Rotate?5Gizmo?5?$CIR?$CJ@
CONST	SEGMENT
??_C@_0BB@ODIOCAMI@Rotate?5Gizmo?5?$CIR?$CJ@ DB 'Rotate Gizmo (R)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GKKHGHLK@PickingColor@
CONST	SEGMENT
??_C@_0N@GKKHGHLK@PickingColor@ DB 'PickingColor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IEALKJIG@Local@
CONST	SEGMENT
??_C@_05IEALKJIG@Local@ DB 'Local', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFLOHCHP@World@
CONST	SEGMENT
??_C@_05MFLOHCHP@World@ DB 'World', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DFAEGNNF@FPS?3?5?$CF?41f?5?$CI?$CF?43f?5ms?1frame?$CJ@
CONST	SEGMENT
??_C@_0BK@DFAEGNNF@FPS?3?5?$CF?41f?5?$CI?$CF?43f?5ms?1frame?$CJ@ DB 'FPS:'
	DB	' %.1f (%.3f ms/frame)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBBNLEM@Game@
CONST	SEGMENT
??_C@_04IBBNLEM@Game@ DB 'Game', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCPPJDNL@RotateGizmo@
CONST	SEGMENT
??_C@_0M@PCPPJDNL@RotateGizmo@ DB 'RotateGizmo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGGNGPDH@Translate?5Gizmo?5?$CIG?$CJ@
CONST	SEGMENT
??_C@_0BE@MGGNGPDH@Translate?5Gizmo?5?$CIG?$CJ@ DB 'Translate Gizmo (G)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DMOEPKE@TranslateGizmo@
CONST	SEGMENT
??_C@_0P@DMOEPKE@TranslateGizmo@ DB 'TranslateGizmo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GCNPBLOP@Mode?3?5@
CONST	SEGMENT
??_C@_06GCNPBLOP@Mode?3?5@ DB 'Mode: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FDDHGJMI@Instanced@
CONST	SEGMENT
??_C@_09FDDHGJMI@Instanced@ DB 'Instanced', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JPIMECAN@Picking@
CONST	SEGMENT
??_C@_07JPIMECAN@Picking@ DB 'Picking', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBLJNJCC@MapView@
CONST	SEGMENT
??_C@_07NBLJNJCC@MapView@ DB 'MapView', 00H		; `string'
?Open@UIMapView@@3_NA DB 01H				; UIMapView::Open
?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A DD 07H ; UIMapView::ImGuizmoOperation
?ImGuizmoMode@UIMapView@@3W4MODE@ImGuizmo@@A DD 01H	; UIMapView::ImGuizmoMode
?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A DB 01H ; UIMapView::RenderSettings
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	ORG $+5
?ObjectMatrix@UIMapView@@3PAMA DD 03f800000r	; 1	; UIMapView::ObjectMatrix
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
?ClearColor@UIMapView@@3UImVec4@@A DD 03e3851ecr ; 0.18	; UIMapView::ClearColor
	DD	03e570a3dr			; 0.21
	DD	03e800000r			; 0.25
	DD	03f800000r			; 1
PUBLIC	??$construct_at@U?$mat@$03$03M$0A@@glm@@U12@$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@$$QEAU12@@Z ; std::construct_at<glm::mat<4,4,float,0>,glm::mat<4,4,float,0>,0>
PUBLIC	??$?0V?$tuple@AEBH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHPEAUActor@@@std@@QEAA@AEAV?$tuple@AEBH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<int const ,Actor *>::pair<int const ,Actor *><std::tuple<int const &>,std::tuple<>,0>
PUBLIC	??$construct_at@U?$mat@$03$03M$0A@@glm@@$$V$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@@Z ; std::construct_at<glm::mat<4,4,float,0>,0>
PUBLIC	??$construct@U?$mat@$03$03M$0A@@glm@@U12@@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::construct<glm::mat<4,4,float,0>,glm::mat<4,4,float,0> >
PUBLIC	??$forward@U?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z ; std::forward<glm::mat<4,4,float,0> >
PUBLIC	??$?0AEBH$$Z$$V@?$pair@$$CBHPEAUActor@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBH@1@V?$tuple@$$V@1@@Z ; std::pair<int const ,Actor *>::pair<int const ,Actor *><int const &>
PUBLIC	??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &,0>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >
PUBLIC	??$construct@U?$mat@$03$03M$0A@@glm@@$$V@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@@Z ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::construct<glm::mat<4,4,float,0> >
PUBLIC	??$_Emplace_back@U?$mat@$03$03M$0A@@glm@@@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX$$QEAU?$mat@$03$03M$0A@@glm@@@Z ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Emplace_back<glm::mat<4,4,float,0> >
PUBLIC	??$move@AEAU?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z ; std::move<glm::mat<4,4,float,0> &>
PUBLIC	??$construct_at@U?$pair@$$CBHPEAUActor@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@QEAU10@$$QEAU10@@Z ; std::construct_at<std::pair<int const ,Actor *>,std::pair<int const ,Actor *>,0>
PUBLIC	??$construct_at@U?$pair@$$CBHPEAUActor@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBH@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBH@0@$$QEAV?$tuple@$$V@0@@Z ; std::construct_at<std::pair<int const ,Actor *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<>,0>
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * const &,0>
PUBLIC	??$forward@AEBQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,Actor *>,void *> * const &>
PUBLIC	??$destroy_at@U?$pair@$$CBHPEAUActor@@@std@@@std@@YAXQEAU?$pair@$$CBHPEAUActor@@@0@@Z ; std::destroy_at<std::pair<int const ,Actor *> >
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &>
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAU?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@0PEAU12@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z ; std::_Uninitialized_move<glm::mat<4,4,float,0> *,std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	??$_Get_unwrapped@AEBQEAU?$mat@$03$03M$0A@@glm@@@std@@YA?A_TAEBQEAU?$mat@$03$03M$0A@@glm@@@Z ; std::_Get_unwrapped<glm::mat<4,4,float,0> * const &>
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >
PUBLIC	??$construct@U?$pair@$$CBHPEAUActor@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@$$QEAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::construct<std::pair<int const ,Actor *>,std::pair<int const ,Actor *> >
PUBLIC	??$forward@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,Actor *>,void *> *>
PUBLIC	??$construct@U?$pair@$$CBHPEAUActor@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::construct<std::pair<int const ,Actor *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > ><std::pair<int const ,Actor *> >
PUBLIC	?capacity@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::capacity
PUBLIC	?_Calculate_growth@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBA_K_K@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXQEAU?$mat@$03$03M$0A@@glm@@_K1@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Change_array
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_Allocate
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > const >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * const &>
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::nullptr_t>
PUBLIC	??$destroy@U?$pair@$$CBHPEAUActor@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::destroy<std::pair<int const ,Actor *> >
PUBLIC	??$addressof@U?$pair@$$CBHPEAUActor@@@std@@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z ; std::addressof<std::pair<int const ,Actor *> >
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * &,0>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<int const ,Actor *>,void *> * &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<int const ,Actor *>,void *> *>
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,Actor *>,void *> *>
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,Actor *>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1><std::allocator<std::pair<int const ,Actor *> > const &>
PUBLIC	??$forward@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<int const ,Actor *> > const &>
PUBLIC	??$forward@AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@AEBV10@@Z ; std::forward<std::allocator<glm::mat<4,4,float,0> > const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@_KAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,bool,0>
PUBLIC	??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > ><std::pair<int const ,Actor *> >
PUBLIC	??$forward@U?$pair@$$CBHPEAUActor@@@std@@@std@@YA$$QEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z ; std::forward<std::pair<int const ,Actor *> >
PUBLIC	??$?0PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool><std::_List_node<std::pair<int const ,Actor *>,void *> *,bool,0>
PUBLIC	??$?0AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool><std::_List_node<std::pair<int const ,Actor *>,void *> * &,bool,0>
PUBLIC	??$_Kfn@$$CBHPEAUActor@@@?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@SAAEBHAEBU?$pair@$$CBHPEAUActor@@@1@@Z ; std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0>::_Kfn<int const ,Actor *>
PUBLIC	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$_Find_last@H@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBH_K@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Find_last<int>
PUBLIC	??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> ><std::pair<int const ,Actor *> >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >::_Orphan_non_end
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::clear
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Unchecked_erase
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Unchecked_begin
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1>::_Get_first
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::clear
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::max_size
PUBLIC	?_Getal@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Getal
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >::_Unchecked_splice
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Unchecked_end
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBA_KAEBH@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::bucket
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Min_load_factor_buckets
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Max_bucket_size
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::max_size
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBHPEAUActor@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator==
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHPEAUActor@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::operator++
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::__autoclassinit2
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >::deallocate
PUBLIC	?max_size@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::max_size
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::bucket_count
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::max_load_factor
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Forced_rehash
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >
PUBLIC	?_Orphan_range@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBAXPEAU?$mat@$03$03M$0A@@glm@@0@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Orphan_range
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::deallocate
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@@Z ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Make_iter
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Rehash_for_1
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_Release
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
PUBLIC	?_Extract@?$_In_place_key_extract_map@HU?$pair@$$CBHPEAUActor@@@std@@@std@@SAAEBHAEBU?$pair@$$CBHPEAUActor@@@2@@Z ; std::_In_place_key_extract_map<int,std::pair<int const ,Actor *> >::_Extract
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::_Release
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * &>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1><std::allocator<std::pair<int const ,Actor *> > const &>
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > * const &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,Actor *>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<int const ,Actor *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > ><std::allocator<std::pair<int const ,Actor *> > const &,0>
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>
PUBLIC	??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Construct_n<>
PUBLIC	??$?0AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1><std::allocator<glm::mat<4,4,float,0> > const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Resize<std::_Value_init_tag>
PUBLIC	??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::emplace<std::pair<int const ,Actor *> >
PUBLIC	??$move@AEAU?$pair@$$CBHPEAUActor@@@std@@@std@@YA$$QEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z ; std::move<std::pair<int const ,Actor *> &>
PUBLIC	??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Try_emplace<int const &>
PUBLIC	??$get@$00QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@std@@YAAEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@0@AEAU?$pair@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@0@@Z ; std::get<1,BfresFile * const,std::vector<Actor *,std::allocator<Actor *> > >
PUBLIC	??$get@$0A@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@std@@YAAEBQEAVBfresFile@@AEAU?$pair@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@0@@Z ; std::get<0,BfresFile * const,std::vector<Actor *,std::allocator<Actor *> > >
PUBLIC	??$?0AEAHPEAUActor@@$0A@@?$pair@$$CBHPEAUActor@@@std@@QEAA@AEAH$$QEAPEAUActor@@@Z ; std::pair<int const ,Actor *>::pair<int const ,Actor *><int &,Actor *,0>
PUBLIC	??$fmax@NM$0A@@@YANNM@Z				; fmax<double,float,0>
PUBLIC	??$fmax@HM$0A@@@YANHM@Z				; fmax<int,float,0>
PUBLIC	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >::allocate
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Alloc_sentinel_and_proxy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1>::_Get_first
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >::allocate
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::size
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >
PUBLIC	??0?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ; std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0>::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0>
PUBLIC	??0?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Unchecked_end
PUBLIC	?_Getal@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Getal
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Max_bucket_size
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >::deallocate
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Assign_grow
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1>::_Get_first
PUBLIC	??0?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<int const ,Actor *> >::allocator<std::pair<int const ,Actor *> >
PUBLIC	?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Tidy
PUBLIC	??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Tidy
PUBLIC	??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
PUBLIC	?resize@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::resize
PUBLIC	??A?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAAEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::operator[]
PUBLIC	?_Unchecked_begin@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAPEAVMesh@@XZ ; std::vector<Mesh,std::allocator<Mesh> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAPEAVMesh@@XZ ; std::vector<Mesh,std::allocator<Mesh> >::_Unchecked_end
PUBLIC	?size@?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@QEBA_KXZ ; std::vector<Actor *,std::allocator<Actor *> >::size
PUBLIC	??A?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@QEAAAEAPEAUActor@@_K@Z ; std::vector<Actor *,std::allocator<Actor *> >::operator[]
PUBLIC	??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::~list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >
PUBLIC	?insert@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHPEAUActor@@@2@@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::insert
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >
PUBLIC	??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >
PUBLIC	??A?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAAAEAPEAUActor@@AEBH@Z ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::operator[]
PUBLIC	?__autoclassinit2@?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAAX_K@Z ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::__autoclassinit2
PUBLIC	??1?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::~_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >
PUBLIC	??1?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::~unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >
PUBLIC	?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z ; UIMapView::SelectActorByClicking
PUBLIC	?__autoclassinit2@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::__autoclassinit2
PUBLIC	?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z ; UIMapView::DrawInstancedActor
PUBLIC	?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z ; UIMapView::DrawActor
PUBLIC	?DrawOverlay@UIMapView@@YAXXZ			; UIMapView::DrawOverlay
PUBLIC	?__autoclassinit2@Camera@@QEAAX_K@Z		; Camera::__autoclassinit2
PUBLIC	?GLFWKeyCallback@UIMapView@@YAXPEAUGLFWwindow@@HHHH@Z ; UIMapView::GLFWKeyCallback
PUBLIC	?DrawMapViewWindow@UIMapView@@YAXXZ		; UIMapView::DrawMapViewWindow
PUBLIC	?Initialize@UIMapView@@YAXPEAUGLFWwindow@@@Z	; UIMapView::Initialize
PUBLIC	?IsInCameraMovement@UIMapView@@YA_NXZ		; UIMapView::IsInCameraMovement
PUBLIC	?CameraView@UIMapView@@3VCamera@@A		; UIMapView::CameraView
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAU?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@0PEAU12@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+52
	DD	imagerel $unwind$??$_Uninitialized_move@PEAU?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@0PEAU12@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXQEAU?$mat@$03$03M$0A@@glm@@_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+142
	DD	imagerel $unwind$?_Change_array@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXQEAU?$mat@$03$03M$0A@@glm@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN33
	DD	imagerel $LN33+37
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@_KAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z DD imagerel $LN26
	DD	imagerel $LN26+64
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@_KAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN95
	DD	imagerel $LN95+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN95+33
	DD	imagerel $LN95+41
	DD	imagerel $chain$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN95+41
	DD	imagerel $LN95+127
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN95+127
	DD	imagerel $LN95+251
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN95+251
	DD	imagerel $LN95+258
	DD	imagerel $chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN95+258
	DD	imagerel $LN95+264
	DD	imagerel $chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z DD imagerel $LN44
	DD	imagerel $LN44+63
	DD	imagerel $unwind$??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN50
	DD	imagerel $LN50+84
	DD	imagerel $unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN52
	DD	imagerel $LN52+43
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN64
	DD	imagerel $LN64+31
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN64+31
	DD	imagerel $LN64+74
	DD	imagerel $chain$0$?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN64+74
	DD	imagerel $LN64+101
	DD	imagerel $chain$1$?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN206
	DD	imagerel $LN206+43
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN206+43
	DD	imagerel $LN206+260
	DD	imagerel $chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN206+260
	DD	imagerel $LN206+272
	DD	imagerel $chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN206+272
	DD	imagerel $LN206+459
	DD	imagerel $chain$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN79
	DD	imagerel $LN79+81
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN79+81
	DD	imagerel $LN79+122
	DD	imagerel $chain$0$?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN79+122
	DD	imagerel $LN79+178
	DD	imagerel $chain$1$?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN10
	DD	imagerel $LN10+99
	DD	imagerel $unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN84
	DD	imagerel $LN84+90
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN84+90
	DD	imagerel $LN84+122
	DD	imagerel $chain$0$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN84+122
	DD	imagerel $LN84+178
	DD	imagerel $chain$1$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z DD imagerel $LN21
	DD	imagerel $LN21+159
	DD	imagerel $unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN216
	DD	imagerel $LN216+57
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN216+57
	DD	imagerel $LN216+130
	DD	imagerel $chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN216+130
	DD	imagerel $LN216+374
	DD	imagerel $chain$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN216+374
	DD	imagerel $LN216+391
	DD	imagerel $chain$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN216+391
	DD	imagerel $LN216+429
	DD	imagerel $chain$5$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN6
	DD	imagerel $LN6+39
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN23
	DD	imagerel $LN23+175
	DD	imagerel $unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21+62
	DD	imagerel $LN21+98
	DD	imagerel $chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN21+98
	DD	imagerel $LN21+132
	DD	imagerel $chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN61
	DD	imagerel $LN61+23
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN61+23
	DD	imagerel $LN61+58
	DD	imagerel $chain$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN61+58
	DD	imagerel $LN61+63
	DD	imagerel $chain$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z DD imagerel $LN42
	DD	imagerel $LN42+33
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z DD imagerel $LN42+33
	DD	imagerel $LN42+110
	DD	imagerel $chain$1$??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z DD imagerel $LN42+110
	DD	imagerel $LN42+117
	DD	imagerel $chain$2$??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN10
	DD	imagerel $LN10+100
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z DD imagerel $LN186
	DD	imagerel $LN186+566
	DD	imagerel $unwind$??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z DD imagerel $LN184
	DD	imagerel $LN184+549
	DD	imagerel $unwind$??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z DD imagerel $LN140
	DD	imagerel $LN140+375
	DD	imagerel $unwind$??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN33
	DD	imagerel $LN33+35
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z DD imagerel $LN41
	DD	imagerel $LN41+45
	DD	imagerel $unwind$??0?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z DD imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z DD imagerel $LN88+54
	DD	imagerel $LN88+270
	DD	imagerel $chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z DD imagerel $LN88+270
	DD	imagerel $LN88+277
	DD	imagerel $chain$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z DD imagerel $LN88+277
	DD	imagerel $LN88+301
	DD	imagerel $chain$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z DD imagerel $LN88+301
	DD	imagerel $LN88+307
	DD	imagerel $chain$5$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN107
	DD	imagerel $LN107+31
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN107+31
	DD	imagerel $LN107+74
	DD	imagerel $chain$0$?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN107+74
	DD	imagerel $LN107+92
	DD	imagerel $chain$1$?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z DD imagerel $LN60
	DD	imagerel $LN60+115
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN32
	DD	imagerel $LN32+92
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z DD imagerel $LN48
	DD	imagerel $LN48+46
	DD	imagerel $unwind$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z DD imagerel $LN48+46
	DD	imagerel $LN48+116
	DD	imagerel $chain$1$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z DD imagerel $LN48+116
	DD	imagerel $LN48+132
	DD	imagerel $chain$2$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+100
	DD	imagerel $unwind$?resize@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN110
	DD	imagerel $LN110+31
	DD	imagerel $unwind$??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN110+31
	DD	imagerel $LN110+74
	DD	imagerel $chain$0$??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN110+74
	DD	imagerel $LN110+92
	DD	imagerel $chain$1$??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHPEAUActor@@@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?insert@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHPEAUActor@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN35
	DD	imagerel $LN35+92
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ DD imagerel $LN70
	DD	imagerel $LN70+113
	DD	imagerel $unwind$??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAAAEAPEAUActor@@AEBH@Z DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$??A?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAAAEAPEAUActor@@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN38
	DD	imagerel $LN38+102
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z DD imagerel $LN710
	DD	imagerel $LN710+4470
	DD	imagerel $unwind$?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z DD imagerel $LN378
	DD	imagerel $LN378+1641
	DD	imagerel $unwind$?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z DD imagerel $LN164
	DD	imagerel $LN164+83
	DD	imagerel $unwind$?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z DD imagerel $LN164+83
	DD	imagerel $LN164+784
	DD	imagerel $chain$4$?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z DD imagerel $LN164+784
	DD	imagerel $LN164+1026
	DD	imagerel $chain$5$?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawOverlay@UIMapView@@YAXXZ DD imagerel $LN496
	DD	imagerel $LN496+1651
	DD	imagerel $unwind$?DrawOverlay@UIMapView@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??DrawOverlay@UIMapView@@YAXXZ@4HA DD imagerel ?dtor$0@?0??DrawOverlay@UIMapView@@YAXXZ@4HA
	DD	imagerel ?dtor$0@?0??DrawOverlay@UIMapView@@YAXXZ@4HA+44
	DD	imagerel $unwind$?dtor$0@?0??DrawOverlay@UIMapView@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??DrawOverlay@UIMapView@@YAXXZ@4HA DD imagerel ?dtor$1@?0??DrawOverlay@UIMapView@@YAXXZ@4HA
	DD	imagerel ?dtor$1@?0??DrawOverlay@UIMapView@@YAXXZ@4HA+44
	DD	imagerel $unwind$?dtor$1@?0??DrawOverlay@UIMapView@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GLFWKeyCallback@UIMapView@@YAXPEAUGLFWwindow@@HHHH@Z DD imagerel $LN22
	DD	imagerel $LN22+164
	DD	imagerel $unwind$?GLFWKeyCallback@UIMapView@@YAXPEAUGLFWwindow@@HHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawMapViewWindow@UIMapView@@YAXXZ DD imagerel $LN643
	DD	imagerel $LN643+4171
	DD	imagerel $unwind$?DrawMapViewWindow@UIMapView@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@UIMapView@@YAXPEAUGLFWwindow@@@Z DD imagerel $LN83
	DD	imagerel $LN83+356
	DD	imagerel $unwind$?Initialize@UIMapView@@YAXPEAUGLFWwindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsInCameraMovement@UIMapView@@YA_NXZ DD imagerel $LN9
	DD	imagerel $LN9+68
	DD	imagerel $unwind$?IsInCameraMovement@UIMapView@@YA_NXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsInCameraMovement@UIMapView@@YA_NXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@UIMapView@@YAXPEAUGLFWwindow@@@Z DD 040d01H
	DD	0b340dH
	DD	05006720dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?DrawMapViewWindow@UIMapView@@YAXXZ DB 06H
	DB	0d8H
	DB	00H
	DB	05H, '6'
	DB	02H
	DB	0adH, 07H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?DrawMapViewWindow@UIMapView@@YAXXZ DB 02H
	DB	0aH
	DD	imagerel ??1Actor@@QEAA@XZ
	DB	0c1H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?DrawMapViewWindow@UIMapView@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?DrawMapViewWindow@UIMapView@@YAXXZ
	DD	imagerel $ip2state$?DrawMapViewWindow@UIMapView@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawMapViewWindow@UIMapView@@YAXXZ DD 0174e19H
	DD	07ba83dH
	DD	07c9838H
	DD	07d8833H
	DD	07e782eH
	DD	07f682aH
	DD	01087426H
	DD	01076426H
	DD	01063426H
	DD	01000126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?DrawMapViewWindow@UIMapView@@YAXXZ
	DD	07a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GLFWKeyCallback@UIMapView@@YAXPEAUGLFWwindow@@HHHH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??DrawOverlay@UIMapView@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??DrawOverlay@UIMapView@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?DrawOverlay@UIMapView@@YAXXZ DB 0aH
	DB	09eH
	DB	00H
	DB	011H, 02H
	DB	02H
	DB	08eH
	DB	04H
	DB	09aH
	DB	06H
	DB	'}', 06H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?DrawOverlay@UIMapView@@YAXXZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??DrawOverlay@UIMapView@@YAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??DrawOverlay@UIMapView@@YAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?DrawOverlay@UIMapView@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?DrawOverlay@UIMapView@@YAXXZ
	DD	imagerel $ip2state$?DrawOverlay@UIMapView@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawOverlay@UIMapView@@YAXXZ DD 081911H
	DD	0a7819H
	DD	0170111H
	DD	060047005H
	DD	050023003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?DrawOverlay@UIMapView@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z DD 021H
	DD	imagerel $LN164
	DD	imagerel $LN164+83
	DD	imagerel $unwind$?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z DD 0a6621H
	DD	0ca866H
	DD	0d9855H
	DD	0e880fH
	DD	0f780aH
	DD	0106805H
	DD	imagerel $LN164
	DD	imagerel $LN164+83
	DD	imagerel $unwind$?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z DD 0b2c19H
	DD	02a641eH
	DD	029341eH
	DD	022011eH
	DD	0e011f013H
	DD	0700dc00fH
	DD	0500cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z DB 06H
	DB	'E', 02H
	DB	00H
	DB	089H, 010H
	DB	02H
	DB	095H, 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ
	DB	081H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z
	DD	imagerel $ip2state$?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z DD 0195619H
	DD	011c848H
	DD	012b840H
	DD	013a838H
	DD	0149830H
	DD	015882bH
	DD	0167826H
	DD	0176822H
	DD	03a341eH
	DD	030011eH
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z
	DD	0102H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z DB 0aH
	DB	0a9H, 06H
	DB	00H
	DB	'I', 01eH
	DB	02H
	DB	082H
	DB	04H
	DB	'e', 013H
	DB	06H
	DB	'e', 09H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$4@?0??SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0??SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z@4HA
	DB	05aH
	DD	imagerel ??1?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ
	DB	0c1H
	DB	07H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z DB 028H
	DD	imagerel $stateUnwindMap$?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z
	DD	imagerel $ip2state$?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z DD 01f7319H
	DD	024f862H
	DD	025e85aH
	DD	026d852H
	DD	027c84aH
	DD	028b842H
	DD	029a83aH
	DD	02a9832H
	DD	02b882dH
	DD	02c7828H
	DD	02d6824H
	DD	0663420H
	DD	05c0120H
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z
	DD	0232H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAAAEAPEAUActor@@AEBH@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ DB 04H
	DB	'B'
	DB	00H
	DB	'x'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0???0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHPEAUActor@@@2@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN110
	DD	imagerel $LN110+31
	DD	imagerel $unwind$??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ DD 020521H
	DD	073405H
	DD	imagerel $LN110
	DD	imagerel $LN110+31
	DD	imagerel $unwind$??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z DD 021H
	DD	imagerel $LN48
	DD	imagerel $LN48+46
	DD	imagerel $unwind$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z DD 040a21H
	DD	04740aH
	DD	0a3405H
	DD	imagerel $LN48
	DD	imagerel $LN48+46
	DD	imagerel $unwind$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z DD 030701H
	DD	060034207H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z DB 04H
	DB	'F'
	DB	00H
	DB	'x'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN107
	DD	imagerel $LN107+31
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ DD 020521H
	DD	073405H
	DD	imagerel $LN107
	DD	imagerel $LN107+31
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z DD 040021H
	DD	047400H
	DD	0b6400H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z DD 040021H
	DD	047400H
	DD	0b6400H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z DD 040a21H
	DD	04740aH
	DD	0b6405H
	DD	imagerel $LN88
	DD	imagerel $LN88+54
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z DD 030c01H
	DD	0e008420cH
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z DD 0d6e01H
	DD	01b86eH
	DD	02a849H
	DD	039840H
	DD	048836H
	DD	05782dH
	DD	066822H
	DD	0e207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z DB 06H
	DB	085H, 03H
	DB	00H
	DB	'4'
	DB	02H
	DB	0faH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z
	DD	imagerel $ip2state$??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z DD 0a1411H
	DD	0113414H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z DB 06H
	DB	085H, 03H
	DB	00H
	DB	'4'
	DB	02H
	DB	0f2H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z
	DD	imagerel $ip2state$??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z DD 0a1411H
	DD	0113414H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN42
	DD	imagerel $LN42+33
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z DD 040a21H
	DD	04740aH
	DD	0a3405H
	DD	imagerel $LN42
	DD	imagerel $LN42+33
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z DD 030c01H
	DD	0e008420cH
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z DD 021H
	DD	imagerel $LN61
	DD	imagerel $LN61+23
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z DD 020521H
	DD	043405H
	DD	imagerel $LN61
	DD	imagerel $LN61+23
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN21
	DD	imagerel $LN21+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD 060021H
	DD	04e400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN216
	DD	imagerel $LN216+57
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN216+57
	DD	imagerel $LN216+130
	DD	imagerel $chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD 020521H
	DD	0b5405H
	DD	imagerel $LN216+57
	DD	imagerel $LN216+130
	DD	imagerel $chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD 041821H
	DD	04e418H
	DD	0a3405H
	DD	imagerel $LN216
	DD	imagerel $LN216+57
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD 030701H
	DD	070034207H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN84
	DD	imagerel $LN84+90
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD 020521H
	DD	093405H
	DD	imagerel $LN84
	DD	imagerel $LN84+90
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+81
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD 020521H
	DD	093405H
	DD	imagerel $LN79
	DD	imagerel $LN79+81
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 0a0021H
	DD	08f400H
	DD	09d400H
	DD	011c400H
	DD	0107400H
	DD	0f3400H
	DD	imagerel $LN206
	DD	imagerel $LN206+43
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 021H
	DD	imagerel $LN206
	DD	imagerel $LN206+43
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 0a2421H
	DD	08f424H
	DD	09d41cH
	DD	011c40fH
	DD	010740bH
	DD	0f3404H
	DD	imagerel $LN206
	DD	imagerel $LN206+43
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 040b01H
	DD	0e007920bH
	DD	050046005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+31
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ DD 020521H
	DD	073405H
	DD	imagerel $LN64
	DD	imagerel $LN64+31
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	'Z'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z DB 02H
	DB	'B'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z
	DD	imagerel $ip2state$??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN95
	DD	imagerel $LN95+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020021H
	DD	0a5400H
	DD	imagerel $LN95
	DD	imagerel $LN95+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN95+33
	DD	imagerel $LN95+41
	DD	imagerel $chain$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	0be405H
	DD	imagerel $LN95+33
	DD	imagerel $LN95+41
	DD	imagerel $chain$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	0a5405H
	DD	imagerel $LN95
	DD	imagerel $LN95+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@_KAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXQEAU?$mat@$03$03M$0A@@glm@@_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAU?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@0PEAU12@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
?CameraView@UIMapView@@3VCamera@@A DB 0cH DUP (?)
	DD	000000000r			; 0	; UIMapView::CameraView
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DB	128 DUP(00H)
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DB	8 DUP(00H)
	DD	0500H
	DD	02d0H
	DB	01H
	DB	00H
	DB	2 DUP(00H)
	DD	03f19999ar			; 0.6
	DD	042c80000r			; 100
	DQ	0000000000000000H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
;	COMDAT ?IsInCameraMovement@UIMapView@@YA_NXZ
_TEXT	SEGMENT
?IsInCameraMovement@UIMapView@@YA_NXZ PROC		; UIMapView::IsInCameraMovement, COMDAT

; 472  : {

$LN9:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 146  : 	if (WindowHovered)

	cmp	BYTE PTR ?CameraView@UIMapView@@3VCamera@@A+245, 0
	je	SHORT $LN4@IsInCamera

; 147  : 	{
; 148  : 		return (glfwGetMouseButton(pWindow, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS && glfwGetMouseButton(pWindow, GLFW_MOUSE_BUTTON_LEFT) != GLFW_PRESS);

	mov	rcx, QWORD PTR ?CameraView@UIMapView@@3VCamera@@A+256
	mov	edx, 1
	call	glfwGetMouseButton
	cmp	eax, 1
	jne	SHORT $LN4@IsInCamera
	mov	rcx, QWORD PTR ?CameraView@UIMapView@@3VCamera@@A+256
	xor	edx, edx
	call	glfwGetMouseButton
	cmp	eax, 1
	je	SHORT $LN4@IsInCamera
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 473  : 	return CameraView.IsInCameraMovement();

	mov	al, 1

; 474  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@IsInCamera:
	xor	al, al
	add	rsp, 40					; 00000028H
	ret	0
?IsInCameraMovement@UIMapView@@YA_NXZ ENDP		; UIMapView::IsInCameraMovement
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
;	COMDAT ?Initialize@UIMapView@@YAXPEAUGLFWwindow@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
pWindow$dead$ = 80
?Initialize@UIMapView@@YAXPEAUGLFWwindow@@@Z PROC	; UIMapView::Initialize, COMDAT

; 58   : {

$LN83:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	mov	rbp, rsp
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR ?Window@@3PEAUGLFWwindow@@EA ; Window
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_07NBLJNJCC@MapView@

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	ebx, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 59   : 	Window = pWindow;

	mov	QWORD PTR ?Window@UIMapView@@3PEAUGLFWwindow@@EA, rax ; UIMapView::Window
	xorps	xmm0, xmm0

; 60   : 	CameraView.pWindow = pWindow;

	mov	QWORD PTR ?CameraView@UIMapView@@3VCamera@@A+256, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rcx, QWORD PTR $T6[rbp-64]

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T6[rbp-48], rbx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rbp-64], xmm0

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+7]

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T6[rbp-40], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 62   : 	MapViewFramebuffer = FramebufferMgr::CreateFramebuffer(1280, 720, "MapView");

	lea	r8, QWORD PTR $T6[rbp-64]
	mov	edx, 720				; 000002d0H
	mov	ecx, 1280				; 00000500H
	call	?CreateFramebuffer@FramebufferMgr@@YAPEAVFramebuffer@@HHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FramebufferMgr::CreateFramebuffer
	xorps	xmm0, xmm0
	mov	QWORD PTR ?MapViewFramebuffer@UIMapView@@3PEAVFramebuffer@@EA, rax ; UIMapView::MapViewFramebuffer
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+7]

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T5[rbp-48], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_07MCAEODGB@Default@

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T5[rbp-40], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rcx, QWORD PTR $T5[rbp-64]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rbp-64], xmm0

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 64   : 	DefaultShader = ShaderMgr::GetShader("Default");

	lea	rcx, QWORD PTR $T5[rbp-64]
	call	?GetShader@ShaderMgr@@YAPEAVShader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ShaderMgr::GetShader
	xorps	xmm0, xmm0
	mov	QWORD PTR ?DefaultShader@UIMapView@@3PEAVShader@@EA, rax ; UIMapView::DefaultShader
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+8]

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T4[rbp-48], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_08KLEPBNHL@Selected@

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rbp-40], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rcx, QWORD PTR $T4[rbp-64]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rbp-64], xmm0

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 65   : 	SelectedShader = ShaderMgr::GetShader("Selected");

	lea	rcx, QWORD PTR $T4[rbp-64]
	call	?GetShader@ShaderMgr@@YAPEAVShader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ShaderMgr::GetShader
	xorps	xmm0, xmm0
	mov	QWORD PTR ?SelectedShader@UIMapView@@3PEAVShader@@EA, rax ; UIMapView::SelectedShader
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+7]

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T3[rbp-48], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_07JPIMECAN@Picking@

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rbp-40], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rcx, QWORD PTR $T3[rbp-64]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rbp-64], xmm0

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 66   : 	PickingShader = ShaderMgr::GetShader("Picking");

	lea	rcx, QWORD PTR $T3[rbp-64]
	call	?GetShader@ShaderMgr@@YAPEAVShader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ShaderMgr::GetShader
	xorps	xmm0, xmm0
	mov	QWORD PTR ?PickingShader@UIMapView@@3PEAVShader@@EA, rax ; UIMapView::PickingShader
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+9]

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rbp-48], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_09FDDHGJMI@Instanced@

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rbp-40], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rcx, QWORD PTR $T2[rbp-64]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rbp-64], xmm0

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 67   : 	InstancedShader = ShaderMgr::GetShader("Instanced");

	lea	rcx, QWORD PTR $T2[rbp-64]
	call	?GetShader@ShaderMgr@@YAPEAVShader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ShaderMgr::GetShader
	xorps	xmm0, xmm0
	mov	QWORD PTR ?InstancedShader@UIMapView@@3PEAVShader@@EA, rax ; UIMapView::InstancedShader
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+4]

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T1[rbp-48], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_04IBBNLEM@Game@

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rbp-40], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rcx, QWORD PTR $T1[rbp-64]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rbp-64], xmm0

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 68   : 	GameShader = ShaderMgr::GetShader("Game");

	lea	rcx, QWORD PTR $T1[rbp-64]
	call	?GetShader@ShaderMgr@@YAPEAVShader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ShaderMgr::GetShader

; 69   : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rbp
	ret	0
?Initialize@UIMapView@@YAXPEAUGLFWwindow@@@Z ENDP	; UIMapView::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Framebuffer.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Framebuffer.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
;	COMDAT ?DrawMapViewWindow@UIMapView@@YAXXZ
_TEXT	SEGMENT
tv4012 = 64
type$8 = 64
$T9 = 64
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 96
$T14 = 96
$T15 = 96
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 128
mat$20 = 1008
GLMModel$21 = 1008
OldActor$22 = 1072
__$ArrayPad$ = 1952
?DrawMapViewWindow@UIMapView@@YAXXZ PROC		; UIMapView::DrawMapViewWindow, COMDAT

; 317  : {

$LN643:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-1832]
	sub	rsp, 2048				; 00000800H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 318  : 	if (!Open) return;

	cmp	BYTE PTR ?Open@UIMapView@@3_NA, 0	; UIMapView::Open
	je	$LN1@DrawMapVie

; 319  : 
; 320  : 	Focused = ImGui::Begin("Map View", &Open);

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:?Open@UIMapView@@3_NA	; UIMapView::Open
	lea	rcx, OFFSET FLAT:??_C@_08BOLBBOCB@Map?5View@
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin
	mov	BYTE PTR ?Focused@UIMapView@@3_NA, al	; UIMapView::Focused

; 322  : 	RenderSettings.AllowSelectingActor = RenderSettings.AllowSelectingActor && !ImGui::GetIO().WantTextInput;

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+5, 0
	je	SHORT $LN44@DrawMapVie
	cmp	BYTE PTR [rdx+218], 0
	jne	SHORT $LN44@DrawMapVie
	mov	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+5, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1031 :       gContext.mbEnable = enable;

	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1085, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 322  : 	RenderSettings.AllowSelectingActor = RenderSettings.AllowSelectingActor && !ImGui::GetIO().WantTextInput;

	jmp	SHORT $LN477@DrawMapVie
$LN44@DrawMapVie:
	mov	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+5, 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 1034 :          gContext.mbUsing = false;

	mov	WORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0

; 1035 :          gContext.mbUsingBounds = false;

	mov	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, 0
$LN477@DrawMapVie:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rdx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rdx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 959  :       gContext.mDrawList = drawlist ? drawlist : ImGui::GetWindowDrawList();

	mov	rcx, QWORD PTR [rax+728]
	mov	QWORD PTR ?gContext@ImGuizmo@@3UContext@1@A, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10452:     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rcx, QWORD PTR [rdx+16408]

; 10446:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	mov	r8, QWORD PTR [rcx+480]
	test	r8, r8
	jne	SHORT $LN579@DrawMapVie
	cmp	QWORD PTR [rdx+19728], r8
	jne	SHORT $LN579@DrawMapVie
	movss	xmm0, DWORD PTR [rcx+648]
	subss	xmm0, DWORD PTR [rcx+312]
	movaps	xmm7, xmm0
	mov	edx, 652				; 0000028cH
	jmp	SHORT $LN453@DrawMapVie
$LN579@DrawMapVie:
	movss	xmm0, DWORD PTR [rcx+600]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm0, DWORD PTR [rcx+312]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm7, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10446:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	test	r8, r8
	jne	SHORT $LN452@DrawMapVie
	cmp	QWORD PTR [rdx+19728], r8
	jne	SHORT $LN452@DrawMapVie
	mov	edx, 652				; 0000028cH
	jmp	SHORT $LN453@DrawMapVie
$LN452@DrawMapVie:
	mov	edx, 604				; 0000025cH
$LN453@DrawMapVie:
	movss	xmm8, DWORD PTR [rcx+rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm8, DWORD PTR [rcx+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 330  : 	CameraView.Width = WindowWidth;

	cvttss2si ebx, xmm0
	mov	DWORD PTR ?CameraView@UIMapView@@3VCamera@@A+236, ebx

; 331  : 	CameraView.Height = WindowHeight;

	cvttss2si edi, xmm8
	mov	DWORD PTR ?CameraView@UIMapView@@3VCamera@@A+240, edi

; 332  : 
; 333  : 	MapViewFramebuffer->RescaleFramebuffer(WindowWidth, WindowHeight);

	movaps	xmm2, xmm8
	movaps	xmm1, xmm7
	mov	rcx, QWORD PTR ?MapViewFramebuffer@UIMapView@@3PEAVFramebuffer@@EA ; UIMapView::MapViewFramebuffer
	call	?RescaleFramebuffer@Framebuffer@@QEAAXMM@Z ; Framebuffer::RescaleFramebuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10239:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]

; 10240:     return window->DC.CursorPos;

	movss	xmm9, DWORD PTR [rcx+312]
	movss	xmm10, DWORD PTR [rcx+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 336  : 	CameraView.WindowHovered = (ImGui::IsWindowHovered() && !ImGui::IsItemHovered());

	call	?IsWindowHovered@ImGui@@YA_NH@Z		; ImGui::IsWindowHovered
	test	al, al
	je	SHORT $LN46@DrawMapVie
	xor	ecx, ecx
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	test	al, al
	mov	BYTE PTR ?CameraView@UIMapView@@3VCamera@@A+245, 1
	je	SHORT $LN47@DrawMapVie
$LN46@DrawMapVie:
	mov	BYTE PTR ?CameraView@UIMapView@@3VCamera@@A+245, 0
$LN47@DrawMapVie:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Framebuffer.cpp

; 50   : 	glBindFramebuffer(GL_FRAMEBUFFER, m_FBO);

	mov	rdx, QWORD PTR ?MapViewFramebuffer@UIMapView@@3PEAVFramebuffer@@EA ; UIMapView::MapViewFramebuffer
	mov	edx, DWORD PTR [rdx]
	mov	ecx, 36160				; 00008d40H
	call	QWORD PTR glad_glBindFramebuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 339  : 	glViewport(0, 0, WindowWidth, WindowHeight);

	mov	r9d, edi
	mov	r8d, ebx
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR glad_glViewport
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp

; 75   : 	glUseProgram(ID);

	mov	rcx, QWORD PTR ?DefaultShader@UIMapView@@3PEAVShader@@EA ; UIMapView::DefaultShader
	mov	ecx, DWORD PTR [rcx]
	call	QWORD PTR glad_glUseProgram
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 341  : 	glClearColor(ClearColor.x * ClearColor.w, ClearColor.y * ClearColor.w, ClearColor.z * ClearColor.w, ClearColor.w);

	movss	xmm2, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A+8
	movss	xmm3, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A+12
	mulss	xmm2, xmm3
	movss	xmm1, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A+4
	mulss	xmm1, xmm3
	movss	xmm0, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A
	mulss	xmm0, xmm3
	call	QWORD PTR glad_glClearColor

; 342  : 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

	mov	ecx, 17664				; 00004500H
	call	QWORD PTR glad_glClear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7964 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 344  : 	CameraView.Inputs(ImGui::GetIO().Framerate, ImGui::GetWindowPos());

	movss	xmm0, DWORD PTR [rax+84]
	movss	xmm2, DWORD PTR [rax+80]
	unpcklps xmm2, xmm0
	movq	r8, xmm2
	movss	xmm1, DWORD PTR [rcx+224]
	lea	rcx, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A ; UIMapView::CameraView
	call	?Inputs@Camera@@QEAAXMUImVec2@@@Z	; Camera::Inputs

; 345  : 	CameraView.UpdateMatrix(45.0f, 0.1f, 30000.0f);

	movss	xmm3, DWORD PTR __real@46ea6000
	movss	xmm2, DWORD PTR __real@3dcccccd
	movss	xmm1, DWORD PTR __real@42340000
	lea	rcx, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A ; UIMapView::CameraView
	call	?UpdateMatrix@Camera@@QEAAXMMM@Z	; Camera::UpdateMatrix

; 346  : 	CameraView.Matrix(DefaultShader, "camMatrix");

	mov	rcx, QWORD PTR ?DefaultShader@UIMapView@@3PEAVShader@@EA ; UIMapView::DefaultShader
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 33   : 	glUniformMatrix4fv(glGetUniformLocation(shader->ID, uniform), 1, GL_FALSE, glm::value_ptr(CameraMatrix));

	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_09KNKDONHI@camMatrix@
	mov	ecx, DWORD PTR [rcx]
	call	rax
	lea	r9, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A+164
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp

; 75   : 	glUseProgram(ID);

	mov	rcx, QWORD PTR ?PickingShader@UIMapView@@3PEAVShader@@EA ; UIMapView::PickingShader
	mov	ecx, DWORD PTR [rcx]
	call	QWORD PTR glad_glUseProgram
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 348  : 	CameraView.Matrix(PickingShader, "camMatrix");

	mov	rcx, QWORD PTR ?PickingShader@UIMapView@@3PEAVShader@@EA ; UIMapView::PickingShader
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 33   : 	glUniformMatrix4fv(glGetUniformLocation(shader->ID, uniform), 1, GL_FALSE, glm::value_ptr(CameraMatrix));

	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_09KNKDONHI@camMatrix@
	mov	ecx, DWORD PTR [rcx]
	call	rax
	lea	r9, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A+164
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 350  : 	Frustum::CalculateFrustum(&CameraView);

	lea	rcx, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A ; UIMapView::CameraView
	call	?CalculateFrustum@Frustum@@YAXPEAVCamera@@@Z ; Frustum::CalculateFrustum
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10459:     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm0, DWORD PTR [rcx+644]
	subss	xmm0, DWORD PTR [rcx+84]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9009 :     return g.IO.MousePos;

	movss	xmm3, DWORD PTR [rax+3592]
	movss	xmm4, DWORD PTR [rax+3596]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 352  : 	SelectActorByClicking(ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y), ImVec2(ImGui::GetMousePos().x - ImGui::GetWindowPos().x - ImGui::GetWindowContentRegionMin().x,

	subss	xmm4, DWORD PTR [rcx+84]
	subss	xmm4, xmm0
	subss	xmm3, DWORD PTR [rcx+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm0, DWORD PTR [rcx+640]
	subss	xmm0, DWORD PTR [rcx+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 352  : 	SelectActorByClicking(ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y), ImVec2(ImGui::GetMousePos().x - ImGui::GetWindowPos().x - ImGui::GetWindowContentRegionMin().x,

	subss	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10446:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	mov	r8, QWORD PTR [rcx+480]
	test	r8, r8
	jne	SHORT $LN580@DrawMapVie
	cmp	QWORD PTR [rax+19728], r8
	jne	SHORT $LN580@DrawMapVie
	movss	xmm2, DWORD PTR [rcx+652]
	subss	xmm2, DWORD PTR [rcx+316]
	mov	eax, 648				; 00000288H
	jmp	SHORT $LN397@DrawMapVie
$LN580@DrawMapVie:
	movss	xmm2, DWORD PTR [rcx+604]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, DWORD PTR [rcx+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10446:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	test	r8, r8
	jne	SHORT $LN396@DrawMapVie
	cmp	QWORD PTR [rax+19728], r8
	jne	SHORT $LN396@DrawMapVie
	mov	eax, 648				; 00000288H
	jmp	SHORT $LN397@DrawMapVie
$LN396@DrawMapVie:
	mov	eax, 600				; 00000258H
$LN397@DrawMapVie:
	movss	xmm1, DWORD PTR [rcx+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm1, DWORD PTR [rcx+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 352  : 	SelectActorByClicking(ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y), ImVec2(ImGui::GetMousePos().x - ImGui::GetWindowPos().x - ImGui::GetWindowContentRegionMin().x,

	movaps	xmm0, xmm3
	unpcklps xmm0, xmm4
	movq	rdx, xmm0
	unpcklps xmm1, xmm2
	movq	rcx, xmm1
	call	?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z ; UIMapView::SelectActorByClicking

; 353  : 		ImGui::GetMousePos().y - ImGui::GetWindowPos().y - ImGui::GetWindowContentRegionMin().y));
; 354  : 
; 355  : 	glClearColor(ClearColor.x * ClearColor.w, ClearColor.y * ClearColor.w, ClearColor.z * ClearColor.w, ClearColor.w);

	movss	xmm2, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A+8
	movss	xmm3, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A+12
	mulss	xmm2, xmm3
	movss	xmm1, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A+4
	mulss	xmm1, xmm3
	movss	xmm0, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A
	mulss	xmm0, xmm3
	call	QWORD PTR glad_glClearColor

; 356  : 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

	mov	ecx, 17664				; 00004500H
	call	QWORD PTR glad_glClear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp

; 75   : 	glUseProgram(ID);

	mov	rcx, QWORD PTR ?InstancedShader@UIMapView@@3PEAVShader@@EA ; UIMapView::InstancedShader
	mov	ecx, DWORD PTR [rcx]
	call	QWORD PTR glad_glUseProgram
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 359  : 	CameraView.Matrix(InstancedShader, "camMatrix");

	mov	rcx, QWORD PTR ?InstancedShader@UIMapView@@3PEAVShader@@EA ; UIMapView::InstancedShader
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 33   : 	glUniformMatrix4fv(glGetUniformLocation(shader->ID, uniform), 1, GL_FALSE, glm::value_ptr(CameraMatrix));

	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_09KNKDONHI@camMatrix@
	mov	ecx, DWORD PTR [rcx]
	call	rax
	lea	r9, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A+164
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR ?OpaqueActors@ActorMgr@@3V?$unordered_map@PEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@U?$hash@PEAVBfresFile@@@3@U?$equal_to@PEAVBfresFile@@@3@V?$allocator@U?$pair@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@std@@@3@@std@@A+8
	mov	QWORD PTR tv4012[rsp], rax

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rbx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 361  : 	for (auto& [Model, ActorPtrs] : ActorMgr::OpaqueActors)

	xor	edi, edi
	lea	r14, OFFSET FLAT:??_C@_04GJPNONHK@_Far@
	lea	r10, OFFSET FLAT:??_C@_04MCJDHKLE@Npc_@
	cmp	rbx, rax
	je	$LN3@DrawMapVie
	mov	rcx, rax
	npad	5
$LL295@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rbx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 363  : 		if (ActorPtrs[0]->IsUMii) continue;

	mov	rsi, QWORD PTR [rax]
	cmp	BYTE PTR [rsi+688], dil
	jne	$LN2@DrawMapVie

; 364  : 		if (!Model->IsDefaultModel() && !RenderSettings.RenderVisibleActors) continue;

	mov	r13, QWORD PTR [rbx+16]
	movzx	r15d, BYTE PTR [r13+72]
	test	r15b, r15b
	jne	SHORT $LN578@DrawMapVie
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A, dil

; 365  : 		if (Model->IsDefaultModel() && !RenderSettings.RenderInvisibleActors) continue;

	jmp	SHORT $LN640@DrawMapVie
$LN578@DrawMapVie:
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+1, dil
$LN640@DrawMapVie:

; 366  : 		if (ActorPtrs[0]->Gyml.ends_with("_Far") && !RenderSettings.RenderFarActors) continue;

	je	$LN2@DrawMapVie
	add	rsi, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r9, QWORD PTR [rsi+24]

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN581@DrawMapVie

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rsi]
$LN581@DrawMapVie:

; 4689 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);

	mov	r8, QWORD PTR [rsi+16]

; 1435 :         const auto _Rightsize = _Right._Mysize;

	cmp	r8, 4

; 1436 :         if (_Mysize < _Rightsize) {

	jb	SHORT $LN21@DrawMapVie

; 1437 :             return false;
; 1438 :         }
; 1439 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;

	lea	rdx, QWORD PTR [rax+r8]

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rcx, rdi
	npad	3
$LL627@DrawMapVie:
	movzx	eax, BYTE PTR [rdx+rcx-4]
	inc	rcx
	cmp	al, BYTE PTR [r14+rcx-1]
	jne	SHORT $LN628@DrawMapVie
	cmp	rcx, 4
	jne	SHORT $LL627@DrawMapVie
	mov	eax, edi
	jmp	SHORT $LN629@DrawMapVie
$LN628@DrawMapVie:
	sbb	eax, eax
	or	eax, 1
$LN629@DrawMapVie:

; 1439 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 366  : 		if (ActorPtrs[0]->Gyml.ends_with("_Far") && !RenderSettings.RenderFarActors) continue;

	jne	SHORT $LN21@DrawMapVie
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+3, dil
	je	$LN639@DrawMapVie
$LN21@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN582@DrawMapVie

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rsi]
$LN582@DrawMapVie:

; 1419 :         const auto _Rightsize = _Right._Mysize;

	cmp	r8, 4

; 1420 :         if (_Mysize < _Rightsize) {

	jb	SHORT $LN22@DrawMapVie

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rcx, rdi
	npad	12
$LL623@DrawMapVie:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	cmp	al, BYTE PTR [r10+rcx-1]
	jne	SHORT $LN624@DrawMapVie
	cmp	rcx, 4
	jne	SHORT $LL623@DrawMapVie
	mov	eax, edi
	jmp	SHORT $LN625@DrawMapVie
$LN624@DrawMapVie:
	sbb	eax, eax
	or	eax, 1
$LN625@DrawMapVie:

; 1423 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 367  : 		if (ActorPtrs[0]->Gyml.starts_with("Npc_") && !RenderSettings.RenderNPCs) continue;

	jne	SHORT $LN22@DrawMapVie
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+4, dil
	je	$LN639@DrawMapVie
$LN22@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN502@DrawMapVie

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rsi]
$LN502@DrawMapVie:

; 577  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	cmp	r8, 4
	jb	$LN23@DrawMapVie

; 578  :         // xpos cannot exist, report failure
; 579  :         // N4950 [string.view.find]/3 says:
; 580  :         // 1. _Start_at <= xpos
; 581  :         // 2. xpos + _Needle_size <= _Hay_size;
; 582  :         // therefore:
; 583  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 584  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 585  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 586  :         return static_cast<size_t>(-1);
; 587  :     }
; 588  : 
; 589  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 590  :         return _Start_at;
; 591  :     }
; 592  : 
; 593  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	lea	r14, QWORD PTR [r8+rsi]

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [r14-3]
	sub	r8, rsi

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, 65					; 00000041H
	mov	rcx, rsi
	call	memchr

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	je	SHORT $LN23@DrawMapVie
	npad	2
$LL509@DrawMapVie:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rdx, rdi
	lea	r8, OFFSET FLAT:??_C@_04KPICECCB@Area@
	npad	6
$LL619@DrawMapVie:
	movzx	ecx, BYTE PTR [rax+rdx]
	inc	rdx
	cmp	cl, BYTE PTR [r8+rdx-1]
	jne	SHORT $LN620@DrawMapVie
	cmp	rdx, 4
	jne	SHORT $LL619@DrawMapVie
	mov	ecx, edi
	jmp	SHORT $LN621@DrawMapVie
$LN620@DrawMapVie:
	sbb	ecx, ecx
	or	ecx, 1
$LN621@DrawMapVie:

; 600  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	test	ecx, ecx
	je	SHORT $LN530@DrawMapVie

; 594  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	inc	rax

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [r14-3]
	sub	r8, rax

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, 65					; 00000041H
	mov	rcx, rax
	call	memchr

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	jne	SHORT $LL509@DrawMapVie

; 597  :             return static_cast<size_t>(-1);

	jmp	SHORT $LN23@DrawMapVie
$LN530@DrawMapVie:

; 601  :             return static_cast<size_t>(_Match_try - _Haystack);

	sub	rax, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 368  : 		if (ActorPtrs[0]->Gyml.find("Area") != std::string::npos && Model->IsDefaultModel() && !RenderSettings.RenderAreas) continue;

	cmp	rax, -1
	je	SHORT $LN23@DrawMapVie
	test	r15b, r15b
	je	SHORT $LN23@DrawMapVie
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+2, dil
	je	SHORT $LN637@DrawMapVie
$LN23@DrawMapVie:

; 369  : 
; 370  : 		DrawInstancedActor(Model, ActorPtrs);

	lea	rdx, QWORD PTR [rbx+24]
	mov	rcx, r13
	call	?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z ; UIMapView::DrawInstancedActor
$LN637@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 51   :         _Ptr = _Ptr->_Next;

	lea	r10, OFFSET FLAT:??_C@_04MCJDHKLE@Npc_@
$LN639@DrawMapVie:
	mov	rcx, QWORD PTR tv4012[rsp]
$LN2@DrawMapVie:
	mov	rax, QWORD PTR [rbx]
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 361  : 	for (auto& [Model, ActorPtrs] : ActorMgr::OpaqueActors)

	cmp	rax, rcx
	lea	r14, OFFSET FLAT:??_C@_04GJPNONHK@_Far@
	jne	$LL295@DrawMapVie
	lea	r14, OFFSET FLAT:??_C@_04GJPNONHK@_Far@
$LN3@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	r13, QWORD PTR ?TransparentActors@ActorMgr@@3V?$unordered_map@PEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@U?$hash@PEAVBfresFile@@@3@U?$equal_to@PEAVBfresFile@@@3@V?$allocator@U?$pair@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@std@@@3@@std@@A+8

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rbx, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 373  : 	for (auto& [Model, ActorPtrs] : ActorMgr::TransparentActors)

	cmp	rbx, r13
	je	$LN6@DrawMapVie
	lea	r15, OFFSET FLAT:??_C@_04MCJDHKLE@Npc_@
	npad	10
$LL170@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rbx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 375  : 		if (ActorPtrs[0]->IsUMii) continue;

	mov	rdx, QWORD PTR [rax]
	cmp	BYTE PTR [rdx+688], dil
	jne	$LN5@DrawMapVie

; 376  : 		if (Model->IsDefaultModel()) continue;

	mov	r11, QWORD PTR [rbx+16]
	cmp	BYTE PTR [r11+72], dil
	jne	$LN5@DrawMapVie

; 377  : 		if (!Model->IsDefaultModel() && !RenderSettings.RenderVisibleActors) continue;

	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A, dil
	je	$LN5@DrawMapVie

; 378  : 		if (ActorPtrs[0]->Gyml.starts_with("Npc_") && !RenderSettings.RenderNPCs) continue;

	add	rdx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r10, QWORD PTR [rdx+24]

; 2236 :         if (_Large_string_engaged()) {

	cmp	r10, 16
	jb	SHORT $LN583@DrawMapVie

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN583@DrawMapVie:

; 4677 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);

	mov	r9, QWORD PTR [rdx+16]

; 1419 :         const auto _Rightsize = _Right._Mysize;

	cmp	r9, 4

; 1420 :         if (_Mysize < _Rightsize) {

	jb	SHORT $LN27@DrawMapVie

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rcx, rdi
$LL615@DrawMapVie:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	cmp	al, BYTE PTR [r15+rcx-1]
	jne	SHORT $LN616@DrawMapVie
	cmp	rcx, 4
	jne	SHORT $LL615@DrawMapVie
	mov	eax, edi
	jmp	SHORT $LN617@DrawMapVie
$LN616@DrawMapVie:
	sbb	eax, eax
	or	eax, 1
$LN617@DrawMapVie:

; 1423 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 378  : 		if (ActorPtrs[0]->Gyml.starts_with("Npc_") && !RenderSettings.RenderNPCs) continue;

	jne	SHORT $LN27@DrawMapVie
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+4, dil
	je	SHORT $LN5@DrawMapVie
$LN27@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	cmp	r10, 16
	jb	SHORT $LN323@DrawMapVie

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN323@DrawMapVie:

; 1435 :         const auto _Rightsize = _Right._Mysize;

	cmp	r9, 4

; 1436 :         if (_Mysize < _Rightsize) {

	jb	SHORT $LN565@DrawMapVie

; 1437 :             return false;
; 1438 :         }
; 1439 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;

	lea	r8, QWORD PTR [r9+rdx]

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rcx, rdi
	npad	15
$LL611@DrawMapVie:
	movzx	eax, BYTE PTR [r8+rcx-4]
	inc	rcx
	cmp	al, BYTE PTR [r14+rcx-1]
	jne	SHORT $LN612@DrawMapVie
	cmp	rcx, 4
	jne	SHORT $LL611@DrawMapVie
	mov	eax, edi
	jmp	SHORT $LN613@DrawMapVie
$LN612@DrawMapVie:
	sbb	eax, eax
	or	eax, 1
$LN613@DrawMapVie:

; 1439 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 379  : 		if (ActorPtrs[0]->Gyml.ends_with("_Far") && !RenderSettings.RenderFarActors) continue;

	jne	SHORT $LN565@DrawMapVie
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+3, dil
	je	SHORT $LN5@DrawMapVie
$LN565@DrawMapVie:

; 380  : 
; 381  : 		DrawInstancedActor(Model, ActorPtrs);

	lea	rdx, QWORD PTR [rbx+24]
	mov	rcx, r11
	call	?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z ; UIMapView::DrawInstancedActor
$LN5@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 51   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rbx]
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 373  : 	for (auto& [Model, ActorPtrs] : ActorMgr::TransparentActors)

	cmp	rax, r13
	jne	$LL170@DrawMapVie
	mov	r13, QWORD PTR ?TransparentActors@ActorMgr@@3V?$unordered_map@PEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@U?$hash@PEAVBfresFile@@@3@U?$equal_to@PEAVBfresFile@@@3@V?$allocator@U?$pair@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@std@@@3@@std@@A+8
$LN6@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rbx, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 384  : 	for (auto& [Model, ActorPtrs] : ActorMgr::TransparentActors)

	cmp	rbx, r13
	je	$LN9@DrawMapVie
	npad	5
$LL160@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rbx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 386  : 		if (ActorPtrs[0]->IsUMii) continue;

	mov	rsi, QWORD PTR [rax]
	cmp	BYTE PTR [rsi+688], dil
	jne	$LN8@DrawMapVie

; 387  : 		if (!Model->IsDefaultModel()) continue;

	mov	r15, QWORD PTR [rbx+16]
	cmp	BYTE PTR [r15+72], dil
	je	$LN8@DrawMapVie

; 388  : 		if (Model->IsDefaultModel() && !RenderSettings.RenderInvisibleActors) continue;

	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+1, dil
	je	$LN8@DrawMapVie

; 389  : 		if (ActorPtrs[0]->Gyml.ends_with("_Far") && !RenderSettings.RenderFarActors) continue;

	add	rsi, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r9, QWORD PTR [rsi+24]

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN584@DrawMapVie

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rsi]
$LN584@DrawMapVie:

; 4689 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);

	mov	r8, QWORD PTR [rsi+16]

; 1435 :         const auto _Rightsize = _Right._Mysize;

	cmp	r8, 4

; 1436 :         if (_Mysize < _Rightsize) {

	jb	SHORT $LN32@DrawMapVie

; 1437 :             return false;
; 1438 :         }
; 1439 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;

	lea	rdx, QWORD PTR [r8+rax]

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rcx, rdi
	npad	12
$LL607@DrawMapVie:
	movzx	eax, BYTE PTR [rdx+rcx-4]
	inc	rcx
	cmp	al, BYTE PTR [r14+rcx-1]
	jne	SHORT $LN608@DrawMapVie
	cmp	rcx, 4
	jne	SHORT $LL607@DrawMapVie
	mov	eax, edi
	jmp	SHORT $LN609@DrawMapVie
$LN608@DrawMapVie:
	sbb	eax, eax
	or	eax, 1
$LN609@DrawMapVie:

; 1439 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 389  : 		if (ActorPtrs[0]->Gyml.ends_with("_Far") && !RenderSettings.RenderFarActors) continue;

	jne	SHORT $LN32@DrawMapVie
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+3, dil
	je	$LN8@DrawMapVie
$LN32@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN585@DrawMapVie

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rsi]
$LN585@DrawMapVie:

; 1419 :         const auto _Rightsize = _Right._Mysize;

	cmp	r8, 4

; 1420 :         if (_Mysize < _Rightsize) {

	jb	SHORT $LN33@DrawMapVie

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rcx, rdi
	lea	r10, OFFSET FLAT:??_C@_04MCJDHKLE@Npc_@
	npad	5
$LL603@DrawMapVie:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	cmp	al, BYTE PTR [r10+rcx-1]
	jne	SHORT $LN604@DrawMapVie
	cmp	rcx, 4
	jne	SHORT $LL603@DrawMapVie
	mov	eax, edi
	jmp	SHORT $LN605@DrawMapVie
$LN604@DrawMapVie:
	sbb	eax, eax
	or	eax, 1
$LN605@DrawMapVie:

; 1423 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 390  : 		if (ActorPtrs[0]->Gyml.starts_with("Npc_") && !RenderSettings.RenderNPCs) continue;

	jne	SHORT $LN33@DrawMapVie
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+4, dil
	je	$LN8@DrawMapVie
$LN33@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN244@DrawMapVie

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rsi]
$LN244@DrawMapVie:

; 577  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	cmp	r8, 4
	jb	$LN34@DrawMapVie

; 578  :         // xpos cannot exist, report failure
; 579  :         // N4950 [string.view.find]/3 says:
; 580  :         // 1. _Start_at <= xpos
; 581  :         // 2. xpos + _Needle_size <= _Hay_size;
; 582  :         // therefore:
; 583  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 584  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 585  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 586  :         return static_cast<size_t>(-1);
; 587  :     }
; 588  : 
; 589  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 590  :         return _Start_at;
; 591  :     }
; 592  : 
; 593  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	lea	r14, QWORD PTR [r8+rsi]

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [r14-3]
	sub	r8, rsi

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, 65					; 00000041H
	mov	rcx, rsi
	call	memchr

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	je	SHORT $LN34@DrawMapVie
	npad	2
$LL251@DrawMapVie:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rdx, rdi
	lea	r8, OFFSET FLAT:??_C@_04KPICECCB@Area@
	npad	6
$LL599@DrawMapVie:
	movzx	ecx, BYTE PTR [rax+rdx]
	inc	rdx
	cmp	cl, BYTE PTR [r8+rdx-1]
	jne	SHORT $LN600@DrawMapVie
	cmp	rdx, 4
	jne	SHORT $LL599@DrawMapVie
	mov	ecx, edi
	jmp	SHORT $LN601@DrawMapVie
$LN600@DrawMapVie:
	sbb	ecx, ecx
	or	ecx, 1
$LN601@DrawMapVie:

; 600  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	test	ecx, ecx
	je	SHORT $LN532@DrawMapVie

; 594  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	inc	rax

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [r14-3]
	sub	r8, rax

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, 65					; 00000041H
	mov	rcx, rax
	call	memchr

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	jne	SHORT $LL251@DrawMapVie

; 597  :             return static_cast<size_t>(-1);

	jmp	SHORT $LN34@DrawMapVie
$LN532@DrawMapVie:

; 601  :             return static_cast<size_t>(_Match_try - _Haystack);

	sub	rax, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 391  : 		if (ActorPtrs[0]->Gyml.find("Area") != std::string::npos && Model->IsDefaultModel() && !RenderSettings.RenderAreas) continue;

	cmp	rax, -1
	je	SHORT $LN34@DrawMapVie
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+2, dil
	je	SHORT $LN8@DrawMapVie
$LN34@DrawMapVie:

; 392  : 
; 393  : 		DrawInstancedActor(Model, ActorPtrs);

	lea	rdx, QWORD PTR [rbx+24]
	mov	rcx, r15
	call	?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z ; UIMapView::DrawInstancedActor
$LN8@DrawMapVie:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 51   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rbx]
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 384  : 	for (auto& [Model, ActorPtrs] : ActorMgr::TransparentActors)

	cmp	rax, r13
	lea	r14, OFFSET FLAT:??_C@_04GJPNONHK@_Far@
	jne	$LL160@DrawMapVie
$LN9@DrawMapVie:

; 394  : 	}
; 395  : 
; 396  : 	if (RenderSettings.RenderNPCs)

	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+4, dil
	je	$LN631@DrawMapVie
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp

; 75   : 	glUseProgram(ID);

	mov	rcx, QWORD PTR ?DefaultShader@UIMapView@@3PEAVShader@@EA ; UIMapView::DefaultShader
	mov	ecx, DWORD PTR [rcx]
	call	QWORD PTR glad_glUseProgram
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 399  : 		for (Actor* NPC : ActorMgr::UMiiActors)

	mov	rsi, QWORD PTR ?UMiiActors@ActorMgr@@3V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@A+8
	mov	rbx, QWORD PTR ?UMiiActors@ActorMgr@@3V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@A
	cmp	rbx, rsi
	je	$LN631@DrawMapVie
	npad	10
$LL13@DrawMapVie:
	mov	rdx, QWORD PTR [rbx]

; 400  : 		{
; 401  : 			if (NPC == UIOutliner::SelectedActor) continue;

	cmp	rdx, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	je	SHORT $LN11@DrawMapVie

; 402  : 			NPC->UMiiData.Draw(NPC->Translate, NPC->Rotate, NPC->Scale, DefaultShader);

	lea	rcx, QWORD PTR [rdx+696]
	movsd	xmm0, QWORD PTR [rdx+64]
	movsd	QWORD PTR $T11[rsp], xmm0
	mov	eax, DWORD PTR [rdx+72]
	mov	DWORD PTR $T11[rsp+8], eax
	movsd	xmm0, QWORD PTR [rdx+76]
	movsd	QWORD PTR $T17[rsp], xmm0
	mov	eax, DWORD PTR [rdx+84]
	mov	DWORD PTR $T17[rsp+8], eax
	movsd	xmm0, QWORD PTR [rdx+52]
	movsd	QWORD PTR $T14[rsp], xmm0
	mov	eax, DWORD PTR [rdx+60]
	mov	DWORD PTR $T14[rsp+8], eax
	mov	QWORD PTR [rsp+48], rdi
	mov	BYTE PTR [rsp+40], dil
	mov	rax, QWORD PTR ?DefaultShader@UIMapView@@3PEAVShader@@EA ; UIMapView::DefaultShader
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T11[rsp]
	lea	r8, QWORD PTR $T17[rsp]
	lea	rdx, QWORD PTR $T14[rsp]
	call	?Draw@UMii@@QEAAXVVector3F@@00PEAVShader@@_NPEAVCamera@@@Z ; UMii::Draw
$LN11@DrawMapVie:

; 399  : 		for (Actor* NPC : ActorMgr::UMiiActors)

	add	rbx, 8
	cmp	rbx, rsi
	jne	SHORT $LL13@DrawMapVie
$LN631@DrawMapVie:

; 403  : 		}
; 404  : 	}
; 405  : 
; 406  : 	//Selected actor
; 407  : 	if (UIOutliner::SelectedActor != nullptr)

	cmp	QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA, rdi ; UIOutliner::SelectedActor
	je	$LN39@DrawMapVie
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp

; 75   : 	glUseProgram(ID);

	mov	rcx, QWORD PTR ?SelectedShader@UIMapView@@3PEAVShader@@EA ; UIMapView::SelectedShader
	mov	ecx, DWORD PTR [rcx]
	call	QWORD PTR glad_glUseProgram
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 410  : 		CameraView.Matrix(SelectedShader, "camMatrix");

	mov	rcx, QWORD PTR ?SelectedShader@UIMapView@@3PEAVShader@@EA ; UIMapView::SelectedShader
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 33   : 	glUniformMatrix4fv(glGetUniformLocation(shader->ID, uniform), 1, GL_FALSE, glm::value_ptr(CameraMatrix));

	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_09KNKDONHI@camMatrix@
	mov	ecx, DWORD PTR [rcx]
	call	rax
	lea	r9, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A+164
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 411  : 		if (!UIOutliner::SelectedActor->IsUMii)

	mov	rdx, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	cmp	BYTE PTR [rdx+688], dil
	jne	SHORT $LN38@DrawMapVie

; 412  : 		{
; 413  : 			DrawActor(*UIOutliner::SelectedActor, SelectedShader);

	mov	rcx, rdx
	call	?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z ; UIMapView::DrawActor

; 414  : 
; 415  : 			for (Actor& Child : UIOutliner::SelectedActor->MergedActorContent)

	mov	rax, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	mov	rsi, QWORD PTR [rax+440]

; 412  : 		{
; 413  : 			DrawActor(*UIOutliner::SelectedActor, SelectedShader);

	mov	rbx, QWORD PTR [rax+432]

; 414  : 
; 415  : 			for (Actor& Child : UIOutliner::SelectedActor->MergedActorContent)

	cmp	rbx, rsi
	je	$LN39@DrawMapVie
$LL16@DrawMapVie:

; 416  : 			{
; 417  : 				DrawActor(Child, SelectedShader);

	mov	rcx, rbx
	call	?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z ; UIMapView::DrawActor

; 414  : 
; 415  : 			for (Actor& Child : UIOutliner::SelectedActor->MergedActorContent)

	add	rbx, 872				; 00000368H
	cmp	rbx, rsi
	jne	SHORT $LL16@DrawMapVie

; 418  : 			}
; 419  : 		}

	jmp	SHORT $LN39@DrawMapVie
$LN38@DrawMapVie:

; 420  : 		else
; 421  : 		{
; 422  : 			UIOutliner::SelectedActor->UMiiData.Draw(UIOutliner::SelectedActor->Translate, UIOutliner::SelectedActor->Rotate, UIOutliner::SelectedActor->Scale, SelectedShader);

	lea	rcx, QWORD PTR [rdx+696]
	movsd	xmm0, QWORD PTR [rdx+64]
	movsd	QWORD PTR $T10[rsp], xmm0
	mov	eax, DWORD PTR [rdx+72]
	mov	DWORD PTR $T10[rsp+8], eax
	movsd	xmm0, QWORD PTR [rdx+76]
	movsd	QWORD PTR $T16[rsp], xmm0
	mov	eax, DWORD PTR [rdx+84]
	mov	DWORD PTR $T16[rsp+8], eax
	movsd	xmm0, QWORD PTR [rdx+52]
	movsd	QWORD PTR $T13[rsp], xmm0
	mov	eax, DWORD PTR [rdx+60]
	mov	DWORD PTR $T13[rsp+8], eax
	mov	QWORD PTR [rsp+48], rdi
	mov	BYTE PTR [rsp+40], dil
	mov	rax, QWORD PTR ?SelectedShader@UIMapView@@3PEAVShader@@EA ; UIMapView::SelectedShader
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T10[rsp]
	lea	r8, QWORD PTR $T16[rsp]
	lea	rdx, QWORD PTR $T13[rsp]
	call	?Draw@UMii@@QEAAXVVector3F@@00PEAVShader@@_NPEAVCamera@@@Z ; UMii::Draw
$LN39@DrawMapVie:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp

; 75   : 	glUseProgram(ID);

	mov	rcx, QWORD PTR ?DefaultShader@UIMapView@@3PEAVShader@@EA ; UIMapView::DefaultShader
	mov	ecx, DWORD PTR [rcx]
	call	QWORD PTR glad_glUseProgram
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 427  : 	if (RenderSettings.RenderNavMesh && !SceneMgr::NavMeshModel.GetModels().empty())

	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+6, dil
	je	$LN40@DrawMapVie
	mov	rax, QWORD PTR ?NavMeshModel@SceneMgr@@3VBfresFile@@A+8
	cmp	QWORD PTR ?NavMeshModel@SceneMgr@@3VBfresFile@@A, rax
	je	$LN40@DrawMapVie
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movaps	XMMWORD PTR GLMModel$21[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	XMMWORD PTR GLMModel$21[rbp-240], xmm1
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR GLMModel$21[rbp-224], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR GLMModel$21[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 431  : 		glUniformMatrix4fv(glGetUniformLocation(DefaultShader->ID, "modelMatrix"), 1, GL_FALSE, glm::value_ptr(GLMModel));

	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_0M@DDLHAGJC@modelMatrix@
	mov	rcx, QWORD PTR ?DefaultShader@UIMapView@@3PEAVShader@@EA ; UIMapView::DefaultShader
	mov	ecx, DWORD PTR [rcx]
	call	rax
	lea	r9, QWORD PTR GLMModel$21[rbp-256]
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR ?NavMeshModel@SceneMgr@@3VBfresFile@@A
	mov	rcx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 432  : 		SceneMgr::NavMeshModel.GetModels()[0].LODs[0].GL_Meshes[0].Draw();

	mov	rcx, QWORD PTR [rcx+24]
	call	?Draw@Mesh@@QEAAXPEAVShader@@H@Z	; Mesh::Draw
$LN40@DrawMapVie:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8204 :     return window->DrawList;

	mov	rbx, QWORD PTR [rax+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T9[rsp], 1065353216		; 3f800000H
	xorps	xmm6, xmm6
	mov	DWORD PTR $T15[rsp], edi
	mov	DWORD PTR $T15[rsp+4], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 438  : 	ImGui::GetWindowDrawList()->AddImage(

	movaps	xmm0, xmm10
	addss	xmm0, xmm8
	addss	xmm7, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T18[rsp], xmm7
	movss	DWORD PTR $T18[rsp+4], xmm0
	movss	DWORD PTR $T12[rsp], xmm9
	movss	DWORD PTR $T12[rsp+4], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 438  : 	ImGui::GetWindowDrawList()->AddImage(

	mov	rax, QWORD PTR ?MapViewFramebuffer@UIMapView@@3PEAVFramebuffer@@EA ; UIMapView::MapViewFramebuffer
	mov	esi, DWORD PTR [rax+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1615 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

	mov	r14, QWORD PTR [rbx+152]

; 1616 :     if (push_texture_id)

	cmp	rsi, r14
	je	SHORT $LN72@DrawMapVie

; 1617 :         PushTextureID(user_texture_id);

	mov	edx, esi
	mov	rcx, rbx
	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID
$LN72@DrawMapVie:

; 1618 : 
; 1619 :     PrimReserve(6, 4);

	mov	edx, 6
	lea	r8d, QWORD PTR [rdx-2]
	mov	rcx, rbx
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 1620 :     PrimRectUV(p_min, p_max, uv_min, uv_max, col);

	mov	DWORD PTR [rsp+40], -1			; ffffffffH
	lea	rax, QWORD PTR $T9[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T15[rsp]
	lea	r8, QWORD PTR $T18[rsp]
	lea	rdx, QWORD PTR $T12[rsp]
	mov	rcx, rbx
	call	?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::PrimRectUV

; 1621 : 
; 1622 :     if (push_texture_id)

	cmp	rsi, r14
	je	SHORT $LN73@DrawMapVie
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	movsxd	rcx, DWORD PTR [rbx+104]
	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [rbx+104], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 618  :     _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];

	test	eax, eax
	jne	SHORT $LN77@DrawMapVie
	mov	rax, rdi
	jmp	SHORT $LN78@DrawMapVie
$LN77@DrawMapVie:
	mov	rax, QWORD PTR [rbx+112]
	mov	rax, QWORD PTR [rax+rcx*8-16]
$LN78@DrawMapVie:
	mov	QWORD PTR [rbx+152], rax

; 619  :     _OnChangedTextureID();

	mov	rcx, rbx
	call	?_OnChangedTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::_OnChangedTextureID
$LN73@DrawMapVie:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 446  : 	if(UIOutliner::SelectedActor != nullptr)

	mov	rax, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	test	rax, rax
	je	$LN635@DrawMapVie

; 447  : 	{
; 448  : 		ImGuizmo::RecomposeMatrixFromComponents(UIOutliner::SelectedActor->Translate.GetRawData(), UIOutliner::SelectedActor->Rotate.GetRawData(), UIOutliner::SelectedActor->Scale.GetRawData(), ObjectMatrix);

	lea	r8, QWORD PTR [rax+64]
	lea	rdx, QWORD PTR [rax+76]
	lea	rcx, QWORD PTR [rax+52]
	call	?RecomposeMatrixFromComponents@ImGuizmo@@YAXPEBM00PEAM@Z ; ImGuizmo::RecomposeMatrixFromComponents
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7957 :     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]

; 7958 :     return window->Size.y;

	movss	xmm3, DWORD PTR [rcx+92]

; 7952 :     return window->Size.x;

	movss	xmm4, DWORD PTR [rcx+88]

; 7965 :     return window->Pos;

	movss	xmm1, DWORD PTR [rcx+80]
	movss	xmm2, DWORD PTR [rcx+84]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 943  :       gContext.mX = x;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1404, xmm1

; 944  :       gContext.mY = y;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1408, xmm2

; 945  :       gContext.mWidth = width;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1412, xmm4

; 946  :       gContext.mHeight = height;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1416, xmm3
	movaps	xmm0, xmm4
	addss	xmm0, xmm1

; 947  :       gContext.mXMax = gContext.mX + gContext.mWidth;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1420, xmm0
	addss	xmm0, xmm2

; 948  :       gContext.mYMax = gContext.mY + gContext.mXMax;

	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1424, xmm0

; 949  :       gContext.mDisplayRatio = width / height;

	divss	xmm4, xmm3
	movss	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1428, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 452  : 		ImGuizmo::Manipulate(glm::value_ptr(CameraView.GetViewMatrix()), glm::value_ptr(CameraView.GetProjectionMatrix()), ImGuizmoOperation, ImGuizmoMode, ObjectMatrix);

	mov	r9d, DWORD PTR ?ImGuizmoMode@UIMapView@@3W4MODE@ImGuizmo@@A ; UIMapView::ImGuizmoMode
	mov	ebx, DWORD PTR ?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A ; UIMapView::ImGuizmoOperation
	test	ebx, 896				; 00000380H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2514 :       ComputeContext(view, projection, matrix, (operation & SCALE) ? LOCAL : mode);

	cmovne	r9d, edi
	lea	rdx, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A+100
	lea	rcx, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A+36
	call	?ComputeContext@ImGuizmo@@YAXPEBM0PEAMW4MODE@1@@Z ; ImGuizmo::ComputeContext

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	movss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+740
	mulss	xmm2, xmm6

; 265  :       void TransformPoint(const vec_t& v, const matrix_t& matrix) { (*this) = v; this->TransformPoint(matrix); }

	movss	xmm0, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+756
	mulss	xmm0, xmm6

; 436  :       out.z = x * matrix.m[0][2] + y * matrix.m[1][2] + z * matrix.m[2][2] + matrix.m[3][2];

	addss	xmm2, xmm0
	movss	xmm1, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+772
	mulss	xmm1, xmm6
	addss	xmm2, xmm1
	addss	xmm2, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+788

; 2525 :       if (!gContext.mIsOrthographic && camSpacePosition.z < 0.001f && !gContext.mbUsing)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1432, dil
	jne	SHORT $LN83@DrawMapVie
	movss	xmm0, DWORD PTR __real@3a83126f
	comiss	xmm0, xmm2
	jbe	SHORT $LN83@DrawMapVie
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, dil
	jne	SHORT $LN83@DrawMapVie
	mov	rax, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	jmp	$LN577@DrawMapVie
$LN83@DrawMapVie:

; 2526 :       {
; 2527 :          return false;
; 2528 :       }
; 2529 : 
; 2530 :       // --
; 2531 :       int type = MT_NONE;

	mov	DWORD PTR type$8[rsp], edi

; 2532 :       bool manipulated = false;
; 2533 :       if (gContext.mbEnable)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1085, dil
	je	SHORT $LN633@DrawMapVie

; 2534 :       {
; 2535 :          if (!gContext.mbUsingBounds)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, dil
	jne	SHORT $LN633@DrawMapVie

; 2536 :          {
; 2537 :             manipulated = HandleTranslation(matrix, deltaMatrix, operation, type, snap) ||

	lea	r9, QWORD PTR type$8[rsp]
	mov	r8d, ebx
	call	?HandleTranslation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z ; ImGuizmo::HandleTranslation
	test	al, al
	jne	SHORT $LN632@DrawMapVie
	lea	r9, QWORD PTR type$8[rsp]
	mov	r8d, ebx
	call	?HandleScale@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z ; ImGuizmo::HandleScale
	test	al, al
	jne	SHORT $LN632@DrawMapVie
	lea	r9, QWORD PTR type$8[rsp]
	mov	r8d, ebx
	call	?HandleRotation@ImGuizmo@@YA_NPEAM0W4OPERATION@1@AEAHPEBM@Z ; ImGuizmo::HandleRotation
$LN632@DrawMapVie:

; 2538 :                           HandleScale(matrix, deltaMatrix, operation, type, snap) ||
; 2539 :                           HandleRotation(matrix, deltaMatrix, operation, type, snap);
; 2540 :          }
; 2541 :       }
; 2542 : 
; 2543 :       if (localBounds && !gContext.mbUsing)
; 2544 :       {
; 2545 :          HandleAndDrawLocalBounds(localBounds, (matrix_t*)matrix, boundsSnap, operation);
; 2546 :       }
; 2547 : 
; 2548 :       gContext.mOperation = operation;

	mov	edi, DWORD PTR type$8[rsp]
$LN633@DrawMapVie:
	mov	DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1444, ebx

; 2549 :       if (!gContext.mbUsingBounds)

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, 0
	jne	SHORT $LN634@DrawMapVie

; 2550 :       {
; 2551 :          DrawRotationGizmo(operation, type);

	mov	edx, edi
	mov	ecx, ebx
	call	?DrawRotationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ; ImGuizmo::DrawRotationGizmo

; 2552 :          DrawTranslationGizmo(operation, type);

	mov	edx, edi
	mov	ecx, ebx
	call	?DrawTranslationGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ; ImGuizmo::DrawTranslationGizmo

; 2553 :          DrawScaleGizmo(operation, type);

	mov	edx, edi
	mov	ecx, ebx
	call	?DrawScaleGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ; ImGuizmo::DrawScaleGizmo

; 2554 :          DrawScaleUniveralGizmo(operation, type);

	mov	edx, edi
	mov	ecx, ebx
	call	?DrawScaleUniveralGizmo@ImGuizmo@@YAXW4OPERATION@1@H@Z ; ImGuizmo::DrawScaleUniveralGizmo
$LN634@DrawMapVie:

; 998  :       return gContext.mbUsing || gContext.mbUsingBounds;

	mov	rax, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
$LN635@DrawMapVie:
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	jne	SHORT $LN58@DrawMapVie
$LN577@DrawMapVie:
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, 0
	jne	SHORT $LN58@DrawMapVie
	xor	cl, cl
	jmp	SHORT $LN59@DrawMapVie
$LN58@DrawMapVie:
	mov	cl, 1
$LN59@DrawMapVie:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 455  : 	if (ImGuizmo::IsUsingAny())

	test	cl, cl
	je	$LN42@DrawMapVie

; 456  : 	{
; 457  : 		Actor OldActor = *UIOutliner::SelectedActor;

	mov	rdx, rax
	lea	rcx, QWORD PTR OldActor$22[rbp-256]
	call	??0Actor@@QEAA@AEBU0@@Z
	npad	1

; 458  : 		ImGuizmo::DecomposeMatrixToComponents(ObjectMatrix, UIOutliner::SelectedActor->Translate.GetRawData(), UIOutliner::SelectedActor->Rotate.GetRawData(), UIOutliner::SelectedActor->Scale.GetRawData());

	mov	rbx, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 2444 :       matrix_t mat = *(matrix_t*)matrix;

	movaps	xmm1, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA
	movaps	XMMWORD PTR mat$20[rbp-256], xmm1
	movaps	xmm7, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+16
	movaps	XMMWORD PTR mat$20[rbp-240], xmm7
	movaps	xmm6, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+32
	movaps	XMMWORD PTR mat$20[rbp-224], xmm6
	movaps	xmm0, XMMWORD PTR ?ObjectMatrix@UIMapView@@3PAMA+48
	movaps	XMMWORD PTR mat$20[rbp-208], xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm2, xmm1
	mulss	xmm2, xmm1
	movaps	xmm0, xmm1
	shufps	xmm0, xmm1, 85				; 00000055H
	mulss	xmm0, xmm0
	addss	xmm2, xmm0
	shufps	xmm1, xmm1, 170				; 000000aaH
	mulss	xmm1, xmm1
	addss	xmm2, xmm1
	xorps	xmm0, xmm0
	ucomiss	xmm0, xmm2
	ja	SHORT $LN596@DrawMapVie
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm2
	jmp	SHORT $LN597@DrawMapVie
$LN596@DrawMapVie:
	movaps	xmm0, xmm2
	call	sqrtf
$LN597@DrawMapVie:

; 2446 :       scale[0] = mat.v.right.Length();

	movss	DWORD PTR [rbx+64], xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm7
	mulss	xmm1, xmm7
	movaps	xmm0, xmm7
	shufps	xmm0, xmm7, 85				; 00000055H
	mulss	xmm0, xmm0
	addss	xmm1, xmm0
	shufps	xmm7, xmm7, 170				; 000000aaH
	mulss	xmm7, xmm7
	addss	xmm1, xmm7
	xorps	xmm0, xmm0
	ucomiss	xmm0, xmm1
	ja	SHORT $LN594@DrawMapVie
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN595@DrawMapVie
$LN594@DrawMapVie:
	movaps	xmm0, xmm1
	call	sqrtf
$LN595@DrawMapVie:

; 2447 :       scale[1] = mat.v.up.Length();

	movss	DWORD PTR [rbx+68], xmm0

; 222  :       float Length() const { return sqrtf(x * x + y * y + z * z); };

	movaps	xmm1, xmm6
	mulss	xmm1, xmm6
	movaps	xmm0, xmm6
	shufps	xmm0, xmm6, 85				; 00000055H
	mulss	xmm0, xmm0
	addss	xmm1, xmm0
	shufps	xmm6, xmm6, 170				; 000000aaH
	mulss	xmm6, xmm6
	addss	xmm1, xmm6
	xorps	xmm0, xmm0
	ucomiss	xmm0, xmm1
	ja	SHORT $LN592@DrawMapVie
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	jmp	SHORT $LN593@DrawMapVie
$LN592@DrawMapVie:
	movaps	xmm0, xmm1
	call	sqrtf
$LN593@DrawMapVie:

; 2448 :       scale[2] = mat.v.dir.Length();

	movss	DWORD PTR [rbx+72], xmm0

; 2449 : 
; 2450 :       mat.OrthoNormalize();

	lea	rcx, QWORD PTR mat$20[rbp-256]
	call	?OrthoNormalize@matrix_t@ImGuizmo@@QEAAXXZ ; ImGuizmo::matrix_t::OrthoNormalize

; 2451 : 
; 2452 :       rotation[0] = RAD2DEG * atan2f(mat.m[1][2], mat.m[2][2]);

	movss	xmm7, DWORD PTR mat$20[rbp-216]
	movaps	xmm1, xmm7
	movss	xmm6, DWORD PTR mat$20[rbp-232]
	movaps	xmm0, xmm6
	call	atan2f
	movss	xmm9, DWORD PTR __real@42652ee0
	mulss	xmm0, xmm9
	movss	DWORD PTR [rbx+76], xmm0

; 2453 :       rotation[1] = RAD2DEG * atan2f(-mat.m[0][2], sqrtf(mat.m[1][2] * mat.m[1][2] + mat.m[2][2] * mat.m[2][2]));

	movss	xmm8, DWORD PTR mat$20[rbp-248]
	xorps	xmm8, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm7, xmm7
	mulss	xmm6, xmm6
	addss	xmm7, xmm6
	xorps	xmm0, xmm0
	ucomiss	xmm0, xmm7
	ja	SHORT $LN590@DrawMapVie
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm7
	jmp	SHORT $LN591@DrawMapVie
$LN590@DrawMapVie:
	movaps	xmm0, xmm7
	call	sqrtf
$LN591@DrawMapVie:
	movaps	xmm1, xmm0
	movaps	xmm0, xmm8
	call	atan2f
	mulss	xmm0, xmm9
	movss	DWORD PTR [rbx+80], xmm0

; 2454 :       rotation[2] = RAD2DEG * atan2f(mat.m[0][1], mat.m[0][0]);

	movss	xmm1, DWORD PTR mat$20[rbp-256]
	movss	xmm0, DWORD PTR mat$20[rbp-252]
	call	atan2f
	mulss	xmm0, xmm9
	movss	DWORD PTR [rbx+84], xmm0

; 2455 : 
; 2456 :       translation[0] = mat.v.position.x;

	movss	xmm0, DWORD PTR mat$20[rbp-208]
	movss	DWORD PTR [rbx+52], xmm0

; 2457 :       translation[1] = mat.v.position.y;

	movss	xmm1, DWORD PTR mat$20[rbp-204]
	movss	DWORD PTR [rbx+56], xmm1

; 2458 :       translation[2] = mat.v.position.z;

	movss	xmm0, DWORD PTR mat$20[rbp-200]
	movss	DWORD PTR [rbx+60], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 459  : 		ActorMgr::UpdateMergedActorContent(UIOutliner::SelectedActor, OldActor);

	lea	rdx, QWORD PTR OldActor$22[rbp-256]
	lea	rcx, QWORD PTR $T19[rbp-256]
	call	??0Actor@@QEAA@AEBU0@@Z
	mov	rdx, rax
	mov	rcx, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	call	?UpdateMergedActorContent@ActorMgr@@YAXPEAUActor@@U2@@Z ; ActorMgr::UpdateMergedActorContent
	npad	1

; 460  : 	}

	lea	rcx, QWORD PTR OldActor$22[rbp-256]
	call	??1Actor@@QEAA@XZ
$LN42@DrawMapVie:

; 461  : 
; 462  : 	DrawOverlay();

	call	?DrawOverlay@UIMapView@@YAXXZ		; UIMapView::DrawOverlay
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Framebuffer.cpp

; 55   : 	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	xor	edx, edx
	mov	ecx, 36160				; 00008d40H
	call	QWORD PTR glad_glBindFramebuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 466  : 	ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 467  : 
; 468  : 	RenderSettings.AllowSelectingActor = true;

	mov	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+5, 1
$LN1@DrawMapVie:

; 469  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+2048]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?DrawMapViewWindow@UIMapView@@YAXXZ ENDP		; UIMapView::DrawMapViewWindow
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv4012 = 64
type$8 = 64
$T9 = 64
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 96
$T14 = 96
$T15 = 96
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 128
mat$20 = 1008
GLMModel$21 = 1008
OldActor$22 = 1072
__$ArrayPad$ = 1952
?dtor$0@?0??DrawMapViewWindow@UIMapView@@YAXXZ@4HA PROC	; `UIMapView::DrawMapViewWindow'::`1'::dtor$0
	lea	rcx, QWORD PTR OldActor$22[rdx]
	jmp	??1Actor@@QEAA@XZ
?dtor$0@?0??DrawMapViewWindow@UIMapView@@YAXXZ@4HA ENDP	; `UIMapView::DrawMapViewWindow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
;	COMDAT ?GLFWKeyCallback@UIMapView@@YAXPEAUGLFWwindow@@HHHH@Z
_TEXT	SEGMENT
Window$ = 48
Key$ = 56
Scancode$ = 64
Action$ = 72
Mods$ = 80
?GLFWKeyCallback@UIMapView@@YAXPEAUGLFWwindow@@HHHH@Z PROC ; UIMapView::GLFWKeyCallback, COMDAT

; 43   : {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 44   : 	if (ImGui::GetIO().WantTextInput || CameraView.IsInCameraMovement() || Action != GLFW_PRESS) return;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	edi, r9d
	mov	ebx, edx
	cmp	BYTE PTR [rax+218], 0
	jne	SHORT $LN3@GLFWKeyCal
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 146  : 	if (WindowHovered)

	cmp	BYTE PTR ?CameraView@UIMapView@@3VCamera@@A+245, 0
	je	SHORT $LN9@GLFWKeyCal

; 147  : 	{
; 148  : 		return (glfwGetMouseButton(pWindow, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS && glfwGetMouseButton(pWindow, GLFW_MOUSE_BUTTON_LEFT) != GLFW_PRESS);

	mov	rcx, QWORD PTR ?CameraView@UIMapView@@3VCamera@@A+256
	mov	edx, 1
	call	glfwGetMouseButton
	cmp	eax, 1
	jne	SHORT $LN9@GLFWKeyCal
	mov	rcx, QWORD PTR ?CameraView@UIMapView@@3VCamera@@A+256
	xor	edx, edx
	call	glfwGetMouseButton
	cmp	eax, 1
	jne	SHORT $LN3@GLFWKeyCal
$LN9@GLFWKeyCal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 44   : 	if (ImGui::GetIO().WantTextInput || CameraView.IsInCameraMovement() || Action != GLFW_PRESS) return;

	cmp	edi, 1
	jne	SHORT $LN3@GLFWKeyCal

; 45   : 
; 46   : 	//Rotation hot key
; 47   : 	if (Key == GLFW_KEY_R)

	cmp	ebx, 82					; 00000052H
	jne	SHORT $LN4@GLFWKeyCal

; 48   : 		ImGuizmoOperation = ImGuizmo::ROTATE;

	mov	DWORD PTR ?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A, 120 ; UIMapView::ImGuizmoOperation, 00000078H

; 55   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@GLFWKeyCal:

; 49   : 
; 50   : 	if (Key == GLFW_KEY_S)

	cmp	ebx, 83					; 00000053H
	jne	SHORT $LN5@GLFWKeyCal

; 51   : 		ImGuizmoOperation = ImGuizmo::SCALE;

	mov	DWORD PTR ?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A, 896 ; UIMapView::ImGuizmoOperation, 00000380H

; 55   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@GLFWKeyCal:

; 52   : 
; 53   : 	if (Key == GLFW_KEY_G)

	cmp	ebx, 71					; 00000047H
	jne	SHORT $LN3@GLFWKeyCal

; 54   : 		ImGuizmoOperation = ImGuizmo::TRANSLATE;

	mov	DWORD PTR ?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A, 7 ; UIMapView::ImGuizmoOperation
$LN3@GLFWKeyCal:

; 55   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?GLFWKeyCallback@UIMapView@@YAXPEAUGLFWwindow@@HHHH@Z ENDP ; UIMapView::GLFWKeyCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@Camera@@QEAAX_K@Z
_TEXT	SEGMENT
this$dead$ = 8
classSize$dead$ = 16
?__autoclassinit2@Camera@@QEAAX_K@Z PROC		; Camera::__autoclassinit2, COMDAT
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A ; UIMapView::CameraView
	mov	r8d, 264				; 00000108H
	jmp	memset
?__autoclassinit2@Camera@@QEAAX_K@Z ENDP		; Camera::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
;	COMDAT ?DrawOverlay@UIMapView@@YAXXZ
_TEXT	SEGMENT
backup$1 = 64
backup$2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 64
$T7 = 64
$T8 = 64
backup$9 = 96
backup$10 = 96
$T11 = 96
$T12 = 96
$T13 = 96
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 96
$T18 = 96
$T19 = 128
$T20 = 128
$T21 = 128
$T22 = 128
$T23 = 224
$T24 = 224
$T25 = 224
$T26 = 224
$T27 = 232
$T28 = 232
$T29 = 232
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
?DrawOverlay@UIMapView@@YAXXZ PROC			; UIMapView::DrawOverlay, COMDAT

; 72   : {

$LN496:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [rsp-63]
	sub	rsp, 184				; 000000b8H
	movaps	XMMWORD PTR [rsp+160], xmm7
	xor	esi, esi
	mov	edi, esi
	mov	DWORD PTR $T23[rbp-121], esi

; 73   : 	ImGui::Text("FPS: %.1f (%.3f ms/frame)", ImGui::GetIO().Framerate, 1000.0 / ImGui::GetIO().Framerate);

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+224]
	cvtps2pd xmm1, xmm1
	movsd	xmm2, QWORD PTR __real@408f400000000000
	divsd	xmm2, xmm1
	movq	r8, xmm2
	movq	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_0BK@DFAEGNNF@FPS?3?5?$CF?41f?5?$CI?$CF?43f?5ms?1frame?$CJ@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3133 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3135 :     backup.Col = idx;

	mov	DWORD PTR backup$10[rbp-121], 21

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+15112]
	movups	XMMWORD PTR backup$10[rbp-117], xmm0

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
	lea	rdx, QWORD PTR backup$10[rbp-121]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	mov	QWORD PTR [rbx+15112], rsi
	mov	DWORD PTR [rbx+15120], esi
	mov	DWORD PTR [rbx+15124], 1056964608	; 3f000000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T30[rbp-121], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 76   : 	if (ImGui::Button(std::string("Mode: " + (ImGuizmoMode == ImGuizmo::WORLD ? std::string("World") : std::string("Local"))).c_str()))

	xorps	xmm0, xmm0
	cmp	DWORD PTR ?ImGuizmoMode@UIMapView@@3W4MODE@ImGuizmo@@A, 1 ; UIMapView::ImGuizmoMode
	jne	SHORT $LN9@DrawOverla
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T8[rbp-121], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rbp-105], 5

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-97], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_05MFLOHCHP@World@
	mov	DWORD PTR $T8[rbp-121], eax
	movzx	eax, BYTE PTR ??_C@_05MFLOHCHP@World@+4
	mov	BYTE PTR $T8[rbp-117], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T8[rbp-116], sil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 76   : 	if (ImGui::Button(std::string("Mode: " + (ImGuizmoMode == ImGuizmo::WORLD ? std::string("World") : std::string("Local"))).c_str()))

	lea	rcx, QWORD PTR $T8[rbp-121]
	or	edi, 1
	jmp	SHORT $LN490@DrawOverla
$LN9@DrawOverla:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T18[rbp-121], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T18[rbp-105], 5

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T18[rbp-97], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_05IEALKJIG@Local@
	mov	DWORD PTR $T18[rbp-121], eax
	movzx	eax, BYTE PTR ??_C@_05IEALKJIG@Local@+4
	mov	BYTE PTR $T18[rbp-117], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T18[rbp-116], sil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 76   : 	if (ImGui::Button(std::string("Mode: " + (ImGuizmoMode == ImGuizmo::WORLD ? std::string("World") : std::string("Local"))).c_str()))

	lea	rcx, QWORD PTR $T18[rbp-121]
	or	edi, 2
$LN490@DrawOverla:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	DWORD PTR $T23[rbp-121], edi
	mov	r9d, 6
	lea	r8, OFFSET FLAT:??_C@_06GCNPBLOP@Mode?3?5@
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T22[rbp-121], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqu	XMMWORD PTR $T22[rbp-105], xmm1

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T22[rbp-121], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T22[rbp-105], xmm1

; 4986 :     return _STD move(_Right.insert(0, _Left));

	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	or	edi, 4
	mov	DWORD PTR $T23[rbp-121], edi

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T22[rbp-121]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T22[rbp-97], 16
	cmovae	rcx, QWORD PTR $T22[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T30[rbp-121]
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
	movzx	ebx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T22[rbp-97]
	cmp	rdx, 16
	jb	SHORT $LN98@DrawOverla

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T22[rbp-121]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN110@DrawOverla

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN110@DrawOverla
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN110@DrawOverla:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN98@DrawOverla:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T22[rbp-105], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T22[rbp-121], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 76   : 	if (ImGui::Button(std::string("Mode: " + (ImGuizmoMode == ImGuizmo::WORLD ? std::string("World") : std::string("Local"))).c_str()))

	test	dil, 2
	je	SHORT $LN276@DrawOverla
	and	edi, -3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T18[rbp-97]
	cmp	rdx, 16
	jb	SHORT $LN283@DrawOverla

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T18[rbp-121]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN295@DrawOverla

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN295@DrawOverla
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@DrawOverla:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN283@DrawOverla:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T18[rbp-105], rsi

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T18[rbp-97], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T18[rbp-121], 0
$LN276@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 76   : 	if (ImGui::Button(std::string("Mode: " + (ImGuizmoMode == ImGuizmo::WORLD ? std::string("World") : std::string("Local"))).c_str()))

	test	dil, 1
	je	SHORT $LN305@DrawOverla
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T8[rbp-97]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN312@DrawOverla

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T8[rbp-121]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN324@DrawOverla

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN324@DrawOverla
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN324@DrawOverla:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN312@DrawOverla:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T8[rbp-105], rsi

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-97], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T8[rbp-121], 0
$LN305@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 76   : 	if (ImGui::Button(std::string("Mode: " + (ImGuizmoMode == ImGuizmo::WORLD ? std::string("World") : std::string("Local"))).c_str()))

	test	bl, bl
	je	SHORT $LN3@DrawOverla

; 77   : 	{
; 78   : 		if (ImGuizmoMode == ImGuizmo::WORLD) ImGuizmoMode = ImGuizmo::LOCAL;

	mov	eax, esi
	cmp	DWORD PTR ?ImGuizmoMode@UIMapView@@3W4MODE@ImGuizmo@@A, 1 ; UIMapView::ImGuizmoMode
	setne	al
	mov	DWORD PTR ?ImGuizmoMode@UIMapView@@3W4MODE@ImGuizmo@@A, eax ; UIMapView::ImGuizmoMode
$LN3@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3144 :     if (g.ColorStack.Size < count)

	movsxd	rax, DWORD PTR [rbx+18824]
	cmp	eax, 1
	jl	SHORT $LN130@DrawOverla

; 3153 :         g.ColorStack.pop_back();

	lea	rdx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [rbx+18832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3152 :         g.Style.Colors[backup.Col] = backup.BackupValue;

	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	movups	XMMWORD PTR [rbx+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rbx+18824]
$LN130@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 83   : 	ImGui::SameLine();

	movss	xmm1, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 84   : 
; 85   : 	//ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.0f, 0.0f, 0.0f, 0.5f));
; 86   : 	ImGui::PushStyleColor(ImGuiCol_Button, UIMapView::ImGuizmoOperation == ImGuizmo::TRANSLATE ? ImGui::GetStyle().Colors[ImGuiCol_ButtonHovered] : ImVec4(0.0f, 0.0f, 0.0f, 0.5f));

	lea	rdi, QWORD PTR $T7[rbp-121]
	cmp	DWORD PTR ?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A, 7 ; UIMapView::ImGuizmoOperation
	jne	SHORT $LN11@DrawOverla
	movups	xmm0, XMMWORD PTR [rbx+15128]
	jmp	SHORT $LN491@DrawOverla
$LN11@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm0, XMMWORD PTR __xmm@3f000000000000000000000000000000
$LN491@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3135 :     backup.Col = idx;

	movups	XMMWORD PTR $T6[rbp-121], xmm0
	mov	DWORD PTR backup$9[rbp-121], 21

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+15112]
	movups	XMMWORD PTR backup$9[rbp-117], xmm0

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR backup$9[rbp-121]
	lea	rcx, QWORD PTR [rbx+18824]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rbx+15112], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm1, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
	movups	XMMWORD PTR $T5[rbp-121], xmm1
	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T17[rbp-121], xmm0

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T26[rbp-121], 1065353216	; 3f800000H
	mov	DWORD PTR $T26[rbp-117], 1065353216	; 3f800000H
	mov	QWORD PTR $T29[rbp-121], 0
	mov	DWORD PTR $T33[rbp-121], 1098907648	; 41800000H
	mov	DWORD PTR $T33[rbp-117], 1098907648	; 41800000H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T21[rbp-121], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T21[rbp-105], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T21[rbp-97], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 14
	lea	rdx, OFFSET FLAT:??_C@_0P@DMOEPKE@TranslateGizmo@
	lea	rcx, QWORD PTR $T21[rbp-121]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 87   : 	if (ImGui::ImageButton((ImTextureID)TextureMgr::GetTexture("TranslateGizmo")->ID, ImVec2(16, 16), ImVec2(0.0f, 0.0f), ImVec2(1.0f, 1.0f), 2))

	lea	rcx, QWORD PTR $T21[rbp-121]
	call	?GetTexture@TextureMgr@@YAPEAUTexture@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureMgr::GetTexture
	mov	ecx, DWORD PTR [rax]
	lea	rax, QWORD PTR $T5[rbp-121]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR $T17[rbp-121]
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR $T26[rbp-121]
	lea	r8, QWORD PTR $T29[rbp-121]
	lea	rdx, QWORD PTR $T33[rbp-121]
	call	?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z ; ImGui::ImageButton
	test	al, al
	je	SHORT $LN5@DrawOverla

; 88   : 	{
; 89   : 		UIMapView::ImGuizmoOperation = ImGuizmo::TRANSLATE;

	mov	DWORD PTR ?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A, 7 ; UIMapView::ImGuizmoOperation
$LN5@DrawOverla:

; 90   : 	}
; 91   : 	ImGui::SetItemTooltip("Translate Gizmo (G)");

	lea	rcx, OFFSET FLAT:??_C@_0BE@MGGNGPDH@Translate?5Gizmo?5?$CIG?$CJ@
	call	?SetItemTooltip@ImGui@@YAXPEBDZZ	; ImGui::SetItemTooltip

; 92   : 	ImGui::SameLine();

	movss	xmm1, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3144 :     if (g.ColorStack.Size < count)

	movsxd	rax, DWORD PTR [rbx+18824]
	cmp	eax, 1
	jl	SHORT $LN178@DrawOverla

; 3153 :         g.ColorStack.pop_back();

	lea	rdx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [rbx+18832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3152 :         g.Style.Colors[backup.Col] = backup.BackupValue;

	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	movups	XMMWORD PTR [rbx+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rbx+18824]
$LN178@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 95   : 	ImGui::PushStyleColor(ImGuiCol_Button, UIMapView::ImGuizmoOperation == ImGuizmo::ROTATE ? ImGui::GetStyle().Colors[ImGuiCol_ButtonHovered] : ImVec4(0.0f, 0.0f, 0.0f, 0.5f));

	lea	rdi, QWORD PTR $T16[rbp-121]
	cmp	DWORD PTR ?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A, 120 ; UIMapView::ImGuizmoOperation, 00000078H
	jne	SHORT $LN13@DrawOverla
	movups	xmm0, XMMWORD PTR [rbx+15128]
	jmp	SHORT $LN492@DrawOverla
$LN13@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm0, XMMWORD PTR __xmm@3f000000000000000000000000000000
$LN492@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3135 :     backup.Col = idx;

	movups	XMMWORD PTR $T15[rbp-121], xmm0
	mov	DWORD PTR backup$2[rbp-121], 21

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+15112]
	movups	XMMWORD PTR backup$2[rbp-117], xmm0

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR backup$2[rbp-121]
	lea	rcx, QWORD PTR [rbx+18824]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rbx+15112], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm1, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
	movups	XMMWORD PTR $T14[rbp-121], xmm1
	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T4[rbp-121], xmm0

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T25[rbp-121], 1065353216	; 3f800000H
	mov	DWORD PTR $T25[rbp-117], 1065353216	; 3f800000H
	mov	QWORD PTR $T28[rbp-121], 0
	mov	DWORD PTR $T32[rbp-121], 1098907648	; 41800000H
	mov	DWORD PTR $T32[rbp-117], 1098907648	; 41800000H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T20[rbp-121], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T20[rbp-105], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T20[rbp-97], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@PCPPJDNL@RotateGizmo@
	lea	rcx, QWORD PTR $T20[rbp-121]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 96   : 	if (ImGui::ImageButton((ImTextureID)TextureMgr::GetTexture("RotateGizmo")->ID, ImVec2(16, 16), ImVec2(0.0f, 0.0f), ImVec2(1.0f, 1.0f), 2))

	lea	rcx, QWORD PTR $T20[rbp-121]
	call	?GetTexture@TextureMgr@@YAPEAUTexture@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureMgr::GetTexture
	mov	ecx, DWORD PTR [rax]
	lea	rax, QWORD PTR $T14[rbp-121]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR $T4[rbp-121]
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR $T25[rbp-121]
	lea	r8, QWORD PTR $T28[rbp-121]
	lea	rdx, QWORD PTR $T32[rbp-121]
	call	?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z ; ImGui::ImageButton
	test	al, al
	je	SHORT $LN6@DrawOverla

; 97   : 	{
; 98   : 		UIMapView::ImGuizmoOperation = ImGuizmo::ROTATE;

	mov	DWORD PTR ?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A, 120 ; UIMapView::ImGuizmoOperation, 00000078H
$LN6@DrawOverla:

; 99   : 	}
; 100  : 	ImGui::SetItemTooltip("Rotate Gizmo (R)");

	lea	rcx, OFFSET FLAT:??_C@_0BB@ODIOCAMI@Rotate?5Gizmo?5?$CIR?$CJ@
	call	?SetItemTooltip@ImGui@@YAXPEBDZZ	; ImGui::SetItemTooltip

; 101  : 	ImGui::SameLine();

	movss	xmm1, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3144 :     if (g.ColorStack.Size < count)

	movsxd	rax, DWORD PTR [rbx+18824]
	cmp	eax, 1
	jl	SHORT $LN215@DrawOverla

; 3153 :         g.ColorStack.pop_back();

	lea	rdx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [rbx+18832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3152 :         g.Style.Colors[backup.Col] = backup.BackupValue;

	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	movups	XMMWORD PTR [rbx+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rbx+18824]
$LN215@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 104  : 	ImGui::PushStyleColor(ImGuiCol_Button, UIMapView::ImGuizmoOperation == ImGuizmo::SCALE ? ImGui::GetStyle().Colors[ImGuiCol_ButtonHovered] : ImVec4(0.0f, 0.0f, 0.0f, 0.5f));

	lea	rdi, QWORD PTR $T13[rbp-121]
	cmp	DWORD PTR ?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A, 896 ; UIMapView::ImGuizmoOperation, 00000380H
	jne	SHORT $LN15@DrawOverla
	movups	xmm0, XMMWORD PTR [rbx+15128]
	jmp	SHORT $LN493@DrawOverla
$LN15@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm0, XMMWORD PTR __xmm@3f000000000000000000000000000000
$LN493@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3135 :     backup.Col = idx;

	movups	XMMWORD PTR $T12[rbp-121], xmm0
	mov	DWORD PTR backup$1[rbp-121], 21

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+15112]
	movups	XMMWORD PTR backup$1[rbp-117], xmm0

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR backup$1[rbp-121]
	lea	rcx, QWORD PTR [rbx+18824]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rbx+15112], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm1, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
	movups	XMMWORD PTR $T11[rbp-121], xmm1
	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T3[rbp-121], xmm0

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T24[rbp-121], 1065353216	; 3f800000H
	mov	DWORD PTR $T24[rbp-117], 1065353216	; 3f800000H
	mov	QWORD PTR $T27[rbp-121], 0
	mov	DWORD PTR $T31[rbp-121], 1098907648	; 41800000H
	mov	DWORD PTR $T31[rbp-117], 1098907648	; 41800000H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T19[rbp-121], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T19[rbp-105], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T19[rbp-97], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 10
	lea	rdx, OFFSET FLAT:??_C@_0L@HKLBEJBP@ScaleGizmo@
	lea	rcx, QWORD PTR $T19[rbp-121]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 105  : 	if(ImGui::ImageButton((ImTextureID)TextureMgr::GetTexture("ScaleGizmo")->ID, ImVec2(16, 16), ImVec2(0.0f, 0.0f), ImVec2(1.0f, 1.0f), 2))

	lea	rcx, QWORD PTR $T19[rbp-121]
	call	?GetTexture@TextureMgr@@YAPEAUTexture@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureMgr::GetTexture
	mov	ecx, DWORD PTR [rax]
	lea	rax, QWORD PTR $T11[rbp-121]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR $T3[rbp-121]
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR $T24[rbp-121]
	lea	r8, QWORD PTR $T27[rbp-121]
	lea	rdx, QWORD PTR $T31[rbp-121]
	call	?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z ; ImGui::ImageButton
	test	al, al
	je	SHORT $LN7@DrawOverla

; 106  : 	{
; 107  : 		UIMapView::ImGuizmoOperation = ImGuizmo::SCALE;

	mov	DWORD PTR ?ImGuizmoOperation@UIMapView@@3W4OPERATION@ImGuizmo@@A, 896 ; UIMapView::ImGuizmoOperation, 00000380H
$LN7@DrawOverla:

; 108  : 	}
; 109  : 	ImGui::SetItemTooltip("Scale Gizmo (S)");

	lea	rcx, OFFSET FLAT:??_C@_0BA@DOGOOPJA@Scale?5Gizmo?5?$CIS?$CJ@
	call	?SetItemTooltip@ImGui@@YAXPEBDZZ	; ImGui::SetItemTooltip
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3144 :     if (g.ColorStack.Size < count)

	movsxd	rax, DWORD PTR [r8+18824]
	cmp	eax, 1
	jl	SHORT $LN139@DrawOverla

; 3153 :         g.ColorStack.pop_back();

	lea	rdx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [r8+18832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3152 :         g.Style.Colors[backup.Col] = backup.BackupValue;

	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	movups	XMMWORD PTR [r8+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [r8+18824]
$LN139@DrawOverla:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 112  : }

	movaps	xmm7, XMMWORD PTR [rsp+160]
	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN489@DrawOverla:
?DrawOverlay@UIMapView@@YAXXZ ENDP			; UIMapView::DrawOverlay
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
backup$1 = 64
backup$2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 64
$T7 = 64
$T8 = 64
backup$9 = 96
backup$10 = 96
$T11 = 96
$T12 = 96
$T13 = 96
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 96
$T18 = 96
$T19 = 128
$T20 = 128
$T21 = 128
$T22 = 128
$T23 = 224
$T24 = 224
$T25 = 224
$T26 = 224
$T27 = 232
$T28 = 232
$T29 = 232
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
?dtor$0@?0??DrawOverlay@UIMapView@@YAXXZ@4HA PROC	; `UIMapView::DrawOverlay'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T23[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN18@dtor$0
	and	DWORD PTR $T23[rbp], -2
	lea	rcx, QWORD PTR $T8[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN18@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??DrawOverlay@UIMapView@@YAXXZ@4HA ENDP	; `UIMapView::DrawOverlay'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
backup$1 = 64
backup$2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 64
$T7 = 64
$T8 = 64
backup$9 = 96
backup$10 = 96
$T11 = 96
$T12 = 96
$T13 = 96
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 96
$T18 = 96
$T19 = 128
$T20 = 128
$T21 = 128
$T22 = 128
$T23 = 224
$T24 = 224
$T25 = 224
$T26 = 224
$T27 = 232
$T28 = 232
$T29 = 232
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
?dtor$1@?0??DrawOverlay@UIMapView@@YAXXZ@4HA PROC	; `UIMapView::DrawOverlay'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T23[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN20@dtor$1
	and	DWORD PTR $T23[rbp], -3
	lea	rcx, QWORD PTR $T18[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN20@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??DrawOverlay@UIMapView@@YAXXZ@4HA ENDP	; `UIMapView::DrawOverlay'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
backup$1 = 64
backup$2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 64
$T7 = 64
$T8 = 64
backup$9 = 96
backup$10 = 96
$T11 = 96
$T12 = 96
$T13 = 96
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 96
$T18 = 96
$T19 = 128
$T20 = 128
$T21 = 128
$T22 = 128
$T23 = 224
$T24 = 224
$T25 = 224
$T26 = 224
$T27 = 232
$T28 = 232
$T29 = 232
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
?dtor$2@?0??DrawOverlay@UIMapView@@YAXXZ@4HA PROC	; `UIMapView::DrawOverlay'::`1'::dtor$2
	lea	rcx, QWORD PTR $T22[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??DrawOverlay@UIMapView@@YAXXZ@4HA ENDP	; `UIMapView::DrawOverlay'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
;	COMDAT ?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z
_TEXT	SEGMENT
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
GLMModel$ = 112
__$ArrayPad$ = 176
Actor$ = 320
Shader$dead$ = 328
?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z PROC	; UIMapView::DrawActor, COMDAT

; 115  : {

$LN164:
	mov	r11, rsp
	mov	QWORD PTR [r11+16], rbx
	mov	QWORD PTR [r11+24], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [r11-56]
	sub	rsp, 272				; 00000110H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx+424]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 120  : 	GLMModel = glm::translate(GLMModel, glm::vec3(Actor.Translate.GetX(), Actor.Translate.GetY(), Actor.Translate.GetZ()));

	lea	r8, QWORD PTR $T5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 115  : {

	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	mov	r15, QWORD PTR ?SelectedShader@UIMapView@@3PEAVShader@@EA ; UIMapView::SelectedShader
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 115  : {

	movaps	XMMWORD PTR [r11-56], xmm6
	movaps	XMMWORD PTR [r11-72], xmm7
	movaps	XMMWORD PTR [r11-88], xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r14, QWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 120  : 	GLMModel = glm::translate(GLMModel, glm::vec3(Actor.Translate.GetX(), Actor.Translate.GetY(), Actor.Translate.GetZ()));

	lea	rdx, QWORD PTR GLMModel$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	XMMWORD PTR GLMModel$[rsp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR GLMModel$[rbp-224], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm0, DWORD PTR [rcx+52]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	XMMWORD PTR GLMModel$[rbp-240], xmm1
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	DWORD PTR $T5[rsp], xmm0
	movss	xmm0, DWORD PTR [rcx+60]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	XMMWORD PTR GLMModel$[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm1, DWORD PTR [rcx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 120  : 	GLMModel = glm::translate(GLMModel, glm::vec3(Actor.Translate.GetX(), Actor.Translate.GetY(), Actor.Translate.GetZ()));

	lea	rcx, QWORD PTR $T9[rsp]
	movaps	XMMWORD PTR [r11-104], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	DWORD PTR $T5[rsp+8], xmm0
	movss	DWORD PTR $T5[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 115  : {

	movaps	XMMWORD PTR [r11-120], xmm10

; 120  : 	GLMModel = glm::translate(GLMModel, glm::vec3(Actor.Translate.GetX(), Actor.Translate.GetY(), Actor.Translate.GetZ()));

	call	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	movss	xmm2, DWORD PTR [rbx+84]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 122  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	lea	r9, QWORD PTR $T4[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	movss	xmm6, DWORD PTR __real@3c8efa35
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 122  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	lea	rdx, QWORD PTR GLMModel$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 122  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	lea	rcx, QWORD PTR $T8[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T4[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 120  : 	GLMModel = glm::translate(GLMModel, glm::vec3(Actor.Translate.GetX(), Actor.Translate.GetY(), Actor.Translate.GetZ()));

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T4[rsp+8], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 120  : 	GLMModel = glm::translate(GLMModel, glm::vec3(Actor.Translate.GetX(), Actor.Translate.GetY(), Actor.Translate.GetZ()));

	movaps	XMMWORD PTR GLMModel$[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$[rbp-208], xmm1

; 122  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	movss	xmm2, DWORD PTR [rbx+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 123  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	lea	r9, QWORD PTR $T3[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 123  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	lea	rdx, QWORD PTR GLMModel$[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	DWORD PTR $T3[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 122  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 55   : 		, y(static_cast<T>(_y))

	mov	QWORD PTR $T3[rsp+4], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 122  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	movaps	XMMWORD PTR GLMModel$[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$[rbp-208], xmm1

; 123  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 30   : 	return this->m_Data[0];

	movss	xmm2, DWORD PTR [rbx+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 124  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetX()), glm::vec3(1.0, 0.0f, 0.0));

	lea	r9, QWORD PTR $T2[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 124  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetX()), glm::vec3(1.0, 0.0f, 0.0));

	lea	rdx, QWORD PTR GLMModel$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T2[rsp], 1065353216		; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 123  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T2[rsp+8], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 123  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	movaps	XMMWORD PTR GLMModel$[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$[rbp-208], xmm1

; 124  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetX()), glm::vec3(1.0, 0.0f, 0.0));

	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
	movups	xmm3, XMMWORD PTR [rax]
	movaps	XMMWORD PTR GLMModel$[rsp], xmm3
	movups	xmm4, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$[rbp-240], xmm4
	movups	xmm7, XMMWORD PTR [rax+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm2, DWORD PTR [rbx+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm9, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm8, DWORD PTR [rbx+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm5, DWORD PTR [rbx+68]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm1, xmm3

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	mulss	xmm9, xmm2
	movaps	xmm6, xmm5
	mulss	xmm6, xmm4

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	shufps	xmm0, xmm3, 85				; 00000055H
	shufps	xmm1, xmm3, 170				; 000000aaH
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 81   : 		Result[0] = m[0] * v[0];

	shufps	xmm9, xmm9, 225				; 000000e1H
	movss	xmm9, xmm0

; 82   : 		Result[1] = m[1] * v[1];

	shufps	xmm6, xmm6, 225				; 000000e1H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 124  : 	GLMModel = glm::rotate(GLMModel, glm::radians(Actor.Rotate.GetX()), glm::vec3(1.0, 0.0f, 0.0));

	movaps	XMMWORD PTR GLMModel$[rbp-224], xmm7
	movups	xmm10, XMMWORD PTR [rax+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	shufps	xmm0, xmm4, 85				; 00000055H
	shufps	xmm3, xmm3, 255				; 000000ffH
	mulss	xmm3, xmm2
	movaps	xmm2, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 81   : 		Result[0] = m[0] * v[0];

	shufps	xmm9, xmm9, 198				; 000000c6H
	movss	xmm9, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	mulss	xmm2, xmm0
	movaps	xmm1, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 81   : 		Result[0] = m[0] * v[0];

	shufps	xmm9, xmm9, 39				; 00000027H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	shufps	xmm1, xmm4, 170				; 000000aaH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 81   : 		Result[0] = m[0] * v[0];

	movss	xmm9, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	shufps	xmm4, xmm4, 255				; 000000ffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 82   : 		Result[1] = m[1] * v[1];

	movss	xmm6, xmm2
	shufps	xmm6, xmm6, 198				; 000000c6H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm3, xmm5
	mulss	xmm5, xmm4
	movaps	xmm0, xmm7
	mulss	xmm3, xmm1

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm4, xmm8
	mulss	xmm4, xmm7

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm2, xmm8
	shufps	xmm0, xmm7, 85				; 00000055H
	movaps	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 82   : 		Result[1] = m[1] * v[1];

	movss	xmm6, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	shufps	xmm1, xmm7, 170				; 000000aaH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 83   : 		Result[2] = m[2] * v[2];

	shufps	xmm4, xmm4, 225				; 000000e1H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm3, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 82   : 		Result[1] = m[1] * v[1];

	shufps	xmm6, xmm6, 39				; 00000027H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 126  : 	GLMModel = glm::scale(GLMModel, glm::vec3(Actor.Scale.GetX(), Actor.Scale.GetY(), Actor.Scale.GetZ()));

	movaps	XMMWORD PTR GLMModel$[rbp-208], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 82   : 		Result[1] = m[1] * v[1];

	movss	xmm6, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 128  : 	for (uint32_t SubModelIndexOpaque : LODModel->OpaqueObjects)

	movaps	xmm10, XMMWORD PTR [rsp+192]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	shufps	xmm7, xmm7, 255				; 000000ffH
	mulss	xmm8, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 128  : 	for (uint32_t SubModelIndexOpaque : LODModel->OpaqueObjects)

	movaps	xmm7, XMMWORD PTR [rsp+240]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 81   : 		Result[0] = m[0] * v[0];

	shufps	xmm9, xmm9, 57				; 00000039H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 126  : 	GLMModel = glm::scale(GLMModel, glm::vec3(Actor.Scale.GetX(), Actor.Scale.GetY(), Actor.Scale.GetZ()));

	movaps	XMMWORD PTR GLMModel$[rsp], xmm9

; 128  : 	for (uint32_t SubModelIndexOpaque : LODModel->OpaqueObjects)

	movaps	xmm9, XMMWORD PTR [rsp+208]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 82   : 		Result[1] = m[1] * v[1];

	shufps	xmm6, xmm6, 57				; 00000039H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 126  : 	GLMModel = glm::scale(GLMModel, glm::vec3(Actor.Scale.GetX(), Actor.Scale.GetY(), Actor.Scale.GetZ()));

	movaps	XMMWORD PTR GLMModel$[rbp-240], xmm6

; 128  : 	for (uint32_t SubModelIndexOpaque : LODModel->OpaqueObjects)

	movaps	xmm6, XMMWORD PTR [rsp+256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	mulss	xmm2, xmm0
	mulss	xmm3, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 83   : 		Result[2] = m[2] * v[2];

	movss	xmm4, xmm2
	shufps	xmm4, xmm4, 198				; 000000c6H
	movss	xmm4, xmm3
	shufps	xmm4, xmm4, 39				; 00000027H
	movss	xmm4, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 128  : 	for (uint32_t SubModelIndexOpaque : LODModel->OpaqueObjects)

	movaps	xmm8, XMMWORD PTR [rsp+224]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 83   : 		Result[2] = m[2] * v[2];

	shufps	xmm4, xmm4, 57				; 00000039H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 126  : 	GLMModel = glm::scale(GLMModel, glm::vec3(Actor.Scale.GetX(), Actor.Scale.GetY(), Actor.Scale.GetZ()));

	movaps	XMMWORD PTR GLMModel$[rbp-224], xmm4

; 128  : 	for (uint32_t SubModelIndexOpaque : LODModel->OpaqueObjects)

	mov	r12, QWORD PTR [r14+56]
	mov	rsi, QWORD PTR [r14+48]
	cmp	rsi, r12
	je	SHORT $LN159@DrawActor
	npad	11
$LL4@DrawActor:

; 130  : 		LODModel->GL_Meshes[SubModelIndexOpaque].UpdateInstances(1);

	mov	eax, DWORD PTR [rsi]
	mov	edx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r14+24]
	lea	rdi, QWORD PTR [rax+rax*2]
	shl	rdi, 5
	add	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 130  : 		LODModel->GL_Meshes[SubModelIndexOpaque].UpdateInstances(1);

	call	?UpdateInstances@Mesh@@QEAAXI@Z		; Mesh::UpdateInstances

; 131  : 		glUniformMatrix4fv(glGetUniformLocation(Shader->ID, "modelMatrix"), 1, GL_FALSE, glm::value_ptr(GLMModel));

	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_0M@DDLHAGJC@modelMatrix@
	mov	ecx, DWORD PTR [r15]
	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	call	rax
	xor	r8d, r8d
	lea	r9, QWORD PTR GLMModel$[rsp]
	mov	ecx, eax
	lea	edx, QWORD PTR [r8+1]
	call	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r14+24]
	add	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 132  : 		LODModel->GL_Meshes[SubModelIndexOpaque].Draw();

	call	?Draw@Mesh@@QEAAXPEAVShader@@H@Z	; Mesh::Draw
	add	rsi, 4
	cmp	rsi, r12
	jne	SHORT $LL4@DrawActor
$LN159@DrawActor:

; 133  : 	}
; 134  : 
; 135  : 	for (uint32_t SubModelIndexTransparent : LODModel->TransparentObjects)

	mov	r12, QWORD PTR [r14+80]
	mov	rsi, QWORD PTR [r14+72]
	cmp	rsi, r12
	je	SHORT $LN6@DrawActor
	npad	9
$LL7@DrawActor:

; 137  : 		LODModel->GL_Meshes[SubModelIndexTransparent].UpdateInstances(1);

	mov	eax, DWORD PTR [rsi]
	mov	edx, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r14+24]
	lea	rdi, QWORD PTR [rax+rax*2]
	shl	rdi, 5
	add	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 137  : 		LODModel->GL_Meshes[SubModelIndexTransparent].UpdateInstances(1);

	call	?UpdateInstances@Mesh@@QEAAXI@Z		; Mesh::UpdateInstances

; 138  : 		glUniformMatrix4fv(glGetUniformLocation(Shader->ID, "modelMatrix"), 1, GL_FALSE, glm::value_ptr(GLMModel));

	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_0M@DDLHAGJC@modelMatrix@
	mov	ecx, DWORD PTR [r15]
	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	call	rax
	xor	r8d, r8d
	lea	r9, QWORD PTR GLMModel$[rsp]
	mov	ecx, eax
	lea	edx, QWORD PTR [r8+1]
	call	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r14+24]
	add	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 139  : 		LODModel->GL_Meshes[SubModelIndexTransparent].Draw();

	call	?Draw@Mesh@@QEAAXPEAVShader@@H@Z	; Mesh::Draw
	add	rsi, 4
	cmp	rsi, r12
	jne	SHORT $LL7@DrawActor
$LN6@DrawActor:

; 140  : 	}
; 141  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+272]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
?DrawActor@UIMapView@@YAXAEAUActor@@PEAVShader@@@Z ENDP	; UIMapView::DrawActor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Frustum.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Frustum.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
;	COMDAT ?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z
_TEXT	SEGMENT
$T4 = 48
$T5 = 60
$T6 = 72
$T7 = 84
$T8 = 96
$T9 = 96
$T10 = 96
$T11 = 96
InstanceMatrices$ = 160
GLMModel$12 = 192
__$ArrayPad$ = 256
Model$ = 448
ActorPtrs$ = 456
?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z PROC ; UIMapView::DrawInstancedActor, COMDAT

; 144  : {

$LN378:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-128]
	sub	rsp, 384				; 00000180H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	movaps	XMMWORD PTR [rax-104], xmm8
	movaps	XMMWORD PTR [rax-120], xmm9
	movaps	XMMWORD PTR [rax-136], xmm10
	movaps	XMMWORD PTR [rax-152], xmm11
	movaps	XMMWORD PTR [rax-168], xmm12
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rsi, rdx
	mov	r13, rcx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdi, QWORD PTR [rdx+8]
	sub	rdi, QWORD PTR [rdx]
	sar	rdi, 3

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR InstanceMatrices$[rbp-256], xmm0
	xor	r14d, r14d
	mov	QWORD PTR InstanceMatrices$[rbp-240], r14

; 2065 :         if (_Count != 0) {

	test	rdi, rdi
	je	SHORT $LN362@DrawInstan

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	rdi, rax
	ja	$LN376@DrawInstan

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rdi
	call	?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::allocator<glm::mat<4,4,float,0> >::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR InstanceMatrices$[rbp-256], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	rbx, rdi
	shl	rbx, 6
	add	rbx, rax
	mov	QWORD PTR InstanceMatrices$[rbp-240], rbx

; 1890 :     }
; 1891 : 
; 1892 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {
; 1893 :         auto& _My_data = _Mypair._Myval2;
; 1894 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1895 :         _STL_VERIFY(
; 1896 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1897 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1898 : 
; 1899 :         return _My_data._Myfirst[_Pos];
; 1900 :     }
; 1901 : 
; 1902 :     _NODISCARD _CONSTEXPR20 _Ty& at(const size_type _Pos) {
; 1903 :         auto& _My_data = _Mypair._Myval2;
; 1904 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {
; 1905 :             _Xrange();
; 1906 :         }
; 1907 : 
; 1908 :         return _My_data._Myfirst[_Pos];
; 1909 :     }
; 1910 : 
; 1911 :     _NODISCARD _CONSTEXPR20 const _Ty& at(const size_type _Pos) const {
; 1912 :         auto& _My_data = _Mypair._Myval2;
; 1913 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {
; 1914 :             _Xrange();
; 1915 :         }
; 1916 : 
; 1917 :         return _My_data._Myfirst[_Pos];
; 1918 :     }
; 1919 : 
; 1920 :     _NODISCARD _CONSTEXPR20 _Ty& front() noexcept /* strengthened */ {
; 1921 :         auto& _My_data = _Mypair._Myval2;
; 1922 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1923 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "front() called on empty vector");
; 1924 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1925 : 
; 1926 :         return *_My_data._Myfirst;
; 1927 :     }
; 1928 : 
; 1929 :     _NODISCARD _CONSTEXPR20 const _Ty& front() const noexcept /* strengthened */ {
; 1930 :         auto& _My_data = _Mypair._Myval2;
; 1931 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1932 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "front() called on empty vector");
; 1933 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1934 : 
; 1935 :         return *_My_data._Myfirst;
; 1936 :     }
; 1937 : 
; 1938 :     _NODISCARD _CONSTEXPR20 _Ty& back() noexcept /* strengthened */ {
; 1939 :         auto& _My_data = _Mypair._Myval2;
; 1940 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1941 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1942 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1943 : 
; 1944 :         return _My_data._Mylast[-1];
; 1945 :     }
; 1946 : 
; 1947 :     _NODISCARD _CONSTEXPR20 const _Ty& back() const noexcept /* strengthened */ {
; 1948 :         auto& _My_data = _Mypair._Myval2;
; 1949 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1950 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1951 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1952 : 
; 1953 :         return _My_data._Mylast[-1];
; 1954 :     }
; 1955 : 
; 1956 :     _NODISCARD _CONSTEXPR20 allocator_type get_allocator() const noexcept {
; 1957 :         return static_cast<allocator_type>(_Getal());
; 1958 :     }
; 1959 : 
; 1960 : private:
; 1961 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {
; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {
; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;
; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {
; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }
; 1978 : 
; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {
; 1980 :         // allocate array with _Newcapacity elements
; 1981 :         auto& _My_data    = _Mypair._Myval2;
; 1982 :         pointer& _Myfirst = _My_data._Myfirst;
; 1983 :         pointer& _Mylast  = _My_data._Mylast;
; 1984 :         pointer& _Myend   = _My_data._Myend;
; 1985 : 
; 1986 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1987 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1988 : 
; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	shl	rdi, 6
	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR InstanceMatrices$[rbp-248], rbx
$LN362@DrawInstan:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 148  : 	for (int i = 0; i < ActorPtrs.size(); i++)

	mov	r15d, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR [rsi]
	mov	rax, QWORD PTR [rsi+8]
	sub	rax, r8
	sar	rax, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 148  : 	for (int i = 0; i < ActorPtrs.size(); i++)

	test	rax, rax
	je	$LN364@DrawInstan
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	rdi, r14
	mov	r12, r14
	movss	xmm10, DWORD PTR __xmm@80000000800000008000000080000000
	movsd	xmm11, QWORD PTR __real@3ff0000000000000
	movss	xmm12, DWORD PTR __real@3c8efa35
	mov	rdx, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	npad	1
$LL4@DrawInstan:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 150  : 		if ((ActorPtrs[i]->MergedActorParent == UIOutliner::SelectedActor && UIOutliner::SelectedActor != nullptr) || ActorPtrs[i] == UIOutliner::SelectedActor || !Frustum::SphereInFrustum(ActorPtrs[i]->Translate.GetX(), ActorPtrs[i]->Translate.GetY(), ActorPtrs[i]->Translate.GetZ(), ActorPtrs[i]->Model->GetModels()[0].BoundingBoxSphereRadius * std::fmax(std::fmax(std::fmax(1, ActorPtrs[i]->Scale.GetX()), ActorPtrs[i]->Scale.GetY()), ActorPtrs[i]->Scale.GetZ())))

	mov	rax, QWORD PTR [r8+rdi*8]
	cmp	QWORD PTR [rax+680], rdx
	jne	SHORT $LN13@DrawInstan
	test	rdx, rdx
	jne	$LN12@DrawInstan
$LN13@DrawInstan:
	cmp	rax, rdx
	je	$LN12@DrawInstan
	mov	rbx, QWORD PTR [rax+424]
	movss	xmm7, DWORD PTR [rax+72]
	movss	xmm6, DWORD PTR [rax+68]
	movss	xmm1, DWORD PTR [rax+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 698  : _GENERIC_MATH2(fmax)

	cvtps2pd xmm1, xmm1
	movaps	xmm0, xmm11
	call	QWORD PTR __imp_fmax
	cvtps2pd xmm1, xmm6
	call	QWORD PTR __imp_fmax
	cvtps2pd xmm1, xmm7
	call	QWORD PTR __imp_fmax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rbx]
	movss	xmm1, DWORD PTR [rax+96]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 150  : 		if ((ActorPtrs[i]->MergedActorParent == UIOutliner::SelectedActor && UIOutliner::SelectedActor != nullptr) || ActorPtrs[i] == UIOutliner::SelectedActor || !Frustum::SphereInFrustum(ActorPtrs[i]->Translate.GetX(), ActorPtrs[i]->Translate.GetY(), ActorPtrs[i]->Translate.GetZ(), ActorPtrs[i]->Model->GetModels()[0].BoundingBoxSphereRadius * std::fmax(std::fmax(std::fmax(1, ActorPtrs[i]->Scale.GetX()), ActorPtrs[i]->Scale.GetY()), ActorPtrs[i]->Scale.GetZ())))

	cvtps2pd xmm1, xmm1
	mulsd	xmm1, xmm0
	cvtpd2ps xmm3, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 150  : 		if ((ActorPtrs[i]->MergedActorParent == UIOutliner::SelectedActor && UIOutliner::SelectedActor != nullptr) || ActorPtrs[i] == UIOutliner::SelectedActor || !Frustum::SphereInFrustum(ActorPtrs[i]->Translate.GetX(), ActorPtrs[i]->Translate.GetY(), ActorPtrs[i]->Translate.GetZ(), ActorPtrs[i]->Model->GetModels()[0].BoundingBoxSphereRadius * std::fmax(std::fmax(std::fmax(1, ActorPtrs[i]->Scale.GetX()), ActorPtrs[i]->Scale.GetY()), ActorPtrs[i]->Scale.GetZ())))

	mov	r9, QWORD PTR [rax+rdi*8]
	movss	xmm4, DWORD PTR [r9+60]
	movss	xmm5, DWORD PTR [r9+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 30   : 	return this->m_Data[0];

	movss	xmm6, DWORD PTR [r9+52]
	xorps	xmm3, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 150  : 		if ((ActorPtrs[i]->MergedActorParent == UIOutliner::SelectedActor && UIOutliner::SelectedActor != nullptr) || ActorPtrs[i] == UIOutliner::SelectedActor || !Frustum::SphereInFrustum(ActorPtrs[i]->Translate.GetX(), ActorPtrs[i]->Translate.GetY(), ActorPtrs[i]->Translate.GetZ(), ActorPtrs[i]->Model->GetModels()[0].BoundingBoxSphereRadius * std::fmax(std::fmax(std::fmax(1, ActorPtrs[i]->Scale.GetX()), ActorPtrs[i]->Scale.GetY()), ActorPtrs[i]->Scale.GetZ())))

	lea	rax, OFFSET FLAT:?FrustumValues@Frustum@@3PAY03MA ; Frustum::FrustumValues
	lea	rcx, OFFSET FLAT:?FrustumValues@Frustum@@3PAY03MA+96
	npad	14
$LL133@DrawInstan:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Frustum.cpp

; 106  : 		if (FrustumValues[i][A] * X + FrustumValues[i][B] * Y + FrustumValues[i][C] * Z + FrustumValues[i][D] <= -Radius)

	movaps	xmm2, xmm5
	mulss	xmm2, DWORD PTR [rax+4]
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rax]
	addss	xmm2, xmm0
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rax+8]
	addss	xmm2, xmm1
	addss	xmm2, DWORD PTR [rax+12]
	comiss	xmm3, xmm2
	jae	$LN363@DrawInstan

; 104  : 	for (int i = 0; i < 6; i++)

	add	rax, 16
	cmp	rax, rcx
	jl	SHORT $LL133@DrawInstan
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movaps	XMMWORD PTR GLMModel$12[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	XMMWORD PTR GLMModel$12[rbp-240], xmm1
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR GLMModel$12[rbp-224], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR GLMModel$12[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	DWORD PTR $T4[rsp], xmm6
	movss	DWORD PTR $T4[rsp+4], xmm5
	movss	DWORD PTR $T4[rsp+8], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 158  : 		GLMModel = glm::translate(GLMModel, glm::vec3(ActorPtrs[i]->Translate.GetX(), ActorPtrs[i]->Translate.GetY(), ActorPtrs[i]->Translate.GetZ()));

	lea	r8, QWORD PTR $T4[rsp]
	lea	rdx, QWORD PTR GLMModel$12[rbp-256]
	lea	rcx, QWORD PTR $T11[rsp]
	call	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR GLMModel$12[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$12[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$12[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$12[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T5[rsp], 0

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T5[rsp+8], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 160  : 		GLMModel = glm::rotate(GLMModel, glm::radians(ActorPtrs[i]->Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	movss	xmm2, DWORD PTR [r9+84]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 160  : 		GLMModel = glm::rotate(GLMModel, glm::radians(ActorPtrs[i]->Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	lea	r9, QWORD PTR $T5[rsp]
	lea	rdx, QWORD PTR GLMModel$12[rbp-256]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR GLMModel$12[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$12[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$12[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$12[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	DWORD PTR $T6[rsp], 0

; 55   : 		, y(static_cast<T>(_y))

	mov	QWORD PTR $T6[rsp+4], 1065353216	; 3f800000H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mov	rax, QWORD PTR [rax+rdi*8]
	movss	xmm2, DWORD PTR [rax+80]
	mulss	xmm2, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 161  : 		GLMModel = glm::rotate(GLMModel, glm::radians(ActorPtrs[i]->Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	lea	r9, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR GLMModel$12[rbp-256]
	lea	rcx, QWORD PTR $T9[rsp]
	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR GLMModel$12[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$12[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$12[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$12[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T7[rsp], 1065353216		; 3f800000H

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T7[rsp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 30   : 	return this->m_Data[0];

	mov	rax, QWORD PTR [rax+rdi*8]
	movss	xmm2, DWORD PTR [rax+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 162  : 		GLMModel = glm::rotate(GLMModel, glm::radians(ActorPtrs[i]->Rotate.GetX()), glm::vec3(1.0, 0.0f, 0.0));

	lea	r9, QWORD PTR $T7[rsp]
	lea	rdx, QWORD PTR GLMModel$12[rbp-256]
	lea	rcx, QWORD PTR $T8[rsp]
	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
	movups	xmm6, XMMWORD PTR [rax]
	movups	xmm7, XMMWORD PTR [rax+16]
	movups	xmm8, XMMWORD PTR [rax+32]
	movups	xmm9, XMMWORD PTR [rax+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 164  : 		GLMModel = glm::scale(GLMModel, glm::vec3(ActorPtrs[i]->Scale.GetX(), ActorPtrs[i]->Scale.GetY(), ActorPtrs[i]->Scale.GetZ()));

	mov	rcx, QWORD PTR [rax+rdi*8]
	movss	xmm5, DWORD PTR [rcx+72]
	movss	xmm4, DWORD PTR [rcx+68]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm1, DWORD PTR [rcx+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm3, xmm6
	shufps	xmm3, xmm6, 255				; 000000ffH
	mulss	xmm3, xmm1

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movaps	xmm2, xmm6
	shufps	xmm2, xmm6, 170				; 000000aaH
	mulss	xmm2, xmm1
	movaps	xmm0, xmm6
	shufps	xmm0, xmm6, 85				; 00000055H
	mulss	xmm0, xmm1
	mulss	xmm6, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 81   : 		Result[0] = m[0] * v[0];

	shufps	xmm6, xmm6, 225				; 000000e1H
	movss	xmm6, xmm0
	shufps	xmm6, xmm6, 198				; 000000c6H
	movss	xmm6, xmm2
	shufps	xmm6, xmm6, 39				; 00000027H
	movss	xmm6, xmm3
	shufps	xmm6, xmm6, 57				; 00000039H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm2, xmm7
	shufps	xmm2, xmm7, 255				; 000000ffH
	mulss	xmm2, xmm4

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movaps	xmm1, xmm7
	shufps	xmm1, xmm7, 170				; 000000aaH
	mulss	xmm1, xmm4
	movaps	xmm0, xmm7
	shufps	xmm0, xmm7, 85				; 00000055H
	mulss	xmm0, xmm4
	mulss	xmm7, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 82   : 		Result[1] = m[1] * v[1];

	shufps	xmm7, xmm7, 225				; 000000e1H
	movss	xmm7, xmm0
	shufps	xmm7, xmm7, 198				; 000000c6H
	movss	xmm7, xmm1
	shufps	xmm7, xmm7, 39				; 00000027H
	movss	xmm7, xmm2
	shufps	xmm7, xmm7, 57				; 00000039H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm2, xmm8
	shufps	xmm2, xmm8, 255				; 000000ffH
	mulss	xmm2, xmm5

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movaps	xmm1, xmm8
	shufps	xmm1, xmm8, 170				; 000000aaH
	mulss	xmm1, xmm5
	movaps	xmm0, xmm8
	shufps	xmm0, xmm8, 85				; 00000055H
	mulss	xmm0, xmm5
	mulss	xmm8, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 83   : 		Result[2] = m[2] * v[2];

	shufps	xmm8, xmm8, 225				; 000000e1H
	movss	xmm8, xmm0
	shufps	xmm8, xmm8, 198				; 000000c6H
	movss	xmm8, xmm1
	shufps	xmm8, xmm8, 39				; 00000027H
	movss	xmm8, xmm2
	shufps	xmm8, xmm8, 57				; 00000039H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, rdi
	sub	rax, r12
	shl	rax, 6
	add	rax, QWORD PTR InstanceMatrices$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 166  : 		InstanceMatrices[i - Shrinking] = GLMModel;

	movups	XMMWORD PTR [rax], xmm6
	movups	XMMWORD PTR [rax+16], xmm7
	movups	XMMWORD PTR [rax+32], xmm8
	movups	XMMWORD PTR [rax+48], xmm9

; 167  : 	}

	mov	rdx, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	jmp	SHORT $LN2@DrawInstan
$LN363@DrawInstan:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Frustum.cpp

; 106  : 		if (FrustumValues[i][A] * X + FrustumValues[i][B] * Y + FrustumValues[i][C] * Z + FrustumValues[i][D] <= -Radius)

	mov	rdx, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
$LN12@DrawInstan:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 152  : 			Shrinking++;

	inc	r14d
	inc	r12
$LN2@DrawInstan:

; 148  : 	for (int i = 0; i < ActorPtrs.size(); i++)

	inc	r15d
	inc	rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR [rsi]
	mov	rcx, QWORD PTR [rsi+8]
	sub	rcx, r8
	sar	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 148  : 	for (int i = 0; i < ActorPtrs.size(); i++)

	movsxd	rax, r15d
	cmp	rax, rcx
	jb	$LL4@DrawInstan

; 168  : 
; 169  : 	if (Shrinking > 0)

	test	r14d, r14d
	jle	SHORT $LN364@DrawInstan
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR InstanceMatrices$[rbp-248]
	mov	rcx, QWORD PTR InstanceMatrices$[rbp-256]
	sub	rdx, rcx
	sar	rdx, 6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 170  : 		InstanceMatrices.resize(InstanceMatrices.size() - Shrinking);

	movsxd	rax, r14d
	mov	rbx, rdx
	sub	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rbx, rdx
	jae	SHORT $LN85@DrawInstan

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rbx, 6
	add	rbx, rcx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR InstanceMatrices$[rbp-248], rbx

; 1564 :             return;

	jmp	SHORT $LN364@DrawInstan
$LN85@DrawInstan:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN364@DrawInstan

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR InstanceMatrices$[rbp-240]
	sub	rax, QWORD PTR InstanceMatrices$[rbp-256]
	sar	rax, 6

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rbx, rax
	jbe	SHORT $LN87@DrawInstan

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rbx
	lea	rcx, QWORD PTR InstanceMatrices$[rbp-256]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN364@DrawInstan
$LN87@DrawInstan:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	rdi, QWORD PTR InstanceMatrices$[rbp-248]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN92@DrawInstan
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	shl	rbx, 6
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rdi
	call	memset
	add	rdi, rbx
$LN92@DrawInstan:
	mov	QWORD PTR InstanceMatrices$[rbp-248], rdi
$LN364@DrawInstan:

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [r13]

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r14, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 174  : 	for (uint32_t SubModelIndexOpaque : LODModel->OpaqueObjects)

	mov	r15, QWORD PTR [r14+56]
	mov	rsi, QWORD PTR [r14+48]
	cmp	rsi, r15
	je	SHORT $LN361@DrawInstan
	npad	1
$LL7@DrawInstan:

; 176  : 		LODModel->GL_Meshes[SubModelIndexOpaque].UpdateInstances(InstanceMatrices.size());

	mov	eax, DWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rbx, QWORD PTR [rax+rax*2]
	shl	rbx, 5
	mov	rcx, QWORD PTR [r14+24]
	add	rcx, rbx

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR InstanceMatrices$[rbp-248]
	sub	rdx, QWORD PTR InstanceMatrices$[rbp-256]
	sar	rdx, 6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 176  : 		LODModel->GL_Meshes[SubModelIndexOpaque].UpdateInstances(InstanceMatrices.size());

	call	?UpdateInstances@Mesh@@QEAAXI@Z		; Mesh::UpdateInstances
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [r14+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 21   : 	glBindBuffer(GL_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR [rbx+rdx+76]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR InstanceMatrices$[rbp-248]
	mov	r8, QWORD PTR InstanceMatrices$[rbp-256]
	sub	rdx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 120  : 	glBufferData(GL_ARRAY_BUFFER, Matrix.size() * sizeof(glm::mat4), Matrix.data(), GL_STATIC_DRAW);

	and	rdx, -64				; ffffffffffffffc0H
	mov	ecx, 34962				; 00008892H
	lea	r9d, QWORD PTR [rcx+82]
	call	QWORD PTR glad_glBufferData
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r14+24]
	add	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 178  : 		LODModel->GL_Meshes[SubModelIndexOpaque].Draw();

	call	?Draw@Mesh@@QEAAXPEAVShader@@H@Z	; Mesh::Draw

; 174  : 	for (uint32_t SubModelIndexOpaque : LODModel->OpaqueObjects)

	add	rsi, 4
	cmp	rsi, r15
	jne	SHORT $LL7@DrawInstan
$LN361@DrawInstan:

; 179  : 	}
; 180  : 
; 181  : 	for (uint32_t SubModelIndexTransparent : LODModel->TransparentObjects)

	mov	r15, QWORD PTR [r14+80]
	mov	rsi, QWORD PTR [r14+72]
	cmp	rsi, r15
	je	SHORT $LN373@DrawInstan
	npad	11
$LL10@DrawInstan:

; 183  : 		LODModel->GL_Meshes[SubModelIndexTransparent].UpdateInstances(InstanceMatrices.size());

	mov	eax, DWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rbx, QWORD PTR [rax+rax*2]
	shl	rbx, 5
	mov	rcx, QWORD PTR [r14+24]
	add	rcx, rbx

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR InstanceMatrices$[rbp-248]
	sub	rdx, QWORD PTR InstanceMatrices$[rbp-256]
	sar	rdx, 6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 183  : 		LODModel->GL_Meshes[SubModelIndexTransparent].UpdateInstances(InstanceMatrices.size());

	call	?UpdateInstances@Mesh@@QEAAXI@Z		; Mesh::UpdateInstances
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [r14+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VBO.cpp

; 21   : 	glBindBuffer(GL_ARRAY_BUFFER, ID);

	mov	edx, DWORD PTR [rbx+rdx+76]
	mov	ecx, 34962				; 00008892H
	call	QWORD PTR glad_glBindBuffer
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR InstanceMatrices$[rbp-248]
	mov	r8, QWORD PTR InstanceMatrices$[rbp-256]
	sub	rdx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 120  : 	glBufferData(GL_ARRAY_BUFFER, Matrix.size() * sizeof(glm::mat4), Matrix.data(), GL_STATIC_DRAW);

	and	rdx, -64				; ffffffffffffffc0H
	mov	ecx, 34962				; 00008892H
	lea	r9d, QWORD PTR [rcx+82]
	call	QWORD PTR glad_glBufferData
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r14+24]
	add	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 185  : 		LODModel->GL_Meshes[SubModelIndexTransparent].Draw();

	call	?Draw@Mesh@@QEAAXPEAVShader@@H@Z	; Mesh::Draw

; 179  : 	}
; 180  : 
; 181  : 	for (uint32_t SubModelIndexTransparent : LODModel->TransparentObjects)

	add	rsi, 4
	cmp	rsi, r15
	jne	SHORT $LL10@DrawInstan
$LN373@DrawInstan:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR InstanceMatrices$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN32@DrawInstan

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR InstanceMatrices$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN44@DrawInstan

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN44@DrawInstan
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@DrawInstan:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN32@DrawInstan:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 187  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+384]
	mov	rbx, QWORD PTR [r11+80]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN376@DrawInstan:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Xlength
	int	3
$LN374@DrawInstan:
?DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z ENDP ; UIMapView::DrawInstancedActor
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 48
$T5 = 60
$T6 = 72
$T7 = 84
$T8 = 96
$T9 = 96
$T10 = 96
$T11 = 96
InstanceMatrices$ = 160
GLMModel$12 = 192
__$ArrayPad$ = 256
Model$ = 448
ActorPtrs$ = 456
?dtor$0@?0??DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z@4HA PROC ; `UIMapView::DrawInstancedActor'::`1'::dtor$0
	lea	rcx, QWORD PTR InstanceMatrices$[rdx]
	jmp	??1?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@XZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::~vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
?dtor$0@?0??DrawInstancedActor@UIMapView@@YAXPEAVBfresFile@@AEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@Z@4HA ENDP ; `UIMapView::DrawInstancedActor'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Framebuffer.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_mat4x4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_mat4x4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIOutliner.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIOutliner.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp
;	COMDAT ?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z
_TEXT	SEGMENT
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 64
MousePos$ = 96
$T7 = 104
$T8 = 104
<begin>$L1$1$ = 120
$T9 = 120
$T10 = 144
$T11 = 144
$T12 = 160
$T13 = 160
$T14 = 176
$T15 = 176
SceneWindowSize$ = 192
<end>$L2$1$ = 200
$T16 = 200
<end>$L1$1$ = 216
$T17 = 216
$T18 = 232
$T19 = 256
$T20 = 256
$T21 = 320
$T22 = 320
$T23 = 336
$T24 = 336
$T25 = 336
$T26 = 336
$T27 = 336
$T28 = 336
$T29 = 336
$T30 = 336
Data$31 = 400
GLMModel$32 = 416
GLMModel$33 = 416
PickedActorId$34 = 480
MergedActorIds$35 = 496
__$ArrayPad$ = 560
?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z PROC	; UIMapView::SelectActorByClicking, COMDAT

; 190  : {

$LN710:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-536]
	sub	rsp, 736				; 000002e0H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	movaps	XMMWORD PTR [rax-104], xmm8
	movaps	XMMWORD PTR [rax-120], xmm9
	movaps	XMMWORD PTR [rax-136], xmm10
	movaps	XMMWORD PTR [rax-152], xmm11
	movaps	XMMWORD PTR [rax-168], xmm12
	movaps	XMMWORD PTR [rax-184], xmm13
	movaps	XMMWORD PTR [rax-200], xmm14
	movaps	XMMWORD PTR [rax-216], xmm15
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	QWORD PTR MousePos$[rsp], rdx
	mov	QWORD PTR SceneWindowSize$[rbp-256], rcx

; 191  : 	if (!RenderSettings.AllowSelectingActor || !Focused) return;

	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+5, 0
	je	$LN21@SelectActo
	cmp	BYTE PTR ?Focused@UIMapView@@3_NA, 0	; UIMapView::Focused
	je	$LN21@SelectActo

; 192  : 	if (glfwGetMouseButton(Window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS && glfwGetMouseButton(Window, GLFW_MOUSE_BUTTON_RIGHT) != GLFW_PRESS && !ImGui::IsAnyItemHovered())

	xor	edx, edx
	mov	rcx, QWORD PTR ?Window@UIMapView@@3PEAUGLFWwindow@@EA ; UIMapView::Window
	call	glfwGetMouseButton
	cmp	eax, 1
	jne	$LN21@SelectActo
	mov	edx, eax
	mov	rcx, QWORD PTR ?Window@UIMapView@@3PEAUGLFWwindow@@EA ; UIMapView::Window
	call	glfwGetMouseButton
	cmp	eax, 1
	je	$LN21@SelectActo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5567 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5568 :     return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;

	cmp	DWORD PTR [rax+16484], 0
	jne	SHORT $LN121@SelectActo
	cmp	DWORD PTR [rax+16488], 0
	jne	SHORT $LN121@SelectActo
	xor	al, al
	jmp	SHORT $LN122@SelectActo
$LN121@SelectActo:
	mov	al, 1
$LN122@SelectActo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 192  : 	if (glfwGetMouseButton(Window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS && glfwGetMouseButton(Window, GLFW_MOUSE_BUTTON_RIGHT) != GLFW_PRESS && !ImGui::IsAnyItemHovered())

	test	al, al
	jne	$LN21@SelectActo

; 193  : 	{
; 194  : 		if (!(SceneWindowSize.x > MousePos.x && SceneWindowSize.y > MousePos.y && MousePos.x > 0 && MousePos.y > 0)) return;

	movss	xmm0, DWORD PTR SceneWindowSize$[rbp-256]
	movss	xmm1, DWORD PTR MousePos$[rsp]
	comiss	xmm0, xmm1
	jbe	$LN21@SelectActo
	movss	xmm2, DWORD PTR MousePos$[rsp+4]
	movss	xmm0, DWORD PTR SceneWindowSize$[rbp-252]
	comiss	xmm0, xmm2
	jbe	$LN21@SelectActo
	xorps	xmm0, xmm0
	comiss	xmm1, xmm0
	jbe	$LN21@SelectActo
	comiss	xmm2, xmm0
	jbe	$LN21@SelectActo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_gizmo\ImGuizmo.cpp

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	mov	ebx, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1444
	test	bl, 7

; 1003 :       return (Intersects(gContext.mOperation, TRANSLATE) && GetMoveType(gContext.mOperation, NULL) != MT_NONE) ||

	je	SHORT $LN432@SelectActo
	xor	edx, edx
	mov	ecx, ebx
	call	?GetMoveType@ImGuizmo@@YAHW4OPERATION@1@PEAUvec_t@1@@Z ; ImGuizmo::GetMoveType
	test	eax, eax
	jne	SHORT $LN670@SelectActo
	mov	ebx, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1444
$LN432@SelectActo:

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	bl, 120					; 00000078H

; 1003 :       return (Intersects(gContext.mOperation, TRANSLATE) && GetMoveType(gContext.mOperation, NULL) != MT_NONE) ||

	je	SHORT $LN433@SelectActo
	mov	ecx, ebx
	call	?GetRotateType@ImGuizmo@@YAHW4OPERATION@1@@Z ; ImGuizmo::GetRotateType
	test	eax, eax
	jne	SHORT $LN670@SelectActo
$LN433@SelectActo:

; 58   :      return static_cast<OPERATION>(static_cast<int>(lhs) & static_cast<int>(rhs));

	test	ebx, 896				; 00000380H

; 1003 :       return (Intersects(gContext.mOperation, TRANSLATE) && GetMoveType(gContext.mOperation, NULL) != MT_NONE) ||

	je	SHORT $LN435@SelectActo
	mov	ecx, ebx
	call	?GetScaleType@ImGuizmo@@YAHW4OPERATION@1@@Z ; ImGuizmo::GetScaleType
	test	eax, eax
	jne	SHORT $LN670@SelectActo
$LN435@SelectActo:

; 993  :       return (gContext.mbUsing && (gContext.mActualID == -1 || gContext.mActualID == gContext.mEditingID)) || gContext.mbUsingBounds;

	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1084, 0
	je	SHORT $LN458@SelectActo
	mov	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1436
	cmp	eax, -1
	je	SHORT $LN670@SelectActo
	cmp	eax, DWORD PTR ?gContext@ImGuizmo@@3UContext@1@A+1440
	je	SHORT $LN670@SelectActo
$LN458@SelectActo:
	cmp	BYTE PTR ?gContext@ImGuizmo@@3UContext@1@A+1332, 0
	je	SHORT $LN22@SelectActo
$LN670@SelectActo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 195  : 		if (ImGuizmo::IsOver() && UIOutliner::SelectedActor != nullptr) return;

	cmp	QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA, 0 ; UIOutliner::SelectedActor
	jne	$LN21@SelectActo
$LN22@SelectActo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Framebuffer.cpp

; 50   : 	glBindFramebuffer(GL_FRAMEBUFFER, m_FBO);

	mov	rdx, QWORD PTR ?MapViewFramebuffer@UIMapView@@3PEAVFramebuffer@@EA ; UIMapView::MapViewFramebuffer
	mov	edx, DWORD PTR [rdx]
	mov	ecx, 36160				; 00008d40H
	call	QWORD PTR glad_glBindFramebuffer
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 198  : 		glClearColor(ClearColor.x * ClearColor.w, ClearColor.y * ClearColor.w, ClearColor.z * ClearColor.w, ClearColor.w);

	movss	xmm2, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A+8
	movss	xmm3, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A+12
	mulss	xmm2, xmm3
	movss	xmm1, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A+4
	mulss	xmm1, xmm3
	movss	xmm0, DWORD PTR ?ClearColor@UIMapView@@3UImVec4@@A
	mulss	xmm0, xmm3
	call	QWORD PTR glad_glClearColor

; 199  : 		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

	mov	ecx, 17664				; 00004500H
	call	QWORD PTR glad_glClear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp

; 75   : 	glUseProgram(ID);

	mov	rcx, QWORD PTR ?PickingShader@UIMapView@@3PEAVShader@@EA ; UIMapView::PickingShader
	mov	ecx, DWORD PTR [rcx]
	call	QWORD PTR glad_glUseProgram
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 205  : 		for (int ActorIndex = 0; ActorIndex < ActorMgr::GetActors().size(); ActorIndex++)

	xor	r12d, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A+8
	sub	rax, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A
	sar	rax, 3
	mov	r14, -6430974998173972123		; a6c0964fda6c0965H
	imul	rax, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 205  : 		for (int ActorIndex = 0; ActorIndex < ActorMgr::GetActors().size(); ActorIndex++)

	lea	rdi, OFFSET FLAT:??_C@_04GJPNONHK@_Far@
	lea	r10, OFFSET FLAT:??_C@_04MCJDHKLE@Npc_@
	lea	r15, OFFSET FLAT:??_C@_04KPICECCB@Area@
	movss	xmm13, DWORD PTR __real@437f0000
	movss	xmm14, DWORD PTR __real@3f800000
	movss	xmm15, DWORD PTR __real@3c8efa35
	test	rax, rax
	je	$LN3@SelectActo
	xor	r14d, r14d
	lea	rsi, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A ; UIMapView::CameraView
	lea	r13, OFFSET FLAT:??_C@_04KPICECCB@Area@
	npad	7
$LL4@SelectActo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdi, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 208  : 			if (!CurrentActor.Model->IsDefaultModel() && !RenderSettings.RenderVisibleActors) continue;

	mov	rax, QWORD PTR [r14+rdi+424]
	movzx	r15d, BYTE PTR [rax+72]
	test	r15b, r15b
	jne	SHORT $LN664@SelectActo
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A, r15b

; 209  : 			if (CurrentActor.Model->IsDefaultModel() && !RenderSettings.RenderInvisibleActors && !CurrentActor.IsUMii) continue;

	jmp	SHORT $LN704@SelectActo
$LN664@SelectActo:
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+1, 0
	jne	SHORT $LN24@SelectActo
	cmp	BYTE PTR [r14+rdi+688], 0
$LN704@SelectActo:

; 210  : 			if (CurrentActor.Gyml.ends_with("_Far") && !RenderSettings.RenderFarActors) continue;

	je	$LN2@SelectActo
$LN24@SelectActo:
	lea	rbx, QWORD PTR [rdi+8]
	add	rbx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r9, QWORD PTR [rbx+24]

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN666@SelectActo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN666@SelectActo:

; 4689 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);

	mov	r8, QWORD PTR [rbx+16]

; 1435 :         const auto _Rightsize = _Right._Mysize;

	cmp	r8, 4

; 1436 :         if (_Mysize < _Rightsize) {

	jb	SHORT $LN25@SelectActo

; 1437 :             return false;
; 1438 :         }
; 1439 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;

	lea	rdx, QWORD PTR [r8+rax]

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	xor	ecx, ecx
	lea	r10, OFFSET FLAT:??_C@_04GJPNONHK@_Far@
	npad	8
$LL693@SelectActo:
	movzx	eax, BYTE PTR [rdx+rcx-4]
	inc	rcx
	cmp	al, BYTE PTR [r10+rcx-1]
	jne	SHORT $LN694@SelectActo
	cmp	rcx, 4
	jne	SHORT $LL693@SelectActo
	xor	eax, eax
	jmp	SHORT $LN695@SelectActo
$LN694@SelectActo:
	sbb	eax, eax
	or	eax, 1
$LN695@SelectActo:

; 1439 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
	sete	al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 210  : 			if (CurrentActor.Gyml.ends_with("_Far") && !RenderSettings.RenderFarActors) continue;

	lea	r10, OFFSET FLAT:??_C@_04MCJDHKLE@Npc_@
	test	al, al
	je	SHORT $LN25@SelectActo
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+3, 0
	je	$LN2@SelectActo
$LN25@SelectActo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN667@SelectActo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rbx]
$LN667@SelectActo:

; 1419 :         const auto _Rightsize = _Right._Mysize;

	cmp	r8, 4

; 1420 :         if (_Mysize < _Rightsize) {

	jb	SHORT $LN26@SelectActo

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	xor	ecx, ecx
	npad	1
$LL689@SelectActo:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	cmp	al, BYTE PTR [r10+rcx-1]
	jne	SHORT $LN690@SelectActo
	cmp	rcx, 4
	jne	SHORT $LL689@SelectActo
	xor	eax, eax
	jmp	SHORT $LN691@SelectActo
$LN690@SelectActo:
	sbb	eax, eax
	or	eax, 1
$LN691@SelectActo:

; 1423 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
	sete	al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 211  : 			if (CurrentActor.Gyml.starts_with("Npc_") && !RenderSettings.RenderNPCs) continue;

	test	al, al
	je	SHORT $LN26@SelectActo
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+4, 0
	je	$LN2@SelectActo
$LN26@SelectActo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN412@SelectActo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rbx]
$LN412@SelectActo:

; 577  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	cmp	r8, 4
	jb	SHORT $LN27@SelectActo

; 578  :         // xpos cannot exist, report failure
; 579  :         // N4950 [string.view.find]/3 says:
; 580  :         // 1. _Start_at <= xpos
; 581  :         // 2. xpos + _Needle_size <= _Hay_size;
; 582  :         // therefore:
; 583  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 584  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 585  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 586  :         return static_cast<size_t>(-1);
; 587  :     }
; 588  : 
; 589  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 590  :         return _Start_at;
; 591  :     }
; 592  : 
; 593  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	lea	rsi, QWORD PTR [r8+rbx]

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [rsi-3]
	sub	r8, rbx

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, 65					; 00000041H
	mov	rcx, rbx
	call	memchr

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	je	SHORT $LN702@SelectActo
	npad	1
$LL419@SelectActo:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	xor	edx, edx
$LL685@SelectActo:
	movzx	ecx, BYTE PTR [rax+rdx]
	inc	rdx
	cmp	cl, BYTE PTR [rdx+r13-1]
	jne	SHORT $LN686@SelectActo
	cmp	rdx, 4
	jne	SHORT $LL685@SelectActo
	xor	ecx, ecx
	jmp	SHORT $LN687@SelectActo
$LN686@SelectActo:
	sbb	ecx, ecx
	or	ecx, 1
$LN687@SelectActo:

; 600  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	test	ecx, ecx
	je	$LN580@SelectActo

; 594  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	inc	rax

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [rsi-3]
	sub	r8, rax

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, 65					; 00000041H
	mov	rcx, rax
	call	memchr

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	jne	SHORT $LL419@SelectActo
$LN702@SelectActo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 214  : 			int R = (ActorIndex & 0x000000FF) >> 0;

	lea	rsi, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A ; UIMapView::CameraView
$LN27@SelectActo:
	movzx	r8d, r12b

; 215  : 			int G = (ActorIndex & 0x0000FF00) >> 8;

	mov	eax, r12d
	sar	eax, 8
	movzx	edx, al

; 216  : 			int B = (ActorIndex & 0x00FF0000) >> 16;

	mov	eax, r12d
	sar	eax, 16
	movzx	ecx, al

; 217  : 
; 218  : 			glUniform4f(glGetUniformLocation(PickingShader->ID, "PickingColor"), R / 255.0f, G / 255.0f, B / 255.0f, 1.0f);

	mov	rbx, QWORD PTR glad_glUniform4f
	mov	rax, QWORD PTR glad_glGetUniformLocation
	movd	xmm8, ecx
	cvtdq2ps xmm8, xmm8
	divss	xmm8, xmm13
	movd	xmm7, edx
	cvtdq2ps xmm7, xmm7
	divss	xmm7, xmm13
	movd	xmm6, r8d
	cvtdq2ps xmm6, xmm6
	divss	xmm6, xmm13
	lea	rdx, OFFSET FLAT:??_C@_0N@GKKHGHLK@PickingColor@
	mov	rcx, QWORD PTR ?PickingShader@UIMapView@@3PEAVShader@@EA ; UIMapView::PickingShader
	mov	ecx, DWORD PTR [rcx]
	call	rax
	mov	ecx, eax
	movss	DWORD PTR [rsp+32], xmm14
	movaps	xmm3, xmm8
	movaps	xmm2, xmm7
	movaps	xmm1, xmm6
	call	rbx

; 219  : 
; 220  : 			if (!CurrentActor.IsUMii)

	cmp	BYTE PTR [r14+rdi+688], 0
	jne	$LN28@SelectActo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movaps	XMMWORD PTR GLMModel$33[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	XMMWORD PTR GLMModel$33[rbp-240], xmm1
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR GLMModel$33[rbp-224], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR GLMModel$33[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 224  : 				GLMModel = glm::translate(GLMModel, glm::vec3(CurrentActor.Translate.GetX(), CurrentActor.Translate.GetY(), CurrentActor.Translate.GetZ()));

	movss	xmm2, DWORD PTR [r14+rdi+60]
	movss	xmm1, DWORD PTR [r14+rdi+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm0, DWORD PTR [r14+rdi+52]
	movss	DWORD PTR $T17[rbp-256], xmm0
	movss	DWORD PTR $T17[rbp-252], xmm1
	movss	DWORD PTR $T17[rbp-248], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 224  : 				GLMModel = glm::translate(GLMModel, glm::vec3(CurrentActor.Translate.GetX(), CurrentActor.Translate.GetY(), CurrentActor.Translate.GetZ()));

	lea	r8, QWORD PTR $T17[rbp-256]
	lea	rdx, QWORD PTR GLMModel$33[rbp-256]
	lea	rcx, QWORD PTR $T30[rbp-256]
	call	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR GLMModel$33[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$33[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$33[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$33[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T16[rbp-256], 0

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T16[rbp-248], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 226  : 				GLMModel = glm::rotate(GLMModel, glm::radians(CurrentActor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	movss	xmm2, DWORD PTR [r14+rdi+84]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 226  : 				GLMModel = glm::rotate(GLMModel, glm::radians(CurrentActor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	lea	r9, QWORD PTR $T16[rbp-256]
	lea	rdx, QWORD PTR GLMModel$33[rbp-256]
	lea	rcx, QWORD PTR $T29[rbp-256]
	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR GLMModel$33[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$33[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$33[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$33[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	DWORD PTR $T9[rsp], 0

; 55   : 		, y(static_cast<T>(_y))

	mov	QWORD PTR $T9[rsp+4], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 227  : 				GLMModel = glm::rotate(GLMModel, glm::radians(CurrentActor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	movss	xmm2, DWORD PTR [r14+rdi+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 227  : 				GLMModel = glm::rotate(GLMModel, glm::radians(CurrentActor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	lea	r9, QWORD PTR $T9[rsp]
	lea	rdx, QWORD PTR GLMModel$33[rbp-256]
	lea	rcx, QWORD PTR $T28[rbp-256]
	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR GLMModel$33[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$33[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$33[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$33[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T8[rsp], 1065353216		; 3f800000H

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T8[rsp+8], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 30   : 	return this->m_Data[0];

	movss	xmm2, DWORD PTR [r14+rdi+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 228  : 				GLMModel = glm::rotate(GLMModel, glm::radians(CurrentActor.Rotate.GetX()), glm::vec3(1.0, 0.0f, 0.0));

	lea	r9, QWORD PTR $T8[rsp]
	lea	rdx, QWORD PTR GLMModel$33[rbp-256]
	lea	rcx, QWORD PTR $T27[rbp-256]
	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
	movups	xmm3, XMMWORD PTR [rax]
	movups	xmm7, XMMWORD PTR [rax+16]
	movups	xmm8, XMMWORD PTR [rax+32]
	movups	xmm10, XMMWORD PTR [rax+48]

; 229  : 
; 230  : 				GLMModel = glm::scale(GLMModel, glm::vec3(CurrentActor.Scale.GetX(), CurrentActor.Scale.GetY(), CurrentActor.Scale.GetZ()));

	movss	xmm6, DWORD PTR [r14+rdi+72]
	movss	xmm5, DWORD PTR [r14+rdi+68]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm9, DWORD PTR [r14+rdi+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm4, xmm9
	movaps	xmm0, xmm3
	shufps	xmm0, xmm3, 255				; 000000ffH
	mulss	xmm4, xmm0

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movaps	xmm2, xmm9
	movaps	xmm0, xmm3
	shufps	xmm0, xmm3, 170				; 000000aaH
	mulss	xmm2, xmm0
	movaps	xmm1, xmm9
	movaps	xmm0, xmm3
	shufps	xmm0, xmm3, 85				; 00000055H
	mulss	xmm1, xmm0
	mulss	xmm9, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 81   : 		Result[0] = m[0] * v[0];

	shufps	xmm9, xmm9, 225				; 000000e1H
	movss	xmm9, xmm1
	shufps	xmm9, xmm9, 198				; 000000c6H
	movss	xmm9, xmm2
	shufps	xmm9, xmm9, 39				; 00000027H
	movss	xmm9, xmm4
	shufps	xmm9, xmm9, 57				; 00000039H
	movups	XMMWORD PTR $T5[rsp], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm2, xmm7
	shufps	xmm2, xmm7, 255				; 000000ffH
	mulss	xmm2, xmm5

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movaps	xmm1, xmm7
	shufps	xmm1, xmm7, 170				; 000000aaH
	mulss	xmm1, xmm5
	movaps	xmm0, xmm7
	shufps	xmm0, xmm7, 85				; 00000055H
	mulss	xmm0, xmm5
	mulss	xmm7, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 82   : 		Result[1] = m[1] * v[1];

	shufps	xmm7, xmm7, 225				; 000000e1H
	movss	xmm7, xmm0
	shufps	xmm7, xmm7, 198				; 000000c6H
	movss	xmm7, xmm1
	shufps	xmm7, xmm7, 39				; 00000027H
	movss	xmm7, xmm2
	shufps	xmm7, xmm7, 57				; 00000039H
	movups	XMMWORD PTR $T4[rsp], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm2, xmm8
	shufps	xmm2, xmm8, 255				; 000000ffH
	mulss	xmm2, xmm6

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movaps	xmm1, xmm8
	shufps	xmm1, xmm8, 170				; 000000aaH
	mulss	xmm1, xmm6
	movaps	xmm0, xmm8
	shufps	xmm0, xmm8, 85				; 00000055H
	mulss	xmm0, xmm6
	mulss	xmm8, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 83   : 		Result[2] = m[2] * v[2];

	shufps	xmm8, xmm8, 225				; 000000e1H
	movss	xmm8, xmm0
	shufps	xmm8, xmm8, 198				; 000000c6H
	movss	xmm8, xmm1
	shufps	xmm8, xmm8, 39				; 00000027H
	movss	xmm8, xmm2
	shufps	xmm8, xmm8, 57				; 00000039H
	movups	XMMWORD PTR $T3[rsp], xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [r14+rdi+424]
	mov	rcx, QWORD PTR [rax]

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 234  : 				for (Mesh& SubMesh : LODModel->GL_Meshes)

	mov	r15, QWORD PTR [rax+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_mat4x4.inl

; 292  : 		return this->value[i];

	mov	rsi, QWORD PTR [rax+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 234  : 				for (Mesh& SubMesh : LODModel->GL_Meshes)

	cmp	rsi, r15
	je	$LN696@SelectActo
	npad	6
$LL7@SelectActo:

; 235  : 				{
; 236  : 					SubMesh.DrawPicking(PickingShader, &CameraView, GLMModel);

	movaps	XMMWORD PTR $T20[rbp-256], xmm9
	movaps	XMMWORD PTR $T20[rbp-240], xmm7
	movaps	XMMWORD PTR $T20[rbp-224], xmm8
	movaps	XMMWORD PTR $T20[rbp-208], xmm10
	mov	rdi, QWORD PTR ?PickingShader@UIMapView@@3PEAVShader@@EA ; UIMapView::PickingShader
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp

; 75   : 	glUseProgram(ID);

	mov	ecx, DWORD PTR [rdi]
	call	QWORD PTR glad_glUseProgram
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 21   : 	glBindVertexArray(ID);

	mov	ecx, DWORD PTR [rsi+72]
	call	QWORD PTR glad_glBindVertexArray
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 33   : 	glUniformMatrix4fv(glGetUniformLocation(shader->ID, uniform), 1, GL_FALSE, glm::value_ptr(CameraMatrix));

	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_09KNKDONHI@camMatrix@
	mov	ecx, DWORD PTR [rdi]
	call	rax
	lea	r9, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A+164
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 93   : 	glUniformMatrix4fv(glGetUniformLocation(Shader->ID, "modelMatrix"), 1, GL_FALSE, glm::value_ptr(Matrix));

	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_0M@DDLHAGJC@modelMatrix@
	mov	ecx, DWORD PTR [rdi]
	call	rax
	lea	r9, QWORD PTR $T20[rbp-256]
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rsi+32]
	sub	rdx, QWORD PTR [rsi+24]
	sar	rdx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 96   : 	glDrawElements(GL_TRIANGLES, sizeof(int) * indices.size(), GL_UNSIGNED_INT, 0);

	lea	edx, DWORD PTR [rdx*4]
	xor	r9d, r9d
	lea	ecx, QWORD PTR [r9+4]
	mov	r8d, 5125				; 00001405H
	call	QWORD PTR glad_glDrawElements
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 234  : 				for (Mesh& SubMesh : LODModel->GL_Meshes)

	add	rsi, 96					; 00000060H
	cmp	rsi, r15
	jne	$LL7@SelectActo
$LN696@SelectActo:

; 205  : 		for (int ActorIndex = 0; ActorIndex < ActorMgr::GetActors().size(); ActorIndex++)

	lea	rsi, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A ; UIMapView::CameraView
	jmp	$LN697@SelectActo
$LN580@SelectActo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 601  :             return static_cast<size_t>(_Match_try - _Haystack);

	sub	rax, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 212  : 			if (CurrentActor.Gyml.find("Area") != std::string::npos && CurrentActor.Model->IsDefaultModel() && !RenderSettings.RenderAreas) continue;

	cmp	rax, -1
	je	$LN702@SelectActo
	lea	rsi, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A ; UIMapView::CameraView
	test	r15b, r15b
	je	$LN27@SelectActo
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+2, 0
	je	SHORT $LN697@SelectActo

; 214  : 			int R = (ActorIndex & 0x000000FF) >> 0;

	jmp	$LN27@SelectActo
$LN28@SelectActo:

; 237  : 				}
; 238  : 			}
; 239  : 			else
; 240  : 			{
; 241  : 				CurrentActor.UMiiData.Draw(CurrentActor.Translate, CurrentActor.Rotate, CurrentActor.Scale, PickingShader, true, &CameraView);

	lea	rcx, QWORD PTR [rdi+696]
	add	rcx, r14
	movsd	xmm0, QWORD PTR [r14+rdi+64]
	movsd	QWORD PTR $T14[rbp-256], xmm0
	mov	eax, DWORD PTR [r14+rdi+72]
	mov	DWORD PTR $T14[rbp-248], eax
	movsd	xmm0, QWORD PTR [r14+rdi+76]
	movsd	QWORD PTR $T12[rbp-256], xmm0
	mov	eax, DWORD PTR [r14+rdi+84]
	mov	DWORD PTR $T12[rbp-248], eax
	movsd	xmm0, QWORD PTR [r14+rdi+52]
	movsd	QWORD PTR $T10[rbp-256], xmm0
	mov	eax, DWORD PTR [r14+rdi+60]
	mov	DWORD PTR $T10[rbp-248], eax
	mov	QWORD PTR [rsp+48], rsi
	mov	BYTE PTR [rsp+40], 1
	mov	rax, QWORD PTR ?PickingShader@UIMapView@@3PEAVShader@@EA ; UIMapView::PickingShader
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T14[rbp-256]
	lea	r8, QWORD PTR $T12[rbp-256]
	lea	rdx, QWORD PTR $T10[rbp-256]
	call	?Draw@UMii@@QEAAXVVector3F@@00PEAVShader@@_NPEAVCamera@@@Z ; UMii::Draw
$LN697@SelectActo:

; 205  : 		for (int ActorIndex = 0; ActorIndex < ActorMgr::GetActors().size(); ActorIndex++)

	lea	r10, OFFSET FLAT:??_C@_04MCJDHKLE@Npc_@
$LN2@SelectActo:
	inc	r12d
	add	r14, 872				; 00000368H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A+8
	sub	rcx, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A
	sar	rcx, 3
	mov	rax, -6430974998173972123		; a6c0964fda6c0965H
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 205  : 		for (int ActorIndex = 0; ActorIndex < ActorMgr::GetActors().size(); ActorIndex++)

	movsxd	rax, r12d
	cmp	rax, rcx
	jb	$LL4@SelectActo
	lea	r15, OFFSET FLAT:??_C@_04KPICECCB@Area@
	lea	rdi, OFFSET FLAT:??_C@_04GJPNONHK@_Far@
	mov	r14, -6430974998173972123		; a6c0964fda6c0965H
$LN3@SelectActo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rsi, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A+8
	sub	rsi, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A
	sar	rsi, 3
	imul	rsi, r14
	mov	QWORD PTR $T7[rsp], rsi
	xorps	xmm0, xmm0
	movups	XMMWORD PTR MergedActorIds$35[rbp-256], xmm0
	movups	XMMWORD PTR MergedActorIds$35[rbp-240], xmm0
	movups	XMMWORD PTR MergedActorIds$35[rbp-224], xmm0
	movups	XMMWORD PTR MergedActorIds$35[rbp-208], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	DWORD PTR MergedActorIds$35[rbp-256], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR MergedActorIds$35[rbp-248], 0
	mov	QWORD PTR MergedActorIds$35[rbp-240], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR MergedActorIds$35[rbp-248], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebx, ebx
	mov	QWORD PTR MergedActorIds$35[rbp-232], rbx
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR MergedActorIds$35[rbp-224], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR MergedActorIds$35[rbp-208], 7
	mov	QWORD PTR MergedActorIds$35[rbp-200], 8

; 377  :         // construct empty hash table
; 378  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR MergedActorIds$35[rbp-256], 1065353216 ; 3f800000H

; 379  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, rax
	lea	edx, QWORD PTR [rbx+16]
	lea	rcx, QWORD PTR MergedActorIds$35[rbp-232]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Assign_grow
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 249  : 		for (Actor& MergedActorMain : ActorMgr::GetActors())

	mov	rax, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A+8
	mov	QWORD PTR <end>$L1$1$[rbp-256], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1836 :         auto _Newhead = _Al.allocate(1);

	mov	rcx, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A
	mov	QWORD PTR <begin>$L1$1$[rsp], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 249  : 		for (Actor& MergedActorMain : ActorMgr::GetActors())

	cmp	rcx, rax
	je	$LN9@SelectActo
$LL10@SelectActo:

; 250  : 		{
; 251  : 			for (Actor& MergedActor : MergedActorMain.MergedActorContent)

	mov	rax, QWORD PTR [rcx+440]
	mov	QWORD PTR <end>$L2$1$[rbp-256], rax
	mov	r13, QWORD PTR [rcx+432]
	cmp	r13, rax
	je	$LN8@SelectActo
	lea	r12, QWORD PTR [r13+8]
	npad	14
$LL13@SelectActo:

; 252  : 			{
; 253  : 				if (!MergedActor.Model->IsDefaultModel() && !RenderSettings.RenderVisibleActors) continue;

	mov	rax, QWORD PTR [r12+416]
	movzx	r14d, BYTE PTR [rax+72]
	test	r14b, r14b
	jne	SHORT $LN663@SelectActo
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A, r14b

; 254  : 				if (MergedActor.Model->IsDefaultModel() && !RenderSettings.RenderInvisibleActors && !MergedActor.IsUMii) continue;

	jmp	SHORT $LN705@SelectActo
$LN663@SelectActo:
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+1, 0
	jne	SHORT $LN31@SelectActo
	cmp	BYTE PTR [r12+680], 0
$LN705@SelectActo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	je	$LN11@SelectActo
$LN31@SelectActo:
	mov	rax, r12

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r9, QWORD PTR [r12+24]

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN668@SelectActo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [r12]
$LN668@SelectActo:

; 4689 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);

	mov	r8, QWORD PTR [r12+16]

; 1435 :         const auto _Rightsize = _Right._Mysize;

	cmp	r8, 4

; 1436 :         if (_Mysize < _Rightsize) {

	jb	SHORT $LN32@SelectActo

; 1437 :             return false;
; 1438 :         }
; 1439 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;

	lea	rdx, QWORD PTR [rax+r8]

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	xor	ecx, ecx
	npad	10
$LL681@SelectActo:
	movzx	eax, BYTE PTR [rdx+rcx-4]
	inc	rcx
	cmp	al, BYTE PTR [rdi+rcx-1]
	jne	SHORT $LN682@SelectActo
	cmp	rcx, 4
	jne	SHORT $LL681@SelectActo
	xor	eax, eax
	jmp	SHORT $LN683@SelectActo
$LN682@SelectActo:
	sbb	eax, eax
	or	eax, 1
$LN683@SelectActo:

; 1439 :         return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
	sete	al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 255  : 				if (MergedActor.Gyml.ends_with("_Far") && !RenderSettings.RenderFarActors) continue;

	test	al, al
	je	SHORT $LN32@SelectActo
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+3, 0
	je	$LN11@SelectActo
$LN32@SelectActo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, r12

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN669@SelectActo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [r12]
$LN669@SelectActo:

; 1419 :         const auto _Rightsize = _Right._Mysize;

	cmp	r8, 4

; 1420 :         if (_Mysize < _Rightsize) {

	jb	SHORT $LN33@SelectActo

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	xor	ecx, ecx
	lea	r10, OFFSET FLAT:??_C@_04MCJDHKLE@Npc_@
	npad	1
$LL677@SelectActo:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	cmp	al, BYTE PTR [r10+rcx-1]
	jne	SHORT $LN678@SelectActo
	cmp	rcx, 4
	jne	SHORT $LL677@SelectActo
	xor	eax, eax
	jmp	SHORT $LN679@SelectActo
$LN678@SelectActo:
	sbb	eax, eax
	or	eax, 1
$LN679@SelectActo:

; 1423 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
	sete	al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 256  : 				if (MergedActor.Gyml.starts_with("Npc_") && !RenderSettings.RenderNPCs) continue;

	test	al, al
	je	SHORT $LN33@SelectActo
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+4, 0
	je	$LN11@SelectActo
$LN33@SelectActo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdi, r12

; 2236 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN101@SelectActo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [r12]
$LN101@SelectActo:

; 577  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	cmp	r8, 4
	jb	$LN34@SelectActo

; 578  :         // xpos cannot exist, report failure
; 579  :         // N4950 [string.view.find]/3 says:
; 580  :         // 1. _Start_at <= xpos
; 581  :         // 2. xpos + _Needle_size <= _Hay_size;
; 582  :         // therefore:
; 583  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 584  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 585  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 586  :         return static_cast<size_t>(-1);
; 587  :     }
; 588  : 
; 589  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 590  :         return _Start_at;
; 591  :     }
; 592  : 
; 593  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	lea	rbx, QWORD PTR [r8+rdi]

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [rbx-3]
	sub	r8, rdi

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, 65					; 00000041H
	mov	rcx, rdi
	call	memchr

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	je	SHORT $LN34@SelectActo
	npad	9
$LL108@SelectActo:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	xor	edx, edx
$LL673@SelectActo:
	movzx	ecx, BYTE PTR [rax+rdx]
	inc	rdx
	cmp	cl, BYTE PTR [r15+rdx-1]
	jne	SHORT $LN674@SelectActo
	cmp	rdx, 4
	jne	SHORT $LL673@SelectActo
	xor	ecx, ecx
	jmp	SHORT $LN675@SelectActo
$LN674@SelectActo:
	sbb	ecx, ecx
	or	ecx, 1
$LN675@SelectActo:

; 600  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	test	ecx, ecx
	je	SHORT $LN582@SelectActo

; 594  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	inc	rax

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [rbx-3]
	sub	r8, rax

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, 65					; 00000041H
	mov	rcx, rax
	call	memchr

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	jne	SHORT $LL108@SelectActo

; 597  :             return static_cast<size_t>(-1);

	jmp	SHORT $LN34@SelectActo
$LN582@SelectActo:

; 601  :             return static_cast<size_t>(_Match_try - _Haystack);

	sub	rax, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 257  : 				if (MergedActor.Gyml.find("Area") != std::string::npos && MergedActor.Model->IsDefaultModel() && !RenderSettings.RenderAreas) continue;

	cmp	rax, -1
	je	SHORT $LN34@SelectActo
	test	r14b, r14b
	je	SHORT $LN34@SelectActo
	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+2, 0
	je	$LN11@SelectActo
$LN34@SelectActo:

; 258  : 
; 259  : 				int R = (MergedActorIndex & 0x000000FF) >> 0;

	movzx	r15d, sil

; 260  : 				int G = (MergedActorIndex & 0x0000FF00) >> 8;

	mov	eax, esi
	sar	eax, 8
	movzx	r14d, al

; 261  : 				int B = (MergedActorIndex & 0x00FF0000) >> 16;

	mov	eax, esi
	sar	eax, 16
	movzx	esi, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movaps	XMMWORD PTR GLMModel$32[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	XMMWORD PTR GLMModel$32[rbp-240], xmm1
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR GLMModel$32[rbp-224], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR GLMModel$32[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 265  : 				GLMModel = glm::translate(GLMModel, glm::vec3(MergedActor.Translate.GetX(), MergedActor.Translate.GetY(), MergedActor.Translate.GetZ()));

	movss	xmm2, DWORD PTR [r12+52]
	movss	xmm1, DWORD PTR [r12+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm0, DWORD PTR [r12+44]
	movss	DWORD PTR $T6[rsp], xmm0
	movss	DWORD PTR $T6[rsp+4], xmm1
	movss	DWORD PTR $T6[rsp+8], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 265  : 				GLMModel = glm::translate(GLMModel, glm::vec3(MergedActor.Translate.GetX(), MergedActor.Translate.GetY(), MergedActor.Translate.GetZ()));

	lea	r8, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR GLMModel$32[rbp-256]
	lea	rcx, QWORD PTR $T26[rbp-256]
	call	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR GLMModel$32[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$32[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$32[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$32[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T11[rbp-256], 0

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T11[rbp-248], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 267  : 				GLMModel = glm::rotate(GLMModel, glm::radians(MergedActor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	movss	xmm2, DWORD PTR [r12+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 267  : 				GLMModel = glm::rotate(GLMModel, glm::radians(MergedActor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	lea	r9, QWORD PTR $T11[rbp-256]
	lea	rdx, QWORD PTR GLMModel$32[rbp-256]
	lea	rcx, QWORD PTR $T25[rbp-256]
	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR GLMModel$32[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$32[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$32[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$32[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	DWORD PTR $T13[rbp-256], 0

; 55   : 		, y(static_cast<T>(_y))

	mov	QWORD PTR $T13[rbp-252], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 268  : 				GLMModel = glm::rotate(GLMModel, glm::radians(MergedActor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	movss	xmm2, DWORD PTR [r12+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 268  : 				GLMModel = glm::rotate(GLMModel, glm::radians(MergedActor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	lea	r9, QWORD PTR $T13[rbp-256]
	lea	rdx, QWORD PTR GLMModel$32[rbp-256]
	lea	rcx, QWORD PTR $T24[rbp-256]
	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
	movups	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR GLMModel$32[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$32[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$32[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$32[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T15[rbp-256], 1065353216	; 3f800000H

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T15[rbp-248], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 30   : 	return this->m_Data[0];

	movss	xmm2, DWORD PTR [r12+68]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 269  : 				GLMModel = glm::rotate(GLMModel, glm::radians(MergedActor.Rotate.GetX()), glm::vec3(1.0, 0.0f, 0.0));

	lea	r9, QWORD PTR $T15[rbp-256]
	lea	rdx, QWORD PTR GLMModel$32[rbp-256]
	lea	rcx, QWORD PTR $T23[rbp-256]
	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
	movups	xmm9, XMMWORD PTR [rax]
	movups	xmm4, XMMWORD PTR [rax+16]
	movups	xmm5, XMMWORD PTR [rax+32]
	movups	xmm12, XMMWORD PTR [rax+48]

; 270  : 
; 271  : 				GLMModel = glm::scale(GLMModel, glm::vec3(MergedActor.Scale.GetX(), MergedActor.Scale.GetY(), MergedActor.Scale.GetZ()));

	movss	xmm11, DWORD PTR [r12+64]
	movss	xmm10, DWORD PTR [r12+60]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm1, DWORD PTR [r12+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm3, xmm9
	shufps	xmm3, xmm9, 255				; 000000ffH
	mulss	xmm3, xmm1

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movaps	xmm2, xmm9
	shufps	xmm2, xmm9, 170				; 000000aaH
	mulss	xmm2, xmm1
	movaps	xmm0, xmm9
	shufps	xmm0, xmm9, 85				; 00000055H
	mulss	xmm0, xmm1
	mulss	xmm9, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 81   : 		Result[0] = m[0] * v[0];

	shufps	xmm9, xmm9, 225				; 000000e1H
	movss	xmm9, xmm0
	shufps	xmm9, xmm9, 198				; 000000c6H
	movss	xmm9, xmm2
	shufps	xmm9, xmm9, 39				; 00000027H
	movss	xmm9, xmm3
	shufps	xmm9, xmm9, 57				; 00000039H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm3, xmm10
	movaps	xmm0, xmm4
	shufps	xmm0, xmm4, 255				; 000000ffH
	mulss	xmm3, xmm0

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movaps	xmm2, xmm10
	movaps	xmm0, xmm4
	shufps	xmm0, xmm4, 170				; 000000aaH
	mulss	xmm2, xmm0
	movaps	xmm1, xmm10
	movaps	xmm0, xmm4
	shufps	xmm0, xmm4, 85				; 00000055H
	mulss	xmm1, xmm0
	mulss	xmm10, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 82   : 		Result[1] = m[1] * v[1];

	shufps	xmm10, xmm10, 225			; 000000e1H
	movss	xmm10, xmm1
	shufps	xmm10, xmm10, 198			; 000000c6H
	movss	xmm10, xmm2
	shufps	xmm10, xmm10, 39			; 00000027H
	movss	xmm10, xmm3
	shufps	xmm10, xmm10, 57			; 00000039H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm3, xmm11
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 255				; 000000ffH
	mulss	xmm3, xmm0

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movaps	xmm2, xmm11
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 170				; 000000aaH
	mulss	xmm2, xmm0
	movaps	xmm1, xmm11
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 85				; 00000055H
	mulss	xmm1, xmm0
	mulss	xmm11, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 83   : 		Result[2] = m[2] * v[2];

	shufps	xmm11, xmm11, 225			; 000000e1H
	movss	xmm11, xmm1
	shufps	xmm11, xmm11, 198			; 000000c6H
	movss	xmm11, xmm2
	shufps	xmm11, xmm11, 39			; 00000027H
	movss	xmm11, xmm3
	shufps	xmm11, xmm11, 57			; 00000039H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [r12+416]
	mov	rcx, QWORD PTR [rax]

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdi, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 275  : 				glUniform4f(glGetUniformLocation(PickingShader->ID, "PickingColor"), R / 255.0f, G / 255.0f, B / 255.0f, 1.0f);

	mov	rbx, QWORD PTR glad_glUniform4f
	mov	rax, QWORD PTR glad_glGetUniformLocation
	movd	xmm8, esi
	cvtdq2ps xmm8, xmm8
	divss	xmm8, xmm13
	movd	xmm7, r14d
	cvtdq2ps xmm7, xmm7
	divss	xmm7, xmm13
	movd	xmm6, r15d
	cvtdq2ps xmm6, xmm6
	divss	xmm6, xmm13
	lea	rdx, OFFSET FLAT:??_C@_0N@GKKHGHLK@PickingColor@
	mov	rcx, QWORD PTR ?PickingShader@UIMapView@@3PEAVShader@@EA ; UIMapView::PickingShader
	mov	ecx, DWORD PTR [rcx]
	call	rax
	mov	ecx, eax
	movss	DWORD PTR [rsp+32], xmm14
	movaps	xmm3, xmm8
	movaps	xmm2, xmm7
	movaps	xmm1, xmm6
	call	rbx

; 277  : 				for (Mesh& SubMesh : LODModel->GL_Meshes)

	mov	r14, QWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_mat4x4.inl

; 292  : 		return this->value[i];

	mov	rsi, QWORD PTR [rdi+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 277  : 				for (Mesh& SubMesh : LODModel->GL_Meshes)

	cmp	rsi, r14
	je	$LN15@SelectActo
	npad	2
$LL16@SelectActo:

; 278  : 				{
; 279  : 					SubMesh.DrawPicking(PickingShader, &CameraView, GLMModel);

	movaps	XMMWORD PTR $T19[rbp-256], xmm9
	movaps	XMMWORD PTR $T19[rbp-240], xmm10
	movaps	XMMWORD PTR $T19[rbp-224], xmm11
	movaps	XMMWORD PTR $T19[rbp-208], xmm12
	mov	rdi, QWORD PTR ?PickingShader@UIMapView@@3PEAVShader@@EA ; UIMapView::PickingShader
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Shader.cpp

; 75   : 	glUseProgram(ID);

	mov	ecx, DWORD PTR [rdi]
	call	QWORD PTR glad_glUseProgram
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\VAO.cpp

; 21   : 	glBindVertexArray(ID);

	mov	ecx, DWORD PTR [rsi+72]
	call	QWORD PTR glad_glBindVertexArray
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Camera.cpp

; 33   : 	glUniformMatrix4fv(glGetUniformLocation(shader->ID, uniform), 1, GL_FALSE, glm::value_ptr(CameraMatrix));

	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_09KNKDONHI@camMatrix@
	mov	ecx, DWORD PTR [rdi]
	call	rax
	lea	r9, OFFSET FLAT:?CameraView@UIMapView@@3VCamera@@A+164
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 93   : 	glUniformMatrix4fv(glGetUniformLocation(Shader->ID, "modelMatrix"), 1, GL_FALSE, glm::value_ptr(Matrix));

	mov	rbx, QWORD PTR glad_glUniformMatrix4fv
	mov	rax, QWORD PTR glad_glGetUniformLocation
	lea	rdx, OFFSET FLAT:??_C@_0M@DDLHAGJC@modelMatrix@
	mov	ecx, DWORD PTR [rdi]
	call	rax
	lea	r9, QWORD PTR $T19[rbp-256]
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rsi+32]
	sub	rdx, QWORD PTR [rsi+24]
	sar	rdx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Mesh.cpp

; 96   : 	glDrawElements(GL_TRIANGLES, sizeof(int) * indices.size(), GL_UNSIGNED_INT, 0);

	lea	edx, DWORD PTR [rdx*4]
	xor	r9d, r9d
	lea	ecx, QWORD PTR [r9+4]
	mov	r8d, 5125				; 00001405H
	call	QWORD PTR glad_glDrawElements
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 277  : 				for (Mesh& SubMesh : LODModel->GL_Meshes)

	add	rsi, 96					; 00000060H
	cmp	rsi, r14
	jne	$LL16@SelectActo
$LN15@SelectActo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rsi, QWORD PTR $T7[rsp]
	mov	DWORD PTR $T18[rbp-256], esi
	mov	QWORD PTR $T18[rbp-248], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T18[rbp-256]
	lea	rdx, QWORD PTR $T22[rbp-256]
	lea	rcx, QWORD PTR MergedActorIds$35[rbp-256]
	call	??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::emplace<std::pair<int const ,Actor *> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 282  : 				MergedActorIndex++;

	inc	esi
	mov	QWORD PTR $T7[rsp], rsi
$LN11@SelectActo:

; 250  : 		{
; 251  : 			for (Actor& MergedActor : MergedActorMain.MergedActorContent)

	add	r13, 872				; 00000368H
	add	r12, 872				; 00000368H
	cmp	r13, QWORD PTR <end>$L2$1$[rbp-256]
	lea	r15, OFFSET FLAT:??_C@_04KPICECCB@Area@
	lea	rdi, OFFSET FLAT:??_C@_04GJPNONHK@_Far@
	jne	$LL13@SelectActo
	mov	rcx, QWORD PTR <begin>$L1$1$[rsp]
$LN8@SelectActo:

; 249  : 		for (Actor& MergedActorMain : ActorMgr::GetActors())

	add	rcx, 872				; 00000368H
	mov	QWORD PTR <begin>$L1$1$[rsp], rcx
	cmp	rcx, QWORD PTR <end>$L1$1$[rbp-256]
	lea	r15, OFFSET FLAT:??_C@_04KPICECCB@Area@
	lea	rdi, OFFSET FLAT:??_C@_04GJPNONHK@_Far@
	jne	$LL10@SelectActo
	xor	ebx, ebx
	mov	r14, -6430974998173972123		; a6c0964fda6c0965H
$LN9@SelectActo:

; 283  : 			}
; 284  : 		}
; 285  : 
; 286  : 		glReadBuffer(GL_COLOR_ATTACHMENT0);

	mov	ecx, 36064				; 00008ce0H
	call	QWORD PTR glad_glReadBuffer

; 287  : 		unsigned char Data[3];
; 288  : 
; 289  : 		glReadPixels((GLint)MousePos.x, (GLint)SceneWindowSize.y - MousePos.y, 1, 1, GL_RGB, GL_UNSIGNED_BYTE, Data);

	cvttss2si eax, DWORD PTR SceneWindowSize$[rbp-252]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, DWORD PTR MousePos$[rsp+4]
	cvttss2si edx, xmm0
	cvttss2si ecx, DWORD PTR MousePos$[rsp]
	lea	rax, QWORD PTR Data$31[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], 5121		; 00001401H
	mov	DWORD PTR [rsp+32], 6407		; 00001907H
	mov	r9d, 1
	mov	r8d, r9d
	call	QWORD PTR glad_glReadPixels

; 290  : 
; 291  : 		int PickedActorId =

	movzx	edx, BYTE PTR Data$31[rbp-254]
	shl	edx, 8
	movzx	eax, BYTE PTR Data$31[rbp-255]
	add	edx, eax
	shl	edx, 8
	movzx	eax, BYTE PTR Data$31[rbp-256]
	add	edx, eax
	mov	DWORD PTR PickedActorId$34[rbp-256], edx
	cmp	edx, 4208174				; 0040362eH

; 292  : 			Data[0] +
; 293  : 			Data[1] * 256 +
; 294  : 			Data[2] * 256 * 256;
; 295  : 
; 296  : 		if (PickedActorId == 4208174 || PickedActorId < 0) //3024412 = background color

	je	SHORT $LN37@SelectActo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A
	mov	rcx, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A+8
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r14
	mov	r9d, edx
	mov	eax, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 302  : 			if (PickedActorId < ActorMgr::GetActors().size())

	cmp	rax, rcx
	jae	SHORT $LN38@SelectActo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rcx, r9, 872				; 00000368H
	add	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 305  : 			}

	jmp	SHORT $LN707@SelectActo
$LN38@SelectActo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 438  :         return this->_Try_emplace(_Keyval).first->_Myval.second;

	lea	r8, QWORD PTR PickedActorId$34[rbp-256]
	lea	rdx, QWORD PTR $T21[rbp-256]
	lea	rcx, QWORD PTR MergedActorIds$35[rbp-256]
	call	??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Try_emplace<int const &>
	mov	rcx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 308  : 				UIOutliner::SelectActor(MergedActorIds[PickedActorId]);

	mov	rcx, QWORD PTR [rcx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIOutliner.cpp

; 26   : 	if(pActor != nullptr) ImGuizmo::RecomposeMatrixFromComponents(pActor->Translate.GetRawData(), pActor->Rotate.GetRawData(), pActor->Scale.GetRawData(), UIMapView::ObjectMatrix);

	test	rcx, rcx
$LN707@SelectActo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 312  : 		glReadBuffer(GL_NONE);

	mov	QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA, rcx ; UIOutliner::SelectedActor
	je	SHORT $LN269@SelectActo
	lea	r8, QWORD PTR [rcx+64]
	lea	rdx, QWORD PTR [rcx+76]
	add	rcx, 52					; 00000034H
	call	?RecomposeMatrixFromComponents@ImGuizmo@@YAXPEBM00PEAM@Z ; ImGuizmo::RecomposeMatrixFromComponents
	jmp	SHORT $LN269@SelectActo
$LN37@SelectActo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIOutliner.cpp

; 24   : 	SelectedActor = pActor;

	mov	QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA, rbx ; UIOutliner::SelectedActor
$LN269@SelectActo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 312  : 		glReadBuffer(GL_NONE);

	xor	ecx, ecx
	call	QWORD PTR glad_glReadBuffer
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 312  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR MergedActorIds$35[rbp-232]
	test	rcx, rcx
	je	SHORT $LN240@SelectActo

; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR MergedActorIds$35[rbp-216]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN260@SelectActo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN260@SelectActo
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN260@SelectActo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 315  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	QWORD PTR MergedActorIds$35[rbp-232], rbx
	xorps	xmm0, xmm0

; 316  :             _Mypair._Myval2._Mylast  = nullptr;

	movdqa	XMMWORD PTR MergedActorIds$35[rbp-224], xmm0
$LN240@SelectActo:
	lea	rcx, QWORD PTR MergedActorIds$35[rbp-248]
	call	??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::~list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >
$LN21@SelectActo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIMapView.cpp

; 314  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+736]
	mov	rbx, QWORD PTR [r11+80]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [r11-144]
	movaps	xmm15, XMMWORD PTR [r11-160]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN703@SelectActo:
?SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z ENDP	; UIMapView::SelectActorByClicking
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 64
MousePos$ = 96
$T7 = 104
$T8 = 104
<begin>$L1$1$ = 120
$T9 = 120
$T10 = 144
$T11 = 144
$T12 = 160
$T13 = 160
$T14 = 176
$T15 = 176
SceneWindowSize$ = 192
<end>$L2$1$ = 200
$T16 = 200
<end>$L1$1$ = 216
$T17 = 216
$T18 = 232
$T19 = 256
$T20 = 256
$T21 = 320
$T22 = 320
$T23 = 336
$T24 = 336
$T25 = 336
$T26 = 336
$T27 = 336
$T28 = 336
$T29 = 336
$T30 = 336
Data$31 = 400
GLMModel$32 = 416
GLMModel$33 = 416
PickedActorId$34 = 480
MergedActorIds$35 = 496
__$ArrayPad$ = 560
?dtor$4@?0??SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z@4HA PROC ; `UIMapView::SelectActorByClicking'::`1'::dtor$4
	lea	rcx, QWORD PTR MergedActorIds$35[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::~list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >
?dtor$4@?0??SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z@4HA ENDP ; `UIMapView::SelectActorByClicking'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 64
MousePos$ = 96
$T7 = 104
$T8 = 104
<begin>$L1$1$ = 120
$T9 = 120
$T10 = 144
$T11 = 144
$T12 = 160
$T13 = 160
$T14 = 176
$T15 = 176
SceneWindowSize$ = 192
<end>$L2$1$ = 200
$T16 = 200
<end>$L1$1$ = 216
$T17 = 216
$T18 = 232
$T19 = 256
$T20 = 256
$T21 = 320
$T22 = 320
$T23 = 336
$T24 = 336
$T25 = 336
$T26 = 336
$T27 = 336
$T28 = 336
$T29 = 336
$T30 = 336
Data$31 = 400
GLMModel$32 = 416
GLMModel$33 = 416
PickedActorId$34 = 480
MergedActorIds$35 = 496
__$ArrayPad$ = 560
?dtor$5@?0??SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z@4HA PROC ; `UIMapView::SelectActorByClicking'::`1'::dtor$5
	lea	rcx, QWORD PTR MergedActorIds$35[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >
?dtor$5@?0??SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z@4HA ENDP ; `UIMapView::SelectActorByClicking'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 64
MousePos$ = 96
$T7 = 104
$T8 = 104
<begin>$L1$1$ = 120
$T9 = 120
$T10 = 144
$T11 = 144
$T12 = 160
$T13 = 160
$T14 = 176
$T15 = 176
SceneWindowSize$ = 192
<end>$L2$1$ = 200
$T16 = 200
<end>$L1$1$ = 216
$T17 = 216
$T18 = 232
$T19 = 256
$T20 = 256
$T21 = 320
$T22 = 320
$T23 = 336
$T24 = 336
$T25 = 336
$T26 = 336
$T27 = 336
$T28 = 336
$T29 = 336
$T30 = 336
Data$31 = 400
GLMModel$32 = 416
GLMModel$33 = 416
PickedActorId$34 = 480
MergedActorIds$35 = 496
__$ArrayPad$ = 560
?dtor$0@?0??SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z@4HA PROC ; `UIMapView::SelectActorByClicking'::`1'::dtor$0
	lea	rcx, QWORD PTR MergedActorIds$35[rdx]
	jmp	??1?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ
?dtor$0@?0??SelectActorByClicking@UIMapView@@YAXUImVec2@@0@Z@4HA ENDP ; `UIMapView::SelectActorByClicking'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ PROC ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::~unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >, COMDAT
	jmp	??1?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
??1?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ ENDP ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::~unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::~_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >, COMDAT
$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 312  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx+24]
	test	rcx, rcx
	je	SHORT $LN6@Hash

; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+40]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN26@Hash

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN23@Hash

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN26@Hash:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 315  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+24], rax

; 316  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+32], rax

; 317  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+40], rax
$LN6@Hash:
	lea	rcx, QWORD PTR [rbx+8]
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::~list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >
$LN23@Hash:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN35@Hash:
??1?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::~_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAAX_K@Z PROC ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	ret	0
?__autoclassinit2@?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAAX_K@Z ENDP ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??A?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAAAEAPEAUActor@@AEBH@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Keyval$ = 72
??A?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAAAEAPEAUActor@@AEBH@Z PROC ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::operator[], COMDAT

; 437  :     mapped_type& operator[](const key_type& _Keyval) {

$LN4:
	sub	rsp, 56					; 00000038H

; 438  :         return this->_Try_emplace(_Keyval).first->_Myval.second;

	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Try_emplace<int const &>
	mov	rax, QWORD PTR [rax]
	add	rax, 24

; 439  :     }

	add	rsp, 56					; 00000038H
	ret	0
??A?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAAAEAPEAUActor@@AEBH@Z ENDP ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ PROC ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >, COMDAT

; 107  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN70:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	xor	edi, edi
	mov	DWORD PTR [rcx], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rdi+32]
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	lea	rcx, QWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR [rbx+48], 7
	mov	QWORD PTR [rbx+56], 8

; 377  :         // construct empty hash table
; 378  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [rbx], 1065353216		; 3f800000H

; 379  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, QWORD PTR [rbx+8]
	lea	edx, QWORD PTR [rdi+16]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Assign_grow
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 107  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ ENDP ; std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::~list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >
?dtor$1@?0???0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$2@?0???0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >
?dtor$2@?0???0?$unordered_map@HPEAUActor@@U?$hash@H@std@@U?$equal_to@H@3@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >::unordered_map<int,Actor *,std::hash<int>,std::equal_to<int>,std::allocator<std::pair<int const ,Actor *> > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >, COMDAT

; 321  :     ~_Hash_vec() {

$LN35:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 312  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@Hash_vec

; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@Hash_vec

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@Hash_vec

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@Hash_vec:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 315  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 316  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 317  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@Hash_vec:

; 327  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN21@Hash_vec:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN32@Hash_vec:
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?insert@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHPEAUActor@@@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Val$ = 64
?insert@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHPEAUActor@@@2@@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::insert, COMDAT

; 937  :     conditional_t<_Multi, iterator, pair<iterator, bool>> insert(value_type&& _Val) {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::emplace<std::pair<int const ,Actor *> >
	mov	rax, rbx

; 939  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?insert@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBHPEAUActor@@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::~list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >, COMDAT

; 1045 :     ~list() noexcept {

$LN110:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1501 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]

; 1045 :     ~list() noexcept {

	mov	rdi, rcx

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rcx, QWORD PTR [rdx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rcx, rcx
	je	SHORT $LN7@list
	mov	QWORD PTR [rsp+56], rbx
	npad	12
$LL8@list:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL8@list
	mov	rbx, QWORD PTR [rsp+56]
$LN7@list:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rdi]
	mov	edx, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1051 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::~list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@QEAAAEAPEAUActor@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@QEAAAEAPEAUActor@@_K@Z PROC ; std::vector<Actor *,std::allocator<Actor *> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@QEAAAEAPEAUActor@@_K@Z ENDP ; std::vector<Actor *,std::allocator<Actor *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Actor *,std::allocator<Actor *> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1870 :     }

	ret	0
?size@?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Actor *,std::allocator<Actor *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAPEAVMesh@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAPEAVMesh@@XZ PROC ; std::vector<Mesh,std::allocator<Mesh> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAPEAVMesh@@XZ ENDP ; std::vector<Mesh,std::allocator<Mesh> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAPEAVMesh@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAPEAVMesh@@XZ PROC ; std::vector<Mesh,std::allocator<Mesh> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@VMesh@@V?$allocator@VMesh@@@std@@@std@@QEAAPEAVMesh@@XZ ENDP ; std::vector<Mesh,std::allocator<Mesh> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAAEAU?$mat@$03$03M$0A@@glm@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAAEAU?$mat@$03$03M$0A@@glm@@_K@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdx, 6
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1890 :     }

	ret	0
??A?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAAEAU?$mat@$03$03M$0A@@glm@@_K@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rbx, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	rcx, r9
	sub	rcx, r8
	sar	rcx, 6

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rdx, 6
	add	rdx, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rbx+8], rdx

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rbx+16]
	sub	rax, r8
	sar	rax, 6

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rbx

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, r9
	call	??$_Uninitialized_value_construct_n@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@_KAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<glm::mat<4,4,float,0> > >
	mov	QWORD PTR [rbx+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?resize@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Al$dead$ = 80
??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >, COMDAT

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN48:
	push	rbp
	push	rsi
	sub	rsp, 40					; 00000028H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbp, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN35@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN46@vector
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+32], rdi

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::allocator<glm::mat<4,4,float,0> >::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	rbx, rbp
	mov	QWORD PTR [rsi], rax
	shl	rbx, 6
	xor	edx, edx
	shl	rbp, 6
	mov	rdi, rax
	mov	r8, rbp
	lea	rcx, QWORD PTR [rbx+rax]
	mov	QWORD PTR [rsi+16], rcx
	mov	rcx, rax
	call	memset
	add	rdi, rbx

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	rbx, QWORD PTR [rsp+80]
	mov	QWORD PTR [rsi+8], rdi
	mov	rdi, QWORD PTR [rsp+32]
$LN35@vector:

; 620  :         _Construct_n(_Count);
; 621  :     }

	mov	rax, rsi
	add	rsp, 40					; 00000028H
	pop	rsi
	pop	rbp
	ret	0
$LN46@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Xlength
	int	3
$LN44@vector:
??0?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAA@_KAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Tidy, COMDAT

; 311  :     void _Tidy() noexcept {

$LN32:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 312  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 315  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 316  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 317  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 319  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN29@Tidy:
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$ = 56
_Al$dead$ = 64
??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >, COMDAT

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN60:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	edi, edi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rdi+32]
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	lea	rcx, QWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 376  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR [rbx+48], 7
	mov	QWORD PTR [rbx+56], 8

; 377  :         // construct empty hash table
; 378  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [rbx], 1065353216		; 3f800000H

; 379  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, QWORD PTR [rbx+8]
	lea	edx, QWORD PTR [rdi+16]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Assign_grow
	npad	1

; 380  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 381  :         _Stl_internal_check_container_invariants();
; 382  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 383  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Parg$ = 56
_Al$dead$ = 64
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::~list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Parg$ = 56
_Al$dead$ = 64
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Tidy, COMDAT

; 1497 :     void _Tidy() noexcept {

$LN107:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1498 :         auto& _Al      = _Getal();
; 1499 :         auto& _My_data = _Mypair._Myval2;
; 1500 :         _My_data._Orphan_all();
; 1501 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]
	mov	rdi, rcx

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rcx, QWORD PTR [rdx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rcx, rcx
	je	SHORT $LN5@Tidy
	mov	QWORD PTR [rsp+56], rbx
	npad	12
$LL6@Tidy:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL6@Tidy
	mov	rbx, QWORD PTR [rsp+56]
$LN5@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rdi]
	mov	edx, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1503 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
?_Tidy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<int const ,Actor *> >::allocator<std::pair<int const ,Actor *> >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<int const ,Actor *> >::allocator<std::pair<int const ,Actor *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 64
_Cells$ = 72
_Val$ = 80
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Assign_grow, COMDAT

; 287  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN88:
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	r14
	sub	rsp, 40					; 00000028H
	mov	r14, rcx
	mov	rbx, r8

; 273  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, rcx
	mov	r9, QWORD PTR [r14]
	sub	rax, r9
	sar	rax, 3

; 288  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 289  :         const auto _Oldsize = size();
; 290  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 291  :         auto& _Alvec = _Mypair._Get_first();
; 292  :         if (_Oldsize < _Cells) {

	cmp	rax, rdx
	jae	$LN2@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR [rsp+88], rsi
	mov	QWORD PTR [rsp+32], rdi
	cmp	rdx, rax
	ja	$LN71@Assign_gro

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rsi, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN16@Assign_gro

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN71@Assign_gro

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN51@Assign_gro

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN14@Assign_gro
$LN16@Assign_gro:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN17@Assign_gro

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN14@Assign_gro
$LN17@Assign_gro:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN14@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3

; 293  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws
; 294  :             // nothrow hereafter
; 295  :             const auto _Oldcapacity = capacity();
; 296  :             if (_Oldcapacity != 0) {

	test	rax, rax
	je	SHORT $LN42@Assign_gro
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN54@Assign_gro

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN51@Assign_gro

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN54@Assign_gro:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN42@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 302  :             const auto _Newend       = _Newvec + _Cells;

	lea	rax, QWORD PTR [rsi+rdi]
	mov	QWORD PTR [r14], rdi

; 303  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	QWORD PTR [r14+8], rax

; 304  :             _Mypair._Myval2._Myend   = _Newend;

	mov	QWORD PTR [r14+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1602 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rdi, rax

; 2002 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN84@Assign_gro
	npad	4
$LL58@Assign_gro:

; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	QWORD PTR [rdi], rbx

; 1617 :         ++_Last;

	add	rdi, 8

; 2002 :         while (_Backout._Last != _ULast) {

	cmp	rdi, rax
	jne	SHORT $LL58@Assign_gro
$LN84@Assign_gro:
	mov	rsi, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 309  :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rbx
	ret	0
$LN51@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 307  :             _STD fill(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast, _Val);

	mov	rdx, rcx
	lea	r8, QWORD PTR _Val$[rsp]
	mov	rcx, r9
	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >

; 309  :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rbx
	ret	0
$LN71@Assign_gro:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN85@Assign_gro:
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::capacity, COMDAT

; 282  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 283  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 284  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 285  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Max_bucket_size, COMDAT

; 1801 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, rcx

; 1802 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Getal, COMDAT

; 1848 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1849 :     }

	ret	0
?_Getal@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Unchecked_end, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1114 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	mov	rax, rdx

; 1115 :     }

	ret	0
?_Unchecked_end@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$dead$ = 56
??0?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z PROC ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >, COMDAT

; 803  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN41:
	push	rbx
	sub	rsp, 32					; 00000020H

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax

; 803  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rcx

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+32]
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx], rax

; 804  :         _Alloc_sentinel_and_proxy();
; 805  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ENDP ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??0?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Traits$ = 16
??0?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z PROC ; std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0>::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0>, COMDAT

; 50   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??0?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ENDP ; std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0>::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx

; 39   :         this->_Adopt(_Plist);
; 40   :     }

	mov	rax, rcx
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::size, COMDAT

; 273  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 274  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Alloc_sentinel_and_proxy, COMDAT

; 1832 :     void _Alloc_sentinel_and_proxy() {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1837 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1838 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1839 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx], rax

; 1840 :         _Proxy._Release();
; 1841 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$dead$ = 16
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >::allocate, COMDAT

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	jmp	??2@YAPEAX_K@Z				; operator new
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl
;	COMDAT ??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 128
m$ = 136
v$ = 144
??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z PROC ; glm::translate<float,0>, COMDAT

; 11   : 	{

$LN140:
	mov	r11, rsp
	sub	rsp, 120				; 00000078H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 866  : 		return vec<4, T, Q>(v) *= scalar;

	movss	xmm4, DWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 14   : 		return Result;

	mov	rax, rcx
	movaps	xmm0, XMMWORD PTR [rdx]
	movaps	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx], xmm0
	movaps	xmm0, XMMWORD PTR [rdx+32]
	movaps	XMMWORD PTR [rsp+96], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 866  : 		return vec<4, T, Q>(v) *= scalar;

	movss	xmm6, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+80], xmm7
	movups	xmm7, XMMWORD PTR [rdx+16]
	movaps	XMMWORD PTR [r11-56], xmm8

; 555  : 		return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));

	movaps	xmm8, XMMWORD PTR [rdx+48]
	movaps	XMMWORD PTR [r11-72], xmm9

; 866  : 		return vec<4, T, Q>(v) *= scalar;

	movaps	xmm9, XMMWORD PTR [rdx]
	movaps	XMMWORD PTR [r11-88], xmm10

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm3, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 12   : 		mat<4, 4, T, Q> Result(m);

	movups	XMMWORD PTR [rcx+16], xmm1
	movups	XMMWORD PTR [rcx+32], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 866  : 		return vec<4, T, Q>(v) *= scalar;

	movss	xmm0, DWORD PTR [r8+8]

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm10, xmm9
	mulss	xmm10, xmm4

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	shufps	xmm3, xmm9, 85				; 00000055H
	movaps	XMMWORD PTR [r11-104], xmm11

; 866  : 		return vec<4, T, Q>(v) *= scalar;

	movups	xmm11, XMMWORD PTR [rdx+32]

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	mulss	xmm3, xmm4

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm1, xmm11

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm2, xmm11

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	mulss	xmm1, xmm0

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm5, xmm11
	shufps	xmm2, xmm11, 85				; 00000055H
	mulss	xmm2, xmm0
	shufps	xmm5, xmm11, 170			; 000000aaH
	mulss	xmm5, xmm0
	shufps	xmm11, xmm11, 255			; 000000ffH
	mulss	xmm11, xmm0

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm0, xmm7
	mulss	xmm0, xmm6

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	addss	xmm10, xmm0
	movaps	xmm0, xmm7
	shufps	xmm0, xmm7, 85				; 00000055H
	mulss	xmm0, xmm6
	addss	xmm10, xmm1
	movaps	xmm1, xmm9
	shufps	xmm1, xmm9, 170				; 000000aaH
	addss	xmm3, xmm0
	shufps	xmm9, xmm9, 255				; 000000ffH
	movaps	xmm0, xmm8
	shufps	xmm0, xmm8, 85				; 00000055H
	mulss	xmm9, xmm4

; 555  : 		return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));

	addss	xmm10, xmm8

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	mulss	xmm1, xmm4
	addss	xmm3, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 13   : 		Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];

	shufps	xmm10, xmm10, 225			; 000000e1H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	addss	xmm3, xmm0
	movaps	xmm0, xmm7
	shufps	xmm0, xmm7, 170				; 000000aaH
	mulss	xmm0, xmm6
	shufps	xmm7, xmm7, 255				; 000000ffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 13   : 		Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];

	movss	xmm10, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	mulss	xmm7, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 15   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+96]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	addss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 13   : 		Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];

	shufps	xmm10, xmm10, 198			; 000000c6H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm0, xmm8
	addss	xmm9, xmm7
	shufps	xmm0, xmm8, 170				; 000000aaH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 15   : 	}

	movaps	xmm7, XMMWORD PTR [rsp+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	shufps	xmm8, xmm8, 255				; 000000ffH
	addss	xmm1, xmm5
	addss	xmm9, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 15   : 	}

	movaps	xmm11, XMMWORD PTR [r11-104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	addss	xmm1, xmm0
	addss	xmm9, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\ext\matrix_transform.inl

; 15   : 	}

	movaps	xmm8, XMMWORD PTR [r11-56]
	movss	xmm10, xmm1
	shufps	xmm10, xmm10, 39			; 00000027H
	movss	xmm10, xmm9
	movaps	xmm9, XMMWORD PTR [r11-72]
	shufps	xmm10, xmm10, 57			; 00000039H
	movups	XMMWORD PTR [rcx+48], xmm10
	movaps	xmm10, XMMWORD PTR [r11-88]
	add	rsp, 120				; 00000078H
	ret	0
??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ENDP ; glm::translate<float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
;	COMDAT ??$fmax@HM$0A@@@YANHM@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$ = 16
??$fmax@HM$0A@@@YANHM@Z PROC				; fmax<int,float,0>, COMDAT

; 698  : _GENERIC_MATH2(fmax)

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtss2sd xmm1, xmm1
	rex_jmp	QWORD PTR __imp_fmax
??$fmax@HM$0A@@@YANHM@Z ENDP				; fmax<int,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
;	COMDAT ??$fmax@NM$0A@@@YANNM@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$fmax@NM$0A@@@YANNM@Z PROC				; fmax<double,float,0>, COMDAT

; 698  : _GENERIC_MATH2(fmax)

	cvtss2sd xmm1, xmm1
	rex_jmp	QWORD PTR __imp_fmax
??$fmax@NM$0A@@@YANNM@Z ENDP				; fmax<double,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAHPEAUActor@@$0A@@?$pair@$$CBHPEAUActor@@@std@@QEAA@AEAH$$QEAPEAUActor@@@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAHPEAUActor@@$0A@@?$pair@$$CBHPEAUActor@@@std@@QEAA@AEAH$$QEAPEAUActor@@@Z PROC ; std::pair<int const ,Actor *>::pair<int const ,Actor *><int &,Actor *,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAHPEAUActor@@$0A@@?$pair@$$CBHPEAUActor@@@std@@QEAA@AEAH$$QEAPEAUActor@@@Z ENDP ; std::pair<int const ,Actor *>::pair<int const ,Actor *><int &,Actor *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$get@$0A@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@std@@YAAEBQEAVBfresFile@@AEAU?$pair@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Pr$ = 8
??$get@$0A@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@std@@YAAEBQEAVBfresFile@@AEAU?$pair@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@0@@Z PROC ; std::get<0,BfresFile * const,std::vector<Actor *,std::allocator<Actor *> > >, COMDAT

; 664  :     // get reference to element at _Idx in pair _Pr
; 665  :     if constexpr (_Idx == 0) {
; 666  :         return _Pr.first;

	mov	rax, rcx

; 667  :     } else {
; 668  :         return _Pr.second;
; 669  :     }
; 670  : }

	ret	0
??$get@$0A@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@std@@YAAEBQEAVBfresFile@@AEAU?$pair@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@0@@Z ENDP ; std::get<0,BfresFile * const,std::vector<Actor *,std::allocator<Actor *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$get@$00QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@std@@YAAEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@0@AEAU?$pair@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Pr$ = 8
??$get@$00QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@std@@YAAEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@0@AEAU?$pair@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@0@@Z PROC ; std::get<1,BfresFile * const,std::vector<Actor *,std::allocator<Actor *> > >, COMDAT

; 664  :     // get reference to element at _Idx in pair _Pr
; 665  :     if constexpr (_Idx == 0) {
; 666  :         return _Pr.first;
; 667  :     } else {
; 668  :         return _Pr.second;

	lea	rax, QWORD PTR [rcx+8]

; 669  :     }
; 670  : }

	ret	0
??$get@$00QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@std@@YAAEAV?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@0@AEAU?$pair@QEAVBfresFile@@V?$vector@PEAUActor@@V?$allocator@PEAUActor@@@std@@@std@@@0@@Z ENDP ; std::get<1,BfresFile * const,std::vector<Actor *,std::allocator<Actor *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z
_TEXT	SEGMENT
$T1 = 32
_Newnode$ = 32
this$ = 112
__$ReturnUdt$ = 120
_Keyval_arg$ = 128
??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Try_emplace<int const &>, COMDAT

; 693  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval_arg, _Mappedty&&... _Mapval) {

$LN184:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r13, r8
	mov	r14, rdx
	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r12d, BYTE PTR [r8]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r12, rax

; 2346 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	imul	r12, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+1]
	xor	r12, rax

; 2346 :         _Val *= _FNV_prime;

	imul	r12, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+2]
	xor	r12, rax

; 2346 :         _Val *= _FNV_prime;

	imul	r12, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+3]
	xor	r12, rax

; 2346 :         _Val *= _FNV_prime;

	imul	r12, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, QWORD PTR [rsi+48]
	and	rcx, r12

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rax, QWORD PTR [rsi+24]
	mov	rbx, QWORD PTR [rax+rcx*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	lea	rdx, QWORD PTR [rsi+8]
	mov	r15, QWORD PTR [rdx]

; 1570 :         if (_Where == _End) {

	cmp	rbx, r15
	jne	SHORT $LN25@Try_emplac

; 1571 :             return {_End, _Nodeptr{}};

	mov	rbx, r15
	mov	rbp, r15
	jmp	SHORT $LN2@Try_emplac
$LN25@Try_emplac:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rax+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	eax, DWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	eax, DWORD PTR [rbx+16]
	je	SHORT $LN154@Try_emplac
$LL22@Try_emplac:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rcx
	je	SHORT $LN155@Try_emplac

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	eax, DWORD PTR [rbx+16]
	jne	SHORT $LL22@Try_emplac
$LN154@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rbx
	mov	BYTE PTR [r14+8], 0
$LN181@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 711  :     }

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+136]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN155@Try_emplac:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	r15, rbx
	mov	rbp, rbx
$LN2@Try_emplac:

; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	QWORD PTR [rsi+16], rax
	jne	SHORT $LN36@Try_emplac

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN36@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR _Newnode$[rsp], rdx

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR _Newnode$[rsp+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR _Newnode$[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	eax, DWORD PTR [r13]
	mov	DWORD PTR [rdi+16], eax
	xor	r13d, r13d
	mov	QWORD PTR [rdi+24], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rsi+16]

; 1654 :         const auto _Newsize      = _Oldsize + 1;

	add	rcx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN175@Try_emplac
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN176@Try_emplac
$LN175@Try_emplac:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN176@Try_emplac:
	mov	rcx, QWORD PTR [rsi+56]
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN173@Try_emplac
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN174@Try_emplac
$LN173@Try_emplac:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN174@Try_emplac:
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [rsi]
	seta	al

; 694  :         const auto& _Keyval = _Keyval_arg;
; 695  :         const auto _Hashval = _Traitsobj(_Keyval);
; 696  :         auto _Target        = _Find_last(_Keyval, _Hashval);
; 697  :         if (_Target._Duplicate) {
; 698  :             return {_Target._Duplicate, false};
; 699  :         }
; 700  : 
; 701  :         _Check_max_size();
; 702  :         _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), piecewise_construct,
; 703  :             _STD forward_as_tuple(_STD forward<_Keyty>(_Keyval_arg)),
; 704  :             _STD forward_as_tuple(_STD forward<_Mappedty>(_Mapval)...));
; 705  :         if (_Check_rehash_required_1()) {

	test	al, al
	je	SHORT $LN3@Try_emplac

; 706  :             _Rehash_for_1();

	mov	rcx, rsi
	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Rehash_for_1

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, QWORD PTR [rsi+48]
	and	rcx, r12

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rdx, QWORD PTR [rsi+24]
	mov	rax, QWORD PTR [rdx+rcx*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rbx, QWORD PTR [rsi+8]

; 1570 :         if (_Where == _End) {

	cmp	rax, rbx
	je	SHORT $LN178@Try_emplac

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdx, QWORD PTR [rdx+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	ecx, DWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	ecx, DWORD PTR [rax+16]
	je	SHORT $LN156@Try_emplac
$LL139@Try_emplac:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	mov	rbx, rax
	cmp	rax, rdx
	je	SHORT $LN157@Try_emplac

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	ecx, DWORD PTR [rax+16]
	jne	SHORT $LL139@Try_emplac
$LN156@Try_emplac:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rbx, QWORD PTR [rax]
$LN178@Try_emplac:

; 707  :             _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	QWORD PTR $T1[rsp], rbx
$LN179@Try_emplac:
	mov	rbp, rbx
	mov	r15, QWORD PTR $T1[rsp]
$LN3@Try_emplac:

; 1615 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rdx, QWORD PTR [rbx+8]

; 1616 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [rsi+16]

; 1617 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rdi], r15

; 1618 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rdi+8], rdx

; 1619 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [rdx], rdi

; 1620 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [rbx+8], rdi

; 1621 : 
; 1622 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1623 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rcx, QWORD PTR [rsi+24]

; 1624 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR [rsi+48]
	and	rax, r12

; 1625 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rax, rax

; 1626 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1627 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r8, QWORD PTR [rcx+rax*8]
	cmp	r8, QWORD PTR [rsi+8]
	jne	SHORT $LN102@Try_emplac

; 1628 :             // bucket is empty, set both
; 1629 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rdi

; 1630 :             _Bucket_hi._Ptr = _Newnode;

	jmp	SHORT $LN180@Try_emplac
$LN157@Try_emplac:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rax
	jmp	SHORT $LN179@Try_emplac
$LN102@Try_emplac:

; 1631 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r8, rbp
	jne	SHORT $LN104@Try_emplac

; 1632 :             // new node is the lowest element in the bucket
; 1633 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], rdi
	jmp	SHORT $LN106@Try_emplac
$LN104@Try_emplac:

; 1634 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rcx+rax*8+8], rdx
	jne	SHORT $LN106@Try_emplac
$LN180@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rcx+rax*8+8], rdi
$LN106@Try_emplac:
	mov	QWORD PTR [r14], rdi
	mov	BYTE PTR [r14+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 710  :         return {_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()), true};

	jmp	$LN181@Try_emplac
$LN177@Try_emplac:
??$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Try_emplace<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$ = 32
this$ = 112
__$ReturnUdt$ = 120
_Keyval_arg$ = 128
?dtor$1@?0???$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Try_emplace<int const &>'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
?dtor$1@?0???$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Try_emplace<int const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$ = 32
this$ = 112
__$ReturnUdt$ = 120
_Keyval_arg$ = 128
?dtor$0@?0???$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Try_emplace<int const &>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
?dtor$0@?0???$_Try_emplace@AEBH$$V@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@1@AEBH@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Try_emplace<int const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$pair@$$CBHPEAUActor@@@std@@@std@@YA$$QEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$pair@$$CBHPEAUActor@@@std@@@std@@YA$$QEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z PROC ; std::move<std::pair<int const ,Actor *> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$pair@$$CBHPEAUActor@@@std@@@std@@YA$$QEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z ENDP ; std::move<std::pair<int const ,Actor *> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
_Newnode$2 = 32
this$ = 112
__$ReturnUdt$ = 120
<_Vals_0>$ = 128
??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::emplace<std::pair<int const ,Actor *> >, COMDAT

; 589  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN186:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r13, r8
	mov	r14, rdx
	mov	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	edi, BYTE PTR [r8]
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rdi, rax

; 2346 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	imul	rdi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+1]
	xor	rdi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rdi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+2]
	xor	rdi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rdi, rcx

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+3]
	xor	rdi, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, QWORD PTR [rbp+48]
	and	rcx, rdi

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rax, QWORD PTR [rbp+24]
	mov	rbx, QWORD PTR [rax+rcx*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	lea	rdx, QWORD PTR [rbp+8]
	mov	r12, QWORD PTR [rdx]

; 1570 :         if (_Where == _End) {

	cmp	rbx, r12
	jne	SHORT $LN25@emplace

; 1571 :             return {_End, _Nodeptr{}};

	mov	rbx, r12
	mov	r15, r12
	jmp	SHORT $LN2@emplace
$LN25@emplace:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rax+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	eax, DWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	eax, DWORD PTR [rbx+16]
	je	SHORT $LN156@emplace
$LL22@emplace:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rcx
	je	SHORT $LN157@emplace

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	eax, DWORD PTR [rbx+16]
	jne	SHORT $LL22@emplace
$LN156@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rbx
	mov	BYTE PTR [r14+8], 0
$LN183@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 639  :     }

	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+136]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN157@emplace:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	r12, rbx
	mov	r15, rbx
$LN2@emplace:

; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	QWORD PTR [rbp+16], rax
	jne	SHORT $LN44@emplace

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN44@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR _Newnode$2[rsp], rdx

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR _Newnode$2[rsp+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR _Newnode$2[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [r13]
	movups	XMMWORD PTR [rax+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rbp+16]

; 1654 :         const auto _Newsize      = _Oldsize + 1;

	add	rcx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN177@emplace
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN178@emplace
$LN177@emplace:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN178@emplace:
	mov	rcx, QWORD PTR [rbp+56]
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN175@emplace
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN176@emplace
$LN175@emplace:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN176@emplace:
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [rbp]
	seta	al

; 590  :         // try to insert value_type(_Vals...)
; 591  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 592  :         if constexpr (_Multi) {
; 593  :             _Check_max_size();
; 594  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 595  :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 596  :             const auto _Hashval = _Traitsobj(_Keyval);
; 597  :             if (_Check_rehash_required_1()) {
; 598  :                 _Rehash_for_1();
; 599  :             }
; 600  : 
; 601  :             const auto _Target = _Find_last(_Keyval, _Hashval);
; 602  :             return _List._Make_iter(_Insert_new_node_before(_Hashval, _Target._Insert_before, _Newnode._Release()));
; 603  :         } else if constexpr (_In_place_key_extractor::_Extractable) {
; 604  :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);
; 605  :             const auto _Hashval = _Traitsobj(_Keyval);
; 606  :             auto _Target        = _Find_last(_Keyval, _Hashval);
; 607  :             if (_Target._Duplicate) {
; 608  :                 return {_List._Make_iter(_Target._Duplicate), false};
; 609  :             }
; 610  : 
; 611  :             _Check_max_size();
; 612  :             // invalidates _Keyval:
; 613  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 614  :             if (_Check_rehash_required_1()) {

	test	al, al
	je	SHORT $LN3@emplace

; 615  :                 _Rehash_for_1();

	mov	rcx, rbp
	call	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Rehash_for_1

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rcx, rdi
	and	rcx, QWORD PTR [rbp+48]

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rcx, rcx
	mov	rdx, QWORD PTR [rbp+24]
	mov	rax, QWORD PTR [rdx+rcx*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rbx, QWORD PTR [rbp+8]

; 1570 :         if (_Where == _End) {

	cmp	rax, rbx
	jne	SHORT $LN144@emplace

; 1571 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp+8], 0
	jmp	SHORT $LN180@emplace
$LN144@emplace:

; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rdx, QWORD PTR [rdx+rcx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	ecx, DWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	ecx, DWORD PTR [rax+16]
	je	SHORT $LN158@emplace
	npad	4
$LL141@emplace:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	mov	rbx, rax
	cmp	rax, rdx
	je	SHORT $LN159@emplace

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	ecx, DWORD PTR [rax+16]
	jne	SHORT $LL141@emplace
$LN158@emplace:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rbx, QWORD PTR [rax]
$LN180@emplace:

; 616  :                 _Target = _Find_last(_Traits::_Kfn(_Newnode._Ptr->_Myval), _Hashval);

	mov	QWORD PTR $T1[rsp], rbx
$LN181@emplace:
	mov	r15, rbx
	mov	r12, QWORD PTR $T1[rsp]
$LN3@emplace:

; 1615 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	rcx, QWORD PTR [rbx+8]

; 1616 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [rbp+16]

; 1617 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rsi], r12

; 1618 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rsi+8], rcx

; 1619 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [rcx], rsi

; 1620 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [rbx+8], rsi

; 1621 : 
; 1622 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1623 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rbp+24]

; 1624 :         const size_type _Bucket         = _Hashval & _Mask;

	and	rdi, QWORD PTR [rbp+48]

; 1625 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rdi, rdi

; 1626 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1627 :         if (_Bucket_lo._Ptr == _Head) {

	mov	rdx, QWORD PTR [rax+rdi*8]
	cmp	rdx, QWORD PTR [rbp+8]
	jne	SHORT $LN96@emplace

; 1628 :             // bucket is empty, set both
; 1629 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rax+rdi*8], rsi

; 1630 :             _Bucket_hi._Ptr = _Newnode;

	jmp	SHORT $LN182@emplace
$LN159@emplace:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR $T1[rsp], rax
	mov	QWORD PTR $T1[rsp+8], 0
	jmp	SHORT $LN181@emplace
$LN96@emplace:

; 1631 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	rdx, r15
	jne	SHORT $LN98@emplace

; 1632 :             // new node is the lowest element in the bucket
; 1633 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rax+rdi*8], rsi
	jmp	SHORT $LN100@emplace
$LN98@emplace:

; 1634 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rax+rdi*8+8], rcx
	jne	SHORT $LN100@emplace
$LN182@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rax+rdi*8+8], rsi
$LN100@emplace:
	mov	QWORD PTR [r14], rsi
	mov	BYTE PTR [r14+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 619  :             return {

	jmp	$LN183@emplace
$LN179@emplace:
??$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::emplace<std::pair<int const ,Actor *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$2 = 32
this$ = 112
__$ReturnUdt$ = 120
<_Vals_0>$ = 128
?dtor$1@?0???$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::emplace<std::pair<int const ,Actor *> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
?dtor$1@?0???$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::emplace<std::pair<int const ,Actor *> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Newnode$2 = 32
this$ = 112
__$ReturnUdt$ = 120
<_Vals_0>$ = 128
?dtor$0@?0???$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::emplace<std::pair<int const ,Actor *> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$2[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
?dtor$0@?0???$emplace@U?$pair@$$CBHPEAUActor@@@std@@@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::emplace<std::pair<int const ,Actor *> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR [rcx+8]
	mov	rbx, rcx
	mov	r8, QWORD PTR [rcx]
	mov	rcx, r9
	sub	rcx, r8
	sar	rcx, 6

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rdx, 6
	add	rdx, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rbx+8], rdx

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rbx+16]
	sub	rax, r8
	sar	rax, 6

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rbx

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, r9
	call	??$_Uninitialized_value_construct_n@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@_KAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<glm::mat<4,4,float,0> > >
	mov	QWORD PTR [rbx+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1><std::allocator<glm::mat<4,4,float,0> > const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@V?$_Vector_val@U?$_Simple_types@U?$mat@$03$03M$0A@@glm@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1>::_Compressed_pair<std::allocator<glm::mat<4,4,float,0> >,std::_Vector_val<std::_Simple_types<glm::mat<4,4,float,0> > >,1><std::allocator<glm::mat<4,4,float,0> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Construct_n<>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN42:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN38@Construct_
	push	rsi
	push	r14
	sub	rsp, 40					; 00000028H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rsi, rdx
	mov	r14, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN40@Construct_
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+32], rdi

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::allocator<glm::mat<4,4,float,0> >::allocate

; 1990 :         _Myfirst           = _Newvec;
; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	rbx, rsi
	mov	QWORD PTR [r14], rax
	shl	rbx, 6
	xor	edx, edx
	shl	rsi, 6
	mov	rdi, rax
	mov	r8, rsi
	lea	rcx, QWORD PTR [rbx+rax]
	mov	QWORD PTR [r14+16], rcx
	mov	rcx, rax
	call	memset
	add	rdi, rbx

; 2066 :             _Buy_nonzero(_Count);
; 2067 :             _Tidy_guard<vector> _Guard{this};
; 2068 :             if constexpr (sizeof...(_Val) == 0) {
; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	rbx, QWORD PTR [rsp+80]
	mov	QWORD PTR [r14+8], rdi
	mov	rdi, QWORD PTR [rsp+32]

; 2070 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2071 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2072 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2073 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
$LN38@Construct_:
	ret	0
$LN40@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Xlength
	int	3
$LN37@Construct_:
??$_Construct_n@$$V@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Construct_n<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>, COMDAT

; 1094 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1095 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1096 :         for (; _First != _Last; ++_First) {
; 1097 :             _Destroy_in_place(*_First);
; 1098 :         }
; 1099 :     }
; 1100 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > ><std::allocator<std::pair<int const ,Actor *> > const &,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 267  :     }

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > ><std::allocator<std::pair<int const ,Actor *> > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Head$ = 56
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<int const ,Actor *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >, COMDAT

; 324  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN61:
	sub	rsp, 40					; 00000028H

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rcx, QWORD PTR [rdx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rcx, rcx
	je	SHORT $LN3@Free_non_h
	mov	QWORD PTR [rsp+32], rbx
	npad	4
$LL4@Free_non_h:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL4@Free_non_h
	mov	rbx, QWORD PTR [rsp+32]
$LN3@Free_non_h:

; 330  :             _Freenode(_Al, _Pnode);
; 331  :         }
; 332  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<int const ,Actor *>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<int const ,Actor *>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >, COMDAT

; 308  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<int const ,Actor *>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >, COMDAT

; 1602 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rcx, rdx

; 1987 :     // copy _Val throughout raw [_First, _Last)
; 1988 :     _Adl_verify_range(_First, _Last);
; 1989 :     auto _UFirst      = _Get_unwrapped(_First);
; 1990 :     const auto _ULast = _Get_unwrapped(_Last);
; 1991 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1992 :         _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1993 :     } else {
; 1994 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1995 :             if (_Is_all_bits_zero(_Val)) {
; 1996 :                 _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1997 :                 return;
; 1998 :             }
; 1999 :         }
; 2000 : 
; 2001 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 2002 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN3@uninitiali
	npad	11
$LL2@uninitiali:

; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax

; 1617 :         ++_Last;

	add	rcx, 8

; 1987 :     // copy _Val throughout raw [_First, _Last)
; 1988 :     _Adl_verify_range(_First, _Last);
; 1989 :     auto _UFirst      = _Get_unwrapped(_First);
; 1990 :     const auto _ULast = _Get_unwrapped(_Last);
; 1991 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1992 :         _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 1993 :     } else {
; 1994 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 1995 :             if (_Is_all_bits_zero(_Val)) {
; 1996 :                 _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 1997 :                 return;
; 1998 :             }
; 1999 :         }
; 2000 : 
; 2001 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 2002 :         while (_Backout._Last != _ULast) {

	cmp	rcx, rdx
	jne	SHORT $LL2@uninitiali
$LN3@uninitiali:

; 2003 :             _Backout._Emplace_back(_Val);
; 2004 :         }
; 2005 : 
; 2006 :         _Backout._Release();
; 2007 :     }
; 2008 : }

	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Val$ = 32
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >, COMDAT

; 5032 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN21:
	sub	rsp, 8
	mov	r10, rdx
	xor	eax, eax
	sub	rdx, rcx
	mov	r9, rcx
	add	rdx, 7
	shr	rdx, 3
	cmp	rcx, r10
	cmova	rdx, rax

; 5033 :     // copy _Val through [_First, _Last)
; 5034 :     _Adl_verify_range(_First, _Last);
; 5035 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5036 :         _Fill_vbool(_First, _Last, _Val);
; 5037 :     } else {
; 5038 :         auto _UFirst      = _Get_unwrapped(_First);
; 5039 :         const auto _ULast = _Get_unwrapped(_Last);
; 5040 : #if _HAS_CXX20
; 5041 :         if (!_STD is_constant_evaluated())
; 5042 : #endif // _HAS_CXX20
; 5043 :         {
; 5044 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5045 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5046 :                 return;
; 5047 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5048 :                 if (_Is_all_bits_zero(_Val)) {
; 5049 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5050 :                     return;
; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	test	rdx, rdx
	je	SHORT $LN10@fill
	cmp	rdx, 2
	jb	SHORT $LN10@fill

; 5056 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	add	rcx, -8
	lea	rcx, QWORD PTR [rcx+rdx*8]
	cmp	r9, r8
	ja	SHORT $LN11@fill

; 5032 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

	cmp	rcx, r8
	jae	SHORT $LN10@fill
$LN11@fill:
	mov	QWORD PTR [rsp], rdi
	and	rdx, -2
	mov	rdi, r9
	lea	rdx, QWORD PTR [rdx*8]
	mov	rcx, rdx
	shr	rcx, 3
	rep stosq
	add	r9, rdx
	mov	rdi, QWORD PTR [rsp]
$LN10@fill:

; 5033 :     // copy _Val through [_First, _Last)
; 5034 :     _Adl_verify_range(_First, _Last);
; 5035 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5036 :         _Fill_vbool(_First, _Last, _Val);
; 5037 :     } else {
; 5038 :         auto _UFirst      = _Get_unwrapped(_First);
; 5039 :         const auto _ULast = _Get_unwrapped(_Last);
; 5040 : #if _HAS_CXX20
; 5041 :         if (!_STD is_constant_evaluated())
; 5042 : #endif // _HAS_CXX20
; 5043 :         {
; 5044 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5045 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5046 :                 return;
; 5047 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5048 :                 if (_Is_all_bits_zero(_Val)) {
; 5049 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5050 :                     return;
; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r9, r10
	je	SHORT $LN3@fill
	npad	9
$LL9@fill:

; 5056 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [r9], rax
	add	r9, 8
	cmp	r9, r10
	jne	SHORT $LL9@fill
$LN3@fill:

; 5057 :         }
; 5058 :     }
; 5059 : }

	add	rsp, 8
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1><std::allocator<std::pair<int const ,Actor *> > const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1><std::allocator<std::pair<int const ,Actor *> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::_Release, COMDAT

; 1621 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1622 :         return _Last;
; 1623 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>, COMDAT

; 1610 :         _Destroy_range(_First, _Last);
; 1611 :     }

	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>, COMDAT

; 1602 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map@HU?$pair@$$CBHPEAUActor@@@std@@@std@@SAAEBHAEBU?$pair@$$CBHPEAUActor@@@2@@Z
_TEXT	SEGMENT
_Val$ = 8
?_Extract@?$_In_place_key_extract_map@HU?$pair@$$CBHPEAUActor@@@std@@@std@@SAAEBHAEBU?$pair@$$CBHPEAUActor@@@2@@Z PROC ; std::_In_place_key_extract_map<int,std::pair<int const ,Actor *> >::_Extract, COMDAT

; 2113 :         return _Val.first;

	mov	rax, rcx

; 2114 :     }

	ret	0
?_Extract@?$_In_place_key_extract_map@HU?$pair@$$CBHPEAUActor@@@std@@@std@@SAAEBHAEBU?$pair@$$CBHPEAUActor@@@2@@Z ENDP ; std::_In_place_key_extract_map<int,std::pair<int const ,Actor *> >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1156 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN11@List_node_

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN11@List_node_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 593  :     }

	ret	0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_Release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1148 :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Rehash_for_1, COMDAT

; 1658 :     void _Rehash_for_1() {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1659 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;
; 1660 :         const auto _Newsize = _Oldsize + 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	rdi, rcx
	add	rdx, 1

; 1688 :         const size_type _Old_buckets = bucket_count();

	mov	rbx, QWORD PTR [rcx+56]

; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	js	SHORT $LN14@Rehash_for
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN15@Rehash_for
$LN14@Rehash_for:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN15@Rehash_for:
	divss	xmm0, DWORD PTR [rcx]
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	ecx, ecx
	comiss	xmm0, xmm1
	jb	SHORT $LN13@Rehash_for
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN13@Rehash_for
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN13@Rehash_for:
	cvttss2si rax, xmm0
	add	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 8
	cmp	rax, rcx
	cmova	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1690 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rbx, rcx
	jae	SHORT $LN3@Rehash_for

; 1691 :             // we already have enough buckets so there's no need to change the count
; 1692 :             return _Old_buckets;
; 1693 :         }
; 1694 : 
; 1695 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rbx, 512				; 00000200H
	jae	SHORT $LN5@Rehash_for
	lea	rbx, QWORD PTR [rbx*8]
	cmp	rbx, rcx
	jae	SHORT $LN3@Rehash_for
$LN5@Rehash_for:

; 1696 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1697 :             return _Old_buckets * 8;
; 1698 :         }
; 1699 : 
; 1700 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1701 :         return _Req_buckets;

	mov	rbx, rcx
$LN3@Rehash_for:

; 1661 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, rbx
	mov	rcx, rdi

; 1662 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1661 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	jmp	?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Forced_rehash
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Check_rehash_required_1, COMDAT

; 1653 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1654 :         const auto _Newsize      = _Oldsize + 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	r8, rcx
	add	rdx, 1

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	xorps	xmm0, xmm0
	js	SHORT $LN7@Check_reha
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN8@Check_reha
$LN7@Check_reha:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN8@Check_reha:
	mov	rcx, QWORD PTR [rcx+56]
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN5@Check_reha
	cvtsi2ss xmm1, rcx
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [r8]
	seta	al

; 1656 :     }

	ret	0
$LN5@Check_reha:

; 1655 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
	divss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [r8]
	seta	al

; 1656 :     }

	ret	0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Check_max_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Check_max_size, COMDAT

; 1645 :     void _Check_max_size() const {

$LN6:
	sub	rsp, 40					; 00000028H

; 1646 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1647 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	QWORD PTR [rcx+16], rax
	jne	SHORT $LN2@Check_max_

; 1648 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2@Check_max_:

; 1649 :         }
; 1650 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@Check_max_:
?_Check_max_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
this$ = 8
_Hashval$ = 16
_Insert_before$ = 24
_Newnode$ = 32
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Insert_new_node_before, COMDAT

; 1615 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	r11, QWORD PTR [r8+8]
	mov	rax, r9

; 1616 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [rcx+16]
	mov	r10, rcx
	mov	r9, rdx

; 1617 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rax], r8

; 1618 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rax+8], r11

; 1619 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [r11], rax

; 1620 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [r8+8], rax

; 1621 : 
; 1622 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1623 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;

	mov	rdx, QWORD PTR [rcx+24]

; 1624 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rcx, QWORD PTR [rcx+48]
	and	rcx, r9

; 1625 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rcx, rcx

; 1626 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1627 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r9, QWORD PTR [rdx+rcx*8]
	cmp	r9, QWORD PTR [r10+8]
	jne	SHORT $LN2@Insert_new

; 1628 :             // bucket is empty, set both
; 1629 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rdx+rcx*8], rax

; 1635 :             // new node is the highest element in the bucket
; 1636 :             _Bucket_hi._Ptr = _Newnode;
; 1637 :         }
; 1638 : 
; 1639 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1640 :         _Stl_internal_check_container_invariants();
; 1641 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1642 :         return _Newnode;
; 1643 :     }

	mov	QWORD PTR [rdx+rcx*8+8], rax
	ret	0
$LN2@Insert_new:

; 1630 :             _Bucket_hi._Ptr = _Newnode;
; 1631 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r9, r8
	jne	SHORT $LN4@Insert_new

; 1632 :             // new node is the lowest element in the bucket
; 1633 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rdx+rcx*8], rax

; 1635 :             // new node is the highest element in the bucket
; 1636 :             _Bucket_hi._Ptr = _Newnode;
; 1637 :         }
; 1638 : 
; 1639 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1640 :         _Stl_internal_check_container_invariants();
; 1641 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1642 :         return _Newnode;
; 1643 :     }

	ret	0
$LN4@Insert_new:

; 1634 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rdx+rcx*8+8], r11
	jne	SHORT $LN8@Insert_new

; 1635 :             // new node is the highest element in the bucket
; 1636 :             _Bucket_hi._Ptr = _Newnode;
; 1637 :         }
; 1638 : 
; 1639 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1640 :         _Stl_internal_check_container_invariants();
; 1641 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1642 :         return _Newnode;
; 1643 :     }

	mov	QWORD PTR [rdx+rcx*8+8], rax
$LN8@Insert_new:
	ret	0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >, COMDAT

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@@Z PROC ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Make_iter, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], r8

; 1122 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, rdx

; 1123 :     }

	ret	0
?_Make_iter@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@@Z ENDP ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::deallocate, COMDAT

; 701  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBAXPEAU?$mat@$03$03M$0A@@glm@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBAXPEAU?$mat@$03$03M$0A@@glm@@0@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBAXPEAU?$mat@$03$03M$0A@@glm@@0@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >, COMDAT

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >, COMDAT

; 1156 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@Alloc_cons

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN8@Alloc_cons:

; 1157 :             _Al.deallocate(_Ptr, 1);
; 1158 :         }
; 1159 :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Buckets$ = 72
?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Forced_rehash, COMDAT

; 1708 :     void _Forced_rehash(size_type _Buckets) {

$LN216:
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 42   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1708 :     void _Forced_rehash(size_type _Buckets) {

	mov	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 42   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1716 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	edi, 1
	mov	eax, edi
	shl	rax, cl

; 1717 :         if (_Buckets > _Max_storage_buckets) {

	cmp	rdx, rax
	jbe	SHORT $LN8@Forced_reh

; 1718 :             _Xlength_error("invalid hash bucket count");

	lea	rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN8@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	lea	rax, QWORD PTR [rdx-1]
	mov	QWORD PTR [rsp+80], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rbx, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 26   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	rax, rdi

; 42   :     _BitScanReverse64(&_Result, _Value); // lgtm [cpp/conditionallyuninitializedvariable]

	bsr	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1728 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	r8, rbx
	mov	QWORD PTR [rsp+32], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xbit_ops.h

; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1725 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	shl	rdi, cl

; 1728 :         _Vec._Assign_grow(_Buckets << 1, _End);

	lea	rcx, QWORD PTR [rsi+24]
	lea	rdx, QWORD PTR [rdi+rdi]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Assign_grow

; 1729 :         _Mask   = _Buckets - 1;

	lea	rax, QWORD PTR [rdi-1]

; 1730 :         _Maxidx = _Buckets;

	mov	QWORD PTR [rsi+56], rdi
	mov	QWORD PTR [rsi+48], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rsi+8]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	je	$LN212@Forced_reh
	mov	QWORD PTR [rsp+88], rbp
	mov	rdi, 1099511628211			; 00000100000001b3H
	mov	rbp, -3750763034362895579		; cbf29ce484222325H
	npad	5
$LL4@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	edx, BYTE PTR [rax+17]
	movzx	r9d, BYTE PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r11, QWORD PTR [rsi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	r9, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 51   :         _Ptr = _Ptr->_Next;

	mov	rcx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	imul	r9, rdi
	xor	r9, rdx
	movzx	edx, BYTE PTR [rax+18]
	imul	r9, rdi
	xor	r9, rdx
	movzx	edx, BYTE PTR [rax+19]
	imul	r9, rdi
	xor	r9, rdx
	imul	r9, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	r11, r9

; 1738 :             ++_Next_inserted;
; 1739 : 
; 1740 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);
; 1741 :             const size_type _Bucket = bucket(_Inserted_key);
; 1742 : 
; 1743 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1744 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1745 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	shl	r11, 4
	add	r11, QWORD PTR [rsi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	mov	r9, QWORD PTR [r11]
	cmp	r9, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1748 :             if (_Bucket_lo == _End) {

	jne	SHORT $LN9@Forced_reh

; 1749 :                 // The bucket was empty, set it to the inserted element.
; 1750 :                 _Bucket_lo = _Inserted;

	mov	QWORD PTR [r11], rax

; 1751 :                 _Bucket_hi = _Inserted;

	mov	QWORD PTR [r11+8], rax

; 1752 :                 continue;

	jmp	SHORT $LN2@Forced_reh
$LN9@Forced_reh:

; 1753 :             }
; 1754 : 
; 1755 :             // Search the bucket for the insertion location and move element if necessary.
; 1756 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	mov	rdx, QWORD PTR [r11+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	r8d, DWORD PTR [rax+16]
	cmp	r8d, DWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1757 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	jne	SHORT $LN10@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 51   :         _Ptr = _Ptr->_Next;

	mov	r10, QWORD PTR [rdx]
	cmp	r10, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1761 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	je	SHORT $LN202@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r9, QWORD PTR [rax+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r9], rcx

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r8, QWORD PTR [rcx+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r8], r10

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	rdx, QWORD PTR [r10+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rdx], rax

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [r10+8], r8

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r9

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], rdx
$LN202@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1765 :                 _Bucket_hi = _Inserted;

	mov	QWORD PTR [r11+8], rax

; 1766 :                 continue;

	jmp	SHORT $LN2@Forced_reh
$LN10@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1772 :                 if (_Bucket_lo == _Insert_before) {

	je	SHORT $LN183@Forced_reh
$LL5@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 62   :         _Ptr = _Ptr->_Prev;

	mov	rdx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	r8d, DWORD PTR [rdx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1782 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

	je	SHORT $LN184@Forced_reh
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1772 :                 if (_Bucket_lo == _Insert_before) {

	jne	SHORT $LL5@Forced_reh
$LN183@Forced_reh:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r10, QWORD PTR [rax+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r10], rcx

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r9, QWORD PTR [rcx+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r9], rdx

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	r8, QWORD PTR [rdx+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [r8], rax

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rdx+8], r9

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r10

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1778 :                     _Bucket_lo = _Inserted;

	mov	QWORD PTR [r11], rax
$LN2@Forced_reh:

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 73   :         return _Ptr == _Right._Ptr;

	cmp	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1737 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	jne	$LL4@Forced_reh
	mov	rbp, QWORD PTR [rsp+88]
$LN212@Forced_reh:
	mov	rbx, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+32]

; 1798 :     }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
$LN184@Forced_reh:

; 1783 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1784 :                     ++_Insert_before;
; 1785 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1786 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1787 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);

	mov	r10, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r9, QWORD PTR [rax+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r9], rcx

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r8, QWORD PTR [rcx+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r8], r10

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	rdx, QWORD PTR [r10+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rdx], rax

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [r10+8], r8

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rcx+8], r9

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rax+8], rdx
	jmp	SHORT $LN2@Forced_reh
$LN213@Forced_reh:
?_Forced_rehash@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 48
_For_size$ = 56
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Desired_grow_bucket_count, COMDAT

; 1687 :     _NODISCARD size_type _Desired_grow_bucket_count(const size_type _For_size) const noexcept {

$LN21:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1688 :         const size_type _Old_buckets = bucket_count();

	mov	rbx, QWORD PTR [rcx+56]

; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN12@Desired_gr
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN13@Desired_gr
$LN12@Desired_gr:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN13@Desired_gr:
	divss	xmm0, DWORD PTR [rcx]
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	eax, eax
	comiss	xmm0, xmm1
	jb	SHORT $LN11@Desired_gr
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN11@Desired_gr
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	rax, rcx
$LN11@Desired_gr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	mov	edx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	cvttss2si rcx, xmm0
	add	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmp	rcx, rdx
	cmova	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1690 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rbx, rdx
	jb	SHORT $LN2@Desired_gr

; 1691 :             // we already have enough buckets so there's no need to change the count
; 1692 :             return _Old_buckets;

	mov	rax, rbx

; 1696 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1697 :             return _Old_buckets * 8;
; 1698 :         }
; 1699 : 
; 1700 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1701 :         return _Req_buckets;
; 1702 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Desired_gr:

; 1693 :         }
; 1694 : 
; 1695 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rbx, 512				; 00000200H
	jae	SHORT $LN3@Desired_gr
	lea	rax, QWORD PTR [rbx*8]
	cmp	rax, rdx
	cmovae	rdx, rax
$LN3@Desired_gr:

; 1696 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1697 :             return _Old_buckets * 8;
; 1698 :         }
; 1699 : 
; 1700 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1701 :         return _Req_buckets;
; 1702 :     }

	mov	rax, rdx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?max_load_factor@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::max_load_factor, COMDAT

; 911  :         return _Max_bucket_size();

	movss	xmm0, DWORD PTR [rcx]

; 912  :     }

	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::bucket_count, COMDAT

; 846  :         return _Maxidx;

	mov	rax, QWORD PTR [rcx+56]

; 847  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::max_size, COMDAT

; 1193 :         return (_STD min)(

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1194 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1195 :     }

	ret	0
?max_size@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 482  :         ~_Clear_guard() {

$LN84:
	push	rdi
	sub	rsp, 48					; 00000030H

; 483  :             if (_Target) {

	mov	rdi, QWORD PTR [rcx]
	test	rdi, rdi
	je	$LN4@Clear_guar

; 1158 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 1159 :         if (_Oldsize == 0) {

	test	rcx, rcx
	je	$LN4@Clear_guar

; 1160 :             return;
; 1161 :         }
; 1162 : 
; 1163 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1164 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1165 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1166 :             // as many buckets as elements, remove element-by-element.
; 1167 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rax, QWORD PTR [rdi+56]
	shr	rax, 3
	cmp	rax, rcx
	jbe	SHORT $LN6@Clear_guar

; 1168 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	rdx, QWORD PTR [rdi+8]

; 1169 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	rcx, rdi
	mov	r8, rdx
	mov	rdx, QWORD PTR [rdx]

; 484  :                 _Target->clear();
; 485  :             }
; 486  :         }

	add	rsp, 48					; 00000030H
	pop	rdi

; 1169 :                 _Unchecked_erase(_Head->_Next, _Head);

	jmp	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Unchecked_erase
$LN6@Clear_guar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1490 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rcx, QWORD PTR [rdi+8]

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rcx, QWORD PTR [rcx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rcx, rcx
	je	SHORT $LN12@Clear_guar
	mov	QWORD PTR [rsp+72], rbx
	npad	1
$LL13@Clear_guar:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL13@Clear_guar
	mov	rbx, QWORD PTR [rsp+72]
$LN12@Clear_guar:

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	r8, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	QWORD PTR [rax], rax

; 1492 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rax+8], rax

; 1493 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rdi+16], 0

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	mov	rdx, QWORD PTR [rdi+32]
	mov	rcx, QWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR $T1[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >
$LN4@Clear_guar:

; 484  :                 _Target->clear();
; 485  :             }
; 486  :         }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Target_$ = 16
??0_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 477  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::operator++, COMDAT

; 51   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 108  :         _Mybase::operator++();
; 109  :         return *this;

	mov	rax, rcx

; 51   :         _Ptr = _Ptr->_Next;

	mov	QWORD PTR [rcx], rdx

; 110  :     }

	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHPEAUActor@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHPEAUActor@@@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::operator*, COMDAT

; 43   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 100  :         return const_cast<reference>(_Mybase::operator*());
; 101  :     }

	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBHPEAUActor@@@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator==, COMDAT

; 73   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 74   :     }

	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator--, COMDAT

; 62   :         _Ptr = _Ptr->_Prev;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax+8]

; 63   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 64   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator++, COMDAT

; 51   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 52   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 53   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBHPEAUActor@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBHPEAUActor@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator*, COMDAT

; 43   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 44   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBHPEAUActor@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::max_size, COMDAT

; 277  :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 278  :             _Aliter_traits::max_size(_Mypair._Get_first()));
; 279  :     }

	ret	0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$ = 8
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Max_bucket_size, COMDAT

; 1805 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, rcx

; 1806 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 48
_For_size$ = 56
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Min_load_factor_buckets, COMDAT

; 1682 :     _NODISCARD size_type _Min_load_factor_buckets(const size_type _For_size) const noexcept {

$LN10:
	sub	rsp, 40					; 00000028H

; 1683 :         // returns the minimum number of buckets necessary for the elements in _List
; 1684 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	xorps	xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN6@Min_load_f
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN7@Min_load_f
$LN6@Min_load_f:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN7@Min_load_f:
	divss	xmm0, DWORD PTR [rcx]
	call	ceilf
	movss	xmm1, DWORD PTR __real@5f000000
	xor	ecx, ecx
	comiss	xmm0, xmm1
	jb	SHORT $LN5@Min_load_f
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN5@Min_load_f
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN5@Min_load_f:
	cvttss2si rax, xmm0
	add	rax, rcx

; 1685 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBA_KAEBH@Z
_TEXT	SEGMENT
this$ = 8
_Keyval$ = 16
?bucket@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBA_KAEBH@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::bucket, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]

; 2346 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, r9
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
	imul	r8, r9
	xor	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR [rcx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	imul	r8, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	rax, r8

; 856  :     }

	ret	0
?bucket@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEBA_KAEBH@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Unchecked_end, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 811  :         return _List._Unchecked_end();

	mov	rax, rdx

; 812  :     }

	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Unchecked_begin, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rcx+8]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 803  :         return _List._Unchecked_begin();

	mov	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 804  :     }

	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_Before$ = 8
_First$ = 16
_Last$ = 24
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >::_Unchecked_splice, COMDAT

; 470  :         // splice [_First, _Last) before _Before; returns _Last
; 471  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 472  :         // 3 reads and 6 writes
; 473  : 
; 474  :         // fixup the _Next values
; 475  :         const auto _First_prev  = _First->_Prev;

	mov	r10, QWORD PTR [rdx+8]

; 476  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r10], r8

; 477  :         const auto _Last_prev   = _Last->_Prev;

	mov	r9, QWORD PTR [r8+8]

; 478  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r9], rcx

; 479  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR [rcx+8]

; 480  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rax], rdx

; 481  : 
; 482  :         // fixup the _Prev values
; 483  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rcx+8], r9

; 484  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [r8+8], r10

; 485  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rdx+8], rax

; 486  : 
; 487  :         return _Last;

	mov	rax, r8

; 488  :     }

	ret	0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Getal, COMDAT

; 1852 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1853 :     }

	ret	0
?_Getal@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::clear, COMDAT

; 1150 :     void clear() noexcept {

$LN79:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 1151 :         // TRANSITION, ABI:
; 1152 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1153 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1154 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1155 :         //   (2) The hash function operator() may throw exceptions, and
; 1156 :         //   (3) clear() is a noexcept function.
; 1157 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1158 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 1159 :         if (_Oldsize == 0) {

	test	rcx, rcx
	je	$LN1@clear

; 1160 :             return;
; 1161 :         }
; 1162 : 
; 1163 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1164 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1165 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1166 :             // as many buckets as elements, remove element-by-element.
; 1167 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rax, QWORD PTR [rdi+56]
	shr	rax, 3
	cmp	rax, rcx
	jbe	SHORT $LN3@clear

; 1168 :                 const auto _Head = _List._Mypair._Myval2._Myhead;

	mov	rdx, QWORD PTR [rdi+8]

; 1169 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	rcx, rdi
	mov	r8, rdx
	mov	rdx, QWORD PTR [rdx]

; 1177 :     }

	add	rsp, 48					; 00000030H
	pop	rdi

; 1169 :                 _Unchecked_erase(_Head->_Next, _Head);

	jmp	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Unchecked_erase
$LN3@clear:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1490 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rcx, QWORD PTR [rdi+8]

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rcx, QWORD PTR [rcx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rcx, rcx
	je	SHORT $LN9@clear
	mov	QWORD PTR [rsp+72], rbx
	npad	10
$LL10@clear:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL10@clear
	mov	rbx, QWORD PTR [rsp+72]
$LN9@clear:

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	r8, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	QWORD PTR [rax], rax

; 1492 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rax+8], rax

; 1493 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rdi+16], 0

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	mov	rdx, QWORD PTR [rdi+32]
	mov	rcx, QWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR $T1[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1176 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >
$LN1@clear:

; 1177 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?clear@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >,std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Unchecked_begin, COMDAT

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rcx]

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]

; 1106 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, rdx

; 38   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx

; 1107 :     }

	ret	0
?_Unchecked_begin@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
tv925 = 32
tv921 = 40
_Bucket_bounds$1$ = 48
this$ = 112
_First$ = 120
_Last$ = 128
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Unchecked_erase, COMDAT

; 1026 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN206:
	mov	rax, rsp
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rbp, r8
	mov	r14, rdx
	mov	rsi, rcx

; 1027 :         if (_First == _Last) {

	cmp	rdx, r8
	je	$LN203@Unchecked_

; 1032 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	rdx, QWORD PTR [rcx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	mov	r8, 1099511628211			; 00000100000001b3H
	mov	QWORD PTR [rax+16], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1006 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	rbx, r14
	mov	QWORD PTR [rax+24], rdi
	mov	QWORD PTR [rax+32], r12

; 1028 :             return _Last;
; 1029 :         }
; 1030 : 
; 1031 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	r12, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [r14+16]
	mov	QWORD PTR [rax-32], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1006 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	r13, QWORD PTR [r14+8]
	mov	QWORD PTR [rax-40], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r15, QWORD PTR [rsi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rcx, rax
	movzx	eax, BYTE PTR [r14+17]

; 2346 :         _Val *= _FNV_prime;

	imul	rcx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1032 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	QWORD PTR _Bucket_bounds$1$[rsp], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rcx, rax
	movzx	eax, BYTE PTR [r14+18]

; 2346 :         _Val *= _FNV_prime;

	imul	rcx, r8
	xor	rcx, rax
	movzx	eax, BYTE PTR [r14+19]
	imul	rcx, r8
	xor	rcx, rax
	imul	rcx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	r15, rcx

; 1033 :         _Range_eraser _Eraser{_List, _First};
; 1034 :         {
; 1035 :             // process the first bucket, which is special because here _First might not be the beginning of the bucket
; 1036 :             const auto _Predecessor = _First->_Prev;
; 1037 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws
; 1038 :             // nothrow hereafter this block
; 1039 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	r15, 4
	add	r15, rdx

; 1040 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1041 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

	mov	rax, QWORD PTR [r15]
	mov	QWORD PTR tv925[rsp], rax

; 1042 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	rax, QWORD PTR [r15+8]
	mov	QWORD PTR tv921[rsp], rax
	npad	8
$LL2@Unchecked_:

; 1009 :             const auto _Oldnext = _Next;

	mov	rcx, rbx

; 1043 :             for (;;) { // remove elements until we hit the end of the bucket
; 1044 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rdi, rbx

; 1010 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1012 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [rsi+16]

; 1045 :                 _Eraser._Bump_erased();
; 1046 :                 if (_At_bucket_back) {

	cmp	rdi, QWORD PTR tv921[rsp]
	je	SHORT $LN167@Unchecked_

; 1047 :                     break;
; 1048 :                 }
; 1049 : 
; 1050 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, rbp
	jne	SHORT $LL2@Unchecked_

; 1051 :                     if (_Update_lo) {

	cmp	QWORD PTR tv925[rsp], r14
	jne	SHORT $LN189@Unchecked_
$LN170@Unchecked_:

; 1016 :             _Predecessor->_Next = _Next;

	mov	QWORD PTR [r15], rbx
$LN189@Unchecked_:
	mov	r12, QWORD PTR [rsp+136]
	mov	rdi, QWORD PTR [rsp+128]
	mov	r15, QWORD PTR [rsp+64]
	mov	QWORD PTR [r13], rbx

; 1017 :             _Next->_Prev        = _Predecessor;

	mov	QWORD PTR [rbx+8], r13
	mov	r13, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+120]
$LN203@Unchecked_:

; 1093 :         }
; 1094 : 
; 1095 :         return _Last;
; 1096 :     }

	mov	rax, rbp
	add	rsp, 80					; 00000050H
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN167@Unchecked_:

; 1052 :                         // erased the bucket's prefix
; 1053 :                         _Bucket_lo = _Eraser._Next;
; 1054 :                     }
; 1055 : 
; 1056 :                     return _Last;
; 1057 :                 }
; 1058 :             }
; 1059 : 
; 1060 :             if (_Update_lo) {

	cmp	QWORD PTR tv925[rsp], r14
	jne	SHORT $LN14@Unchecked_

; 1061 :                 // emptied the bucket
; 1062 :                 _Bucket_lo = _End;

	mov	QWORD PTR [r15], r12

; 1063 :                 _Bucket_hi = _End;

	mov	rax, r12

; 1064 :             } else {

	jmp	SHORT $LN163@Unchecked_
$LN14@Unchecked_:

; 1065 :                 _Bucket_hi = _Predecessor;

	mov	rax, r13
$LN163@Unchecked_:

; 1066 :             }
; 1067 :         }
; 1068 : 
; 1069 :         // hereafter we are always erasing buckets' prefixes
; 1070 :         while (_Eraser._Next != _Last) {

	mov	QWORD PTR [r15+8], rax
	cmp	rbx, rbp
	je	SHORT $LN189@Unchecked_
	npad	5
$LL5@Unchecked_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rbx+16]

; 2346 :         _Val *= _FNV_prime;

	mov	rdx, 1099511628211			; 00000100000001b3H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r15, QWORD PTR [rsi+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+17]

; 2346 :         _Val *= _FNV_prime;

	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+18]
	imul	rcx, rdx
	xor	rcx, rax
	movzx	eax, BYTE PTR [rbx+19]
	imul	rcx, rdx
	xor	rcx, rax
	imul	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 855  :         return _Traitsobj(_Keyval) & _Mask;

	and	r15, rcx

; 1071 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws
; 1072 :             // nothrow hereafter this block
; 1073 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	r15, 4
	add	r15, QWORD PTR _Bucket_bounds$1$[rsp]

; 1074 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1075 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	r14, QWORD PTR [r15+8]
	npad	12
$LL7@Unchecked_:

; 1009 :             const auto _Oldnext = _Next;

	mov	rcx, rbx

; 1076 :             for (;;) { // remove elements until we hit the end of the bucket
; 1077 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rdi, rbx

; 1010 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1012 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [rsi+16]

; 1078 :                 _Eraser._Bump_erased();
; 1079 :                 if (_At_bucket_back) {

	cmp	rdi, r14
	je	SHORT $LN169@Unchecked_

; 1080 :                     break;
; 1081 :                 }
; 1082 : 
; 1083 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, rbp
	jne	SHORT $LL7@Unchecked_

; 1084 :                     // erased the bucket's prefix
; 1085 :                     _Bucket_lo = _Eraser._Next;
; 1086 :                     return _Last;
; 1087 :                 }
; 1088 :             }

	jmp	$LN170@Unchecked_
$LN169@Unchecked_:

; 1089 : 
; 1090 :             // emptied the bucket
; 1091 :             _Bucket_lo = _End;

	mov	QWORD PTR [r15], r12

; 1092 :             _Bucket_hi = _End;

	mov	QWORD PTR [r15+8], r12
	cmp	rbx, rbp
	jne	$LL5@Unchecked_

; 1066 :             }
; 1067 :         }
; 1068 : 
; 1069 :         // hereafter we are always erasing buckets' prefixes
; 1070 :         while (_Eraser._Next != _Last) {

	jmp	$LN189@Unchecked_
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::clear, COMDAT

; 1487 :     void clear() noexcept { // erase all

$LN64:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1488 :         auto& _My_data = _Mypair._Myval2;
; 1489 :         _My_data._Orphan_non_end();
; 1490 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]
	mov	rdi, rcx

; 325  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 326  : 
; 327  :         auto _Pnode = _Head->_Next;

	mov	rcx, QWORD PTR [rdx]

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rcx, rcx
	je	SHORT $LN5@clear
	mov	QWORD PTR [rsp+56], rbx
	npad	12
$LL6@clear:

; 329  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 328  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL6@clear
	mov	rbx, QWORD PTR [rsp+56]
$LN5@clear:

; 1491 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rax], rax

; 1492 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rax+8], rax

; 1493 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rdi+8], 0

; 1494 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?clear@?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<int const ,Actor *>,std::allocator<std::pair<int const ,Actor *> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 1016 :             _Predecessor->_Next = _Next;

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rdx], rax

; 1017 :             _Next->_Prev        = _Predecessor;

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+8], rax

; 1018 :         }

	ret	0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 1008 :         void _Bump_erased() noexcept {

$LN52:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1009 :             const auto _Oldnext = _Next;

	mov	rcx, QWORD PTR [rcx+16]

; 1010 :             _Next               = _Oldnext->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rbx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1012 :             --_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rbx]
	dec	QWORD PTR [rax+8]

; 1013 :         }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_List_$ = 16
_First_$ = 24
??0_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 1006 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBHPEAUActor@@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >::_Orphan_non_end, COMDAT

; 378  : #if _ITERATOR_DEBUG_LEVEL == 2
; 379  :         _Lockit _Lock(_LOCK_DEBUG);
; 380  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 381  :         const auto _Head          = _Myhead;
; 382  :         while (*_Pnext) {
; 383  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 384  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 385  :                 _Pnext = _Pnextnext;
; 386  :             } else { // orphan the iterator
; 387  :                 (*_Pnext)->_Myproxy = nullptr;
; 388  :                 *_Pnext             = *_Pnextnext;
; 389  :             }
; 390  :         }
; 391  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 392  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> ><std::pair<int const ,Actor *> >, COMDAT

; 962  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> >::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> ><std::pair<int const ,Actor *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$_Find_last@H@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBH_K@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Keyval$ = 24
_Hashval$ = 32
??$_Find_last@H@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBH_K@Z PROC ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Find_last<int>, COMDAT

; 1565 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

	mov	r11, r8

; 1566 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	r8, QWORD PTR [rcx+48]
	and	r8, r9

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	r9, QWORD PTR [rcx+8]
	shl	r8, 4
	add	r8, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [r8+8]

; 1570 :         if (_Where == _End) {

	cmp	rax, r9
	jne	SHORT $LN5@Find_last

; 1571 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR [rdx], r9

; 1592 :         }
; 1593 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx+8], 0
	ret	0
$LN5@Find_last:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	ecx, DWORD PTR [r11]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r8, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	ecx, DWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN15@Find_last
	npad	7
$LL2@Find_last:

; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rax, r8
	je	SHORT $LN16@Find_last

; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rax, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	ecx, DWORD PTR [rax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL2@Find_last
$LN15@Find_last:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rdx+8], rax

; 1592 :         }
; 1593 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx], rcx
	ret	0
$LN16@Find_last:

; 1588 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR [rdx], rax

; 1592 :         }
; 1593 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx+8], 0
	ret	0
??$_Find_last@H@?$_Hash@V?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBH_K@Z ENDP ; std::_Hash<std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0> >::_Find_last<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT

; 584  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN50:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r9
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], 0

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	edx, DWORD PTR [rcx]
	mov	DWORD PTR [rax+16], edx
	mov	QWORD PTR [rax+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 587  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$dead$ = 64
<_Vals_1>$ = 72
<_Vals_2>$dead$ = 80
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBH@1@V?$tuple@$$V@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
;	COMDAT ??$_Kfn@$$CBHPEAUActor@@@?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@SAAEBHAEBU?$pair@$$CBHPEAUActor@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBHPEAUActor@@@?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@SAAEBHAEBU?$pair@$$CBHPEAUActor@@@1@@Z PROC ; std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0>::_Kfn<int const ,Actor *>, COMDAT

; 56   :         return _Val.first;

	mov	rax, rcx

; 57   :     }

	ret	0
??$_Kfn@$$CBHPEAUActor@@@?$_Umap_traits@HPEAUActor@@V?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@3@$0A@@std@@SAAEBHAEBU?$pair@$$CBHPEAUActor@@@1@@Z ENDP ; std::_Umap_traits<int,Actor *,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<std::pair<int const ,Actor *> >,0>::_Kfn<int const ,Actor *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool><std::_List_node<std::pair<int const ,Actor *>,void *> * &,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@std@@QEAA@AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool><std::_List_node<std::pair<int const ,Actor *>,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool><std::_List_node<std::pair<int const ,Actor *>,void *> *,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@_N@std@@QEAA@$$QEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool>::pair<std::_List_node<std::pair<int const ,Actor *>,void *> *,bool><std::_List_node<std::pair<int const ,Actor *>,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$pair@$$CBHPEAUActor@@@std@@@std@@YA$$QEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@$$CBHPEAUActor@@@std@@@std@@YA$$QEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z PROC ; std::forward<std::pair<int const ,Actor *> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$pair@$$CBHPEAUActor@@@std@@@std@@YA$$QEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z ENDP ; std::forward<std::pair<int const ,Actor *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > ><std::pair<int const ,Actor *> >, COMDAT

; 584  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN44:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+32]
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR [rax+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 587  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > ><std::pair<int const ,Actor *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
?dtor$0@?0???$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > ><std::pair<int const ,Actor *> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
?dtor$0@?0???$?0U?$pair@$$CBHPEAUActor@@@std@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@$$QEAU?$pair@$$CBHPEAUActor@@@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > ><std::pair<int const ,Actor *> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@$$QEA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@$$QEA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN95:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 288230376151711743			; 03ffffffffffffffH
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN93@Resize_rea
	mov	QWORD PTR [rsp+80], rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx
	mov	QWORD PTR [rsp+88], r14

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r14, QWORD PTR [rcx+8]
	sub	r14, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 6

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	r14, 6

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@QEAAPEAU?$mat@$03$03M$0A@@glm@@_K@Z ; std::allocator<glm::mat<4,4,float,0> >::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	rcx, r14

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r8, rdi
	shl	rcx, 6
	mov	rbp, rax
	add	rcx, rax
	sub	r8, r14
	mov	r14, QWORD PTR [rsp+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN18@Resize_rea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	shl	r8, 6
	xor	edx, edx
	call	memset
$LN18@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1931 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	rdx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN59@Resize_rea

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN71@Resize_rea

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN68@Resize_rea

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN71@Resize_rea:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN59@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rsi], rbp

; 2030 :         _Mylast  = _Newvec + _Newsize;

	shl	rdi, 6
	add	rdi, rbp

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	shl	rbx, 6
	add	rbx, rbp
	mov	QWORD PTR [rsi+8], rdi
	mov	rbp, QWORD PTR [rsp+80]
	mov	QWORD PTR [rsi+16], rbx

; 1534 :         }
; 1535 : 
; 1536 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN68@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN93@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@CAXXZ ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Xlength
	int	3
$LN91@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@_KAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@_KAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<glm::mat<4,4,float,0> > >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN22@Uninitiali
	shl	rbx, 6
	xor	edx, edx
	mov	r8, rbx
	call	memset
	lea	rax, QWORD PTR [rbx+rdi]

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@Uninitiali:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@PEAU12@_KAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<glm::mat<4,4,float,0> > const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAAEBV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<glm::mat<4,4,float,0> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<int const ,Actor *> > const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<int const ,Actor *> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1><std::allocator<std::pair<int const ,Actor *> > const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >,1><std::allocator<std::pair<int const ,Actor *> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<int const ,Actor *>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >, COMDAT

; 317  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<int const ,Actor *>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,Actor *>,void *> *>, COMDAT

; 305  :     if constexpr (is_array_v<_Ty>) {
; 306  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 307  :     } else {
; 308  :         _Obj.~_Ty();
; 309  :     }
; 310  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<int const ,Actor *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &>, COMDAT

; 1615 :         // construct a new element at *_Last and increment
; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1617 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1618 :     }

	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<int const ,Actor *>,void *> *>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<int const ,Actor *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<int const ,Actor *>,void *> * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<int const ,Actor *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEAPEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBHPEAUActor@@@std@@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBHPEAUActor@@@std@@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<int const ,Actor *> >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@U?$pair@$$CBHPEAUActor@@@std@@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<int const ,Actor *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBHPEAUActor@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$dead$ = 16
??$destroy@U?$pair@$$CBHPEAUActor@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::destroy<std::pair<int const ,Actor *> >, COMDAT

; 725  : #if _HAS_CXX20
; 726  :         _STD destroy_at(_Ptr);
; 727  : #else // _HAS_CXX20
; 728  :         _Ptr->~_Uty();
; 729  : #endif // _HAS_CXX20
; 730  :     }

	ret	0
??$destroy@U?$pair@$$CBHPEAUActor@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::destroy<std::pair<int const ,Actor *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * const &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_Allocate, COMDAT

; 1150 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rbx+8], rax

; 1153 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >, COMDAT

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 0
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXQEAU?$mat@$03$03M$0A@@glm@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXQEAU?$mat@$03$03M$0A@@glm@@_K1@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	mov	rbx, r9

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rdi, r8
	mov	rbp, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rsi], rbp

; 2030 :         _Mylast  = _Newvec + _Newsize;

	shl	rdi, 6
	add	rdi, rbp

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	shl	rbx, 6
	add	rbx, rbp
	mov	QWORD PTR [rsi+8], rdi

; 2033 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi+16], rbx
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEAAXQEAU?$mat@$03$03M$0A@@glm@@_K1@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 6

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ PROC ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 6

; 1880 :     }

	ret	0
?capacity@?$vector@U?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<glm::mat<4,4,float,0>,std::allocator<glm::mat<4,4,float,0> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > ><std::pair<int const ,Actor *> >, COMDAT

; 962  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0U?$pair@$$CBHPEAUActor@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBHPEAUActor@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > ><std::pair<int const ,Actor *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBHPEAUActor@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$dead$ = 24
<_Args_1>$ = 32
<_Args_2>$dead$ = 40
??$construct@U?$pair@$$CBHPEAUActor@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::construct<std::pair<int const ,Actor *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [r9]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	ecx, DWORD PTR [rax]
	mov	DWORD PTR [rdx], ecx
	mov	QWORD PTR [rdx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@U?$pair@$$CBHPEAUActor@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBH@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::construct<std::pair<int const ,Actor *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<int const ,Actor *>,void *> *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YA$$QEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<int const ,Actor *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBHPEAUActor@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@$$QEAU31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$pair@$$CBHPEAUActor@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@$$QEAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::construct<std::pair<int const ,Actor *>,std::pair<int const ,Actor *> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@U?$pair@$$CBHPEAUActor@@@std@@U12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBHPEAUActor@@@1@$$QEAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<int const ,Actor *>,void *> > >::construct<std::pair<int const ,Actor *>,std::pair<int const ,Actor *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAU?$mat@$03$03M$0A@@glm@@@std@@YA?A_TAEBQEAU?$mat@$03$03M$0A@@glm@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAU?$mat@$03$03M$0A@@glm@@@std@@YA?A_TAEBQEAU?$mat@$03$03M$0A@@glm@@@Z PROC ; std::_Get_unwrapped<glm::mat<4,4,float,0> * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAU?$mat@$03$03M$0A@@glm@@@std@@YA?A_TAEBQEAU?$mat@$03$03M$0A@@glm@@@Z ENDP ; std::_Get_unwrapped<glm::mat<4,4,float,0> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAU?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@0PEAU12@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAU?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@0PEAU12@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z PROC ; std::_Uninitialized_move<glm::mat<4,4,float,0> *,std::allocator<glm::mat<4,4,float,0> > >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN27:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1940 :             return _Dest + (_ULast - _UFirst);

	and	rbx, -64				; ffffffffffffffc0H
	lea	rax, QWORD PTR [rdi+rbx]

; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAU?$mat@$03$03M$0A@@glm@@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@0PEAU12@AEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@0@@Z ENDP ; std::_Uninitialized_move<glm::mat<4,4,float,0> *,std::allocator<glm::mat<4,4,float,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm0
	movups	XMMWORD PTR [rax+32], xmm0
	movups	XMMWORD PTR [rax+48], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 64			; 00000040H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@U?$pair@$$CBHPEAUActor@@@std@@@std@@YAXQEAU?$pair@$$CBHPEAUActor@@@0@@Z
_TEXT	SEGMENT
_Location$dead$ = 8
??$destroy_at@U?$pair@$$CBHPEAUActor@@@std@@@std@@YAXQEAU?$pair@$$CBHPEAUActor@@@0@@Z PROC ; std::destroy_at<std::pair<int const ,Actor *> >, COMDAT

; 315  : #if _HAS_CXX20
; 316  :     if constexpr (is_array_v<_Ty>) {
; 317  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 318  :     } else
; 319  : #endif // _HAS_CXX20
; 320  :     {
; 321  :         _Location->~_Ty();
; 322  :     }
; 323  : }

	ret	0
??$destroy_at@U?$pair@$$CBHPEAUActor@@@std@@@std@@YAXQEAU?$pair@$$CBHPEAUActor@@@0@@Z ENDP ; std::destroy_at<std::pair<int const ,Actor *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<int const ,Actor *>,void *> * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<int const ,Actor *>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBHPEAUActor@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<int const ,Actor *>,void *> *,std::_List_node<std::pair<int const ,Actor *>,void *> * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBHPEAUActor@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBH@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBH@0@$$QEAV?$tuple@$$V@0@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
<_Args_2>$dead$ = 32
??$construct_at@U?$pair@$$CBHPEAUActor@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBH@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBH@0@$$QEAV?$tuple@$$V@0@@Z PROC ; std::construct_at<std::pair<int const ,Actor *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rax, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	edx, DWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	DWORD PTR [rcx], edx
	mov	QWORD PTR [rcx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@U?$pair@$$CBHPEAUActor@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBH@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBH@0@$$QEAV?$tuple@$$V@0@@Z ENDP ; std::construct_at<std::pair<int const ,Actor *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBHPEAUActor@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@QEAU10@$$QEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@U?$pair@$$CBHPEAUActor@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@QEAU10@$$QEAU10@@Z PROC ; std::construct_at<std::pair<int const ,Actor *>,std::pair<int const ,Actor *>,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0

; 242  : }

	ret	0
??$construct_at@U?$pair@$$CBHPEAUActor@@@std@@U12@$0A@@std@@YAPEAU?$pair@$$CBHPEAUActor@@@0@QEAU10@$$QEAU10@@Z ENDP ; std::construct_at<std::pair<int const ,Actor *>,std::pair<int const ,Actor *>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z PROC ; std::move<glm::mat<4,4,float,0> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z ENDP ; std::move<glm::mat<4,4,float,0> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@U?$mat@$03$03M$0A@@glm@@@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX$$QEAU?$mat@$03$03M$0A@@glm@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@U?$mat@$03$03M$0A@@glm@@@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX$$QEAU?$mat@$03$03M$0A@@glm@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Emplace_back<glm::mat<4,4,float,0> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rax+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rax+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rax+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 64			; 00000040H

; 1804 :     }

	ret	0
??$_Emplace_back@U?$mat@$03$03M$0A@@glm@@@?$_Uninitialized_backout_al@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@QEAAX$$QEAU?$mat@$03$03M$0A@@glm@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<glm::mat<4,4,float,0> > >::_Emplace_back<glm::mat<4,4,float,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$mat@$03$03M$0A@@glm@@$$V@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@U?$mat@$03$03M$0A@@glm@@$$V@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@@Z PROC ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::construct<glm::mat<4,4,float,0> >, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rdx], xmm0
	movups	XMMWORD PTR [rdx+16], xmm0
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	XMMWORD PTR [rdx+48], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@U?$mat@$03$03M$0A@@glm@@$$V@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::construct<glm::mat<4,4,float,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z PROC ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@std@@AEBV12@$0A@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBHPEAUActor@@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ENDP ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<int const ,Actor *> > > > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEBH$$Z$$V@?$pair@$$CBHPEAUActor@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBH@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$ = 24
_Val2$dead$ = 32
??$?0AEBH$$Z$$V@?$pair@$$CBHPEAUActor@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBH@1@V?$tuple@$$V@1@@Z PROC ; std::pair<int const ,Actor *>::pair<int const ,Actor *><int const &>, COMDAT

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, QWORD PTR [r8]
	mov	edx, DWORD PTR [rax]

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	mov	rax, rcx

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	DWORD PTR [rcx], edx
	mov	QWORD PTR [rcx+8], 0

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	ret	0
??$?0AEBH$$Z$$V@?$pair@$$CBHPEAUActor@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBH@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<int const ,Actor *>::pair<int const ,Actor *><int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z PROC ; std::forward<glm::mat<4,4,float,0> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$mat@$03$03M$0A@@glm@@@std@@YA$$QEAU?$mat@$03$03M$0A@@glm@@AEAU12@@Z ENDP ; std::forward<glm::mat<4,4,float,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$mat@$03$03M$0A@@glm@@U12@@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$mat@$03$03M$0A@@glm@@U12@@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::construct<glm::mat<4,4,float,0>,glm::mat<4,4,float,0> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rdx+48], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@U?$mat@$03$03M$0A@@glm@@U12@@?$_Default_allocator_traits@V?$allocator@U?$mat@$03$03M$0A@@glm@@@std@@@std@@SAXAEAV?$allocator@U?$mat@$03$03M$0A@@glm@@@1@QEAU?$mat@$03$03M$0A@@glm@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<glm::mat<4,4,float,0> > >::construct<glm::mat<4,4,float,0>,glm::mat<4,4,float,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$mat@$03$03M$0A@@glm@@$$V$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@U?$mat@$03$03M$0A@@glm@@$$V$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@@Z PROC ; std::construct_at<glm::mat<4,4,float,0>,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	xorps	xmm0, xmm0

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0

; 242  : }

	ret	0
??$construct_at@U?$mat@$03$03M$0A@@glm@@$$V$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@@Z ENDP ; std::construct_at<glm::mat<4,4,float,0>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$tuple@AEBH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHPEAUActor@@@std@@QEAA@AEAV?$tuple@AEBH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$dead$ = 24
__formal$dead$ = 32
__formal$dead$ = 40
??$?0V?$tuple@AEBH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHPEAUActor@@@std@@QEAA@AEAV?$tuple@AEBH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z PROC ; std::pair<int const ,Actor *>::pair<int const ,Actor *><std::tuple<int const &>,std::tuple<>,0>, COMDAT

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, QWORD PTR [rdx]
	mov	edx, DWORD PTR [rax]
	mov	rax, rcx
	mov	DWORD PTR [rcx], edx
	mov	QWORD PTR [rcx+8], 0
	ret	0
??$?0V?$tuple@AEBH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHPEAUActor@@@std@@QEAA@AEAV?$tuple@AEBH@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ENDP ; std::pair<int const ,Actor *>::pair<int const ,Actor *><std::tuple<int const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$mat@$03$03M$0A@@glm@@U12@$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@U?$mat@$03$03M$0A@@glm@@U12@$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<glm::mat<4,4,float,0>,glm::mat<4,4,float,0>,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1

; 242  : }

	ret	0
??$construct_at@U?$mat@$03$03M$0A@@glm@@U12@$0A@@std@@YAPEAU?$mat@$03$03M$0A@@glm@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<glm::mat<4,4,float,0>,glm::mat<4,4,float,0>,0>
_TEXT	ENDS
END
