; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CJ@MEHPLN@removeVertex?3?5Out?5of?5memory?5?8ho@ ; `string'
PUBLIC	??_C@_0CK@IOAOCBA@removeVertex?3?5Out?5of?5memory?5?8ed@ ; `string'
PUBLIC	??_C@_0CN@BEHLLPDP@canRemoveVertex?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0CL@BDNMMAMJ@removeVertex?3?5Out?5of?5memory?5?8tv@ ; `string'
PUBLIC	??_C@_0CJ@FFEHKGLD@removeVertex?3?5Out?5of?5memory?5?8tr@ ; `string'
PUBLIC	??_C@_0CK@IKPIPHAA@removeVertex?3?5Out?5of?5memory?5?8ha@ ; `string'
PUBLIC	??_C@_0CJ@LHEFPFDN@removeVertex?3?5Out?5of?5memory?5?8hr@ ; `string'
PUBLIC	??_C@_0CK@BOHENGDJ@removeVertex?3?5Out?5of?5memory?5?8pr@ ; `string'
PUBLIC	??_C@_0CK@MOOJLFPF@removeVertex?3?5Out?5of?5memory?5?8po@ ; `string'
PUBLIC	??_C@_0DC@OAIHHLAF@removeVertex?3?5triangulate?$CI?$CJ?5ret@ ; `string'
PUBLIC	??_C@_0CK@PNHHCBLK@removeVertex?3?5Out?5of?5memory?5?8th@ ; `string'
PUBLIC	??_C@_0CH@GJHGNJJA@rcBuildPolyMesh?3?5Too?5many?5verti@ ; `string'
PUBLIC	??_C@_0GK@HAGAJIIB@H?3?2Paul?2switchemulator?2Zelda?5To@ ; `string'
PUBLIC	??_C@_0CN@GJNOFLAJ@removeVertex?3?5Too?5many?5polygons@ ; `string'
PUBLIC	??_C@_0CL@PNMOHAMH@removeVertex?3?5Out?5of?5memory?5?8pa@ ; `string'
PUBLIC	??_C@_0DB@NNAGGPCH@rcBuildPolyMesh?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0DC@LDBAFDMJ@rcBuildPolyMesh?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0DC@PALMAAAI@rcBuildPolyMesh?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0CO@EIEIICJB@rcBuildPolyMesh?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0CP@MKDKCEGA@rcBuildPolyMesh?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0DB@NCNLOCCJ@rcBuildPolyMesh?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0DA@HOJPIDJL@rcBuildPolyMesh?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0DC@HACDPBN@rcBuildPolyMesh?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0DA@JMLBEHAJ@rcBuildPolyMesh?3?5Too?5many?5polyg@ ; `string'
PUBLIC	??_C@_0CP@NPOINCHP@rcBuildPolyMesh?3?5Bad?5triangulat@ ; `string'
PUBLIC	??_C@_0CN@MKNINCCH@rcBuildPolyMesh?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0CM@LPAGGBDF@rcBuildPolyMesh?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0FO@CHEKKLKE@rcBuildPolyMesh?3?5The?5resulting?5@ ; `string'
PUBLIC	??_C@_0DC@CCJPAEGC@rcBuildPolyMesh?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0CD@OHIDPJGB@rcBuildPolyMesh?3?5Adjacency?5fail@ ; `string'
PUBLIC	??_C@_0DC@JKOEGBKH@rcBuildPolyMesh?3?5Failed?5to?5remo@ ; `string'
PUBLIC	??_C@_0DD@EJOOLDAF@rcMergePolyMeshes?3?5Out?5of?5memor@ ; `string'
PUBLIC	??_C@_0DE@GGOEPKPB@rcMergePolyMeshes?3?5Out?5of?5memor@ ; `string'
PUBLIC	??_C@_0DE@CFEIKJDA@rcMergePolyMeshes?3?5Out?5of?5memor@ ; `string'
PUBLIC	??_C@_0FO@CBEPMBBG@rcBuildPolyMesh?3?5The?5resulting?5@ ; `string'
PUBLIC	??_C@_0DD@EGDDDOAL@rcMergePolyMeshes?3?5Out?5of?5memor@ ; `string'
PUBLIC	??_C@_0DC@PCHICFBC@rcMergePolyMeshes?3?5Out?5of?5memor@ ; `string'
PUBLIC	??_C@_0DE@PHGLKNFK@rcMergePolyMeshes?3?5Out?5of?5memor@ ; `string'
PUBLIC	??_C@_0DE@NCPGJGCF@rcMergePolyMeshes?3?5Out?5of?5memor@ ; `string'
PUBLIC	??_C@_0GA@ELEPGKAF@rcMergePolyMeshes?3?5The?5resultin@ ; `string'
PUBLIC	??_C@_0GA@ENEKAALH@rcMergePolyMeshes?3?5The?5resultin@ ; `string'
PUBLIC	??_C@_0CF@HHMIFAFJ@rcMergePolyMeshes?3?5Adjacency?5fa@ ; `string'
PUBLIC	??_C@_0DA@CLHFAIGA@rcMergePolyMeshes?3?5Out?5of?5memor@ ; `string'
PUBLIC	??_C@_0P@PCKJMPLJ@dst?4areas?5?$DN?$DN?50@	; `string'
PUBLIC	??_C@_0O@BHBMFDCO@dst?4regs?5?$DN?$DN?50@	; `string'
PUBLIC	??_C@_0P@EMHMECCP@dst?4polys?5?$DN?$DN?50@	; `string'
PUBLIC	??_C@_0P@EMOMJEJH@dst?4verts?5?$DN?$DN?50@	; `string'
PUBLIC	??_C@_0CP@JAFGNIPH@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@ ; `string'
PUBLIC	??_C@_0DA@DFIONBKK@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@ ; `string'
PUBLIC	??_C@_0DA@HGCCICGL@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@ ; `string'
PUBLIC	??_C@_0P@HJHGDDOK@dst?4flags?5?$DN?$DN?50@	; `string'
PUBLIC	??_C@_0DA@KEABIGAB@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@ ; `string'
PUBLIC	??_C@_0DA@IBJMLNHO@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@ ; `string'
;	COMDAT ??_C@_0DA@IBJMLNHO@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@
CONST	SEGMENT
??_C@_0DA@IBJMLNHO@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@ DB 'rcCopyPolyM'
	DB	'esh: Out of memory ''dst.areas'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KEABIGAB@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@
CONST	SEGMENT
??_C@_0DA@KEABIGAB@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@ DB 'rcCopyPolyM'
	DB	'esh: Out of memory ''dst.flags'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HJHGDDOK@dst?4flags?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0P@HJHGDDOK@dst?4flags?5?$DN?$DN?50@ DB 'dst.flags == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HGCCICGL@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@
CONST	SEGMENT
??_C@_0DA@HGCCICGL@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@ DB 'rcCopyPolyM'
	DB	'esh: Out of memory ''dst.verts'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DFIONBKK@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@
CONST	SEGMENT
??_C@_0DA@DFIONBKK@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@ DB 'rcCopyPolyM'
	DB	'esh: Out of memory ''dst.polys'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JAFGNIPH@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@
CONST	SEGMENT
??_C@_0CP@JAFGNIPH@rcCopyPolyMesh?3?5Out?5of?5memory?5?8@ DB 'rcCopyPolyM'
	DB	'esh: Out of memory ''dst.regs'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMOMJEJH@dst?4verts?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0P@EMOMJEJH@dst?4verts?5?$DN?$DN?50@ DB 'dst.verts == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMHMECCP@dst?4polys?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0P@EMHMECCP@dst?4polys?5?$DN?$DN?50@ DB 'dst.polys == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BHBMFDCO@dst?4regs?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0O@BHBMFDCO@dst?4regs?5?$DN?$DN?50@ DB 'dst.regs == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PCKJMPLJ@dst?4areas?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0P@PCKJMPLJ@dst?4areas?5?$DN?$DN?50@ DB 'dst.areas == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CLHFAIGA@rcMergePolyMeshes?3?5Out?5of?5memor@
CONST	SEGMENT
??_C@_0DA@CLHFAIGA@rcMergePolyMeshes?3?5Out?5of?5memor@ DB 'rcMergePolyMe'
	DB	'shes: Out of memory ''vremap'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HHMIFAFJ@rcMergePolyMeshes?3?5Adjacency?5fa@
CONST	SEGMENT
??_C@_0CF@HHMIFAFJ@rcMergePolyMeshes?3?5Adjacency?5fa@ DB 'rcMergePolyMes'
	DB	'hes: Adjacency failed.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@ENEKAALH@rcMergePolyMeshes?3?5The?5resultin@
CONST	SEGMENT
??_C@_0GA@ENEKAALH@rcMergePolyMeshes?3?5The?5resultin@ DB 'rcMergePolyMes'
	DB	'hes: The resulting mesh has too many vertices %d (max %d). Da'
	DB	'ta can be corrupted.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@ELEPGKAF@rcMergePolyMeshes?3?5The?5resultin@
CONST	SEGMENT
??_C@_0GA@ELEPGKAF@rcMergePolyMeshes?3?5The?5resultin@ DB 'rcMergePolyMes'
	DB	'hes: The resulting mesh has too many polygons %d (max %d). Da'
	DB	'ta can be corrupted.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NCPGJGCF@rcMergePolyMeshes?3?5Out?5of?5memor@
CONST	SEGMENT
??_C@_0DE@NCPGJGCF@rcMergePolyMeshes?3?5Out?5of?5memor@ DB 'rcMergePolyMe'
	DB	'shes: Out of memory ''mesh.areas'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PHGLKNFK@rcMergePolyMeshes?3?5Out?5of?5memor@
CONST	SEGMENT
??_C@_0DE@PHGLKNFK@rcMergePolyMeshes?3?5Out?5of?5memor@ DB 'rcMergePolyMe'
	DB	'shes: Out of memory ''mesh.flags'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PCHICFBC@rcMergePolyMeshes?3?5Out?5of?5memor@
CONST	SEGMENT
??_C@_0DC@PCHICFBC@rcMergePolyMeshes?3?5Out?5of?5memor@ DB 'rcMergePolyMe'
	DB	'shes: Out of memory ''nextVert'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EGDDDOAL@rcMergePolyMeshes?3?5Out?5of?5memor@
CONST	SEGMENT
??_C@_0DD@EGDDDOAL@rcMergePolyMeshes?3?5Out?5of?5memor@ DB 'rcMergePolyMe'
	DB	'shes: Out of memory ''firstVert'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@CBEPMBBG@rcBuildPolyMesh?3?5The?5resulting?5@
CONST	SEGMENT
??_C@_0FO@CBEPMBBG@rcBuildPolyMesh?3?5The?5resulting?5@ DB 'rcBuildPolyMe'
	DB	'sh: The resulting mesh has too many polygons %d (max %d). Dat'
	DB	'a can be corrupted.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CFEIKJDA@rcMergePolyMeshes?3?5Out?5of?5memor@
CONST	SEGMENT
??_C@_0DE@CFEIKJDA@rcMergePolyMeshes?3?5Out?5of?5memor@ DB 'rcMergePolyMe'
	DB	'shes: Out of memory ''mesh.verts'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GGOEPKPB@rcMergePolyMeshes?3?5Out?5of?5memor@
CONST	SEGMENT
??_C@_0DE@GGOEPKPB@rcMergePolyMeshes?3?5Out?5of?5memor@ DB 'rcMergePolyMe'
	DB	'shes: Out of memory ''mesh.polys'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EJOOLDAF@rcMergePolyMeshes?3?5Out?5of?5memor@
CONST	SEGMENT
??_C@_0DD@EJOOLDAF@rcMergePolyMeshes?3?5Out?5of?5memor@ DB 'rcMergePolyMe'
	DB	'shes: Out of memory ''mesh.regs'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@JKOEGBKH@rcBuildPolyMesh?3?5Failed?5to?5remo@
CONST	SEGMENT
??_C@_0DC@JKOEGBKH@rcBuildPolyMesh?3?5Failed?5to?5remo@ DB 'rcBuildPolyMe'
	DB	'sh: Failed to remove edge vertex %d.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OHIDPJGB@rcBuildPolyMesh?3?5Adjacency?5fail@
CONST	SEGMENT
??_C@_0CD@OHIDPJGB@rcBuildPolyMesh?3?5Adjacency?5fail@ DB 'rcBuildPolyMes'
	DB	'h: Adjacency failed.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CCJPAEGC@rcBuildPolyMesh?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0DC@CCJPAEGC@rcBuildPolyMesh?3?5Out?5of?5memory?5@ DB 'rcBuildPolyM'
	DB	'esh: Out of memory ''mesh.flags'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@CHEKKLKE@rcBuildPolyMesh?3?5The?5resulting?5@
CONST	SEGMENT
??_C@_0FO@CHEKKLKE@rcBuildPolyMesh?3?5The?5resulting?5@ DB 'rcBuildPolyMe'
	DB	'sh: The resulting mesh has too many vertices %d (max %d). Dat'
	DB	'a can be corrupted.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LPAGGBDF@rcBuildPolyMesh?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0CM@LPAGGBDF@rcBuildPolyMesh?3?5Out?5of?5memory?5@ DB 'rcBuildPolyM'
	DB	'esh: Out of memory ''tris'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MKNINCCH@rcBuildPolyMesh?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0CN@MKNINCCH@rcBuildPolyMesh?3?5Out?5of?5memory?5@ DB 'rcBuildPolyM'
	DB	'esh: Out of memory ''polys'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NPOINCHP@rcBuildPolyMesh?3?5Bad?5triangulat@
CONST	SEGMENT
??_C@_0CP@NPOINCHP@rcBuildPolyMesh?3?5Bad?5triangulat@ DB 'rcBuildPolyMes'
	DB	'h: Bad triangulation Contour %d.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JMLBEHAJ@rcBuildPolyMesh?3?5Too?5many?5polyg@
CONST	SEGMENT
??_C@_0DA@JMLBEHAJ@rcBuildPolyMesh?3?5Too?5many?5polyg@ DB 'rcBuildPolyMe'
	DB	'sh: Too many polygons %d (max:%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HACDPBN@rcBuildPolyMesh?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0DC@HACDPBN@rcBuildPolyMesh?3?5Out?5of?5memory?5@ DB 'rcBuildPolyMe'
	DB	'sh: Out of memory ''mesh.areas'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HOJPIDJL@rcBuildPolyMesh?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0DA@HOJPIDJL@rcBuildPolyMesh?3?5Out?5of?5memory?5@ DB 'rcBuildPolyM'
	DB	'esh: Out of memory ''nextVert'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NCNLOCCJ@rcBuildPolyMesh?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0DB@NCNLOCCJ@rcBuildPolyMesh?3?5Out?5of?5memory?5@ DB 'rcBuildPolyM'
	DB	'esh: Out of memory ''firstVert'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MKDKCEGA@rcBuildPolyMesh?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0CP@MKDKCEGA@rcBuildPolyMesh?3?5Out?5of?5memory?5@ DB 'rcBuildPolyM'
	DB	'esh: Out of memory ''indices'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@EIEIICJB@rcBuildPolyMesh?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0CO@EIEIICJB@rcBuildPolyMesh?3?5Out?5of?5memory?5@ DB 'rcBuildPolyM'
	DB	'esh: Out of memory ''vflags'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PALMAAAI@rcBuildPolyMesh?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0DC@PALMAAAI@rcBuildPolyMesh?3?5Out?5of?5memory?5@ DB 'rcBuildPolyM'
	DB	'esh: Out of memory ''mesh.verts'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LDBAFDMJ@rcBuildPolyMesh?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0DC@LDBAFDMJ@rcBuildPolyMesh?3?5Out?5of?5memory?5@ DB 'rcBuildPolyM'
	DB	'esh: Out of memory ''mesh.polys'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NNAGGPCH@rcBuildPolyMesh?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0DB@NNAGGPCH@rcBuildPolyMesh?3?5Out?5of?5memory?5@ DB 'rcBuildPolyM'
	DB	'esh: Out of memory ''mesh.regs'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PNMOHAMH@removeVertex?3?5Out?5of?5memory?5?8pa@
CONST	SEGMENT
??_C@_0CL@PNMOHAMH@removeVertex?3?5Out?5of?5memory?5?8pa@ DB 'removeVerte'
	DB	'x: Out of memory ''pareas'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GJNOFLAJ@removeVertex?3?5Too?5many?5polygons@
CONST	SEGMENT
??_C@_0CN@GJNOFLAJ@removeVertex?3?5Too?5many?5polygons@ DB 'removeVertex:'
	DB	' Too many polygons %d (max:%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@HAGAJIIB@H?3?2Paul?2switchemulator?2Zelda?5To@
CONST	SEGMENT
??_C@_0GK@HAGAJIIB@H?3?2Paul?2switchemulator?2Zelda?5To@ DB 'H:\Paul\swit'
	DB	'chemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recast'
	DB	'navigation\recast\RecastMesh.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GJHGNJJA@rcBuildPolyMesh?3?5Too?5many?5verti@
CONST	SEGMENT
??_C@_0CH@GJHGNJJA@rcBuildPolyMesh?3?5Too?5many?5verti@ DB 'rcBuildPolyMe'
	DB	'sh: Too many vertices %d.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PNHHCBLK@removeVertex?3?5Out?5of?5memory?5?8th@
CONST	SEGMENT
??_C@_0CK@PNHHCBLK@removeVertex?3?5Out?5of?5memory?5?8th@ DB 'removeVerte'
	DB	'x: Out of memory ''thole'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@OAIHHLAF@removeVertex?3?5triangulate?$CI?$CJ?5ret@
CONST	SEGMENT
??_C@_0DC@OAIHHLAF@removeVertex?3?5triangulate?$CI?$CJ?5ret@ DB 'removeVe'
	DB	'rtex: triangulate() returned bad results.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MOOJLFPF@removeVertex?3?5Out?5of?5memory?5?8po@
CONST	SEGMENT
??_C@_0CK@MOOJLFPF@removeVertex?3?5Out?5of?5memory?5?8po@ DB 'removeVerte'
	DB	'x: Out of memory ''polys'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BOHENGDJ@removeVertex?3?5Out?5of?5memory?5?8pr@
CONST	SEGMENT
??_C@_0CK@BOHENGDJ@removeVertex?3?5Out?5of?5memory?5?8pr@ DB 'removeVerte'
	DB	'x: Out of memory ''pregs'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@LHEFPFDN@removeVertex?3?5Out?5of?5memory?5?8hr@
CONST	SEGMENT
??_C@_0CJ@LHEFPFDN@removeVertex?3?5Out?5of?5memory?5?8hr@ DB 'removeVerte'
	DB	'x: Out of memory ''hreg'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IKPIPHAA@removeVertex?3?5Out?5of?5memory?5?8ha@
CONST	SEGMENT
??_C@_0CK@IKPIPHAA@removeVertex?3?5Out?5of?5memory?5?8ha@ DB 'removeVerte'
	DB	'x: Out of memory ''harea'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FFEHKGLD@removeVertex?3?5Out?5of?5memory?5?8tr@
CONST	SEGMENT
??_C@_0CJ@FFEHKGLD@removeVertex?3?5Out?5of?5memory?5?8tr@ DB 'removeVerte'
	DB	'x: Out of memory ''tris'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BDNMMAMJ@removeVertex?3?5Out?5of?5memory?5?8tv@
CONST	SEGMENT
??_C@_0CL@BDNMMAMJ@removeVertex?3?5Out?5of?5memory?5?8tv@ DB 'removeVerte'
	DB	'x: Out of memory ''tverts'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BEHLLPDP@canRemoveVertex?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0CN@BEHLLPDP@canRemoveVertex?3?5Out?5of?5memory?5@ DB 'canRemoveVer'
	DB	'tex: Out of memory ''edges'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IOAOCBA@removeVertex?3?5Out?5of?5memory?5?8ed@
CONST	SEGMENT
??_C@_0CK@IOAOCBA@removeVertex?3?5Out?5of?5memory?5?8ed@ DB 'removeVertex'
	DB	': Out of memory ''edges'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MEHPLN@removeVertex?3?5Out?5of?5memory?5?8ho@
CONST	SEGMENT
??_C@_0CJ@MEHPLN@removeVertex?3?5Out?5of?5memory?5?8ho@ DB 'removeVertex:'
	DB	' Out of memory ''hole'' (%d).', 00H		; `string'
PUBLIC	??$rcSwap@G@@YAXAEAG0@Z				; rcSwap<unsigned short>
PUBLIC	??0?$rcScopedDelete@H@@QEAA@PEAH@Z		; rcScopedDelete<int>::rcScopedDelete<int>
PUBLIC	??1?$rcScopedDelete@H@@QEAA@XZ			; rcScopedDelete<int>::~rcScopedDelete<int>
PUBLIC	??B?$rcScopedDelete@H@@QEAAPEAHXZ		; rcScopedDelete<int>::operator int *
PUBLIC	??0?$rcScopedDelete@G@@QEAA@PEAG@Z		; rcScopedDelete<unsigned short>::rcScopedDelete<unsigned short>
PUBLIC	??1?$rcScopedDelete@G@@QEAA@XZ			; rcScopedDelete<unsigned short>::~rcScopedDelete<unsigned short>
PUBLIC	??B?$rcScopedDelete@G@@QEAAPEAGXZ		; rcScopedDelete<unsigned short>::operator unsigned short *
PUBLIC	?__autoclassinit2@?$rcScopedDelete@G@@QEAAX_K@Z	; rcScopedDelete<unsigned short>::__autoclassinit2
PUBLIC	?__autoclassinit2@?$rcScopedDelete@H@@QEAAX_K@Z	; rcScopedDelete<int>::__autoclassinit2
PUBLIC	?uleft@@YA_NPEBG00@Z				; uleft
PUBLIC	?computeVertexHash@@YAHHHH@Z			; computeVertexHash
PUBLIC	?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z ; rcBuildPolyMesh
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcScopedDelete@H@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+16
	DD	imagerel $unwind$??1?$rcScopedDelete@H@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcScopedDelete@G@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+16
	DD	imagerel $unwind$??1?$rcScopedDelete@G@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z DD imagerel ?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z
	DD	imagerel ?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z+5946
	DD	imagerel $unwind$?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z DD imagerel ?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z
	DD	imagerel ?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z+711
	DD	imagerel $unwind$?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?mergePolyVerts@@YAXPEAG0HH0H@Z DD imagerel ?mergePolyVerts@@YAXPEAG0HH0H@Z
	DD	imagerel ?mergePolyVerts@@YAXPEAG0HH0H@Z+312
	DD	imagerel $unwind$?mergePolyVerts@@YAXPEAG0HH0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z DD imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
	DD	imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z+103
	DD	imagerel $unwind$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z DD imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z+103
	DD	imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z+647
	DD	imagerel $chain$3$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z DD imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z+647
	DD	imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z+654
	DD	imagerel $chain$4$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z DD imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z+654
	DD	imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z+709
	DD	imagerel $chain$5$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?triangulate@@YAHHPEBHPEAH1@Z DD imagerel ?triangulate@@YAHHPEBHPEAH1@Z
	DD	imagerel ?triangulate@@YAHHPEBHPEAH1@Z+1058
	DD	imagerel $unwind$?triangulate@@YAHHPEBHPEAH1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?diagonalLoose@@YA_NHHHPEBHPEAH@Z DD imagerel ?diagonalLoose@@YA_NHHHPEBHPEAH@Z
	DD	imagerel ?diagonalLoose@@YA_NHHHPEBHPEAH@Z+112
	DD	imagerel $unwind$?diagonalLoose@@YA_NHHHPEBHPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?inConeLoose@@YA_NHHHPEBHPEAH@Z DD imagerel ?inConeLoose@@YA_NHHHPEBHPEAH@Z
	DD	imagerel ?inConeLoose@@YA_NHHHPEBHPEAH@Z+332
	DD	imagerel $unwind$?inConeLoose@@YA_NHHHPEBHPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?diagonalieLoose@@YA_NHHHPEBHPEAH@Z DD imagerel ?diagonalieLoose@@YA_NHHHPEBHPEAH@Z
	DD	imagerel ?diagonalieLoose@@YA_NHHHPEBHPEAH@Z+328
	DD	imagerel $unwind$?diagonalieLoose@@YA_NHHHPEBHPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?diagonal@@YA_NHHHPEBHPEAH@Z DD imagerel ?diagonal@@YA_NHHHPEBHPEAH@Z
	DD	imagerel ?diagonal@@YA_NHHHPEBHPEAH@Z+112
	DD	imagerel $unwind$?diagonal@@YA_NHHHPEBHPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?inCone@@YA_NHHHPEBHPEAH@Z DD imagerel ?inCone@@YA_NHHHPEBHPEAH@Z
	DD	imagerel ?inCone@@YA_NHHHPEBHPEAH@Z+326
	DD	imagerel $unwind$?inCone@@YA_NHHHPEBHPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?diagonalie@@YA_NHHHPEBHPEAH@Z DD imagerel ?diagonalie@@YA_NHHHPEBHPEAH@Z
	DD	imagerel ?diagonalie@@YA_NHHHPEBHPEAH@Z+411
	DD	imagerel $unwind$?diagonalie@@YA_NHHHPEBHPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?intersect@@YA_NPEBH000@Z DD imagerel ?intersect@@YA_NPEBH000@Z
	DD	imagerel ?intersect@@YA_NPEBH000@Z+139
	DD	imagerel $unwind$?intersect@@YA_NPEBH000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?between@@YA_NPEBH00@Z DD imagerel ?between@@YA_NPEBH00@Z
	DD	imagerel ?between@@YA_NPEBH00@Z+131
	DD	imagerel $unwind$?between@@YA_NPEBH00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?intersectProp@@YA_NPEBH000@Z DD imagerel ?intersectProp@@YA_NPEBH000@Z
	DD	imagerel ?intersectProp@@YA_NPEBH000@Z+195
	DD	imagerel $unwind$?intersectProp@@YA_NPEBH000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addVertex@@YAGGGGPEAGPEAH1AEAH@Z DD imagerel ?addVertex@@YAGGGGPEAGPEAH1AEAH@Z
	DD	imagerel ?addVertex@@YAGGGGPEAGPEAH1AEAH@Z+205
	DD	imagerel $unwind$?addVertex@@YAGGGGPEAGPEAH1AEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?buildMeshAdjacency@@YA_NPEAGHHH@Z DD imagerel ?buildMeshAdjacency@@YA_NPEAGHHH@Z
	DD	imagerel ?buildMeshAdjacency@@YA_NPEAGHHH@Z+712
	DD	imagerel $unwind$?buildMeshAdjacency@@YA_NPEAGHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z DD imagerel $LN2247
	DD	imagerel $LN2247+3246
	DD	imagerel $unwind$?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z DB 016H
	DB	0daH
	DB	00H
	DB	'V'
	DB	02H
	DB	'Q', 03H
	DB	06H
	DB	'a', 05H
	DB	01cH
	DB	08eH
	DB	'$'
	DB	0acH
	DB	'.'
	DB	'z'
	DB	':'
	DB	08cH
	DB	'H'
	DB	'q '
	DB	090H
	DB	05H, 02H
	DB	09cH
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z DB 09cH
	DB	0aH
	DD	imagerel ??1rcScopedTimer@@QEAA@XZ
	DB	0e1H
	DB	02H
	DB	040H
	DB	042H
	DD	imagerel ??1?$rcScopedDelete@E@@QEAA@XZ
	DB	081H
	DB	03H
	DB	078H
	DB	088H
	DB	088H
	DB	098H
	DB	098H
	DB	0a8H
	DB	0a8H
	DB	0b8H
	DB	0b8H
	DB	0c8H
	DB	08aH
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	0c1H
	DB	03H
	DB	0c0H
	DB	011H
	DB	02H
	DB	041H
	DB	02H
	DB	062H
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	0a1H
	DB	03H
	DB	098H
	DB	051H
	DB	02H
	DB	0f1H
	DB	02H
	DB	021H
	DB	03H
	DB	072H
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	041H
	DB	03H
	DB	0a8H
	DB	021H
	DB	02H
	DB	051H
	DB	03H
	DB	0f1H
	DB	03H
	DB	021H
	DB	04H
	DB	082H
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	061H
	DB	03H
	DB	0b8H
	DB	061H
	DB	02H
	DB	041H
	DB	03H
	DB	071H
	DB	04H
	DB	011H
	DB	05H
	DB	041H
	DB	05H
	DB	092H
	DD	imagerel ??1?$rcScopedDelete@G@@QEAA@XZ
	DB	021H
	DB	03H
	DB	0c8H
	DB	0a1H
	DB	02H
	DB	0a1H
	DB	03H
	DB	081H
	DB	04H
	DB	0b1H
	DB	05H
	DB	051H
	DB	06H
	DB	081H
	DB	06H
	DB	061H
	DB	02H
	DB	081H
	DB	03H
	DB	081H
	DB	04H
	DB	061H
	DB	05H
	DB	091H
	DB	06H
	DB	031H
	DB	07H
	DB	061H
	DB	07H
	DB	041H
	DB	03H
	DB	061H
	DB	04H
	DB	061H
	DB	05H
	DB	041H
	DB	06H
	DB	071H
	DB	07H
	DB	011H
	DB	08H
	DB	041H
	DB	08H
	DB	021H
	DB	04H
	DB	041H
	DB	05H
	DB	041H
	DB	06H
	DB	021H
	DB	07H
	DB	051H
	DB	08H
	DB	0f1H
	DB	08H
	DB	021H
	DB	09H
	DB	01H
	DB	05H
	DB	021H
	DB	06H
	DB	021H
	DB	07H
	DB	01H
	DB	08H
	DB	031H
	DB	09H
	DB	0d1H
	DB	09H
	DB	01H
	DB	0aH
	DB	0edH
	DB	05H
	DD	imagerel __imp___std_terminate
	DB	04dH
	DB	07H
	DD	imagerel __imp___std_terminate
	DB	08dH
	DB	08H
	DD	imagerel __imp___std_terminate
	DB	0adH
	DB	09H
	DD	imagerel __imp___std_terminate
	DB	01dH
	DB	0bH
	DD	imagerel __imp___std_terminate
	DB	0fdH
	DB	0bH
	DD	imagerel __imp___std_terminate
	DB	06dH
	DB	0cH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z
	DD	imagerel $ip2state$?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z DD 0a2619H
	DD	0210114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z
	DD	0faH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?buildMeshAdjacency@@YA_NPEAGHHH@Z DD 0d5c01H
	DD	06f45cH
	DD	07d457H
	DD	085452H
	DD	0103449H
	DD	0e00f8213H
	DD	0700bc00dH
	DD	0600aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addVertex@@YAGGGGPEAGPEAH1AEAH@Z DD 081401H
	DD	047414H
	DD	03640fH
	DD	02540aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?intersectProp@@YA_NPEBH000@Z DD 091601H
	DD	057416H
	DD	046416H
	DD	035416H
	DD	023416H
	DD	0e016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?between@@YA_NPEBH00@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?intersect@@YA_NPEBH000@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?diagonalie@@YA_NHHHPEBHPEAH@Z DD 0a1e01H
	DD	0c341eH
	DD	0f01a321eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?inCone@@YA_NHHHPEBHPEAH@Z DD 0a1801H
	DD	067418H
	DD	056418H
	DD	045418H
	DD	033418H
	DD	0e016f018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?diagonal@@YA_NHHHPEBHPEAH@Z DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0e016521aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?diagonalieLoose@@YA_NHHHPEBHPEAH@Z DD 0c2101H
	DD	0c6421H
	DD	0b5421H
	DD	0a3421H
	DD	0f01d3221H
	DD	0d019e01bH
	DD	07015c017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?inConeLoose@@YA_NHHHPEBHPEAH@Z DD 0a1801H
	DD	067418H
	DD	056418H
	DD	045418H
	DD	033418H
	DD	0e016f018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?diagonalLoose@@YA_NHHHPEBHPEAH@Z DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0e016521aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?triangulate@@YAHHPEBHPEAH1@Z DD 0a1901H
	DD	0133419H
	DD	0f0159219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z DD 080021H
	DD	0f400H
	DD	01e400H
	DD	02c400H
	DD	085400H
	DD	imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
	DD	imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z+103
	DD	imagerel $unwind$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z DD 021H
	DD	imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
	DD	imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z+103
	DD	imagerel $unwind$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z DD 081821H
	DD	0f418H
	DD	01e414H
	DD	02c40dH
	DD	085405H
	DD	imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
	DD	imagerel ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z+103
	DD	imagerel $unwind$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z DD 051301H
	DD	0d00f2213H
	DD	0600c700dH
	DD	0300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?mergePolyVerts@@YAXPEAG0HH0H@Z DD 0a1e01H
	DD	0c341eH
	DD	0f01a321eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z DB 06H
	DB	0dH, 04H
	DB	00H
	DB	'H'
	DB	02H
	DB	0f5H, 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z DB 08H
	DB	0aH
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	070H
	DB	038H
	DB	040H
	DB	04eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z DB 028H
	DD	imagerel $stateUnwindMap$?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z
	DD	imagerel $ip2state$?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z DD 0c2b19H
	DD	013641cH
	DD	012541cH
	DD	011341cH
	DD	0f018921cH
	DD	0d014e016H
	DD	07010c012H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z DB 01cH
	DB	0e9H, 03H
	DB	00H
	DB	'j'
	DB	02H
	DB	'b'
	DB	06H
	DB	088H
	DB	0cH
	DB	088H
	DB	014H
	DB	']', 015H
	DB	'&'
	DB	098H
	DB	'2'
	DB	0a4H
	DB	'@'
	DB	']!'
	DB	'P'
	DB	0a8H
	DB	'b'
	DB	08aH
	DB	'v'
	DB	0d1H, 015H
	DB	0b4H
	DB	0e9H, 02H
	DB	00H
	DB	'\'
	DB	'v'
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z DB 0c6H
	DB	0aH
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	0c1H
	DB	04H
	DB	040H
	DB	042H
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	0e1H
	DB	04H
	DB	078H
	DB	088H
	DB	04aH
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	01H
	DB	05H
	DB	080H
	DB	0c8H
	DB	0d8H
	DB	052H
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	021H
	DB	05H
	DB	088H
	DB	0d8H
	DB	041H
	DB	02H
	DB	071H
	DB	02H
	DB	0b8H
	DB	011H
	DB	02H
	DB	0b1H
	DB	02H
	DB	0e1H
	DB	02H
	DB	0a2H
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	041H
	DB	05H
	DB	0d8H
	DB	061H
	DB	02H
	DB	011H
	DB	03H
	DB	0b1H
	DB	03H
	DB	0e1H
	DB	03H
	DB	082H
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	061H
	DB	05H
	DB	0b8H
	DB	0c1H
	DB	02H
	DB	081H
	DB	03H
	DB	031H
	DB	04H
	DB	0d1H
	DB	04H
	DB	01H
	DB	05H
	DB	092H
	DD	imagerel ??1?$rcScopedDelete@H@@QEAA@XZ
	DB	081H
	DB	05H
	DB	0c8H
	DB	0a1H
	DB	02H
	DB	01H
	DB	04H
	DB	0c1H
	DB	04H
	DB	071H
	DB	05H
	DB	011H
	DB	06H
	DB	041H
	DB	06H
	DB	0a2H
	DD	imagerel ??1?$rcScopedDelete@G@@QEAA@XZ
	DB	0a1H
	DB	05H
	DB	0d8H
	DB	0e1H
	DB	02H
	DB	01H
	DB	04H
	DB	061H
	DB	05H
	DB	021H
	DB	06H
	DB	0d1H
	DB	06H
	DB	071H
	DB	07H
	DB	0a1H
	DB	07H
	DB	0b2H
	DD	imagerel ??1?$rcScopedDelete@G@@QEAA@XZ
	DB	0c1H
	DB	05H
	DB	0e8H
	DB	021H
	DB	03H
	DB	061H
	DB	04H
	DB	081H
	DB	05H
	DB	0e1H
	DB	06H
	DB	0a1H
	DB	07H
	DB	051H
	DB	08H
	DB	0f1H
	DB	08H
	DB	021H
	DB	09H
	DB	0c2H
	DD	imagerel ??1?$rcScopedDelete@E@@QEAA@XZ
	DB	0e1H
	DB	05H
	DB	0f8H
	DB	061H
	DB	03H
	DB	0c1H
	DB	04H
	DB	01H
	DB	06H
	DB	021H
	DB	07H
	DB	081H
	DB	08H
	DB	041H
	DB	09H
	DB	0f1H
	DB	09H
	DB	091H
	DB	0aH
	DB	0c1H
	DB	0aH
	DB	021H
	DB	03H
	DB	0a1H
	DB	04H
	DB	01H
	DB	06H
	DB	041H
	DB	07H
	DB	061H
	DB	08H
	DB	0c1H
	DB	09H
	DB	081H
	DB	0aH
	DB	031H
	DB	0bH
	DB	0d1H
	DB	0bH
	DB	01H
	DB	0cH
	DB	061H
	DB	04H
	DB	0e1H
	DB	05H
	DB	041H
	DB	07H
	DB	081H
	DB	08H
	DB	0a1H
	DB	09H
	DB	01H
	DB	0bH
	DB	0c1H
	DB	0bH
	DB	071H
	DB	0cH
	DB	011H
	DB	0dH
	DB	041H
	DB	0dH
	DB	0adH
	DB	05H
	DD	imagerel __imp___std_terminate
	DB	06dH
	DB	07H
	DD	imagerel __imp___std_terminate
	DB	0dH
	DB	09H
	DD	imagerel __imp___std_terminate
	DB	08dH
	DB	0aH
	DD	imagerel __imp___std_terminate
	DB	0edH
	DB	0bH
	DD	imagerel __imp___std_terminate
	DB	08dH
	DB	0dH
	DD	imagerel __imp___std_terminate
	DB	08dH
	DB	0eH
	DD	imagerel __imp___std_terminate
	DB	07dH
	DB	0fH
	DD	imagerel __imp___std_terminate
	DB	05dH
	DB	010H
	DD	imagerel __imp___std_terminate
	DB	0cdH
	DB	010H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z DB 028H
	DD	imagerel $stateUnwindMap$?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z
	DD	imagerel $ip2state$?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z DD 0a2619H
	DD	0330114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z
	DD	0182H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcScopedDelete@G@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcScopedDelete@G@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$rcScopedDelete@G@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcScopedDelete@G@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcScopedDelete@G@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcScopedDelete@H@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcScopedDelete@H@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$rcScopedDelete@H@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcScopedDelete@H@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcScopedDelete@H@@QEAA@XZ
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z
_TEXT	SEGMENT
tv5663 = 64
maxTris$1$ = 64
ctx$GSCopy$1$ = 72
nvp$GSCopy$1$ = 80
i$1$ = 84
npolys$1$ = 88
ntris$1$ = 88
mesh$GSCopy$1$ = 96
tv5689 = 104
tv5573 = 104
tv5721 = 108
i$1$ = 108
tv5576 = 112
tv5688 = 120
tv5572 = 120
bestEa$1$ = 124
bestEb$1$ = 128
ea$1 = 132
eb$2 = 136
tv5808 = 144
cset$GSCopy$1$ = 152
tv5603 = 160
tv5641 = 168
pj$1$ = 176
timer$ = 184
polys$ = 200
indices$ = 208
tris$ = 216
vflags$ = 224
firstVert$ = 232
nextVert$ = 240
__$ArrayPad$ = 248
ctx$ = 336
cset$ = 344
nvp$ = 352
mesh$ = 360
?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z PROC ; rcBuildPolyMesh, COMDAT

; 991  : {

$LN2247:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 264				; 00000108H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r12, r9
	mov	QWORD PTR mesh$GSCopy$1$[rsp], r9
	movsxd	rsi, r8d
	mov	DWORD PTR nvp$GSCopy$1$[rsp], esi
	mov	rdi, rdx
	mov	QWORD PTR cset$GSCopy$1$[rsp], rdx
	mov	r15, rcx
	mov	QWORD PTR ctx$GSCopy$1$[rsp], rcx

; 992  : 	rcAssert(ctx);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN49@rcBuildPol
	test	rcx, rcx
	jne	SHORT $LN49@rcBuildPol
	mov	r8d, 992				; 000003e0H
	lea	rdx, OFFSET FLAT:??_C@_0GK@HAGAJIIB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_03EDDGELHM@ctx@
	call	rax
$LN49@rcBuildPol:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 202  : 	inline rcScopedTimer(rcContext* ctx, const rcTimerLabel label) : m_ctx(ctx), m_label(label) { m_ctx->startTimer(m_label); }

	mov	QWORD PTR timer$[rsp], r15
	mov	DWORD PTR timer$[rsp+8], 11

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN202@rcBuildPol
	mov	rax, QWORD PTR [r15]
	mov	edx, 11
	mov	rcx, r15
	call	QWORD PTR [rax+32]
	npad	1
$LN202@rcBuildPol:

; 774  : 	dest[0] = v[0];

	mov	eax, DWORD PTR [rdi+12]
	mov	DWORD PTR [r12+56], eax

; 775  : 	dest[1] = v[1];

	mov	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR [r12+60], eax

; 776  : 	dest[2] = v[2];

	mov	eax, DWORD PTR [rdi+20]
	mov	DWORD PTR [r12+64], eax

; 774  : 	dest[0] = v[0];

	mov	eax, DWORD PTR [rdi+24]
	mov	DWORD PTR [r12+68], eax

; 775  : 	dest[1] = v[1];

	mov	eax, DWORD PTR [rdi+28]
	mov	DWORD PTR [r12+72], eax

; 776  : 	dest[2] = v[2];

	mov	eax, DWORD PTR [rdi+32]
	mov	DWORD PTR [r12+76], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 998  : 	mesh.cs = cset.cs;

	mov	eax, DWORD PTR [rdi+36]
	mov	DWORD PTR [r12+80], eax

; 999  : 	mesh.ch = cset.ch;

	mov	eax, DWORD PTR [rdi+40]
	mov	DWORD PTR [r12+84], eax

; 1000 : 	mesh.borderSize = cset.borderSize;

	mov	eax, DWORD PTR [rdi+52]
	mov	DWORD PTR [r12+88], eax

; 1001 : 	mesh.maxEdgeError = cset.maxError;

	mov	eax, DWORD PTR [rdi+56]
	mov	DWORD PTR [r12+92], eax

; 1002 : 	
; 1003 : 	int maxVertices = 0;

	xor	ebx, ebx

; 1004 : 	int maxTris = 0;

	xor	r13d, r13d
	mov	DWORD PTR maxTris$1$[rsp], r13d

; 1005 : 	int maxVertsPerCont = 0;

	xor	r14d, r14d

; 1006 : 	for (int i = 0; i < cset.nconts; ++i)

	movsxd	rdx, DWORD PTR [rdi+8]
	test	rdx, rdx
	jle	SHORT $LN51@rcBuildPol

; 1007 : 	{
; 1008 : 		// Skip null contours.
; 1009 : 		if (cset.conts[i].nverts < 3) continue;

	mov	rcx, QWORD PTR [rdi]
	add	rcx, 8
$LL2183@rcBuildPol:
	mov	eax, DWORD PTR [rcx]
	cmp	eax, 3
	jl	SHORT $LN2184@rcBuildPol

; 1010 : 		maxVertices += cset.conts[i].nverts;

	add	ebx, eax

; 1011 : 		maxTris += cset.conts[i].nverts - 2;

	add	r13d, -2
	add	r13d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	cmp	r14d, eax
	cmovg	eax, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1012 : 		maxVertsPerCont = rcMax(maxVertsPerCont, cset.conts[i].nverts);

	mov	r14d, eax
$LN2184@rcBuildPol:

; 1006 : 	for (int i = 0; i < cset.nconts; ++i)

	mov	r9d, ebx
	add	rcx, 32					; 00000020H
	sub	rdx, 1
	jne	SHORT $LL2183@rcBuildPol

; 1013 : 	}
; 1014 : 	
; 1015 : 	if (maxVertices >= 0xfffe)

	mov	DWORD PTR maxTris$1$[rsp], r13d
	cmp	ebx, 65534				; 0000fffeH
	jl	SHORT $LN51@rcBuildPol

; 1016 : 	{
; 1017 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Too many vertices %d.", maxVertices);

	lea	r8, OFFSET FLAT:??_C@_0CH@GJHGNJJA@rcBuildPolyMesh?3?5Too?5many?5verti@
	mov	edx, 3
	mov	rcx, r15
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	r14b, r14b
	jmp	$LN122@rcBuildPol
$LN51@rcBuildPol:

; 1018 : 		return false;
; 1019 : 	}
; 1020 : 		
; 1021 : 	rcScopedDelete<unsigned char> vflags((unsigned char*)rcAlloc(sizeof(unsigned char)*maxVertices, RC_ALLOC_TEMP));

	movsxd	r15, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, r15
	call	QWORD PTR __imp_malloc
	mov	rdi, rax
	mov	QWORD PTR vflags$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1022 : 	if (!vflags)

	test	rax, rax
	jne	SHORT $LN52@rcBuildPol

; 1023 : 	{
; 1024 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'vflags' (%d).", maxVertices);

	lea	r8, OFFSET FLAT:??_C@_0CO@EIEIICJB@rcBuildPolyMesh?3?5Out?5of?5memory?5@
	jmp	$LN101@rcBuildPol
$LN52@rcBuildPol:

; 1025 : 		return false;
; 1026 : 	}
; 1027 : 	memset(vflags, 0, maxVertices);

	mov	r8, r15
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 1029 : 	mesh.verts = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxVertices*3, RC_ALLOC_PERM);

	lea	rbp, QWORD PTR [r15+r15*2]
	add	rbp, rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, rbp
	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1029 : 	mesh.verts = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxVertices*3, RC_ALLOC_PERM);

	mov	QWORD PTR [r12], rax

; 1030 : 	if (!mesh.verts)

	test	rax, rax
	jne	SHORT $LN53@rcBuildPol

; 1031 : 	{
; 1032 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.verts' (%d).", maxVertices);
; 1033 : 		return false;

	lea	r8, OFFSET FLAT:??_C@_0DC@PALMAAAI@rcBuildPolyMesh?3?5Out?5of?5memory?5@
	jmp	$LN101@rcBuildPol
$LN53@rcBuildPol:

; 1035 : 	mesh.polys = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxTris*nvp*2, RC_ALLOC_PERM);

	mov	rax, rsi
	mov	QWORD PTR tv5641[rsp], rax
	movsxd	r12, r13d
	mov	rsi, r12
	imul	rsi, rax
	shl	rsi, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, rsi
	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1035 : 	mesh.polys = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxTris*nvp*2, RC_ALLOC_PERM);

	mov	rcx, QWORD PTR mesh$GSCopy$1$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1036 : 	if (!mesh.polys)

	test	rax, rax
	jne	SHORT $LN54@rcBuildPol

; 1039 : 		return false;

	lea	r8, OFFSET FLAT:??_C@_0DC@LDBAFDMJ@rcBuildPolyMesh?3?5Out?5of?5memory?5@

; 1037 : 	{
; 1038 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.polys' (%d).", maxTris*nvp*2);

	mov	ebx, DWORD PTR nvp$GSCopy$1$[rsp]
	imul	ebx, r13d
	add	ebx, ebx
	jmp	SHORT $LN101@rcBuildPol
$LN54@rcBuildPol:

; 1041 : 	mesh.regs = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxTris, RC_ALLOC_PERM);

	lea	r13, QWORD PTR [r12+r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, r13
	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1041 : 	mesh.regs = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxTris, RC_ALLOC_PERM);

	mov	rcx, QWORD PTR mesh$GSCopy$1$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 1042 : 	if (!mesh.regs)

	test	rax, rax
	jne	SHORT $LN55@rcBuildPol

; 1043 : 	{
; 1044 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.regs' (%d).", maxTris);
; 1045 : 		return false;

	lea	r8, OFFSET FLAT:??_C@_0DB@NNAGGPCH@rcBuildPolyMesh?3?5Out?5of?5memory?5@
	jmp	SHORT $LN2242@rcBuildPol
$LN55@rcBuildPol:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, r12
	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1047 : 	mesh.areas = (unsigned char*)rcAlloc(sizeof(unsigned char)*maxTris, RC_ALLOC_PERM);

	mov	rcx, QWORD PTR mesh$GSCopy$1$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 1048 : 	if (!mesh.areas)

	test	rax, rax
	jne	SHORT $LN56@rcBuildPol

; 1049 : 	{
; 1050 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.areas' (%d).", maxTris);
; 1051 : 		return false;

	lea	r8, OFFSET FLAT:??_C@_0DC@HACDPBN@rcBuildPolyMesh?3?5Out?5of?5memory?5@
$LN2242@rcBuildPol:
	mov	ebx, DWORD PTR maxTris$1$[rsp]
$LN101@rcBuildPol:
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	mov	r9d, ebx
	mov	edx, 3
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	r14b, r14b
	jmp	$LN132@rcBuildPol
$LN56@rcBuildPol:

; 1052 : 	}
; 1053 : 	
; 1054 : 	mesh.nverts = 0;

	xor	edx, edx
	mov	QWORD PTR [rcx+40], rdx

; 1055 : 	mesh.npolys = 0;
; 1056 : 	mesh.nvp = nvp;

	mov	r10d, DWORD PTR nvp$GSCopy$1$[rsp]
	mov	DWORD PTR [rcx+52], r10d

; 1057 : 	mesh.maxpolys = maxTris;

	mov	eax, DWORD PTR maxTris$1$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 1058 : 	
; 1059 : 	memset(mesh.verts, 0, sizeof(unsigned short)*maxVertices*3);

	mov	r8, rbp
	mov	rcx, QWORD PTR [rcx]
	call	memset

; 1060 : 	memset(mesh.polys, 0xff, sizeof(unsigned short)*maxTris*nvp*2);

	mov	r8, rsi
	mov	edx, 255				; 000000ffH
	mov	rsi, QWORD PTR mesh$GSCopy$1$[rsp]
	mov	rcx, QWORD PTR [rsi+8]
	call	memset

; 1061 : 	memset(mesh.regs, 0, sizeof(unsigned short)*maxTris);

	mov	r8, r13
	xor	edx, edx
	mov	rcx, QWORD PTR [rsi+16]
	call	memset

; 1062 : 	memset(mesh.areas, 0, sizeof(unsigned char)*maxTris);

	mov	r8, r12
	xor	edx, edx
	mov	r12, rsi
	mov	rcx, QWORD PTR [rsi+32]
	call	memset

; 1063 : 	
; 1064 : 	rcScopedDelete<int> nextVert((int*)rcAlloc(sizeof(int)*maxVertices, RC_ALLOC_TEMP));

	lea	r15, QWORD PTR [r15*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, r15
	call	QWORD PTR __imp_malloc
	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR nextVert$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1065 : 	if (!nextVert)

	test	rax, rax
	jne	SHORT $LN57@rcBuildPol

; 1066 : 	{
; 1067 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'nextVert' (%d).", maxVertices);

	mov	r9d, ebx
	lea	r8, OFFSET FLAT:??_C@_0DA@HOJPIDJL@rcBuildPolyMesh?3?5Out?5of?5memory?5@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	r14b, r14b
	jmp	$LN142@rcBuildPol
$LN57@rcBuildPol:

; 1068 : 		return false;
; 1069 : 	}
; 1070 : 	memset(nextVert, 0, sizeof(int)*maxVertices);

	mov	r8, r15
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	ecx, 16384				; 00004000H
	call	QWORD PTR __imp_malloc
	mov	rsi, rax
	mov	QWORD PTR firstVert$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1073 : 	if (!firstVert)

	test	rax, rax
	jne	SHORT $LN58@rcBuildPol

; 1074 : 	{
; 1075 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'firstVert' (%d).", VERTEX_BUCKET_COUNT);

	mov	r9d, 4096				; 00001000H
	lea	r8, OFFSET FLAT:??_C@_0DB@NCNLOCCJ@rcBuildPolyMesh?3?5Out?5of?5memory?5@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	r14b, r14b
	jmp	$LN152@rcBuildPol
$LN58@rcBuildPol:

; 1076 : 		return false;
; 1077 : 	}
; 1078 : 	for (int i = 0; i < VERTEX_BUCKET_COUNT; ++i)

	mov	edx, -1
	mov	r8d, 16384				; 00004000H
	mov	rcx, rax
	call	memset

; 1079 : 		firstVert[i] = -1;
; 1080 : 	
; 1081 : 	rcScopedDelete<int> indices((int*)rcAlloc(sizeof(int)*maxVertsPerCont, RC_ALLOC_TEMP));

	movsxd	r15, r14d
	lea	rcx, QWORD PTR [r15*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
	mov	QWORD PTR indices$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1082 : 	if (!indices)

	test	rax, rax
	jne	SHORT $LN59@rcBuildPol

; 1083 : 	{
; 1084 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'indices' (%d).", maxVertsPerCont);

	mov	r9d, r14d
	lea	r8, OFFSET FLAT:??_C@_0CP@MKDKCEGA@rcBuildPolyMesh?3?5Out?5of?5memory?5@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	r14b, r14b
	jmp	$LN162@rcBuildPol
$LN59@rcBuildPol:

; 1085 : 		return false;
; 1086 : 	}
; 1087 : 	rcScopedDelete<int> tris((int*)rcAlloc(sizeof(int)*maxVertsPerCont*3, RC_ALLOC_TEMP));

	lea	rcx, QWORD PTR [r15+r15*2]
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbp, rax
	mov	QWORD PTR tris$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1088 : 	if (!tris)

	test	rax, rax
	jne	SHORT $LN60@rcBuildPol

; 1089 : 	{
; 1090 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'tris' (%d).", maxVertsPerCont*3);

	lea	r9d, DWORD PTR [r14+r14*2]
	lea	r8, OFFSET FLAT:??_C@_0CM@LPAGGBDF@rcBuildPolyMesh?3?5Out?5of?5memory?5@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	r14b, r14b
	jmp	$LN172@rcBuildPol
$LN60@rcBuildPol:

; 1093 : 	rcScopedDelete<unsigned short> polys((unsigned short*)rcAlloc(sizeof(unsigned short)*(maxVertsPerCont+1)*nvp, RC_ALLOC_TEMP));

	lea	eax, DWORD PTR [r14+1]
	movsxd	rcx, eax
	imul	rcx, QWORD PTR tv5641[rsp]
	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR polys$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1093 : 	rcScopedDelete<unsigned short> polys((unsigned short*)rcAlloc(sizeof(unsigned short)*(maxVertsPerCont+1)*nvp, RC_ALLOC_TEMP));

	mov	r13d, DWORD PTR nvp$GSCopy$1$[rsp]
	mov	ecx, r13d
	imul	ecx, r14d

; 1094 : 	if (!polys)

	test	rax, rax
	jne	SHORT $LN61@rcBuildPol

; 1095 : 	{
; 1096 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'polys' (%d).", maxVertsPerCont*nvp);

	lea	r8, OFFSET FLAT:??_C@_0CN@MKNINCCH@rcBuildPolyMesh?3?5Out?5of?5memory?5@
	jmp	$LN2243@rcBuildPol
$LN61@rcBuildPol:

; 1097 : 		return false;
; 1098 : 	}
; 1099 : 	unsigned short* tmpPoly = &polys[maxVertsPerCont*nvp];

	movsxd	rax, ecx
	add	rax, rax
	mov	QWORD PTR tv5603[rsp], rax

; 1100 : 
; 1101 : 	for (int i = 0; i < cset.nconts; ++i)

	mov	DWORD PTR i$1$[rsp], 0
	mov	r11, QWORD PTR cset$GSCopy$1$[rsp]
	cmp	DWORD PTR [r11+8], 0
	jle	$LN2222@rcBuildPol
	xor	r8d, r8d
	mov	QWORD PTR tv5576[rsp], r8
	mov	r12d, r8d
$LL10@rcBuildPol:

; 1102 : 	{
; 1103 : 		rcContour& cont = cset.conts[i];

	mov	r11, QWORD PTR [r11]
	mov	QWORD PTR tv5808[rsp], r11

; 1104 : 		
; 1105 : 		// Skip null contours.
; 1106 : 		if (cont.nverts < 3)

	cmp	DWORD PTR [r8+r11+8], 3
	jl	$LN8@rcBuildPol

; 1107 : 			continue;
; 1108 : 		
; 1109 : 		// Triangulate contour
; 1110 : 		for (int j = 0; j < cont.nverts; ++j)

	xor	eax, eax
	mov	rcx, rbx
	mov	edx, DWORD PTR maxTris$1$[rsp]
	npad	11
$LL13@rcBuildPol:

; 1111 : 			indices[j] = j;

	mov	r14d, edx
	mov	DWORD PTR [rcx], eax

; 1107 : 			continue;
; 1108 : 		
; 1109 : 		// Triangulate contour
; 1110 : 		for (int j = 0; j < cont.nverts; ++j)

	inc	eax
	lea	rcx, QWORD PTR [rcx+4]
	mov	r10d, DWORD PTR [r8+r11+8]
	cmp	eax, r10d
	jl	SHORT $LL13@rcBuildPol

; 1112 : 			
; 1113 : 		int ntris = triangulate(cont.nverts, cont.verts, &indices[0], &tris[0]);

	mov	r9, rbp
	mov	r8, rbx
	mov	rdx, QWORD PTR tv5576[rsp]
	mov	rdx, QWORD PTR [rdx+r11]
	mov	ecx, r10d
	call	?triangulate@@YAHHPEBHPEAH1@Z		; triangulate
	mov	r15d, eax
	mov	DWORD PTR ntris$1$[rsp], eax

; 1114 : 		if (ntris <= 0)

	test	eax, eax
	jg	SHORT $LN63@rcBuildPol

; 1115 : 		{
; 1116 : 			// Bad triangulation, should not happen.
; 1117 : /*			printf("\tconst float bmin[3] = {%ff,%ff,%ff};\n", cset.bmin[0], cset.bmin[1], cset.bmin[2]);
; 1118 : 			printf("\tconst float cs = %ff;\n", cset.cs);
; 1119 : 			printf("\tconst float ch = %ff;\n", cset.ch);
; 1120 : 			printf("\tconst int verts[] = {\n");
; 1121 : 			for (int k = 0; k < cont.nverts; ++k)
; 1122 : 			{
; 1123 : 				const int* v = &cont.verts[k*4];
; 1124 : 				printf("\t\t%d,%d,%d,%d,\n", v[0], v[1], v[2], v[3]);
; 1125 : 			}
; 1126 : 			printf("\t};\n\tconst int nverts = sizeof(verts)/(sizeof(int)*4);\n");*/
; 1127 : 			ctx->log(RC_LOG_WARNING, "rcBuildPolyMesh: Bad triangulation Contour %d.", i);

	mov	r9d, r12d
	lea	r8, OFFSET FLAT:??_C@_0CP@NPOINCHP@rcBuildPolyMesh?3?5Bad?5triangulat@
	mov	edx, 2
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log

; 1128 : 			ntris = -ntris;

	neg	r15d
	mov	DWORD PTR ntris$1$[rsp], r15d
$LN63@rcBuildPol:

; 1129 : 		}
; 1130 : 				
; 1131 : 		// Add and merge vertices.
; 1132 : 		for (int j = 0; j < cont.nverts; ++j)

	xor	r12d, r12d
	mov	DWORD PTR maxTris$1$[rsp], r14d
	mov	rax, QWORD PTR tv5576[rsp]
	mov	rcx, QWORD PTR tv5808[rsp]
	cmp	DWORD PTR [rax+rcx+8], r12d
	jle	$LN15@rcBuildPol
	xor	r15d, r15d
	mov	r13, rbx
	mov	DWORD PTR maxTris$1$[rsp], r14d
	mov	rbp, QWORD PTR mesh$GSCopy$1$[rsp]
	mov	rbx, rax
	npad	5
$LL16@rcBuildPol:

; 1133 : 		{
; 1134 : 			const int* v = &cont.verts[j*4];

	mov	r14, QWORD PTR [rbx+rcx]

; 1135 : 			indices[j] = addVertex((unsigned short)v[0], (unsigned short)v[1], (unsigned short)v[2],

	lea	rax, QWORD PTR [rbp+40]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR nextVert$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rsi
	mov	r9, QWORD PTR [rbp]
	movzx	r8d, WORD PTR [r15+r14+8]
	movzx	edx, WORD PTR [r15+r14+4]
	movzx	ecx, WORD PTR [r15+r14]
	call	?addVertex@@YAGGGGPEAGPEAH1AEAH@Z	; addVertex
	movzx	eax, ax
	mov	DWORD PTR [r13], eax

; 1136 : 								   mesh.verts, firstVert, nextVert, mesh.nverts);
; 1137 : 			if (v[3] & RC_BORDER_VERTEX)

	test	DWORD PTR [r15+r14+12], 65536		; 00010000H
	je	SHORT $LN14@rcBuildPol

; 1138 : 			{
; 1139 : 				// This vertex should be removed.
; 1140 : 				vflags[indices[j]] = 1;

	mov	BYTE PTR [rax+rdi], 1
$LN14@rcBuildPol:

; 1129 : 		}
; 1130 : 				
; 1131 : 		// Add and merge vertices.
; 1132 : 		for (int j = 0; j < cont.nverts; ++j)

	inc	r12d
	add	r15, 16
	add	r13, 4
	mov	rcx, QWORD PTR tv5808[rsp]
	cmp	r12d, DWORD PTR [rbx+rcx+8]
	jl	SHORT $LL16@rcBuildPol
	mov	rbx, QWORD PTR indices$[rsp]
	mov	rbp, QWORD PTR tris$[rsp]
	mov	r15d, DWORD PTR ntris$1$[rsp]
	mov	r13d, DWORD PTR nvp$GSCopy$1$[rsp]
$LN15@rcBuildPol:

; 1141 : 			}
; 1142 : 		}
; 1143 : 
; 1144 : 		// Build initial polygons.
; 1145 : 		int npolys = 0;

	xor	r12d, r12d

; 1146 : 		memset(polys, 0xff, maxVertsPerCont*nvp*sizeof(unsigned short));

	mov	r8, QWORD PTR tv5603[rsp]
	mov	edx, 255				; 000000ffH
	mov	rcx, QWORD PTR polys$[rsp]
	call	memset

; 1147 : 		for (int j = 0; j < ntris; ++j)

	movsxd	r9, r15d
	test	r15d, r15d
	jle	$LN2235@rcBuildPol

; 1141 : 			}
; 1142 : 		}
; 1143 : 
; 1144 : 		// Build initial polygons.
; 1145 : 		int npolys = 0;

	xor	r10d, r10d
	lea	r8, QWORD PTR [rbp+8]
$LL19@rcBuildPol:

; 1148 : 		{
; 1149 : 			int* t = &tris[j*3];
; 1150 : 			if (t[0] != t[1] && t[0] != t[2] && t[1] != t[2])

	mov	edx, DWORD PTR [r8-4]
	movsxd	rax, DWORD PTR [r8-8]
	cmp	eax, edx
	je	SHORT $LN2232@rcBuildPol
	mov	ecx, DWORD PTR [r8]
	cmp	eax, ecx
	je	SHORT $LN2232@rcBuildPol
	mov	r11, QWORD PTR polys$[rsp]
	cmp	edx, ecx
	je	SHORT $LN17@rcBuildPol

; 1151 : 			{
; 1152 : 				polys[npolys*nvp+0] = (unsigned short)indices[t[0]];

	movzx	ecx, WORD PTR [rbx+rax*4]
	movsxd	rdx, r10d
	mov	WORD PTR [r11+rdx*2], cx

; 1153 : 				polys[npolys*nvp+1] = (unsigned short)indices[t[1]];

	movsxd	rax, DWORD PTR [r8-4]
	movzx	eax, WORD PTR [rbx+rax*4]
	mov	WORD PTR [r11+rdx*2+2], ax

; 1154 : 				polys[npolys*nvp+2] = (unsigned short)indices[t[2]];

	movsxd	rax, DWORD PTR [r8]
	movzx	eax, WORD PTR [rbx+rax*4]
	mov	WORD PTR [r11+rdx*2+4], ax

; 1155 : 				npolys++;

	inc	r12d
	add	r10d, r13d

; 1148 : 		{
; 1149 : 			int* t = &tris[j*3];
; 1150 : 			if (t[0] != t[1] && t[0] != t[2] && t[1] != t[2])

	jmp	SHORT $LN17@rcBuildPol
$LN2232@rcBuildPol:

; 1147 : 		for (int j = 0; j < ntris; ++j)

	mov	r11, QWORD PTR polys$[rsp]
$LN17@rcBuildPol:
	add	r8, 12
	sub	r9, 1
	jne	SHORT $LL19@rcBuildPol
	mov	DWORD PTR npolys$1$[rsp], r12d

; 1156 : 			}
; 1157 : 		}
; 1158 : 		if (!npolys)

	test	r12d, r12d
	je	$LN2235@rcBuildPol

; 1159 : 			continue;
; 1160 : 		
; 1161 : 		// Merge polygons.
; 1162 : 		if (nvp > 3)

	cmp	r13d, 3
	jle	$LN69@rcBuildPol
	lea	eax, DWORD PTR [r12-1]
	movsxd	rdi, DWORD PTR nvp$GSCopy$1$[rsp]
	mov	ecx, edi
	imul	ecx, eax
	mov	DWORD PTR tv5721[rsp], ecx
	mov	ebx, DWORD PTR maxTris$1$[rsp]
	npad	14
$LL20@rcBuildPol:

; 1163 : 		{
; 1164 : 			for(;;)
; 1165 : 			{
; 1166 : 				// Find best polygons to merge.
; 1167 : 				int bestMergeVal = 0;

	xor	r15d, r15d

; 1168 : 				int bestPa = 0, bestPb = 0, bestEa = 0, bestEb = 0;

	xor	esi, esi
	xor	ebp, ebp
	xor	r8d, r8d
	mov	DWORD PTR bestEa$1$[rsp], r8d
	xor	r9d, r9d
	mov	DWORD PTR bestEb$1$[rsp], r9d

; 1163 : 		{
; 1164 : 			for(;;)
; 1165 : 			{
; 1166 : 				// Find best polygons to merge.
; 1167 : 				int bestMergeVal = 0;

	xor	r13d, r13d

; 1169 : 				
; 1170 : 				for (int j = 0; j < npolys-1; ++j)

	lea	eax, DWORD PTR [r12-1]
	mov	DWORD PTR tv5689[rsp], eax
	test	eax, eax
	jle	$LN2225@rcBuildPol
	npad	2
$LL25@rcBuildPol:

; 1171 : 				{
; 1172 : 					unsigned short* pj = &polys[j*nvp];

	mov	eax, edi
	imul	eax, r13d
	cdqe
	lea	rcx, QWORD PTR [r11+rax*2]
	mov	QWORD PTR pj$1$[rsp], rcx

; 1173 : 					for (int k = j+1; k < npolys; ++k)

	lea	eax, DWORD PTR [r13+1]
	mov	DWORD PTR tv5688[rsp], eax

; 1171 : 				{
; 1172 : 					unsigned short* pj = &polys[j*nvp];

	mov	r14d, eax

; 1173 : 					for (int k = j+1; k < npolys; ++k)

	cmp	eax, r12d
	jge	$LN23@rcBuildPol
	npad	8
$LL28@rcBuildPol:

; 1174 : 					{
; 1175 : 						unsigned short* pk = &polys[k*nvp];

	mov	r12d, r15d
	mov	eax, edi
	imul	eax, r14d
	cdqe
	lea	rdx, QWORD PTR [r11+rax*2]

; 1176 : 						int ea, eb;
; 1177 : 						int v = getPolyMergeValue(pj, pk, mesh.verts, ea, eb, nvp);

	mov	DWORD PTR [rsp+40], edi
	lea	rax, QWORD PTR eb$2[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR ea$1[rsp]
	mov	rax, QWORD PTR mesh$GSCopy$1$[rsp]
	mov	r8, QWORD PTR [rax]
	call	?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z ; getPolyMergeValue

; 1178 : 						if (v > bestMergeVal)

	cmp	eax, r15d
	jle	SHORT $LN2227@rcBuildPol

; 1179 : 						{
; 1180 : 							bestMergeVal = v;

	mov	r15d, eax

; 1181 : 							bestPa = j;
; 1182 : 							bestPb = k;
; 1183 : 							bestEa = ea;

	mov	r8d, DWORD PTR ea$1[rsp]
	mov	DWORD PTR bestEa$1$[rsp], r8d

; 1184 : 							bestEb = eb;

	mov	r9d, DWORD PTR eb$2[rsp]
	mov	DWORD PTR bestEb$1$[rsp], r9d

; 1178 : 						if (v > bestMergeVal)

	jmp	SHORT $LN26@rcBuildPol
$LN2227@rcBuildPol:
	mov	r8d, DWORD PTR bestEa$1$[rsp]
	mov	r9d, DWORD PTR bestEb$1$[rsp]
$LN26@rcBuildPol:

; 1173 : 					for (int k = j+1; k < npolys; ++k)

	mov	ecx, r14d
	cmp	eax, r12d
	cmovle	ecx, ebp
	mov	ebp, ecx
	mov	eax, r13d
	cmovle	eax, esi
	mov	esi, eax
	inc	r14d
	mov	r12d, DWORD PTR npolys$1$[rsp]
	cmp	r14d, r12d
	mov	rcx, QWORD PTR pj$1$[rsp]
	mov	r11, QWORD PTR polys$[rsp]
	jl	$LL28@rcBuildPol
	mov	eax, DWORD PTR tv5688[rsp]
$LN23@rcBuildPol:

; 1169 : 				
; 1170 : 				for (int j = 0; j < npolys-1; ++j)

	mov	r13d, eax
	cmp	eax, DWORD PTR tv5689[rsp]
	jl	$LL25@rcBuildPol
	mov	DWORD PTR maxTris$1$[rsp], ebx

; 1185 : 						}
; 1186 : 					}
; 1187 : 				}
; 1188 : 				
; 1189 : 				if (bestMergeVal > 0)

	test	r15d, r15d
	jle	SHORT $LN2225@rcBuildPol

; 1193 : 					unsigned short* pb = &polys[bestPb*nvp];

	mov	eax, edi
	imul	eax, ebp
	cdqe
	lea	r14, QWORD PTR [r11+rax*2]

; 1190 : 				{
; 1191 : 					// Found best, merge.
; 1192 : 					unsigned short* pa = &polys[bestPa*nvp];

	mov	eax, edi
	imul	eax, esi
	cdqe
	lea	rcx, QWORD PTR [r11+rax*2]

; 1194 : 					mergePolyVerts(pa, pb, bestEa, bestEb, tmpPoly, nvp);

	mov	DWORD PTR [rsp+40], edi
	mov	rax, QWORD PTR tv5603[rsp]
	add	rax, r11
	mov	QWORD PTR [rsp+32], rax
	mov	rdx, r14
	call	?mergePolyVerts@@YAXPEAG0HH0H@Z		; mergePolyVerts

; 1195 : 					unsigned short* lastPoly = &polys[(npolys-1)*nvp];

	movsxd	rsi, DWORD PTR tv5721[rsp]
	mov	r11, QWORD PTR polys$[rsp]
	lea	rdx, QWORD PTR [r11+rsi*2]

; 1196 : 					if (pb != lastPoly)

	cmp	r14, rdx
	je	SHORT $LN71@rcBuildPol

; 1197 : 						memcpy(pb, lastPoly, sizeof(unsigned short)*nvp);

	lea	r8, QWORD PTR [rdi+rdi]
	mov	rcx, r14
	call	memcpy
	mov	r11, QWORD PTR polys$[rsp]
$LN71@rcBuildPol:

; 1198 : 					npolys--;

	mov	r12d, DWORD PTR tv5689[rsp]
	mov	DWORD PTR npolys$1$[rsp], r12d
	sub	esi, edi
	mov	DWORD PTR tv5721[rsp], esi

; 1199 : 				}
; 1200 : 				else
; 1201 : 				{
; 1202 : 					// Could not merge any polygons, stop.
; 1203 : 					break;
; 1204 : 				}
; 1205 : 			}

	jmp	$LL20@rcBuildPol
$LN2225@rcBuildPol:
	mov	rbx, QWORD PTR indices$[rsp]
	mov	rdi, QWORD PTR vflags$[rsp]
	mov	rsi, QWORD PTR firstVert$[rsp]
	mov	rbp, QWORD PTR tris$[rsp]
	mov	r13d, DWORD PTR nvp$GSCopy$1$[rsp]
$LN69@rcBuildPol:

; 1206 : 		}
; 1207 : 		
; 1208 : 		// Store polygons.
; 1209 : 		for (int j = 0; j < npolys; ++j)

	xor	r10d, r10d
	test	r12d, r12d
	jle	$LN2235@rcBuildPol
	xor	r11d, r11d
	mov	r14, QWORD PTR mesh$GSCopy$1$[rsp]
	mov	r15, QWORD PTR polys$[rsp]
	npad	7
$LL31@rcBuildPol:

; 1210 : 		{
; 1211 : 			unsigned short* p = &mesh.polys[mesh.npolys*nvp*2];

	mov	eax, r13d
	imul	eax, DWORD PTR [r14+44]
	add	eax, eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r14+8]
	lea	rdx, QWORD PTR [rax+rcx*2]

; 1212 : 			unsigned short* q = &polys[j*nvp];

	movsxd	rax, r11d
	lea	r8, QWORD PTR [r15+rax*2]

; 1210 : 		{
; 1211 : 			unsigned short* p = &mesh.polys[mesh.npolys*nvp*2];

	xor	ecx, ecx

; 1213 : 			for (int k = 0; k < nvp; ++k)

	movsxd	r9, r13d
	test	r13d, r13d
	jle	SHORT $LN33@rcBuildPol

; 1210 : 		{
; 1211 : 			unsigned short* p = &mesh.polys[mesh.npolys*nvp*2];

	sub	r8, rdx
	npad	7
$LL2186@rcBuildPol:

; 1214 : 				p[k] = q[k];

	movzx	eax, WORD PTR [r8+rdx]
	mov	WORD PTR [rdx], ax

; 1213 : 			for (int k = 0; k < nvp; ++k)

	inc	rcx
	lea	rdx, QWORD PTR [rdx+2]
	cmp	rcx, r9
	jl	SHORT $LL2186@rcBuildPol
$LN33@rcBuildPol:

; 1215 : 			mesh.regs[mesh.npolys] = cont.reg;

	movsxd	rdx, DWORD PTR [r14+44]
	mov	rcx, QWORD PTR [r14+16]
	mov	r8, QWORD PTR tv5576[rsp]
	mov	r9, QWORD PTR tv5808[rsp]
	movzx	eax, WORD PTR [r8+r9+28]
	mov	WORD PTR [rcx+rdx*2], ax

; 1216 : 			mesh.areas[mesh.npolys] = cont.area;

	movsxd	rdx, DWORD PTR [r14+44]
	mov	rcx, QWORD PTR [r14+32]
	movzx	eax, BYTE PTR [r8+r9+30]
	mov	BYTE PTR [rdx+rcx], al

; 1217 : 			mesh.npolys++;

	mov	r9d, DWORD PTR [r14+44]
	inc	r9d
	mov	DWORD PTR [r14+44], r9d

; 1218 : 			if (mesh.npolys > maxTris)

	mov	eax, DWORD PTR maxTris$1$[rsp]
	cmp	r9d, eax
	jg	$LN2166@rcBuildPol

; 1206 : 		}
; 1207 : 		
; 1208 : 		// Store polygons.
; 1209 : 		for (int j = 0; j < npolys; ++j)

	inc	r10d
	add	r11d, r13d
	cmp	r10d, r12d
	jl	$LL31@rcBuildPol

; 1147 : 		for (int j = 0; j < ntris; ++j)

	jmp	SHORT $LN2236@rcBuildPol
$LN2235@rcBuildPol:

; 1100 : 
; 1101 : 	for (int i = 0; i < cset.nconts; ++i)

	mov	r8, QWORD PTR tv5576[rsp]
$LN2236@rcBuildPol:
	mov	r12d, DWORD PTR i$1$[rsp]
$LN8@rcBuildPol:
	inc	r12d
	mov	DWORD PTR i$1$[rsp], r12d
	add	r8, 32					; 00000020H
	mov	QWORD PTR tv5576[rsp], r8
	mov	r11, QWORD PTR cset$GSCopy$1$[rsp]
	cmp	r12d, DWORD PTR [r11+8]
	jl	$LL10@rcBuildPol
	mov	r12, QWORD PTR mesh$GSCopy$1$[rsp]
$LN2222@rcBuildPol:

; 1221 : 				return false;
; 1222 : 			}
; 1223 : 		}
; 1224 : 	}
; 1225 : 	
; 1226 : 	
; 1227 : 	// Remove edge vertices.
; 1228 : 	for (int i = 0; i < mesh.nverts; ++i)

	xor	r15d, r15d
	mov	r8d, DWORD PTR [r12+40]
	test	r8d, r8d
	jle	$LN36@rcBuildPol
$LL37@rcBuildPol:

; 1229 : 	{
; 1230 : 		if (vflags[i])

	movsxd	r14, r15d
	add	r14, rdi
	cmp	BYTE PTR [r14], 0
	je	SHORT $LN2239@rcBuildPol

; 1231 : 		{
; 1232 : 			if (!canRemoveVertex(ctx, mesh, (unsigned short)i))

	movzx	r8d, r15w
	mov	rdx, r12
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z ; canRemoveVertex
	test	al, al
	je	SHORT $LN2239@rcBuildPol

; 1233 : 				continue;
; 1234 : 			if (!removeVertex(ctx, mesh, (unsigned short)i, maxTris))

	mov	r9d, DWORD PTR maxTris$1$[rsp]
	movzx	r8d, r15w
	mov	rdx, r12
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z ; removeVertex
	test	al, al
	je	$LN2167@rcBuildPol

; 1238 : 				return false;
; 1239 : 			}
; 1240 : 			// Remove vertex
; 1241 : 			// Note: mesh.nverts is already decremented inside removeVertex()!
; 1242 : 			// Fixup vertex flags
; 1243 : 			for (int j = i; j < mesh.nverts; ++j)

	mov	edx, r15d
	lea	r8, QWORD PTR [r12+40]
	cmp	r15d, DWORD PTR [r8]
	jge	SHORT $LN39@rcBuildPol
	npad	4
$LL40@rcBuildPol:

; 1244 : 				vflags[j] = vflags[j+1];

	movzx	eax, BYTE PTR [r14+1]
	mov	BYTE PTR [r14], al

; 1238 : 				return false;
; 1239 : 			}
; 1240 : 			// Remove vertex
; 1241 : 			// Note: mesh.nverts is already decremented inside removeVertex()!
; 1242 : 			// Fixup vertex flags
; 1243 : 			for (int j = i; j < mesh.nverts; ++j)

	inc	edx
	lea	r14, QWORD PTR [r14+1]
	cmp	edx, DWORD PTR [r8]
	jl	SHORT $LL40@rcBuildPol
$LN39@rcBuildPol:

; 1245 : 			--i;

	dec	r15d

; 1229 : 	{
; 1230 : 		if (vflags[i])

	jmp	SHORT $LN35@rcBuildPol
$LN2166@rcBuildPol:

; 1219 : 			{
; 1220 : 				ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Too many polygons %d (max:%d).", mesh.npolys, maxTris);

	mov	DWORD PTR [rsp+32], eax
	lea	r8, OFFSET FLAT:??_C@_0DA@JMLBEHAJ@rcBuildPolyMesh?3?5Too?5many?5polyg@
	mov	edx, 3
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	r14b, r14b
	jmp	$LN114@rcBuildPol
$LN2239@rcBuildPol:

; 1221 : 				return false;
; 1222 : 			}
; 1223 : 		}
; 1224 : 	}
; 1225 : 	
; 1226 : 	
; 1227 : 	// Remove edge vertices.
; 1228 : 	for (int i = 0; i < mesh.nverts; ++i)

	lea	r8, QWORD PTR [r12+40]
$LN35@rcBuildPol:
	inc	r15d
	mov	r8d, DWORD PTR [r8]
	cmp	r15d, r8d
	jl	$LL37@rcBuildPol
$LN36@rcBuildPol:

; 1246 : 		}
; 1247 : 	}
; 1248 : 	
; 1249 : 	// Calculate adjacency.
; 1250 : 	if (!buildMeshAdjacency(mesh.polys, mesh.npolys, mesh.nverts, nvp))

	mov	r9d, r13d
	mov	edx, DWORD PTR [r12+44]
	mov	rcx, QWORD PTR [r12+8]
	call	?buildMeshAdjacency@@YA_NPEAGHHH@Z	; buildMeshAdjacency
	test	al, al
	jne	SHORT $LN76@rcBuildPol

; 1251 : 	{
; 1252 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Adjacency failed.");

	lea	r8, OFFSET FLAT:??_C@_0CD@OHIDPJGB@rcBuildPolyMesh?3?5Adjacency?5fail@
	mov	edx, 3
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	r14b, r14b
	jmp	$LN114@rcBuildPol
$LN2167@rcBuildPol:

; 1235 : 			{
; 1236 : 				// Failed to remove vertex
; 1237 : 				ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Failed to remove edge vertex %d.", i);

	mov	r9d, r15d
	lea	r8, OFFSET FLAT:??_C@_0DC@JKOEGBKH@rcBuildPolyMesh?3?5Failed?5to?5remo@
	jmp	$LN2244@rcBuildPol
$LN76@rcBuildPol:

; 1253 : 		return false;
; 1254 : 	}
; 1255 : 	
; 1256 : 	// Find portal edges
; 1257 : 	if (mesh.borderSize > 0)

	mov	r14d, 65535				; 0000ffffH
	cmp	DWORD PTR [r12+88], 0
	jle	$LN42@rcBuildPol

; 1258 : 	{
; 1259 : 		const int w = cset.width;

	mov	r12, QWORD PTR cset$GSCopy$1$[rsp]
	mov	r15d, DWORD PTR [r12+44]

; 1260 : 		const int h = cset.height;

	mov	r12d, DWORD PTR [r12+48]

; 1261 : 		for (int i = 0; i < mesh.npolys; ++i)

	xor	r13d, r13d
	mov	DWORD PTR i$1$[rsp], r13d
	mov	rax, QWORD PTR mesh$GSCopy$1$[rsp]
	cmp	DWORD PTR [rax+44], r13d
	jle	$LN2228@rcBuildPol

; 1258 : 	{
; 1259 : 		const int w = cset.width;

	xor	r9d, r9d
	mov	DWORD PTR tv5573[rsp], r9d
	mov	r10d, DWORD PTR nvp$GSCopy$1$[rsp]
	add	r10d, r10d
	mov	DWORD PTR tv5572[rsp], r10d
	mov	rsi, rax
	mov	rbx, QWORD PTR tv5641[rsp]
	npad	4
$LL43@rcBuildPol:

; 1262 : 		{
; 1263 : 			unsigned short* p = &mesh.polys[i*2*nvp];

	movsxd	rcx, r9d
	mov	rax, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR [rax+rcx*2]

; 1264 : 			for (int j = 0; j < nvp; ++j)

	xor	r8d, r8d
	test	rbx, rbx
	jle	SHORT $LN41@rcBuildPol
$LL46@rcBuildPol:

; 1265 : 			{
; 1266 : 				if (p[j] == RC_MESH_NULL_IDX) break;

	movzx	eax, WORD PTR [rdx+r8*2]
	cmp	ax, r14w
	je	SHORT $LN2226@rcBuildPol

; 1267 : 				// Skip connected edges.
; 1268 : 				if (p[nvp+j] != RC_MESH_NULL_IDX)

	lea	r9, QWORD PTR [r8+rbx]
	cmp	WORD PTR [rdx+r9*2], r14w
	jne	SHORT $LN44@rcBuildPol

; 1269 : 					continue;
; 1270 : 				int nj = j+1;

	lea	r10, QWORD PTR [r8+1]

; 1271 : 				if (nj >= nvp || p[nj] == RC_MESH_NULL_IDX) nj = 0;

	cmp	r10, rbx
	jge	SHORT $LN81@rcBuildPol
	cmp	WORD PTR [rdx+r8*2+2], r14w
	jne	SHORT $LN80@rcBuildPol
$LN81@rcBuildPol:
	xor	r10d, r10d
$LN80@rcBuildPol:

; 1272 : 				const unsigned short* va = &mesh.verts[p[j]*3];

	mov	rcx, QWORD PTR [rsi]
	lea	r11, QWORD PTR [rax+rax*2]

; 1273 : 				const unsigned short* vb = &mesh.verts[p[nj]*3];

	movzx	eax, WORD PTR [rdx+r10*2]
	lea	r10, QWORD PTR [rax+rax*2]

; 1274 : 
; 1275 : 				if ((int)va[0] == 0 && (int)vb[0] == 0)

	movzx	r14d, WORD PTR [rcx+r11*2]
	test	r14w, r14w
	jne	SHORT $LN2220@rcBuildPol
	cmp	WORD PTR [rcx+r10*2], r14w
	jne	SHORT $LN2220@rcBuildPol

; 1276 : 					p[nvp+j] = 0x8000 | 0;

	mov	WORD PTR [rdx+r9*2], 32768		; 00008000H
$LN2241@rcBuildPol:

; 1264 : 			for (int j = 0; j < nvp; ++j)

	mov	r14d, 65535				; 0000ffffH
$LN44@rcBuildPol:
	inc	r8
	cmp	r8, rbx
	jl	SHORT $LL46@rcBuildPol
$LN2226@rcBuildPol:
	mov	r13d, DWORD PTR i$1$[rsp]
	mov	r9d, DWORD PTR tv5573[rsp]
	mov	r10d, DWORD PTR tv5572[rsp]
$LN41@rcBuildPol:

; 1261 : 		for (int i = 0; i < mesh.npolys; ++i)

	inc	r13d
	mov	DWORD PTR i$1$[rsp], r13d
	add	r9d, r10d
	mov	DWORD PTR tv5573[rsp], r9d
	cmp	r13d, DWORD PTR [rsi+44]
	jl	$LL43@rcBuildPol
	mov	rbx, QWORD PTR indices$[rsp]
	mov	rdi, QWORD PTR vflags$[rsp]
	mov	rsi, QWORD PTR firstVert$[rsp]
	mov	rbp, QWORD PTR tris$[rsp]
	mov	r12, QWORD PTR mesh$GSCopy$1$[rsp]
	jmp	SHORT $LN42@rcBuildPol
$LN2220@rcBuildPol:

; 1277 : 				else if ((int)va[2] == h && (int)vb[2] == h)

	movzx	r11d, WORD PTR [rcx+r11*2+4]
	cmp	r11d, r12d
	jne	SHORT $LN2204@rcBuildPol
	movzx	eax, WORD PTR [rcx+r10*2+4]
	cmp	eax, r12d
	jne	SHORT $LN2204@rcBuildPol

; 1278 : 					p[nvp+j] = 0x8000 | 1;

	mov	WORD PTR [rdx+r9*2], 32769		; 00008001H
	jmp	SHORT $LN2241@rcBuildPol
$LN2204@rcBuildPol:

; 1279 : 				else if ((int)va[0] == w && (int)vb[0] == w)

	cmp	r14d, r15d
	jne	SHORT $LN86@rcBuildPol
	movzx	eax, WORD PTR [rcx+r10*2]
	cmp	eax, r15d
	jne	SHORT $LN86@rcBuildPol

; 1280 : 					p[nvp+j] = 0x8000 | 2;

	mov	WORD PTR [rdx+r9*2], 32770		; 00008002H
	jmp	$LN2241@rcBuildPol
$LN86@rcBuildPol:

; 1281 : 				else if ((int)va[2] == 0 && (int)vb[2] == 0)

	test	r11w, r11w
	jne	$LN2241@rcBuildPol
	mov	r14d, 65535				; 0000ffffH
	cmp	WORD PTR [rcx+r10*2+4], r11w
	jne	$LN44@rcBuildPol

; 1282 : 					p[nvp+j] = 0x8000 | 3;

	mov	WORD PTR [rdx+r9*2], 32771		; 00008003H

; 1281 : 				else if ((int)va[2] == 0 && (int)vb[2] == 0)

	jmp	$LN44@rcBuildPol
$LN2228@rcBuildPol:

; 1261 : 		for (int i = 0; i < mesh.npolys; ++i)

	mov	r12, rax
$LN42@rcBuildPol:

; 1288 : 	mesh.flags = (unsigned short*)rcAlloc(sizeof(unsigned short)*mesh.npolys, RC_ALLOC_PERM);

	movsxd	rcx, DWORD PTR [r12+44]
	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1288 : 	mesh.flags = (unsigned short*)rcAlloc(sizeof(unsigned short)*mesh.npolys, RC_ALLOC_PERM);

	mov	QWORD PTR [r12+24], rax

; 1289 : 	if (!mesh.flags)

	movsxd	rcx, DWORD PTR [r12+44]
	test	rax, rax
	jne	SHORT $LN89@rcBuildPol

; 1290 : 	{
; 1291 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.flags' (%d).", mesh.npolys);

	lea	r8, OFFSET FLAT:??_C@_0DC@CCJPAEGC@rcBuildPolyMesh?3?5Out?5of?5memory?5@
$LN2243@rcBuildPol:
	mov	r9d, ecx
$LN2244@rcBuildPol:
	mov	edx, 3
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	r14b, r14b
	jmp	SHORT $LN114@rcBuildPol
$LN89@rcBuildPol:

; 1292 : 		return false;
; 1293 : 	}
; 1294 : 	memset(mesh.flags, 0, sizeof(unsigned short) * mesh.npolys);

	mov	r8, rcx
	add	r8, r8
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 1295 : 	
; 1296 : 	if (mesh.nverts > 0xffff)

	mov	r9d, DWORD PTR [r12+40]
	cmp	r9d, r14d
	jle	SHORT $LN2237@rcBuildPol

; 1297 : 	{
; 1298 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: The resulting mesh has too many vertices %d (max %d). Data can be corrupted.", mesh.nverts, 0xffff);

	mov	DWORD PTR [rsp+32], r14d
	lea	r8, OFFSET FLAT:??_C@_0FO@CHEKKLKE@rcBuildPolyMesh?3?5The?5resulting?5@
	mov	edx, 3
	mov	r14, QWORD PTR ctx$GSCopy$1$[rsp]
	mov	rcx, r14
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log

; 1295 : 	
; 1296 : 	if (mesh.nverts > 0xffff)

	jmp	SHORT $LN90@rcBuildPol
$LN2237@rcBuildPol:
	mov	r14, QWORD PTR ctx$GSCopy$1$[rsp]
$LN90@rcBuildPol:

; 1299 : 	}
; 1300 : 	if (mesh.npolys > 0xffff)

	mov	r9d, DWORD PTR [r12+44]
	cmp	r9d, 65535				; 0000ffffH
	jle	SHORT $LN91@rcBuildPol

; 1301 : 	{
; 1302 : 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: The resulting mesh has too many polygons %d (max %d). Data can be corrupted.", mesh.npolys, 0xffff);

	mov	DWORD PTR [rsp+32], 65535		; 0000ffffH
	lea	r8, OFFSET FLAT:??_C@_0FO@CBEPMBBG@rcBuildPolyMesh?3?5The?5resulting?5@
	mov	edx, 3
	mov	rcx, r14
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
$LN91@rcBuildPol:

; 1303 : 	}
; 1304 : 	
; 1305 : 	return true;

	mov	r14b, 1
$LN114@rcBuildPol:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rax, QWORD PTR polys$[rsp]
	test	rax, rax
	je	SHORT $LN177@rcBuildPol

; 28   : 	free(ptr);

	mov	rcx, rax
	call	QWORD PTR __imp_free
	npad	1
$LN177@rcBuildPol:
$LN172@rcBuildPol:

; 47   : 	if (ptr != NULL)

	test	rbp, rbp
	je	SHORT $LN167@rcBuildPol

; 28   : 	free(ptr);

	mov	rcx, rbp
	call	QWORD PTR __imp_free
	npad	1
$LN167@rcBuildPol:
	mov	rbp, QWORD PTR nextVert$[rsp]
$LN162@rcBuildPol:

; 47   : 	if (ptr != NULL)

	test	rbx, rbx
	je	SHORT $LN157@rcBuildPol

; 28   : 	free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
	npad	1
$LN157@rcBuildPol:
$LN152@rcBuildPol:

; 47   : 	if (ptr != NULL)

	test	rsi, rsi
	je	SHORT $LN147@rcBuildPol

; 28   : 	free(ptr);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
	npad	1
$LN147@rcBuildPol:
$LN142@rcBuildPol:

; 47   : 	if (ptr != NULL)

	test	rbp, rbp
	je	SHORT $LN137@rcBuildPol

; 28   : 	free(ptr);

	mov	rcx, rbp
	call	QWORD PTR __imp_free
	npad	1
$LN137@rcBuildPol:
$LN132@rcBuildPol:

; 47   : 	if (ptr != NULL)

	test	rdi, rdi
	je	SHORT $LN127@rcBuildPol

; 28   : 	free(ptr);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
	npad	1
$LN127@rcBuildPol:
	mov	r15, QWORD PTR ctx$GSCopy$1$[rsp]
$LN122@rcBuildPol:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN2224@rcBuildPol
	mov	r8, QWORD PTR [r15]
	mov	edx, 11
	mov	rcx, r15
	call	QWORD PTR [r8+40]
	npad	1
$LN2224@rcBuildPol:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 1306 : }

	movzx	eax, r14b
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 264				; 00000108H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z ENDP ; rcBuildPolyMesh
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5663 = 64
maxTris$1$ = 64
ctx$GSCopy$1$ = 72
nvp$GSCopy$1$ = 80
i$1$ = 84
npolys$1$ = 88
ntris$1$ = 88
mesh$GSCopy$1$ = 96
tv5689 = 104
tv5573 = 104
tv5721 = 108
i$1$ = 108
tv5576 = 112
tv5688 = 120
tv5572 = 120
bestEa$1$ = 124
bestEb$1$ = 128
ea$1 = 132
eb$2 = 136
tv5808 = 144
cset$GSCopy$1$ = 152
tv5603 = 160
tv5641 = 168
pj$1$ = 176
timer$ = 184
polys$ = 200
indices$ = 208
tris$ = 216
vflags$ = 224
firstVert$ = 232
nextVert$ = 240
__$ArrayPad$ = 248
ctx$ = 336
cset$ = 344
nvp$ = 352
mesh$ = 360
?dtor$0@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA PROC ; `rcBuildPolyMesh'::`1'::dtor$0
	lea	rcx, QWORD PTR timer$[rdx]
	jmp	??1rcScopedTimer@@QEAA@XZ		; rcScopedTimer::~rcScopedTimer
?dtor$0@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA ENDP ; `rcBuildPolyMesh'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5663 = 64
maxTris$1$ = 64
ctx$GSCopy$1$ = 72
nvp$GSCopy$1$ = 80
i$1$ = 84
npolys$1$ = 88
ntris$1$ = 88
mesh$GSCopy$1$ = 96
tv5689 = 104
tv5573 = 104
tv5721 = 108
i$1$ = 108
tv5576 = 112
tv5688 = 120
tv5572 = 120
bestEa$1$ = 124
bestEb$1$ = 128
ea$1 = 132
eb$2 = 136
tv5808 = 144
cset$GSCopy$1$ = 152
tv5603 = 160
tv5641 = 168
pj$1$ = 176
timer$ = 184
polys$ = 200
indices$ = 208
tris$ = 216
vflags$ = 224
firstVert$ = 232
nextVert$ = 240
__$ArrayPad$ = 248
ctx$ = 336
cset$ = 344
nvp$ = 352
mesh$ = 360
?dtor$1@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA PROC ; `rcBuildPolyMesh'::`1'::dtor$1
	lea	rcx, QWORD PTR vflags$[rdx]
	jmp	??1?$rcScopedDelete@E@@QEAA@XZ		; rcScopedDelete<unsigned char>::~rcScopedDelete<unsigned char>
?dtor$1@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA ENDP ; `rcBuildPolyMesh'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5663 = 64
maxTris$1$ = 64
ctx$GSCopy$1$ = 72
nvp$GSCopy$1$ = 80
i$1$ = 84
npolys$1$ = 88
ntris$1$ = 88
mesh$GSCopy$1$ = 96
tv5689 = 104
tv5573 = 104
tv5721 = 108
i$1$ = 108
tv5576 = 112
tv5688 = 120
tv5572 = 120
bestEa$1$ = 124
bestEb$1$ = 128
ea$1 = 132
eb$2 = 136
tv5808 = 144
cset$GSCopy$1$ = 152
tv5603 = 160
tv5641 = 168
pj$1$ = 176
timer$ = 184
polys$ = 200
indices$ = 208
tris$ = 216
vflags$ = 224
firstVert$ = 232
nextVert$ = 240
__$ArrayPad$ = 248
ctx$ = 336
cset$ = 344
nvp$ = 352
mesh$ = 360
?dtor$2@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA PROC ; `rcBuildPolyMesh'::`1'::dtor$2
	lea	rcx, QWORD PTR nextVert$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$2@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA ENDP ; `rcBuildPolyMesh'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5663 = 64
maxTris$1$ = 64
ctx$GSCopy$1$ = 72
nvp$GSCopy$1$ = 80
i$1$ = 84
npolys$1$ = 88
ntris$1$ = 88
mesh$GSCopy$1$ = 96
tv5689 = 104
tv5573 = 104
tv5721 = 108
i$1$ = 108
tv5576 = 112
tv5688 = 120
tv5572 = 120
bestEa$1$ = 124
bestEb$1$ = 128
ea$1 = 132
eb$2 = 136
tv5808 = 144
cset$GSCopy$1$ = 152
tv5603 = 160
tv5641 = 168
pj$1$ = 176
timer$ = 184
polys$ = 200
indices$ = 208
tris$ = 216
vflags$ = 224
firstVert$ = 232
nextVert$ = 240
__$ArrayPad$ = 248
ctx$ = 336
cset$ = 344
nvp$ = 352
mesh$ = 360
?dtor$3@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA PROC ; `rcBuildPolyMesh'::`1'::dtor$3
	lea	rcx, QWORD PTR firstVert$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$3@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA ENDP ; `rcBuildPolyMesh'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5663 = 64
maxTris$1$ = 64
ctx$GSCopy$1$ = 72
nvp$GSCopy$1$ = 80
i$1$ = 84
npolys$1$ = 88
ntris$1$ = 88
mesh$GSCopy$1$ = 96
tv5689 = 104
tv5573 = 104
tv5721 = 108
i$1$ = 108
tv5576 = 112
tv5688 = 120
tv5572 = 120
bestEa$1$ = 124
bestEb$1$ = 128
ea$1 = 132
eb$2 = 136
tv5808 = 144
cset$GSCopy$1$ = 152
tv5603 = 160
tv5641 = 168
pj$1$ = 176
timer$ = 184
polys$ = 200
indices$ = 208
tris$ = 216
vflags$ = 224
firstVert$ = 232
nextVert$ = 240
__$ArrayPad$ = 248
ctx$ = 336
cset$ = 344
nvp$ = 352
mesh$ = 360
?dtor$4@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA PROC ; `rcBuildPolyMesh'::`1'::dtor$4
	lea	rcx, QWORD PTR indices$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$4@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA ENDP ; `rcBuildPolyMesh'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5663 = 64
maxTris$1$ = 64
ctx$GSCopy$1$ = 72
nvp$GSCopy$1$ = 80
i$1$ = 84
npolys$1$ = 88
ntris$1$ = 88
mesh$GSCopy$1$ = 96
tv5689 = 104
tv5573 = 104
tv5721 = 108
i$1$ = 108
tv5576 = 112
tv5688 = 120
tv5572 = 120
bestEa$1$ = 124
bestEb$1$ = 128
ea$1 = 132
eb$2 = 136
tv5808 = 144
cset$GSCopy$1$ = 152
tv5603 = 160
tv5641 = 168
pj$1$ = 176
timer$ = 184
polys$ = 200
indices$ = 208
tris$ = 216
vflags$ = 224
firstVert$ = 232
nextVert$ = 240
__$ArrayPad$ = 248
ctx$ = 336
cset$ = 344
nvp$ = 352
mesh$ = 360
?dtor$5@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA PROC ; `rcBuildPolyMesh'::`1'::dtor$5
	lea	rcx, QWORD PTR tris$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$5@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA ENDP ; `rcBuildPolyMesh'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5663 = 64
maxTris$1$ = 64
ctx$GSCopy$1$ = 72
nvp$GSCopy$1$ = 80
i$1$ = 84
npolys$1$ = 88
ntris$1$ = 88
mesh$GSCopy$1$ = 96
tv5689 = 104
tv5573 = 104
tv5721 = 108
i$1$ = 108
tv5576 = 112
tv5688 = 120
tv5572 = 120
bestEa$1$ = 124
bestEb$1$ = 128
ea$1 = 132
eb$2 = 136
tv5808 = 144
cset$GSCopy$1$ = 152
tv5603 = 160
tv5641 = 168
pj$1$ = 176
timer$ = 184
polys$ = 200
indices$ = 208
tris$ = 216
vflags$ = 224
firstVert$ = 232
nextVert$ = 240
__$ArrayPad$ = 248
ctx$ = 336
cset$ = 344
nvp$ = 352
mesh$ = 360
?dtor$6@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA PROC ; `rcBuildPolyMesh'::`1'::dtor$6
	lea	rcx, QWORD PTR polys$[rdx]
	jmp	??1?$rcScopedDelete@G@@QEAA@XZ		; rcScopedDelete<unsigned short>::~rcScopedDelete<unsigned short>
?dtor$6@?0??rcBuildPolyMesh@@YA_NPEAVrcContext@@AEBUrcContourSet@@HAEAUrcPolyMesh@@@Z@4HA ENDP ; `rcBuildPolyMesh'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?buildMeshAdjacency@@YA_NPEAGHHH@Z
_TEXT	SEGMENT
tv1359 = 32
polys$ = 112
npolys$ = 120
nverts$ = 128
vertsPerPoly$ = 136
?buildMeshAdjacency@@YA_NPEAGHHH@Z PROC			; buildMeshAdjacency, COMDAT

; 35   : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r12
	push	r14
	sub	rsp, 72					; 00000048H

; 36   : 	// Based on code by Eric Lengyel from:
; 37   : 	// https://web.archive.org/web/20080704083314/http://www.terathon.com/code/edges.php
; 38   : 	
; 39   : 	int maxEdgeCount = npolys*vertsPerPoly;

	mov	edi, edx
	movsxd	rsi, r8d
	imul	edi, r9d
	mov	r14d, r9d

; 40   : 	unsigned short* firstEdge = (unsigned short*)rcAlloc(sizeof(unsigned short)*(nverts + maxEdgeCount), RC_ALLOC_TEMP);

	lea	eax, DWORD PTR [rdi+rsi]
	movsxd	rcx, eax
	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	r12, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 41   : 	if (!firstEdge)

	test	rax, rax
	jne	SHORT $LN23@buildMeshA

; 122  : }

	add	rsp, 72					; 00000048H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN23@buildMeshA:
	mov	QWORD PTR [rsp+128], rbx

; 42   : 		return false;
; 43   : 	unsigned short* nextEdge = firstEdge + nverts;

	lea	rbx, QWORD PTR [rsi+rsi]
	mov	QWORD PTR [rsp+64], rbp
	mov	QWORD PTR [rsp+56], r13
	mov	QWORD PTR [rsp+48], r15
	lea	r15, QWORD PTR [rbx+rax]

; 44   : 	int edgeCount = 0;

	xor	eax, eax
	mov	r13d, eax

; 45   : 	
; 46   : 	rcEdge* edges = (rcEdge*)rcAlloc(sizeof(rcEdge)*maxEdgeCount, RC_ALLOC_TEMP);

	movsxd	rax, edi
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 47   : 	if (!edges)

	test	rax, rax
	jne	SHORT $LN24@buildMeshA
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 28   : 	free(ptr);

	mov	rcx, r12
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 50   : 		return false;

	xor	al, al
	jmp	$LN128@buildMeshA
$LN24@buildMeshA:

; 51   : 	}
; 52   : 	
; 53   : 	for (int i = 0; i < nverts; i++)

	mov	eax, 65535				; 0000ffffH
	test	esi, esi
	jle	SHORT $LN3@buildMeshA
	shr	rbx, 1
	mov	rdi, r12
	mov	rcx, rbx
	movzx	eax, ax
	rep stosw
$LN3@buildMeshA:

; 54   : 		firstEdge[i] = RC_MESH_NULL_IDX;
; 55   : 	
; 56   : 	for (int i = 0; i < npolys; ++i)

	mov	edx, DWORD PTR npolys$[rsp]
	xor	eax, eax
	mov	r11d, eax
	test	edx, edx
	jle	$LN21@buildMeshA
	mov	r10, QWORD PTR polys$[rsp]
	lea	esi, DWORD PTR [r14+r14]
	movsxd	rbx, esi
	mov	esi, 65535				; 0000ffffH
	add	rbx, rbx
	mov	QWORD PTR tv1359[rsp], rbx
$LL7@buildMeshA:

; 57   : 	{
; 58   : 		unsigned short* t = &polys[i*vertsPerPoly*2];
; 59   : 		for (int j = 0; j < vertsPerPoly; ++j)

	mov	ecx, eax
	test	r14d, r14d
	jle	$LN5@buildMeshA
	xor	ebx, ebx
	npad	3
$LL10@buildMeshA:

; 60   : 		{
; 61   : 			if (t[j] == RC_MESH_NULL_IDX) break;

	movsxd	rax, ecx
	movzx	r8d, WORD PTR [r10+rax*2]
	cmp	r8w, si
	je	SHORT $LN104@buildMeshA

; 62   : 			unsigned short v0 = t[j];
; 63   : 			unsigned short v1 = (j+1 >= vertsPerPoly || t[j+1] == RC_MESH_NULL_IDX) ? t[0] : t[j+1];

	lea	r9d, DWORD PTR [rcx+1]
	cmp	r9d, r14d
	jge	SHORT $LN32@buildMeshA
	movzx	edi, WORD PTR [r10+rax*2+2]
	cmp	di, si
	jne	SHORT $LN33@buildMeshA
$LN32@buildMeshA:
	movzx	edi, WORD PTR [r10]
$LN33@buildMeshA:

; 64   : 			if (v0 < v1)

	cmp	r8w, di
	jae	SHORT $LN8@buildMeshA

; 65   : 			{
; 66   : 				rcEdge& edge = edges[edgeCount];

	movsxd	rdx, r13d
	lea	rax, QWORD PTR [rdx+rdx*2]

; 67   : 				edge.vert[0] = v0;
; 68   : 				edge.vert[1] = v1;
; 69   : 				edge.poly[0] = (unsigned short)i;
; 70   : 				edge.polyEdge[0] = (unsigned short)j;

	mov	WORD PTR [rbp+rax*4+4], cx

; 71   : 				edge.poly[1] = (unsigned short)i;
; 72   : 				edge.polyEdge[1] = 0;
; 73   : 				// Insert edge
; 74   : 				nextEdge[edgeCount] = firstEdge[v0];

	lea	rcx, QWORD PTR [r12+r8*2]
	mov	WORD PTR [rbp+rax*4], r8w
	mov	WORD PTR [rbp+rax*4+2], di
	mov	WORD PTR [rbp+rax*4+8], r11w
	mov	WORD PTR [rbp+rax*4+10], r11w
	mov	WORD PTR [rbp+rax*4+6], bx
	movzx	eax, WORD PTR [rcx]
	mov	WORD PTR [r15+rdx*2], ax

; 75   : 				firstEdge[v0] = (unsigned short)edgeCount;

	mov	WORD PTR [rcx], r13w

; 76   : 				edgeCount++;

	inc	r13d
$LN8@buildMeshA:

; 57   : 	{
; 58   : 		unsigned short* t = &polys[i*vertsPerPoly*2];
; 59   : 		for (int j = 0; j < vertsPerPoly; ++j)

	mov	ecx, r9d
	cmp	r9d, r14d
	jl	SHORT $LL10@buildMeshA
$LN104@buildMeshA:
	mov	rbx, QWORD PTR tv1359[rsp]
	xor	eax, eax
	mov	edx, DWORD PTR npolys$[rsp]
$LN5@buildMeshA:

; 54   : 		firstEdge[i] = RC_MESH_NULL_IDX;
; 55   : 	
; 56   : 	for (int i = 0; i < npolys; ++i)

	inc	r11d
	add	r10, rbx
	cmp	r11d, edx
	jl	$LL7@buildMeshA

; 77   : 			}
; 78   : 		}
; 79   : 	}
; 80   : 	
; 81   : 	for (int i = 0; i < npolys; ++i)

	lea	esi, DWORD PTR [r14+r14]
	mov	r11d, eax
	movsxd	rbx, esi
	mov	rsi, QWORD PTR polys$[rsp]
	add	rbx, rbx
	mov	r10, rsi
	npad	2
$LL13@buildMeshA:

; 82   : 	{
; 83   : 		unsigned short* t = &polys[i*vertsPerPoly*2];
; 84   : 		for (int j = 0; j < vertsPerPoly; ++j)

	mov	r8d, eax
	test	r14d, r14d
	jle	$LN11@buildMeshA
	mov	edx, 65535				; 0000ffffH
$LL16@buildMeshA:

; 85   : 		{
; 86   : 			if (t[j] == RC_MESH_NULL_IDX) break;

	movsxd	rax, r8d
	movzx	edi, WORD PTR [r10+rax*2]
	cmp	di, dx
	je	SHORT $LN105@buildMeshA

; 87   : 			unsigned short v0 = t[j];
; 88   : 			unsigned short v1 = (j+1 >= vertsPerPoly || t[j+1] == RC_MESH_NULL_IDX) ? t[0] : t[j+1];

	lea	r9d, DWORD PTR [r8+1]
	cmp	r9d, r14d
	jge	SHORT $LN101@buildMeshA
	movzx	eax, WORD PTR [r10+rax*2+2]
	cmp	ax, dx
	jne	SHORT $LN35@buildMeshA
$LN101@buildMeshA:
	movzx	eax, WORD PTR [r10]
$LN35@buildMeshA:

; 89   : 			if (v0 > v1)

	cmp	di, ax
	jbe	SHORT $LN14@buildMeshA

; 90   : 			{
; 91   : 				for (unsigned short e = firstEdge[v1]; e != RC_MESH_NULL_IDX; e = nextEdge[e])

	movzx	eax, ax
	movzx	ecx, WORD PTR [r12+rax*2]
	cmp	cx, dx
	je	SHORT $LN14@buildMeshA
	npad	8
$LL19@buildMeshA:

; 92   : 				{
; 93   : 					rcEdge& edge = edges[e];

	movzx	edx, cx
	lea	rax, QWORD PTR [rdx+rdx*2]

; 94   : 					if (edge.vert[1] == v0 && edge.poly[0] == edge.poly[1])

	cmp	WORD PTR [rbp+rax*4+2], di
	jne	SHORT $LN17@buildMeshA
	movzx	ecx, WORD PTR [rbp+rax*4+10]
	cmp	WORD PTR [rbp+rax*4+8], cx
	je	SHORT $LN77@buildMeshA
$LN17@buildMeshA:

; 90   : 			{
; 91   : 				for (unsigned short e = firstEdge[v1]; e != RC_MESH_NULL_IDX; e = nextEdge[e])

	movzx	ecx, WORD PTR [r15+rdx*2]
	mov	edx, 65535				; 0000ffffH
	cmp	cx, dx
	jne	SHORT $LL19@buildMeshA
	jmp	SHORT $LN14@buildMeshA
$LN77@buildMeshA:

; 95   : 					{
; 96   : 						edge.poly[1] = (unsigned short)i;

	mov	WORD PTR [rbp+rax*4+10], r11w

; 97   : 						edge.polyEdge[1] = (unsigned short)j;

	mov	edx, 65535				; 0000ffffH
	mov	WORD PTR [rbp+rax*4+6], r8w
$LN14@buildMeshA:

; 82   : 	{
; 83   : 		unsigned short* t = &polys[i*vertsPerPoly*2];
; 84   : 		for (int j = 0; j < vertsPerPoly; ++j)

	mov	r8d, r9d
	cmp	r9d, r14d
	jl	$LL16@buildMeshA
$LN105@buildMeshA:
	mov	edx, DWORD PTR npolys$[rsp]
	xor	eax, eax
$LN11@buildMeshA:

; 77   : 			}
; 78   : 		}
; 79   : 	}
; 80   : 	
; 81   : 	for (int i = 0; i < npolys; ++i)

	inc	r11d
	add	r10, rbx
	cmp	r11d, edx
	jl	$LL13@buildMeshA

; 98   : 						break;
; 99   : 					}
; 100  : 				}
; 101  : 			}
; 102  : 		}
; 103  : 	}
; 104  : 	
; 105  : 	// Store adjacency
; 106  : 	for (int i = 0; i < edgeCount; ++i)

	test	r13d, r13d
	jle	SHORT $LN21@buildMeshA
	lea	rdx, QWORD PTR [rbp+8]
	mov	r9d, r13d
	npad	7
$LL22@buildMeshA:

; 107  : 	{
; 108  : 		const rcEdge& e = edges[i];
; 109  : 		if (e.poly[0] != e.poly[1])

	movzx	r8d, WORD PTR [rdx]
	movzx	edi, WORD PTR [rdx+2]
	cmp	r8w, di
	je	SHORT $LN20@buildMeshA

; 110  : 		{
; 111  : 			unsigned short* p0 = &polys[e.poly[0]*vertsPerPoly*2];
; 112  : 			unsigned short* p1 = &polys[e.poly[1]*vertsPerPoly*2];
; 113  : 			p0[vertsPerPoly + e.polyEdge[0]] = e.poly[1];

	movzx	eax, WORD PTR [rdx-4]
	add	eax, r14d
	movsxd	rcx, eax
	mov	eax, r8d
	imul	eax, r14d
	add	eax, eax
	cdqe
	add	rcx, rax
	mov	WORD PTR [rsi+rcx*2], di

; 114  : 			p1[vertsPerPoly + e.polyEdge[1]] = e.poly[0];

	movzx	eax, WORD PTR [rdx-2]
	add	eax, r14d
	movsxd	rcx, eax
	mov	eax, edi
	imul	eax, r14d
	add	eax, eax
	cdqe
	add	rcx, rax
	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rsi+rcx*2], ax
$LN20@buildMeshA:

; 98   : 						break;
; 99   : 					}
; 100  : 				}
; 101  : 			}
; 102  : 		}
; 103  : 	}
; 104  : 	
; 105  : 	// Store adjacency
; 106  : 	for (int i = 0; i < edgeCount; ++i)

	add	rdx, 12
	sub	r9, 1
	jne	SHORT $LL22@buildMeshA
$LN21@buildMeshA:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 28   : 	free(ptr);

	mov	rcx, r12
	call	QWORD PTR __imp_free
	mov	rcx, rbp
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 121  : 	return true;

	mov	al, 1
$LN128@buildMeshA:
	mov	r13, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+128]
	mov	r15, QWORD PTR [rsp+48]

; 122  : }

	add	rsp, 72					; 00000048H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
?buildMeshAdjacency@@YA_NPEAGHHH@Z ENDP			; buildMeshAdjacency
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?computeVertexHash@@YAHHHH@Z
_TEXT	SEGMENT
x$ = 8
y$dead$ = 16
z$ = 24
?computeVertexHash@@YAHHHH@Z PROC			; computeVertexHash, COMDAT

; 129  : 	const unsigned int h1 = 0x8da6b343; // Large multiplicative constants;
; 130  : 	const unsigned int h2 = 0xd8163841; // here arbitrarily chosen primes
; 131  : 	const unsigned int h3 = 0xcb1ab31f;
; 132  : 	unsigned int n = h1 * x + h2 * y + h3 * z;

	imul	eax, ecx, 835				; 00000343H
	imul	ecx, r8d, 799				; 0000031fH
	add	eax, ecx

; 133  : 	return (int)(n & (VERTEX_BUCKET_COUNT-1));

	and	eax, 4095				; 00000fffH

; 134  : }

	ret	0
?computeVertexHash@@YAHHHH@Z ENDP			; computeVertexHash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?addVertex@@YAGGGGPEAGPEAH1AEAH@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
z$ = 24
verts$ = 32
firstVert$ = 40
nextVert$ = 48
nv$ = 56
?addVertex@@YAGGGGPEAGPEAH1AEAH@Z PROC			; addVertex, COMDAT

; 138  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi

; 139  : 	int bucket = computeVertexHash(x, 0, z);
; 140  : 	int i = firstVert[bucket];

	mov	rax, QWORD PTR firstVert$[rsp]
	mov	rsi, r9
	movzx	ebx, r8w

; 132  : 	unsigned int n = h1 * x + h2 * y + h3 * z;

	imul	r10d, ebx, 799				; 0000031fH

; 138  : {

	movzx	edi, cx

; 132  : 	unsigned int n = h1 * x + h2 * y + h3 * z;

	imul	r11d, edi, 835				; 00000343H

; 138  : {

	movzx	ebp, dx

; 132  : 	unsigned int n = h1 * x + h2 * y + h3 * z;

	add	r11d, r10d

; 141  : 	
; 142  : 	while (i != -1)

	mov	r10, QWORD PTR nextVert$[rsp]

; 133  : 	return (int)(n & (VERTEX_BUCKET_COUNT-1));

	and	r11d, 4095				; 00000fffH

; 139  : 	int bucket = computeVertexHash(x, 0, z);
; 140  : 	int i = firstVert[bucket];

	mov	r9d, DWORD PTR [rax+r11*4]
	lea	r11, QWORD PTR [rax+r11*4]

; 141  : 	
; 142  : 	while (i != -1)

	cmp	r9d, -1
	je	SHORT $LN15@addVertex
$LL2@addVertex:

; 143  : 	{
; 144  : 		const unsigned short* v = &verts[i*3];

	lea	eax, DWORD PTR [r9+r9*2]
	movsxd	rcx, eax

; 145  : 		if (v[0] == x && (rcAbs(v[1] - y) <= 2) && v[2] == z)

	cmp	WORD PTR [rsi+rcx*2], di
	lea	r8, QWORD PTR [rsi+rcx*2]
	jne	SHORT $LN4@addVertex
	movzx	eax, WORD PTR [r8+2]
	sub	eax, ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 669  : template<class T> inline T rcAbs(T a) { return a < 0 ? -a : a; }

	cdq
	xor	eax, edx
	sub	eax, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 145  : 		if (v[0] == x && (rcAbs(v[1] - y) <= 2) && v[2] == z)

	cmp	eax, 2
	jg	SHORT $LN4@addVertex
	cmp	WORD PTR [r8+4], bx
	je	SHORT $LN11@addVertex
$LN4@addVertex:

; 147  : 		i = nextVert[i]; // next

	movsxd	rax, r9d
	mov	r9d, DWORD PTR [r10+rax*4]
	cmp	r9d, -1
	jne	SHORT $LL2@addVertex
$LN15@addVertex:

; 148  : 	}
; 149  : 	
; 150  : 	// Could not find, create new.
; 151  : 	i = nv; nv++;

	mov	rdx, QWORD PTR nv$[rsp]
	movsxd	rax, DWORD PTR [rdx]
	lea	ecx, DWORD PTR [rax+1]
	mov	DWORD PTR [rdx], ecx

; 152  : 	unsigned short* v = &verts[i*3];

	lea	ecx, DWORD PTR [rax+rax*2]
	movsxd	rdx, ecx

; 153  : 	v[0] = x;

	mov	WORD PTR [rsi+rdx*2], di

; 154  : 	v[1] = y;

	mov	WORD PTR [rsi+rdx*2+2], bp

; 155  : 	v[2] = z;

	mov	WORD PTR [rsi+rdx*2+4], bx

; 156  : 	nextVert[i] = firstVert[bucket];

	mov	ecx, DWORD PTR [r11]
	mov	DWORD PTR [r10+rax*4], ecx

; 157  : 	firstVert[bucket] = i;

	mov	DWORD PTR [r11], eax
$LN1@addVertex:

; 158  : 	
; 159  : 	return (unsigned short)i;
; 160  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rbp, QWORD PTR [rsp+16]
	mov	rsi, QWORD PTR [rsp+24]
	mov	rdi, QWORD PTR [rsp+32]
	ret	0
$LN11@addVertex:

; 146  : 			return (unsigned short)i;

	movzx	eax, r9w
	jmp	SHORT $LN1@addVertex
?addVertex@@YAGGGGPEAGPEAH1AEAH@Z ENDP			; addVertex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?intersectProp@@YA_NPEBH000@Z
_TEXT	SEGMENT
a$ = 16
b$ = 24
c$ = 32
d$ = 40
?intersectProp@@YA_NPEBH000@Z PROC			; intersectProp, COMDAT

; 201  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ebp, DWORD PTR [r8]
	mov	eax, ebp
	mov	esi, DWORD PTR [r8+8]
	mov	r8d, esi
	mov	r10d, DWORD PTR [rcx+8]
	sub	r8d, r10d
	mov	ebx, DWORD PTR [rcx]
	sub	eax, ebx
	mov	r11d, DWORD PTR [rdx]
	mov	r14d, r11d
	mov	ecx, DWORD PTR [rdx+8]
	sub	r14d, ebx
	mov	edx, ecx
	imul	r8d, r14d
	sub	edx, r10d
	imul	eax, edx
	sub	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 204  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN3@intersectP
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	edi, DWORD PTR [r9+8]
	mov	r9d, DWORD PTR [r9]
	mov	eax, r9d
	sub	eax, ebx
	imul	eax, edx
	mov	edx, edi
	sub	edx, r10d
	imul	edx, r14d
	sub	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 204  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN3@intersectP
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r9d, ebp
	sub	edi, esi
	sub	ebx, ebp
	sub	r10d, esi
	imul	ebx, edi
	imul	r10d, r9d
	sub	r10d, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 204  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN3@intersectP
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r11d, ebp
	sub	ecx, esi
	imul	r11d, edi
	imul	ecx, r9d
	sub	ecx, r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 204  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN3@intersectP
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 481  : 	return !x ^ !y;

	shr	edx, 31
	shr	r8d, 31
	xor	dl, r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 207  : 	return xorb(left(a,b,c), left(a,b,d)) && xorb(left(c,d,a), left(c,d,b));

	je	SHORT $LN3@intersectP
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 481  : 	return !x ^ !y;

	shr	ecx, 31
	shr	r10d, 31
	xor	cl, r10b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 207  : 	return xorb(left(a,b,c), left(a,b,d)) && xorb(left(c,d,a), left(c,d,b));

	je	SHORT $LN3@intersectP
	mov	al, 1
	jmp	SHORT $LN1@intersectP
$LN3@intersectP:

; 208  : }

	xor	al, al
$LN1@intersectP:
	mov	rbx, QWORD PTR [rsp+16]
	mov	rbp, QWORD PTR [rsp+24]
	mov	rsi, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+40]
	pop	r14
	ret	0
?intersectProp@@YA_NPEBH000@Z ENDP			; intersectProp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?between@@YA_NPEBH00@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
?between@@YA_NPEBH00@Z PROC				; between, COMDAT

; 213  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ebx, DWORD PTR [rcx+8]
	mov	edi, DWORD PTR [rdx+8]
	mov	r11d, DWORD PTR [rcx]
	mov	r9d, DWORD PTR [r8]
	mov	ecx, r9d
	mov	r10d, DWORD PTR [r8+8]
	sub	ecx, r11d
	mov	r8d, DWORD PTR [rdx]
	mov	eax, r10d
	sub	eax, ebx
	mov	edx, r8d
	sub	edx, r11d
	imul	edx, eax
	mov	eax, edi
	sub	eax, ebx
	imul	ecx, eax
	cmp	edx, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 214  : 	if (!collinear(a, b, c))

	jne	SHORT $LN10@between

; 215  : 		return false;
; 216  : 	// If ab not vertical, check betweenness on x; else on y.
; 217  : 	if (a[0] != b[0])

	cmp	r11d, r8d
	je	SHORT $LN3@between

; 218  : 		return	((a[0] <= c[0]) && (c[0] <= b[0])) || ((a[0] >= c[0]) && (c[0] >= b[0]));

	cmp	r11d, r9d
	jg	SHORT $LN24@between
	cmp	r9d, r8d
	jle	SHORT $LN11@between
	cmp	r11d, r9d
	jl	SHORT $LN10@between
$LN24@between:
	cmp	r9d, r8d
	jmp	SHORT $LN25@between
$LN3@between:

; 219  : 
; 220  : 	return	((a[2] <= c[2]) && (c[2] <= b[2])) || ((a[2] >= c[2]) && (c[2] >= b[2]));

	cmp	ebx, r10d
	jg	SHORT $LN27@between
	cmp	r10d, edi
	jle	SHORT $LN11@between
	cmp	ebx, r10d
	jl	SHORT $LN10@between
$LN27@between:
	cmp	r10d, edi
$LN25@between:

; 221  : }

	jl	SHORT $LN10@between
$LN11@between:
	mov	al, 1
	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
$LN10@between:
	mov	rbx, QWORD PTR [rsp+8]
	xor	al, al
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
?between@@YA_NPEBH00@Z ENDP				; between
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?intersect@@YA_NPEBH000@Z
_TEXT	SEGMENT
a$ = 48
b$ = 56
c$ = 64
d$ = 72
?intersect@@YA_NPEBH000@Z PROC				; intersect, COMDAT

; 225  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r9
	mov	rsi, r8
	mov	rbp, rdx
	mov	rbx, rcx

; 226  : 	if (intersectProp(a, b, c, d))

	call	?intersectProp@@YA_NPEBH000@Z		; intersectProp
	test	al, al
	jne	SHORT $LN4@intersect

; 227  : 		return true;
; 228  : 
; 229  : 	if (between(a, b, c) || between(a, b, d) ||
; 230  : 		between(c, d, a) || between(c, d, b))

	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, rbx
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN4@intersect
	mov	r8, rdi
	mov	rdx, rbp
	mov	rcx, rbx
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN4@intersect
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN4@intersect
	mov	r8, rbp
	mov	rdx, rdi
	mov	rcx, rsi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	setne	al
	jmp	SHORT $LN1@intersect
$LN4@intersect:

; 231  : 		return true;

	mov	al, 1
$LN1@intersect:

; 232  : 	
; 233  : 	return false;
; 234  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?intersect@@YA_NPEBH000@Z ENDP				; intersect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?vequal@@YA_NPEBH0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?vequal@@YA_NPEBH0@Z PROC				; vequal, COMDAT

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	jne	SHORT $LN3@vequal
	mov	eax, DWORD PTR [rdx+8]
	cmp	DWORD PTR [rcx+8], eax
	jne	SHORT $LN3@vequal
	mov	al, 1

; 239  : }

	ret	0
$LN3@vequal:

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	xor	al, al

; 239  : }

	ret	0
?vequal@@YA_NPEBH0@Z ENDP				; vequal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?diagonalie@@YA_NHHHPEBHPEAH@Z
_TEXT	SEGMENT
i$ = 96
j$ = 104
n$ = 112
verts$ = 120
indices$ = 128
?diagonalie@@YA_NHHHPEBHPEAH@Z PROC			; diagonalie, COMDAT

; 244  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 245  : 	const int* d0 = &verts[(indices[i] & 0x0fffffff) * 4];

	mov	r10, QWORD PTR indices$[rsp]
	movsxd	r13, ecx

; 246  : 	const int* d1 = &verts[(indices[j] & 0x0fffffff) * 4];

	movsxd	r12, edx
	mov	eax, DWORD PTR [r10+r13*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rsi, QWORD PTR [r9+rax*4]
	mov	eax, DWORD PTR [r10+r12*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rdi, QWORD PTR [r9+rax*4]

; 247  : 	
; 248  : 	// For each edge (k,k+1) of P
; 249  : 	for (int k = 0; k < n; k++)

	test	r8d, r8d
	jle	$LN3@diagonalie
	xor	edx, edx

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	ebp, 1

; 247  : 	
; 248  : 	// For each edge (k,k+1) of P
; 249  : 	for (int k = 0; k < n; k++)

	mov	eax, edx
	npad	2
$LL4@diagonalie:

; 250  : 	{
; 251  : 		int k1 = next(k, n);
; 252  : 		// Skip edges incident to i or j
; 253  : 		if (!((k == i) || (k1 == i) || (k == j) || (k1 == j)))

	cmp	ebp, r8d
	lea	r15, QWORD PTR [rax+1]
	mov	rcx, r15
	cmovge	rcx, rdx
	cmp	rax, r13
	je	$LN2@diagonalie
	cmp	rcx, r13
	je	$LN2@diagonalie
	cmp	rax, r12
	je	$LN2@diagonalie
	cmp	rcx, r12
	je	$LN2@diagonalie

; 254  : 		{
; 255  : 			const int* p0 = &verts[(indices[k] & 0x0fffffff) * 4];

	mov	eax, DWORD PTR [r10+rax*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	r8d, DWORD PTR [r9+rax*4]

; 254  : 		{
; 255  : 			const int* p0 = &verts[(indices[k] & 0x0fffffff) * 4];

	lea	r14, QWORD PTR [r9+rax*4]

; 256  : 			const int* p1 = &verts[(indices[k1] & 0x0fffffff) * 4];

	mov	eax, DWORD PTR [r10+rcx*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rbx, QWORD PTR [r9+rax*4]

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	r9d, DWORD PTR [rsi]
	cmp	r9d, r8d
	jne	SHORT $LN45@diagonalie
	mov	eax, DWORD PTR [r14+8]
	cmp	DWORD PTR [rsi+8], eax
	je	$LN70@diagonalie
$LN45@diagonalie:
	mov	edx, DWORD PTR [rdi]
	cmp	edx, r8d
	jne	SHORT $LN50@diagonalie
	mov	eax, DWORD PTR [r14+8]
	cmp	DWORD PTR [rdi+8], eax
	je	$LN71@diagonalie
$LN50@diagonalie:
	mov	ecx, DWORD PTR [rbx]
	cmp	r9d, ecx
	jne	SHORT $LN46@diagonalie
	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [rsi+8], eax
	je	SHORT $LN71@diagonalie
$LN46@diagonalie:
	cmp	edx, ecx
	jne	SHORT $LN48@diagonalie
	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [rdi+8], eax
	je	SHORT $LN71@diagonalie
$LN48@diagonalie:

; 226  : 	if (intersectProp(a, b, c, d))

	mov	r9, rbx
	mov	r8, r14
	mov	rdx, rdi
	mov	rcx, rsi
	call	?intersectProp@@YA_NPEBH000@Z		; intersectProp
	test	al, al
	jne	$LN36@diagonalie

; 227  : 		return true;
; 228  : 
; 229  : 	if (between(a, b, c) || between(a, b, d) ||
; 230  : 		between(c, d, a) || between(c, d, b))

	mov	r8, r14
	mov	rdx, rdi
	mov	rcx, rsi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN36@diagonalie
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN36@diagonalie
	mov	r8, rsi
	mov	rdx, rbx
	mov	rcx, r14
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN36@diagonalie
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, r14
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN36@diagonalie

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	r10, QWORD PTR indices$[rsp]
$LN71@diagonalie:

; 247  : 	
; 248  : 	// For each edge (k,k+1) of P
; 249  : 	for (int k = 0; k < n; k++)

	xor	edx, edx
$LN70@diagonalie:
	mov	r8d, DWORD PTR n$[rsp]
	mov	r9, QWORD PTR verts$[rsp]
$LN2@diagonalie:
	inc	ebp
	movsxd	rcx, r8d
	mov	rax, r15
	cmp	r15, rcx
	jl	$LL4@diagonalie
$LN3@diagonalie:

; 263  : 		}
; 264  : 	}
; 265  : 	return true;

	mov	al, 1
$LN1@diagonalie:

; 266  : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN36@diagonalie:

; 257  : 
; 258  : 			if (vequal(d0, p0) || vequal(d1, p0) || vequal(d0, p1) || vequal(d1, p1))
; 259  : 				continue;
; 260  : 			
; 261  : 			if (intersect(d0, d1, p0, p1))
; 262  : 				return false;

	xor	al, al
	jmp	SHORT $LN1@diagonalie
?diagonalie@@YA_NHHHPEBHPEAH@Z ENDP			; diagonalie
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?inCone@@YA_NHHHPEBHPEAH@Z
_TEXT	SEGMENT
i$ = 24
j$ = 32
n$ = 40
verts$ = 48
indices$ = 56
?inCone@@YA_NHHHPEBHPEAH@Z PROC				; inCone, COMDAT

; 271  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	push	r15

; 272  : 	const int* pi = &verts[(indices[i] & 0x0fffffff) * 4];

	mov	r11, QWORD PTR indices$[rsp]
	mov	edi, r8d
	movsxd	rbx, ecx

; 274  : 	const int* pi1 = &verts[(indices[next(i, n)] & 0x0fffffff) * 4];

	xor	ecx, ecx
	movsxd	rax, edx
	mov	r10d, DWORD PTR [r11+rbx*4]
	mov	edx, DWORD PTR [r11+rax*4]
	and	r10d, 268435455				; 0fffffffH
	and	edx, 268435455				; 0fffffffH
	shl	r10d, 2
	shl	edx, 2
	lea	eax, DWORD PTR [rbx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ebp, DWORD PTR [r9+rdx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 273  : 	const int* pj = &verts[(indices[j] & 0x0fffffff) * 4];

	lea	r8, QWORD PTR [r9+rdx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r8d, DWORD PTR [r9+rdx*4+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 272  : 	const int* pi = &verts[(indices[i] & 0x0fffffff) * 4];

	lea	r10, QWORD PTR [r9+r10*4]

; 274  : 	const int* pi1 = &verts[(indices[next(i, n)] & 0x0fffffff) * 4];

	cmp	eax, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r14d, ebp
	mov	r15d, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 274  : 	const int* pi1 = &verts[(indices[next(i, n)] & 0x0fffffff) * 4];

	cmovge	eax, ecx
	cdqe
	mov	ecx, DWORD PTR [r11+rax*4]
	lea	eax, DWORD PTR [rbx-1]
	and	ecx, 268435455				; 0fffffffH
	shl	ecx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	esi, DWORD PTR [r9+rcx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 274  : 	const int* pi1 = &verts[(indices[next(i, n)] & 0x0fffffff) * 4];

	lea	rdx, QWORD PTR [r9+rcx*4]

; 275  : 	const int* pin1 = &verts[(indices[prev(i, n)] & 0x0fffffff) * 4];

	test	eax, eax
	cmovs	ebx, edi
	movsxd	rax, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ebx, DWORD PTR [r10+8]
	sub	r15d, ebx
	mov	r10d, DWORD PTR [r10]
	sub	r14d, r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 275  : 	const int* pin1 = &verts[(indices[prev(i, n)] & 0x0fffffff) * 4];

	mov	ecx, DWORD PTR [r11+rax*4-4]
	and	ecx, 268435455				; 0fffffffH
	shl	ecx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r11d, DWORD PTR [r9+rcx*4+8]
	mov	edi, DWORD PTR [r9+rcx*4]
	mov	ecx, esi
	mov	r9d, DWORD PTR [rdx+8]
	sub	ecx, edi
	mov	edx, r10d
	mov	eax, r9d
	sub	eax, r11d
	sub	edx, edi
	imul	edx, eax
	mov	eax, ebx
	sub	eax, r11d
	imul	ecx, eax
	sub	edx, ecx

; 493  : 	return area2(a, b, c) <= 0;

	test	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 278  : 	if (leftOn(pin1, pi, pi1))

	jg	SHORT $LN2@inCone
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	edi, r10d
	sub	r11d, ebx
	imul	edi, r15d
	imul	r11d, r14d
	cmp	r11d, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 279  : 		return left(pi, pj, pin1) && left(pj, pi, pi1);

	jns	SHORT $LN4@inCone
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	ebx, r8d
	sub	esi, ebp
	sub	r9d, r8d
	imul	ebx, esi
	sub	r10d, ebp
	imul	r9d, r10d
	cmp	r9d, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 279  : 		return left(pi, pj, pin1) && left(pj, pi, pi1);

	jns	SHORT $LN4@inCone
$LN6@inCone:

; 283  : }

	mov	al, 1
$LN7@inCone:
	mov	rbx, QWORD PTR [rsp+24]
	mov	rbp, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	pop	r15
	pop	r14
	ret	0
$LN2@inCone:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r9d, ebx
	sub	esi, r10d
	imul	r9d, r14d
	imul	esi, r15d
	sub	r9d, esi

; 493  : 	return area2(a, b, c) <= 0;

	test	r9d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 282  : 	return !(leftOn(pi, pj, pi1) && leftOn(pj, pi, pin1));

	jg	SHORT $LN6@inCone
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r11d, r8d
	sub	ebx, r8d
	sub	edi, ebp
	sub	r10d, ebp
	imul	ebx, edi
	imul	r11d, r10d
	sub	r11d, ebx

; 493  : 	return area2(a, b, c) <= 0;

	test	r11d, r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 282  : 	return !(leftOn(pi, pj, pi1) && leftOn(pj, pi, pin1));

	jg	SHORT $LN6@inCone
$LN4@inCone:

; 283  : }

	xor	al, al
	jmp	SHORT $LN7@inCone
?inCone@@YA_NHHHPEBHPEAH@Z ENDP				; inCone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?diagonal@@YA_NHHHPEBHPEAH@Z
_TEXT	SEGMENT
i$ = 64
j$ = 72
n$ = 80
verts$ = 88
indices$ = 96
?diagonal@@YA_NHHHPEBHPEAH@Z PROC			; diagonal, COMDAT

; 288  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	r14, QWORD PTR indices$[rsp]
	mov	rbx, r9
	mov	QWORD PTR [rsp+32], r14
	mov	edi, r8d
	mov	esi, edx
	mov	ebp, ecx
	call	?inCone@@YA_NHHHPEBHPEAH@Z		; inCone
	test	al, al
	je	SHORT $LN3@diagonal
	mov	r9, rbx
	mov	QWORD PTR [rsp+32], r14
	mov	r8d, edi
	mov	edx, esi
	mov	ecx, ebp
	call	?diagonalie@@YA_NHHHPEBHPEAH@Z		; diagonalie
	test	al, al
	je	SHORT $LN3@diagonal
	mov	al, 1
	jmp	SHORT $LN4@diagonal
$LN3@diagonal:
	xor	al, al
$LN4@diagonal:

; 290  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?diagonal@@YA_NHHHPEBHPEAH@Z ENDP			; diagonal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?diagonalieLoose@@YA_NHHHPEBHPEAH@Z
_TEXT	SEGMENT
i$ = 80
j$ = 88
n$ = 96
verts$ = 104
indices$ = 112
?diagonalieLoose@@YA_NHHHPEBHPEAH@Z PROC		; diagonalieLoose, COMDAT

; 294  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	movsxd	r12, r8d

; 295  : 	const int* d0 = &verts[(indices[i] & 0x0fffffff) * 4];

	mov	r8, QWORD PTR indices$[rsp]
	movsxd	r15, ecx

; 296  : 	const int* d1 = &verts[(indices[j] & 0x0fffffff) * 4];

	movsxd	rbp, edx
	mov	eax, DWORD PTR [r8+r15*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	r14, QWORD PTR [r9+rax*4]
	mov	eax, DWORD PTR [r8+rbp*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rbx, QWORD PTR [r9+rax*4]

; 297  : 	
; 298  : 	// For each edge (k,k+1) of P
; 299  : 	for (int k = 0; k < n; k++)

	test	r12d, r12d
	jle	$LN45@diagonalie
	xor	ecx, ecx

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	edi, 1

; 297  : 	
; 298  : 	// For each edge (k,k+1) of P
; 299  : 	for (int k = 0; k < n; k++)

	mov	eax, ecx
$LL4@diagonalie:

; 300  : 	{
; 301  : 		int k1 = next(k, n);
; 302  : 		// Skip edges incident to i or j
; 303  : 		if (!((k == i) || (k1 == i) || (k == j) || (k1 == j)))

	cmp	edi, r12d
	lea	rsi, QWORD PTR [rax+1]
	mov	rdx, rsi
	cmovge	rdx, rcx
	cmp	rax, r15
	je	$LN2@diagonalie
	cmp	rdx, r15
	je	$LN2@diagonalie
	cmp	rax, rbp
	je	$LN2@diagonalie
	cmp	rdx, rbp
	je	$LN2@diagonalie

; 304  : 		{
; 305  : 			const int* p0 = &verts[(indices[k] & 0x0fffffff) * 4];

	mov	ecx, DWORD PTR [r8+rax*4]

; 306  : 			const int* p1 = &verts[(indices[k1] & 0x0fffffff) * 4];

	mov	eax, DWORD PTR [r8+rdx*4]
	and	ecx, 268435455				; 0fffffffH

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	r10d, DWORD PTR [r14]

; 306  : 			const int* p1 = &verts[(indices[k1] & 0x0fffffff) * 4];

	and	eax, 268435455				; 0fffffffH
	shl	ecx, 2

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	r8d, DWORD PTR [r9+rcx*4]

; 304  : 		{
; 305  : 			const int* p0 = &verts[(indices[k] & 0x0fffffff) * 4];

	lea	r11, QWORD PTR [r9+rcx*4]

; 306  : 			const int* p1 = &verts[(indices[k1] & 0x0fffffff) * 4];

	shl	eax, 2
	lea	r9, QWORD PTR [r9+rax*4]

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	cmp	r10d, r8d
	jne	SHORT $LN38@diagonalie
	mov	eax, DWORD PTR [r11+8]
	cmp	DWORD PTR [r14+8], eax
	je	SHORT $LN48@diagonalie
$LN38@diagonalie:
	mov	edx, DWORD PTR [rbx]
	cmp	edx, r8d
	jne	SHORT $LN43@diagonalie
	mov	eax, DWORD PTR [r11+8]
	cmp	DWORD PTR [rbx+8], eax
	je	SHORT $LN48@diagonalie
$LN43@diagonalie:
	mov	ecx, DWORD PTR [r9]
	cmp	r10d, ecx
	jne	SHORT $LN39@diagonalie
	mov	eax, DWORD PTR [r9+8]
	cmp	DWORD PTR [r14+8], eax
	je	SHORT $LN48@diagonalie
$LN39@diagonalie:
	cmp	edx, ecx
	jne	SHORT $LN41@diagonalie
	mov	eax, DWORD PTR [r9+8]
	cmp	DWORD PTR [rbx+8], eax
	je	SHORT $LN48@diagonalie
$LN41@diagonalie:

; 307  : 			
; 308  : 			if (vequal(d0, p0) || vequal(d1, p0) || vequal(d0, p1) || vequal(d1, p1))
; 309  : 				continue;
; 310  : 			
; 311  : 			if (intersectProp(d0, d1, p0, p1))

	mov	r8, r11
	mov	rdx, rbx
	mov	rcx, r14
	call	?intersectProp@@YA_NPEBH000@Z		; intersectProp
	test	al, al
	jne	SHORT $LN31@diagonalie
$LN48@diagonalie:

; 297  : 	
; 298  : 	// For each edge (k,k+1) of P
; 299  : 	for (int k = 0; k < n; k++)

	mov	r9, QWORD PTR verts$[rsp]
	xor	ecx, ecx
	mov	r8, QWORD PTR indices$[rsp]
$LN2@diagonalie:
	inc	edi
	mov	rax, rsi
	cmp	rsi, r12
	jl	$LL4@diagonalie
$LN45@diagonalie:

; 313  : 		}
; 314  : 	}
; 315  : 	return true;

	mov	al, 1
$LN1@diagonalie:

; 316  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN31@diagonalie:

; 312  : 				return false;

	xor	al, al
	jmp	SHORT $LN1@diagonalie
?diagonalieLoose@@YA_NHHHPEBHPEAH@Z ENDP		; diagonalieLoose
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?inConeLoose@@YA_NHHHPEBHPEAH@Z
_TEXT	SEGMENT
i$ = 24
j$ = 32
n$ = 40
verts$ = 48
indices$ = 56
?inConeLoose@@YA_NHHHPEBHPEAH@Z PROC			; inConeLoose, COMDAT

; 319  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	push	r15

; 320  : 	const int* pi = &verts[(indices[i] & 0x0fffffff) * 4];

	mov	r11, QWORD PTR indices$[rsp]
	mov	edi, r8d
	movsxd	rbx, ecx

; 322  : 	const int* pi1 = &verts[(indices[next(i, n)] & 0x0fffffff) * 4];

	xor	ecx, ecx
	movsxd	rax, edx
	mov	r10d, DWORD PTR [r11+rbx*4]
	mov	edx, DWORD PTR [r11+rax*4]
	and	r10d, 268435455				; 0fffffffH
	and	edx, 268435455				; 0fffffffH
	shl	r10d, 2
	shl	edx, 2
	lea	eax, DWORD PTR [rbx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ebp, DWORD PTR [r9+rdx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 321  : 	const int* pj = &verts[(indices[j] & 0x0fffffff) * 4];

	lea	r8, QWORD PTR [r9+rdx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r8d, DWORD PTR [r9+rdx*4+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 320  : 	const int* pi = &verts[(indices[i] & 0x0fffffff) * 4];

	lea	r10, QWORD PTR [r9+r10*4]

; 322  : 	const int* pi1 = &verts[(indices[next(i, n)] & 0x0fffffff) * 4];

	cmp	eax, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r14d, ebp
	mov	r15d, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 322  : 	const int* pi1 = &verts[(indices[next(i, n)] & 0x0fffffff) * 4];

	cmovge	eax, ecx
	cdqe
	mov	ecx, DWORD PTR [r11+rax*4]
	lea	eax, DWORD PTR [rbx-1]
	and	ecx, 268435455				; 0fffffffH
	shl	ecx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	esi, DWORD PTR [r9+rcx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 322  : 	const int* pi1 = &verts[(indices[next(i, n)] & 0x0fffffff) * 4];

	lea	rdx, QWORD PTR [r9+rcx*4]

; 323  : 	const int* pin1 = &verts[(indices[prev(i, n)] & 0x0fffffff) * 4];

	test	eax, eax
	cmovs	ebx, edi
	movsxd	rax, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ebx, DWORD PTR [r10+8]
	sub	r15d, ebx
	mov	r10d, DWORD PTR [r10]
	sub	r14d, r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 323  : 	const int* pin1 = &verts[(indices[prev(i, n)] & 0x0fffffff) * 4];

	mov	ecx, DWORD PTR [r11+rax*4-4]
	and	ecx, 268435455				; 0fffffffH
	shl	ecx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r11d, DWORD PTR [r9+rcx*4+8]
	mov	edi, DWORD PTR [r9+rcx*4]
	mov	ecx, esi
	mov	r9d, DWORD PTR [rdx+8]
	sub	ecx, edi
	mov	edx, r10d
	mov	eax, r9d
	sub	eax, r11d
	sub	edx, edi
	imul	edx, eax
	mov	eax, ebx
	sub	eax, r11d
	imul	ecx, eax
	sub	edx, ecx

; 493  : 	return area2(a, b, c) <= 0;

	test	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 326  : 	if (leftOn(pin1, pi, pi1))

	jg	SHORT $LN2@inConeLoos
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r11d, ebx
	sub	edi, r10d
	imul	edi, r15d
	imul	r11d, r14d
	sub	r11d, edi

; 493  : 	return area2(a, b, c) <= 0;

	test	r11d, r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 327  : 		return leftOn(pi, pj, pin1) && leftOn(pj, pi, pi1);

	jg	SHORT $LN4@inConeLoos
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r9d, r8d
	sub	ebx, r8d
	sub	esi, ebp
	sub	r10d, ebp
	imul	ebx, esi
	imul	r9d, r10d
	sub	r9d, ebx

; 493  : 	return area2(a, b, c) <= 0;

	test	r9d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 327  : 		return leftOn(pi, pj, pin1) && leftOn(pj, pi, pi1);

	jg	SHORT $LN4@inConeLoos
$LN6@inConeLoos:

; 331  : }

	mov	al, 1
$LN7@inConeLoos:
	mov	rbx, QWORD PTR [rsp+24]
	mov	rbp, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	pop	r15
	pop	r14
	ret	0
$LN2@inConeLoos:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r9d, ebx
	sub	esi, r10d
	imul	r9d, r14d
	imul	esi, r15d
	sub	r9d, esi

; 493  : 	return area2(a, b, c) <= 0;

	test	r9d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 330  : 	return !(leftOn(pi, pj, pi1) && leftOn(pj, pi, pin1));

	jg	SHORT $LN6@inConeLoos
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r11d, r8d
	sub	ebx, r8d
	sub	edi, ebp
	sub	r10d, ebp
	imul	ebx, edi
	imul	r11d, r10d
	sub	r11d, ebx

; 493  : 	return area2(a, b, c) <= 0;

	test	r11d, r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 330  : 	return !(leftOn(pi, pj, pi1) && leftOn(pj, pi, pin1));

	jg	SHORT $LN6@inConeLoos
$LN4@inConeLoos:

; 331  : }

	xor	al, al
	jmp	SHORT $LN7@inConeLoos
?inConeLoose@@YA_NHHHPEBHPEAH@Z ENDP			; inConeLoose
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?diagonalLoose@@YA_NHHHPEBHPEAH@Z
_TEXT	SEGMENT
i$ = 64
j$ = 72
n$ = 80
verts$ = 88
indices$ = 96
?diagonalLoose@@YA_NHHHPEBHPEAH@Z PROC			; diagonalLoose, COMDAT

; 334  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 335  : 	return inConeLoose(i, j, n, verts, indices) && diagonalieLoose(i, j, n, verts, indices);

	mov	r14, QWORD PTR indices$[rsp]
	mov	rbx, r9
	mov	QWORD PTR [rsp+32], r14
	mov	edi, r8d
	mov	esi, edx
	mov	ebp, ecx
	call	?inConeLoose@@YA_NHHHPEBHPEAH@Z		; inConeLoose
	test	al, al
	je	SHORT $LN3@diagonalLo
	mov	r9, rbx
	mov	QWORD PTR [rsp+32], r14
	mov	r8d, edi
	mov	edx, esi
	mov	ecx, ebp
	call	?diagonalieLoose@@YA_NHHHPEBHPEAH@Z	; diagonalieLoose
	test	al, al
	je	SHORT $LN3@diagonalLo
	mov	al, 1
	jmp	SHORT $LN4@diagonalLo
$LN3@diagonalLo:
	xor	al, al
$LN4@diagonalLo:

; 336  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?diagonalLoose@@YA_NHHHPEBHPEAH@Z ENDP			; diagonalLoose
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?triangulate@@YAHHPEBHPEAH1@Z
_TEXT	SEGMENT
mini$1$ = 48
minLen$2$ = 52
tv1727 = 56
tv1744 = 64
ntris$1$ = 144
n$ = 144
verts$ = 152
indices$ = 160
tris$ = 168
?triangulate@@YAHHPEBHPEAH1@Z PROC			; triangulate, COMDAT

; 340  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 341  : 	int ntris = 0;

	xor	r10d, r10d
	mov	r12, rdx
	mov	DWORD PTR ntris$1$[rsp], r10d
	mov	r15, r9
	mov	r14, r8
	mov	ebx, ecx
	mov	r13d, r10d
	mov	edi, r10d

; 342  : 	int* dst = tris;
; 343  : 	
; 344  : 	// The last bit of the index is used to indicate if the vertex can be removed.
; 345  : 	for (int i = 0; i < n; i++)

	lea	edx, QWORD PTR [r10+1]
	test	ecx, ecx
	jle	SHORT $LN96@triangulat
	npad	3
$LL4@triangulat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	lea	ebp, DWORD PTR [rdi+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	QWORD PTR [rsp+32], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	cmp	ebp, ebx
	lea	rsi, QWORD PTR [r13+1]
	lea	eax, DWORD PTR [rbp+1]
	mov	r15d, r10d
	cmovge	eax, edx
	mov	r13, rsi
	cmovge	rsi, r10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	r9, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	cmp	eax, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	r8d, ebx
	mov	ecx, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	cmovl	r15d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	edx, r15d
	call	?inCone@@YA_NHHHPEBHPEAH@Z		; inCone
	test	al, al
	je	SHORT $LN2@triangulat
	mov	r9, r12
	mov	QWORD PTR [rsp+32], r14
	mov	r8d, ebx
	mov	edx, r15d
	mov	ecx, edi
	call	?diagonalie@@YA_NHHHPEBHPEAH@Z		; diagonalie
	test	al, al
	je	SHORT $LN2@triangulat

; 346  : 	{
; 347  : 		int i1 = next(i, n);
; 348  : 		int i2 = next(i1, n);
; 349  : 		if (diagonal(i, i2, n, verts, indices))
; 350  : 			indices[i1] |= 0x80000000;

	or	DWORD PTR [r14+rsi*4], -2147483648	; ffffffff80000000H
$LN2@triangulat:

; 342  : 	int* dst = tris;
; 343  : 	
; 344  : 	// The last bit of the index is used to indicate if the vertex can be removed.
; 345  : 	for (int i = 0; i < n; i++)

	mov	edx, 1
	mov	edi, ebp
	lea	r10d, QWORD PTR [rdx-1]
	cmp	ebp, ebx
	jl	SHORT $LL4@triangulat
	mov	r15, QWORD PTR tris$[rsp]
	mov	r13d, r10d
$LN96@triangulat:

; 351  : 	}
; 352  : 	
; 353  : 	while (n > 3)

	cmp	ebx, 3
	jle	$LN122@triangulat
	npad	4
$LL5@triangulat:

; 354  : 	{
; 355  : 		int minLen = -1;

	mov	esi, -1
	mov	ebp, ebx

; 356  : 		int mini = -1;

	mov	r9d, esi
	mov	rcx, r10
	lea	r13d, QWORD PTR [rsi+2]
	npad	15
$LL9@triangulat:

; 358  : 		{
; 359  : 			int i1 = next(i, n);
; 360  : 			if (indices[i1] & 0x80000000)

	cmp	edx, ebx
	lea	r8, QWORD PTR [rcx+1]
	mov	rax, r8
	mov	r11d, edx
	cmovge	rax, r10
	cmp	DWORD PTR [r14+rax*4], 0
	lea	rdi, QWORD PTR [r14+rax*4]
	jge	SHORT $LN7@triangulat

; 362  : 				const int* p0 = &verts[(indices[i] & 0x0fffffff) * 4];

	mov	eax, DWORD PTR [r14+rcx*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	cmp	edx, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 362  : 				const int* p0 = &verts[(indices[i] & 0x0fffffff) * 4];

	lea	r10, QWORD PTR [r12+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	lea	eax, DWORD PTR [rdx+1]
	cmovge	eax, r13d
	cmp	eax, ebx
	lea	rax, QWORD PTR [rdi+4]
	jl	SHORT $LN82@triangulat
	mov	rax, r14
$LN82@triangulat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 363  : 				const int* p2 = &verts[(indices[next(i1, n)] & 0x0fffffff) * 4];

	mov	eax, DWORD PTR [rax]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2

; 364  : 				
; 365  : 				int dx = p2[0] - p0[0];

	mov	ecx, DWORD PTR [r12+rax*4]

; 366  : 				int dy = p2[2] - p0[2];

	mov	eax, DWORD PTR [r12+rax*4+8]
	sub	eax, DWORD PTR [r10+8]
	sub	ecx, DWORD PTR [r10]

; 367  : 				int len = dx*dx + dy*dy;

	imul	eax, eax
	imul	ecx, ecx
	add	eax, ecx

; 368  : 				
; 369  : 				if (minLen < 0 || len < minLen)

	test	esi, esi
	js	SHORT $LN19@triangulat
	cmp	eax, esi
	jge	SHORT $LN126@triangulat
$LN19@triangulat:

; 370  : 				{
; 371  : 					minLen = len;

	mov	esi, eax

; 372  : 					mini = i;

	lea	r9d, DWORD PTR [rdx-1]
$LN126@triangulat:

; 357  : 		for (int i = 0; i < n; i++)

	xor	r10d, r10d
$LN7@triangulat:
	inc	edx
	mov	rcx, r8
	cmp	r11d, ebx
	jl	SHORT $LL9@triangulat

; 373  : 				}
; 374  : 			}
; 375  : 		}
; 376  : 		
; 377  : 		if (mini == -1)

	mov	r13d, DWORD PTR ntris$1$[rsp]
	cmp	r9d, -1
	jne	$LN24@triangulat

; 378  : 		{
; 379  : 			// We might get here because the contour has overlapping segments, like this:
; 380  : 			//
; 381  : 			//  A o-o=====o---o B
; 382  : 			//   /  |C   D|    \.
; 383  : 			//  o   o     o     o
; 384  : 			//  :   :     :     :
; 385  : 			// We'll try to recover by loosing up the inCone test a bit so that a diagonal
; 386  : 			// like A-B or C-D can be found and we can continue.
; 387  : 			minLen = -1;

	mov	DWORD PTR minLen$2$[rsp], r9d
	mov	esi, r10d

; 388  : 			mini = -1;

	mov	DWORD PTR mini$1$[rsp], r9d

; 389  : 			for (int i = 0; i < n; i++)

	test	ebx, ebx
	je	$LN100@triangulat

; 378  : 		{
; 379  : 			// We might get here because the contour has overlapping segments, like this:
; 380  : 			//
; 381  : 			//  A o-o=====o---o B
; 382  : 			//   /  |C   D|    \.
; 383  : 			//  o   o     o     o
; 384  : 			//  :   :     :     :
; 385  : 			// We'll try to recover by loosing up the inCone test a bit so that a diagonal
; 386  : 			// like A-B or C-D can be found and we can continue.
; 387  : 			minLen = -1;

	lea	r13d, QWORD PTR [r9+3]
	mov	QWORD PTR tv1744[rsp], r14
	npad	4
$LL12@triangulat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	lea	ebp, DWORD PTR [rsi+1]
	mov	eax, 1
	cmp	ebp, ebx
	lea	edi, DWORD PTR [rbp+1]
	cmovge	edi, eax
	cmp	edi, ebx
	jge	SHORT $LN57@triangulat
	cmp	ebp, ebx
	mov	r15, r13
	cmovge	r15, rax
	jmp	SHORT $LN58@triangulat
$LN57@triangulat:
	mov	edi, r10d
	mov	r15, r10
$LN58@triangulat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 335  : 	return inConeLoose(i, j, n, verts, indices) && diagonalieLoose(i, j, n, verts, indices);

	mov	r9, r12
	mov	QWORD PTR [rsp+32], r14
	mov	r8d, ebx
	mov	edx, edi
	mov	ecx, esi
	call	?inConeLoose@@YA_NHHHPEBHPEAH@Z		; inConeLoose
	test	al, al
	je	SHORT $LN124@triangulat
	mov	r9, r12
	mov	QWORD PTR [rsp+32], r14
	mov	r8d, ebx
	mov	edx, edi
	mov	ecx, esi
	call	?diagonalieLoose@@YA_NHHHPEBHPEAH@Z	; diagonalieLoose
	test	al, al
	je	SHORT $LN124@triangulat

; 396  : 					const int* p2 = &verts[(indices[next(i2, n)] & 0x0fffffff) * 4];

	mov	rax, QWORD PTR tv1744[rsp]
	lea	rcx, QWORD PTR [r15+1]
	mov	r10d, 0
	mov	eax, DWORD PTR [rax]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rdx, QWORD PTR [r12+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	lea	eax, DWORD PTR [rdi+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 396  : 					const int* p2 = &verts[(indices[next(i2, n)] & 0x0fffffff) * 4];

	cmp	eax, ebx
	cmovge	rcx, r10
	mov	eax, DWORD PTR [r14+rcx*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2

; 397  : 					int dx = p2[0] - p0[0];

	mov	ecx, DWORD PTR [r12+rax*4]

; 398  : 					int dy = p2[2] - p0[2];

	mov	eax, DWORD PTR [r12+rax*4+8]
	sub	eax, DWORD PTR [rdx+8]
	sub	ecx, DWORD PTR [rdx]

; 399  : 					int len = dx*dx + dy*dy;

	imul	ecx, ecx
	imul	eax, eax
	add	eax, ecx

; 400  : 					
; 401  : 					if (minLen < 0 || len < minLen)

	mov	ecx, DWORD PTR minLen$2$[rsp]
	test	ecx, ecx
	js	SHORT $LN23@triangulat
	cmp	eax, ecx
	jge	SHORT $LN125@triangulat
$LN23@triangulat:

; 402  : 					{
; 403  : 						minLen = len;

	mov	DWORD PTR minLen$2$[rsp], eax

; 404  : 						mini = i;

	mov	r9d, esi
	mov	DWORD PTR mini$1$[rsp], esi

; 335  : 	return inConeLoose(i, j, n, verts, indices) && diagonalieLoose(i, j, n, verts, indices);

	jmp	SHORT $LN10@triangulat
$LN124@triangulat:

; 389  : 			for (int i = 0; i < n; i++)

	xor	r10d, r10d
$LN125@triangulat:
	mov	r9d, DWORD PTR mini$1$[rsp]
$LN10@triangulat:
	add	QWORD PTR tv1744[rsp], 4
	inc	r13
	mov	esi, ebp
	cmp	ebp, ebx
	jl	$LL12@triangulat

; 405  : 					}
; 406  : 				}
; 407  : 			}
; 408  : 			if (mini == -1)

	cmp	r9d, -1
	je	$LN100@triangulat
	mov	r15, QWORD PTR tris$[rsp]
	mov	ebp, ebx
	mov	r13d, DWORD PTR ntris$1$[rsp]
$LN24@triangulat:

; 420  : 		*dst++ = indices[i] & 0x0fffffff;

	movsxd	rax, r9d
	lea	r8d, DWORD PTR [r9+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	cmp	r8d, ebx
	cmovge	r8d, r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 420  : 		*dst++ = indices[i] & 0x0fffffff;

	mov	ecx, DWORD PTR [r14+rax*4]
	and	ecx, 268435455				; 0fffffffH

; 421  : 		*dst++ = indices[i1] & 0x0fffffff;

	movsxd	r9, r8d
	mov	DWORD PTR [r15], ecx
	lea	rdi, QWORD PTR [r14+r9*4]
	mov	eax, DWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	lea	edx, DWORD PTR [r8+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 421  : 		*dst++ = indices[i1] & 0x0fffffff;

	and	eax, 268435455				; 0fffffffH
	cmp	edx, ebx
	mov	DWORD PTR [r15+4], eax
	cmovge	edx, r10d

; 422  : 		*dst++ = indices[i2] & 0x0fffffff;
; 423  : 		ntris++;

	inc	r13d
	movsxd	rax, edx

; 424  : 		
; 425  : 		// Removes P[i1] by copying P[i+1]...P[n-1] left one index.
; 426  : 		n--;

	dec	ebx
	mov	DWORD PTR ntris$1$[rsp], r13d
	mov	ecx, DWORD PTR [r14+rax*4]
	and	ecx, 268435455				; 0fffffffH
	mov	DWORD PTR [r15+8], ecx
	add	r15, 12

; 427  : 		for (int k = i1; k < n; k++)

	mov	ecx, ebp
	dec	rcx
	mov	QWORD PTR tris$[rsp], r15
	cmp	r9, rcx
	jge	SHORT $LN105@triangulat
	lea	rsi, QWORD PTR [rdi+4]
	sub	rcx, r9
	rep movsd
$LN105@triangulat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 467  : inline int prev(int i, int n) { return i-1 >= 0 ? i-1 : n-1; }

	cmp	r8d, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	QWORD PTR [rsp+32], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 467  : inline int prev(int i, int n) { return i-1 >= 0 ? i-1 : n-1; }

	mov	esi, r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	r9, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 467  : inline int prev(int i, int n) { return i-1 >= 0 ? i-1 : n-1; }

	cmovl	esi, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	r8d, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 467  : inline int prev(int i, int n) { return i-1 >= 0 ? i-1 : n-1; }

	test	esi, esi
	mov	edi, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	edx, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 467  : inline int prev(int i, int n) { return i-1 >= 0 ? i-1 : n-1; }

	cmovle	edi, ebx
	dec	edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	ebp, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 467  : inline int prev(int i, int n) { return i-1 >= 0 ? i-1 : n-1; }

	lea	eax, DWORD PTR [rdi-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	test	eax, eax
	cmovs	ebp, ebx
	lea	ecx, DWORD PTR [rbp-1]
	call	?inCone@@YA_NHHHPEBHPEAH@Z		; inCone
	test	al, al
	je	SHORT $LN41@triangulat
	mov	r9, r12
	mov	QWORD PTR [rsp+32], r14
	mov	r8d, ebx
	lea	ecx, DWORD PTR [rbp-1]
	mov	edx, esi
	call	?diagonalie@@YA_NHHHPEBHPEAH@Z		; diagonalie
	test	al, al
	je	SHORT $LN41@triangulat
	movsxd	rax, edi
	lea	rcx, QWORD PTR [r14+rax*4]

; 428  : 			indices[k] = indices[k+1];
; 429  : 		
; 430  : 		if (i1 >= n) i1 = 0;
; 431  : 		i = prev(i1,n);
; 432  : 		// Update diagonal flags.
; 433  : 		if (diagonal(prev(i, n), i1, n, verts, indices))
; 434  : 			indices[i] |= 0x80000000;

	mov	eax, DWORD PTR [r14+rax*4]
	or	eax, -2147483648			; ffffffff80000000H
	jmp	SHORT $LN27@triangulat
$LN41@triangulat:

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	movsxd	rax, edi
	lea	rcx, QWORD PTR [r14+rax*4]

; 435  : 		else
; 436  : 			indices[i] &= 0x0fffffff;

	mov	eax, DWORD PTR [r14+rax*4]
	and	eax, 268435455				; 0fffffffH
$LN27@triangulat:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	mov	DWORD PTR [rcx], eax
	lea	ebp, DWORD PTR [rsi+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	eax, 0
	mov	QWORD PTR [rsp+32], r14
	cmp	ebp, ebx
	mov	r9, r12
	mov	r8d, ebx
	mov	ecx, edi
	cmovge	ebp, eax
	mov	edx, ebp
	call	?inCone@@YA_NHHHPEBHPEAH@Z		; inCone
	test	al, al
	je	SHORT $LN49@triangulat
	mov	r9, r12
	mov	QWORD PTR [rsp+32], r14
	mov	r8d, ebx
	mov	edx, ebp
	mov	ecx, edi
	call	?diagonalie@@YA_NHHHPEBHPEAH@Z		; diagonalie
	test	al, al
	je	SHORT $LN49@triangulat
	movsxd	rax, esi
	lea	rcx, QWORD PTR [r14+rax*4]

; 437  : 		
; 438  : 		if (diagonal(i, next(i1, n), n, verts, indices))
; 439  : 			indices[i1] |= 0x80000000;

	mov	eax, DWORD PTR [r14+rax*4]
	or	eax, -2147483648			; ffffffff80000000H
	jmp	SHORT $LN29@triangulat
$LN49@triangulat:

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	movsxd	rax, esi
	lea	rcx, QWORD PTR [r14+rax*4]

; 440  : 		else
; 441  : 			indices[i1] &= 0x0fffffff;

	mov	eax, DWORD PTR [r14+rax*4]
	and	eax, 268435455				; 0fffffffH
$LN29@triangulat:

; 351  : 	}
; 352  : 	
; 353  : 	while (n > 3)

	mov	DWORD PTR [rcx], eax
	cmp	ebx, 3
	jle	SHORT $LN122@triangulat
	xor	r10d, r10d
	lea	edx, QWORD PTR [r10+1]
	jmp	$LL5@triangulat
$LN100@triangulat:

; 409  : 			{
; 410  : 				// The contour is messed up. This sometimes happens
; 411  : 				// if the contour simplification is too aggressive.
; 412  : 				return -ntris;

	mov	eax, DWORD PTR ntris$1$[rsp]
	neg	eax
	jmp	SHORT $LN1@triangulat
$LN122@triangulat:

; 442  : 	}
; 443  : 	
; 444  : 	// Append the remaining triangle.
; 445  : 	*dst++ = indices[0] & 0x0fffffff;

	mov	eax, DWORD PTR [r14]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR [r15], eax

; 446  : 	*dst++ = indices[1] & 0x0fffffff;

	mov	eax, DWORD PTR [r14+4]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR [r15+4], eax

; 447  : 	*dst++ = indices[2] & 0x0fffffff;

	mov	eax, DWORD PTR [r14+8]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR [r15+8], eax

; 448  : 	ntris++;

	lea	eax, DWORD PTR [r13+1]
$LN1@triangulat:

; 449  : 	
; 450  : 	return ntris;
; 451  : }

	mov	rbx, QWORD PTR [rsp+152]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?triangulate@@YAHHPEBHPEAH1@Z ENDP			; triangulate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?countPolyVerts@@YAHPEBGH@Z
_TEXT	SEGMENT
p$ = 8
nvp$ = 16
?countPolyVerts@@YAHPEBGH@Z PROC			; countPolyVerts, COMDAT

; 455  : 	for (int i = 0; i < nvp; ++i)

	xor	r8d, r8d
	movsxd	r9, edx
	test	edx, edx
	jle	SHORT $LN3@countPolyV
	mov	eax, r8d
	mov	r10d, 65535				; 0000ffffH
$LL4@countPolyV:

; 456  : 		if (p[i] == RC_MESH_NULL_IDX)

	cmp	WORD PTR [rcx+rax*2], r10w
	je	SHORT $LN8@countPolyV

; 455  : 	for (int i = 0; i < nvp; ++i)

	inc	r8d
	inc	rax
	cmp	rax, r9
	jl	SHORT $LL4@countPolyV
$LN3@countPolyV:

; 458  : 	return nvp;

	mov	eax, edx

; 459  : }

	ret	0
$LN8@countPolyV:

; 457  : 			return i;

	mov	eax, r8d

; 459  : }

	ret	0
?countPolyVerts@@YAHPEBGH@Z ENDP			; countPolyVerts
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?uleft@@YA_NPEBG00@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
?uleft@@YA_NPEBG00@Z PROC				; uleft, COMDAT

; 463  : 	return ((int)b[0] - (int)a[0]) * ((int)c[2] - (int)a[2]) -

	movzx	r9d, WORD PTR [rcx+4]
	movzx	r10d, WORD PTR [rcx]
	movzx	ecx, WORD PTR [rdx]
	movzx	edx, WORD PTR [rdx+4]
	sub	ecx, r10d
	movzx	eax, WORD PTR [r8+4]
	sub	edx, r9d
	sub	eax, r9d
	imul	eax, ecx
	movzx	ecx, WORD PTR [r8]
	sub	ecx, r10d
	imul	edx, ecx
	sub	eax, edx
	shr	eax, 31

; 464  : 		   ((int)c[0] - (int)a[0]) * ((int)b[2] - (int)a[2]) < 0;
; 465  : }

	ret	0
?uleft@@YA_NPEBG00@Z ENDP				; uleft
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z
_TEXT	SEGMENT
pa$ = 64
pb$ = 72
verts$ = 80
ea$ = 88
eb$ = 96
tv1218 = 104
nvp$ = 104
?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z PROC		; getPolyMergeValue, COMDAT

; 470  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	rsi
	push	rdi
	push	r13
	sub	rsp, 24

; 455  : 	for (int i = 0; i < nvp; ++i)

	movsxd	r10, DWORD PTR nvp$[rsp]
	xor	esi, esi

; 470  : {

	mov	rdi, rdx
	mov	r13, rcx
	mov	r11, r8

; 455  : 	for (int i = 0; i < nvp; ++i)

	mov	rdx, r10
	mov	ecx, 65535				; 0000ffffH
	test	r10d, r10d
	jle	SHORT $LN19@getPolyMer
	xor	eax, eax
$LL20@getPolyMer:

; 456  : 		if (p[i] == RC_MESH_NULL_IDX)

	cmp	WORD PTR [r13+rax*2], cx
	je	$LN41@getPolyMer

; 455  : 	for (int i = 0; i < nvp; ++i)

	inc	esi
	inc	rax
	cmp	rax, rdx
	jl	SHORT $LL20@getPolyMer
$LN19@getPolyMer:
	xor	ebx, ebx

; 458  : 	return nvp;

	mov	esi, r10d

; 455  : 	for (int i = 0; i < nvp; ++i)

	test	r10d, r10d
	jle	SHORT $LN25@getPolyMer
$LN56@getPolyMer:
	xor	eax, eax
$LL26@getPolyMer:

; 456  : 		if (p[i] == RC_MESH_NULL_IDX)

	cmp	WORD PTR [rdi+rax*2], cx
	je	SHORT $LN23@getPolyMer

; 455  : 	for (int i = 0; i < nvp; ++i)

	inc	ebx
	inc	rax
	cmp	rax, rdx
	jl	SHORT $LL26@getPolyMer
$LN25@getPolyMer:

; 458  : 	return nvp;

	mov	ebx, r10d
$LN23@getPolyMer:
	mov	QWORD PTR [rsp+64], rbp

; 471  : 	const int na = countPolyVerts(pa, nvp);
; 472  : 	const int nb = countPolyVerts(pb, nvp);
; 473  : 	
; 474  : 	// If the merged polygon would be too big, do not merge.
; 475  : 	if (na+nb-2 > nvp)

	lea	eax, DWORD PTR [rsi-2]
	mov	QWORD PTR [rsp+16], r12
	add	eax, ebx
	mov	QWORD PTR [rsp+8], r14
	mov	QWORD PTR [rsp], r15
	cmp	eax, r10d
	jg	$LN13@getPolyMer

; 476  : 		return -1;
; 477  : 	
; 478  : 	// Check if the polygons share an edge.
; 479  : 	ea = -1;
; 480  : 	eb = -1;

	mov	rax, QWORD PTR eb$[rsp]
	xor	r15d, r15d
	mov	DWORD PTR [r9], -1
	mov	DWORD PTR [rax], -1

; 481  : 	
; 482  : 	for (int i = 0; i < na; ++i)

	test	esi, esi
	jle	$LN3@getPolyMer
	movsxd	rbp, ebx
	mov	r12, r13
	npad	5
$LL4@getPolyMer:

; 483  : 	{
; 484  : 		unsigned short va0 = pa[i];

	movzx	ecx, WORD PTR [r12]

; 485  : 		unsigned short va1 = pa[(i+1) % na];

	lea	eax, DWORD PTR [r15+1]
	mov	DWORD PTR tv1218[rsp], eax

; 486  : 		if (va0 > va1)
; 487  : 			rcSwap(va0, va1);
; 488  : 		for (int j = 0; j < nb; ++j)

	movzx	r14d, cx
	cdq
	idiv	esi
	movsxd	rax, edx
	movzx	r11d, WORD PTR [r13+rax*2]
	cmp	cx, r11w
	cmovbe	r14w, r11w
	cmovbe	r11w, cx
	xor	r10d, r10d
	xor	r8d, r8d
	test	ebx, ebx
	jle	SHORT $LN62@getPolyMer
	mov	r9d, 1
	npad	5
$LL7@getPolyMer:

; 489  : 		{
; 490  : 			unsigned short vb0 = pb[j];

	movzx	ecx, WORD PTR [rdi+r8*2]

; 491  : 			unsigned short vb1 = pb[(j+1) % nb];

	mov	eax, r9d
	cdq
	idiv	ebx
	movsxd	rax, edx
	movzx	edx, WORD PTR [rdi+rax*2]

; 492  : 			if (vb0 > vb1)
; 493  : 				rcSwap(vb0, vb1);
; 494  : 			if (va0 == vb0 && va1 == vb1)

	cmp	cx, dx
	movzx	eax, dx
	cmovbe	ax, cx
	cmp	r11w, ax
	jne	SHORT $LN5@getPolyMer
	cmp	cx, dx
	cmovbe	cx, dx
	cmp	r14w, cx
	je	$LN43@getPolyMer
$LN5@getPolyMer:

; 486  : 		if (va0 > va1)
; 487  : 			rcSwap(va0, va1);
; 488  : 		for (int j = 0; j < nb; ++j)

	inc	r10d
	inc	r9d
	inc	r8
	cmp	r8, rbp
	jl	SHORT $LL7@getPolyMer
	mov	r9, QWORD PTR ea$[rsp]
$LN62@getPolyMer:

; 481  : 	
; 482  : 	for (int i = 0; i < na; ++i)

	mov	rax, QWORD PTR eb$[rsp]
$LN2@getPolyMer:
	mov	r15d, DWORD PTR tv1218[rsp]
	add	r12, 2
	cmp	r15d, esi
	jl	$LL4@getPolyMer
	mov	r11, QWORD PTR verts$[rsp]
$LN3@getPolyMer:

; 498  : 				break;
; 499  : 			}
; 500  : 		}
; 501  : 	}
; 502  : 	
; 503  : 	// No common edge, cannot merge.
; 504  : 	if (ea == -1 || eb == -1)

	movsxd	r14, DWORD PTR [r9]
	cmp	r14d, -1
	je	$LN13@getPolyMer
	movsxd	r15, DWORD PTR [rax]
	cmp	r15d, -1
	je	$LN13@getPolyMer

; 511  : 	vb = pa[ea];
; 512  : 	vc = pb[(eb+2) % nb];

	lea	eax, DWORD PTR [r15+2]
	cdq
	idiv	ebx
	movsxd	rax, edx

; 513  : 	if (!uleft(&verts[va*3], &verts[vb*3], &verts[vc*3]))

	movzx	ecx, WORD PTR [rdi+rax*2]
	lea	rax, QWORD PTR [rcx+rcx*2]
	movzx	ecx, WORD PTR [r13+r14*2]
	lea	r10, QWORD PTR [r11+rax*2]
	lea	eax, DWORD PTR [rsi-1]
	add	eax, r14d
	cdq
	lea	r12, QWORD PTR [rcx+rcx*2]

; 463  : 	return ((int)b[0] - (int)a[0]) * ((int)c[2] - (int)a[2]) -

	movzx	r9d, WORD PTR [r11+r12*2+4]
	movzx	ebp, WORD PTR [r11+r12*2]

; 506  : 	
; 507  : 	// Check to see if the merged polygon would be convex.
; 508  : 	unsigned short va, vb, vc;
; 509  : 	
; 510  : 	va = pa[(ea+na-1) % na];

	idiv	esi
	movsxd	rax, edx

; 513  : 	if (!uleft(&verts[va*3], &verts[vb*3], &verts[vc*3]))

	movzx	ecx, WORD PTR [r13+rax*2]
	lea	rax, QWORD PTR [rcx+rcx*2]

; 463  : 	return ((int)b[0] - (int)a[0]) * ((int)c[2] - (int)a[2]) -

	movzx	ecx, WORD PTR [r10+4]
	movzx	edx, WORD PTR [r11+rax*2+4]
	movzx	r8d, WORD PTR [r11+rax*2]
	sub	r9d, edx
	movzx	eax, WORD PTR [r10]
	sub	ecx, edx
	sub	eax, r8d
	imul	r9d, eax
	mov	eax, ebp
	sub	eax, r8d
	imul	ecx, eax
	cmp	ecx, r9d

; 513  : 	if (!uleft(&verts[va*3], &verts[vb*3], &verts[vc*3]))

	jns	$LN13@getPolyMer

; 517  : 	vb = pb[eb];
; 518  : 	vc = pa[(ea+2) % na];

	lea	eax, DWORD PTR [r14+2]
	cdq
	idiv	esi
	movsxd	rax, edx

; 519  : 	if (!uleft(&verts[va*3], &verts[vb*3], &verts[vc*3]))

	movzx	ecx, WORD PTR [r13+rax*2]
	lea	rax, QWORD PTR [rcx+rcx*2]
	movzx	ecx, WORD PTR [rdi+r15*2]

; 463  : 	return ((int)b[0] - (int)a[0]) * ((int)c[2] - (int)a[2]) -

	movzx	r9d, WORD PTR [r11+rax*2+4]

; 519  : 	if (!uleft(&verts[va*3], &verts[vb*3], &verts[vc*3]))

	lea	r11, QWORD PTR [r11+rax*2]
	lea	rax, QWORD PTR [rcx+rcx*2]
	mov	rcx, QWORD PTR verts$[rsp]
	lea	r10, QWORD PTR [rcx+rax*2]
	lea	eax, DWORD PTR [rbx-1]
	add	eax, r15d
	cdq
	idiv	ebx

; 463  : 	return ((int)b[0] - (int)a[0]) * ((int)c[2] - (int)a[2]) -

	mov	rbx, QWORD PTR verts$[rsp]

; 514  : 		return -1;
; 515  : 	
; 516  : 	va = pb[(eb+nb-1) % nb];

	movsxd	rax, edx

; 519  : 	if (!uleft(&verts[va*3], &verts[vb*3], &verts[vc*3]))

	movzx	ecx, WORD PTR [rdi+rax*2]
	lea	rax, QWORD PTR [rcx+rcx*2]

; 463  : 	return ((int)b[0] - (int)a[0]) * ((int)c[2] - (int)a[2]) -

	movzx	ecx, WORD PTR [r10+4]
	movzx	edx, WORD PTR [rbx+rax*2+4]
	movzx	r8d, WORD PTR [rbx+rax*2]
	sub	r9d, edx
	movzx	eax, WORD PTR [r10]
	sub	ecx, edx
	sub	eax, r8d
	imul	r9d, eax
	movzx	eax, WORD PTR [r11]
	sub	eax, r8d
	imul	ecx, eax
	cmp	r9d, ecx

; 519  : 	if (!uleft(&verts[va*3], &verts[vb*3], &verts[vc*3]))

	jns	SHORT $LN13@getPolyMer

; 520  : 		return -1;
; 521  : 	
; 522  : 	va = pa[ea];
; 523  : 	vb = pa[(ea+1)%na];

	lea	eax, DWORD PTR [r14+1]
	cdq
	idiv	esi
	movsxd	rax, edx

; 524  : 	
; 525  : 	int dx = (int)verts[va*3+0] - (int)verts[vb*3+0];

	movzx	ecx, WORD PTR [r13+rax*2]
	lea	rdx, QWORD PTR [rcx+rcx*2]

; 526  : 	int dy = (int)verts[va*3+2] - (int)verts[vb*3+2];

	movzx	ecx, WORD PTR [rbx+r12*2+4]
	movzx	eax, WORD PTR [rbx+rdx*2]
	sub	ebp, eax
	movzx	eax, WORD PTR [rbx+rdx*2+4]
	sub	ecx, eax

; 527  : 	
; 528  : 	return dx*dx + dy*dy;

	imul	ecx, ecx
	imul	ebp, ebp
	lea	eax, DWORD PTR [rcx+rbp]
	jmp	SHORT $LN1@getPolyMer
$LN41@getPolyMer:

; 457  : 			return i;

	xor	ebx, ebx
	jmp	$LN56@getPolyMer
$LN43@getPolyMer:

; 495  : 			{
; 496  : 				ea = i;

	mov	r9, QWORD PTR ea$[rsp]

; 497  : 				eb = j;

	mov	rax, QWORD PTR eb$[rsp]
	mov	DWORD PTR [r9], r15d
	mov	DWORD PTR [rax], r10d
	jmp	$LN2@getPolyMer
$LN13@getPolyMer:

; 505  : 		return -1;

	mov	eax, -1
$LN1@getPolyMer:
	mov	r15, QWORD PTR [rsp]

; 529  : }

	mov	r14, QWORD PTR [rsp+8]
	mov	r12, QWORD PTR [rsp+16]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 24
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z ENDP		; getPolyMergeValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?mergePolyVerts@@YAXPEAG0HH0H@Z
_TEXT	SEGMENT
pa$ = 96
pb$ = 104
ea$ = 112
eb$ = 120
tmp$ = 128
nvp$ = 136
?mergePolyVerts@@YAXPEAG0HH0H@Z PROC			; mergePolyVerts, COMDAT

; 533  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 455  : 	for (int i = 0; i < nvp; ++i)

	xor	ebx, ebx

; 533  : {

	mov	r14, rcx

; 455  : 	for (int i = 0; i < nvp; ++i)

	movsxd	rcx, DWORD PTR nvp$[rsp]

; 533  : {

	mov	r15, rdx

; 455  : 	for (int i = 0; i < nvp; ++i)

	mov	esi, ebx
	mov	edx, 65535				; 0000ffffH
	test	ecx, ecx
	jle	SHORT $LN11@mergePolyV
	mov	eax, ebx
	npad	5
$LL12@mergePolyV:

; 456  : 		if (p[i] == RC_MESH_NULL_IDX)

	cmp	WORD PTR [r14+rax*2], dx
	je	$LN25@mergePolyV

; 455  : 	for (int i = 0; i < nvp; ++i)

	inc	esi
	inc	rax
	cmp	rax, rcx
	jl	SHORT $LL12@mergePolyV
$LN11@mergePolyV:

; 458  : 	return nvp;

	mov	esi, ecx

; 455  : 	for (int i = 0; i < nvp; ++i)

	mov	edi, ebx
	test	ecx, ecx
	jle	SHORT $LN17@mergePolyV
$LN39@mergePolyV:
	mov	rax, rbx
$LL18@mergePolyV:

; 456  : 		if (p[i] == RC_MESH_NULL_IDX)

	cmp	WORD PTR [r15+rax*2], dx
	je	SHORT $LN15@mergePolyV

; 455  : 	for (int i = 0; i < nvp; ++i)

	inc	edi
	inc	rax
	cmp	rax, rcx
	jl	SHORT $LL18@mergePolyV
$LN17@mergePolyV:

; 458  : 	return nvp;

	mov	edi, ecx
$LN15@mergePolyV:

; 534  : 	const int na = countPolyVerts(pa, nvp);
; 535  : 	const int nb = countPolyVerts(pb, nvp);
; 536  : 	
; 537  : 	// Merge polygons.
; 538  : 	memset(tmp, 0xff, sizeof(unsigned short)*nvp);

	mov	r12, QWORD PTR tmp$[rsp]
	lea	r13, QWORD PTR [rcx+rcx]
	mov	r8, r13
	mov	rcx, r12
	mov	edx, 255				; 000000ffH
	call	memset

; 539  : 	int n = 0;
; 540  : 	// Add pa
; 541  : 	for (int i = 0; i < na-1; ++i)

	lea	r10d, DWORD PTR [rsi-1]
	mov	ebp, ebx
	mov	r8d, ebx
	test	r10d, r10d
	jle	SHORT $LN3@mergePolyV
	mov	r11d, DWORD PTR ea$[rsp]
	mov	r9, r12
	inc	r11d
	mov	ebp, r10d
	npad	5
$LL4@mergePolyV:

; 542  : 		tmp[n++] = pa[(ea+1+i) % na];

	lea	eax, DWORD PTR [r11+r8]
	inc	r8d
	cdq
	lea	r9, QWORD PTR [r9+2]
	idiv	esi
	movsxd	rax, edx
	movzx	ecx, WORD PTR [r14+rax*2]
	mov	WORD PTR [r9-2], cx
	cmp	r8d, r10d
	jl	SHORT $LL4@mergePolyV
$LN3@mergePolyV:

; 543  : 	// Add pb
; 544  : 	for (int i = 0; i < nb-1; ++i)

	lea	r10d, DWORD PTR [rdi-1]
	test	r10d, r10d
	jle	SHORT $LN6@mergePolyV
	mov	r11d, DWORD PTR eb$[rsp]
	movsxd	rax, ebp
	inc	r11d
	lea	r9, QWORD PTR [r12+rax*2]
	npad	8
$LL7@mergePolyV:

; 545  : 		tmp[n++] = pb[(eb+1+i) % nb];

	lea	eax, DWORD PTR [r11+rbx]
	inc	ebx
	cdq
	lea	r9, QWORD PTR [r9+2]
	idiv	edi
	movsxd	rax, edx
	movzx	ecx, WORD PTR [r15+rax*2]
	mov	WORD PTR [r9-2], cx
	cmp	ebx, r10d
	jl	SHORT $LL7@mergePolyV
$LN6@mergePolyV:

; 546  : 	
; 547  : 	memcpy(pa, tmp, sizeof(unsigned short)*nvp);

	mov	r8, r13
	mov	rdx, r12
	mov	rcx, r14

; 548  : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp

; 546  : 	
; 547  : 	memcpy(pa, tmp, sizeof(unsigned short)*nvp);

	jmp	memcpy
$LN25@mergePolyV:

; 457  : 			return i;

	mov	edi, ebx
	jmp	$LN39@mergePolyV
?mergePolyVerts@@YAXPEAG0HH0H@Z ENDP			; mergePolyVerts
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?pushFront@@YAXHPEAHAEAH@Z
_TEXT	SEGMENT
v$ = 8
arr$ = 16
an$ = 24
?pushFront@@YAXHPEAHAEAH@Z PROC				; pushFront, COMDAT

; 553  : 	an++;

	movsxd	r9, DWORD PTR [r8]
	mov	r10, rdx
	lea	eax, DWORD PTR [r9+1]
	mov	DWORD PTR [r8], eax
	mov	rax, r9

; 554  : 	for (int i = an-1; i > 0; --i) arr[i] = arr[i-1];

	test	r9d, r9d
	jle	SHORT $LN10@pushFront
	npad	11
$LL4@pushFront:
	mov	edx, DWORD PTR [r10+rax*4-4]
	mov	DWORD PTR [r10+rax*4], edx
	dec	rax
	test	rax, rax
	jg	SHORT $LL4@pushFront

; 555  : 	arr[0] = v;

	mov	DWORD PTR [r10], ecx

; 556  : }

	ret	0
$LN10@pushFront:

; 555  : 	arr[0] = v;

	mov	DWORD PTR [rdx], ecx

; 556  : }

	ret	0
?pushFront@@YAXHPEAHAEAH@Z ENDP				; pushFront
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?pushBack@@YAXHPEAHAEAH@Z
_TEXT	SEGMENT
v$ = 8
arr$ = 16
an$ = 24
?pushBack@@YAXHPEAHAEAH@Z PROC				; pushBack, COMDAT

; 560  : 	arr[an] = v;

	movsxd	rax, DWORD PTR [r8]
	mov	DWORD PTR [rdx+rax*4], ecx

; 561  : 	an++;

	inc	DWORD PTR [r8]

; 562  : }

	ret	0
?pushBack@@YAXHPEAHAEAH@Z ENDP				; pushBack
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z
_TEXT	SEGMENT
rem$1$ = 32
nedges$1$ = 36
tv1254 = 40
mesh$1$ = 48
tv1256 = 56
edges$ = 56
__$ArrayPad$ = 64
ctx$ = 128
mesh$ = 136
rem$ = 144
?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z PROC ; canRemoveVertex, COMDAT

; 565  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	WORD PTR rem$1$[rsp], r8w
	mov	QWORD PTR mesh$1$[rsp], rdx
	mov	r15, rcx

; 566  : 	const int nvp = mesh.nvp;

	movsxd	r14, DWORD PTR [rdx+52]

; 567  : 	
; 568  : 	// Count number of polygons to remove.
; 569  : 	int numTouchedVerts = 0;

	xor	r13d, r13d
	mov	r11d, r13d

; 570  : 	int numRemainingEdges = 0;

	mov	edi, r13d

; 571  : 	for (int i = 0; i < mesh.npolys; ++i)

	mov	eax, DWORD PTR [rdx+44]

; 565  : {

	mov	r12, r14

; 571  : 	for (int i = 0; i < mesh.npolys; ++i)

	test	eax, eax
	jle	$LN126@canRemoveV

; 572  : 	{
; 573  : 		unsigned short* p = &mesh.polys[i*nvp*2];

	lea	ecx, DWORD PTR [r14+r14]
	mov	DWORD PTR tv1254[rsp], ecx
	movsxd	rbp, ecx
	add	rbp, rbp
	mov	r8, QWORD PTR [rdx+8]
	mov	esi, eax
	mov	ecx, 65535				; 0000ffffH
	npad	3
$LL4@canRemoveV:

; 455  : 	for (int i = 0; i < nvp; ++i)

	mov	edx, r13d
	mov	rax, r13
	test	r14d, r14d
	jle	SHORT $LN37@canRemoveV
	npad	5
$LL38@canRemoveV:

; 456  : 		if (p[i] == RC_MESH_NULL_IDX)

	cmp	WORD PTR [r8+rax*2], cx
	je	SHORT $LN35@canRemoveV

; 455  : 	for (int i = 0; i < nvp; ++i)

	inc	edx
	inc	rax
	cmp	rax, r12
	jl	SHORT $LL38@canRemoveV
$LN37@canRemoveV:

; 457  : 			return i;
; 458  : 	return nvp;

	mov	edx, r14d
$LN35@canRemoveV:

; 574  : 		const int nv = countPolyVerts(p, nvp);
; 575  : 		int numRemoved = 0;

	mov	r9d, r13d
	mov	r10, r13

; 576  : 		int numVerts = 0;
; 577  : 		for (int j = 0; j < nv; ++j)

	movsxd	rbx, edx
	test	edx, edx
	jle	SHORT $LN2@canRemoveV
$LL107@canRemoveV:

; 578  : 		{
; 579  : 			if (p[j] == rem)

	movzx	ecx, WORD PTR [r8+r10*2]

; 580  : 			{
; 581  : 				numTouchedVerts++;
; 582  : 				numRemoved++;
; 583  : 			}
; 584  : 			numVerts++;

	lea	eax, DWORD PTR [r9+1]
	cmp	cx, WORD PTR rem$1$[rsp]
	cmovne	eax, r9d
	mov	r9d, eax
	lea	eax, DWORD PTR [r11+1]
	cmovne	eax, r11d
	mov	r11d, eax

; 576  : 		int numVerts = 0;
; 577  : 		for (int j = 0; j < nv; ++j)

	inc	r10
	cmp	r10, rbx
	jl	SHORT $LL107@canRemoveV

; 585  : 		}
; 586  : 		if (numRemoved)

	mov	ecx, 65535				; 0000ffffH
	test	r9d, r9d
	je	SHORT $LN2@canRemoveV

; 587  : 		{
; 588  : 			numRemainingEdges += numVerts-(numRemoved+1);

	sub	edx, r9d
	dec	edi
	add	edi, edx
$LN2@canRemoveV:

; 571  : 	for (int i = 0; i < mesh.npolys; ++i)

	add	r8, rbp
	sub	rsi, 1
	jne	SHORT $LL4@canRemoveV

; 589  : 		}
; 590  : 	}
; 591  : 	
; 592  : 	// There would be too few edges remaining to create a polygon.
; 593  : 	// This can happen for example when a tip of a triangle is marked
; 594  : 	// as deletion, but there are no other polys that share the vertex.
; 595  : 	// In this case, the vertex should not be removed.
; 596  : 	if (numRemainingEdges <= 2)

	cmp	edi, 2
	jle	$LN126@canRemoveV

; 598  : 	
; 599  : 	// Find edges which share the removed vertex.
; 600  : 	const int maxEdges = numTouchedVerts*2;

	lea	edi, DWORD PTR [r11+r11]

; 601  : 	int nedges = 0;

	mov	ebp, r13d
	mov	DWORD PTR nedges$1$[rsp], r13d

; 602  : 	rcScopedDelete<int> edges((int*)rcAlloc(sizeof(int)*maxEdges*3, RC_ALLOC_TEMP));

	movsxd	rax, edi
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
	mov	QWORD PTR edges$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 603  : 	if (!edges)

	test	rax, rax
	jne	SHORT $LN23@canRemoveV

; 604  : 	{
; 605  : 		ctx->log(RC_LOG_WARNING, "canRemoveVertex: Out of memory 'edges' (%d).", maxEdges*3);

	lea	r9d, DWORD PTR [rdi+rdi*2]
	lea	r8, OFFSET FLAT:??_C@_0CN@BEHLLPDP@canRemoveVertex?3?5Out?5of?5memory?5@
	lea	edx, QWORD PTR [rsi+2]
	mov	rcx, r15
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	dil, dil
	jmp	$LN34@canRemoveV
$LN23@canRemoveV:

; 606  : 		return false;
; 607  : 	}
; 608  : 		
; 609  : 	for (int i = 0; i < mesh.npolys; ++i)

	mov	r15d, r13d
	mov	rdx, QWORD PTR mesh$1$[rsp]
	cmp	DWORD PTR [rdx+44], r13d
	jle	$LN9@canRemoveV
	mov	rsi, r13
	mov	eax, r13d
	mov	DWORD PTR tv1256[rsp], eax
$LL10@canRemoveV:

; 610  : 	{
; 611  : 		unsigned short* p = &mesh.polys[i*nvp*2];

	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdx+8]
	lea	rdi, QWORD PTR [rax+rcx*2]

; 455  : 	for (int i = 0; i < nvp; ++i)

	mov	r8, r13
	test	r12, r12
	jle	SHORT $LN63@canRemoveV
	mov	eax, 65535				; 0000ffffH
$LL64@canRemoveV:

; 456  : 		if (p[i] == RC_MESH_NULL_IDX)

	cmp	WORD PTR [rdi+r8*2], ax
	je	SHORT $LN61@canRemoveV

; 455  : 	for (int i = 0; i < nvp; ++i)

	inc	r8
	cmp	r8, r12
	jl	SHORT $LL64@canRemoveV
$LN63@canRemoveV:

; 457  : 			return i;
; 458  : 	return nvp;

	mov	r8, r12
$LN61@canRemoveV:

; 612  : 		const int nv = countPolyVerts(p, nvp);
; 613  : 
; 614  : 		// Collect edges which touches the removed vertex.
; 615  : 		for (int j = 0, k = nv-1; j < nv; k = j++)

	mov	r11, r13
	test	r8, r8
	jle	$LN8@canRemoveV
	lea	rcx, QWORD PTR [r8*2-2]
	lea	r10, QWORD PTR [rsi+1]
	lea	r10, QWORD PTR [rsi+r10*2]
	lea	r10, QWORD PTR [rbx+r10*4]
	movzx	r13d, WORD PTR rem$1$[rsp]
$LL13@canRemoveV:

; 616  : 		{
; 617  : 			if (p[j] == rem || p[k] == rem)

	lea	r14, QWORD PTR [r11+r11]
	movzx	edx, WORD PTR [r14+rdi]
	cmp	dx, r13w
	je	SHORT $LN128@canRemoveV
	lea	rax, QWORD PTR [rcx+rdi]
	cmp	WORD PTR [rax], r13w
	jne	SHORT $LN11@canRemoveV
	jmp	SHORT $LN25@canRemoveV
$LN128@canRemoveV:
	lea	rax, QWORD PTR [rdi+rcx]
$LN25@canRemoveV:

; 618  : 			{
; 619  : 				// Arrange edge so that a=rem.
; 620  : 				int a = p[j], b = p[k];

	movzx	ecx, WORD PTR [rax]

; 621  : 				if (b == rem)
; 622  : 					rcSwap(a,b);
; 623  : 					
; 624  : 				// Check if the edge exists
; 625  : 				bool exists = false;

	mov	ebp, ecx
	cmp	ecx, r13d
	cmovne	ebp, edx
	cmovne	edx, ecx
	xor	r9b, r9b

; 626  : 				for (int m = 0; m < nedges; ++m)

	test	rsi, rsi
	jle	SHORT $LN129@canRemoveV

; 621  : 				if (b == rem)
; 622  : 					rcSwap(a,b);
; 623  : 					
; 624  : 				// Check if the edge exists
; 625  : 				bool exists = false;

	lea	rax, QWORD PTR [rbx+8]
	mov	rcx, rsi
	npad	4
$LL16@canRemoveV:

; 627  : 				{
; 628  : 					int* e = &edges[m*3];
; 629  : 					if (e[1] == b)

	cmp	DWORD PTR [rax-4], edx
	jne	SHORT $LN14@canRemoveV

; 630  : 					{
; 631  : 						// Exists, increment vertex share count.
; 632  : 						e[2]++;

	inc	DWORD PTR [rax]

; 633  : 						exists = true;

	mov	r9b, 1
$LN14@canRemoveV:

; 626  : 				for (int m = 0; m < nedges; ++m)

	add	rax, 12
	sub	rcx, 1
	jne	SHORT $LL16@canRemoveV

; 634  : 					}
; 635  : 				}
; 636  : 				// Add new edge.
; 637  : 				if (!exists)

	test	r9b, r9b
	jne	SHORT $LN130@canRemoveV
$LN129@canRemoveV:

; 638  : 				{
; 639  : 					int* e = &edges[nedges*3];
; 640  : 					e[0] = a;

	mov	DWORD PTR [r10-8], ebp

; 641  : 					e[1] = b;

	mov	DWORD PTR [r10-4], edx

; 642  : 					e[2] = 1;

	mov	DWORD PTR [r10], 1

; 643  : 					nedges++;

	mov	ebp, DWORD PTR nedges$1$[rsp]
	inc	ebp
	mov	DWORD PTR nedges$1$[rsp], ebp
	inc	rsi
	add	r10, 12

; 634  : 					}
; 635  : 				}
; 636  : 				// Add new edge.
; 637  : 				if (!exists)

	jmp	SHORT $LN11@canRemoveV
$LN130@canRemoveV:
	mov	ebp, DWORD PTR nedges$1$[rsp]
$LN11@canRemoveV:

; 612  : 		const int nv = countPolyVerts(p, nvp);
; 613  : 
; 614  : 		// Collect edges which touches the removed vertex.
; 615  : 		for (int j = 0, k = nv-1; j < nv; k = j++)

	mov	rcx, r14
	inc	r11
	cmp	r11, r8
	jl	$LL13@canRemoveV
	xor	r13d, r13d
	mov	rdx, QWORD PTR mesh$1$[rsp]
$LN8@canRemoveV:

; 606  : 		return false;
; 607  : 	}
; 608  : 		
; 609  : 	for (int i = 0; i < mesh.npolys; ++i)

	inc	r15d
	mov	eax, DWORD PTR tv1256[rsp]
	add	eax, DWORD PTR tv1254[rsp]
	mov	DWORD PTR tv1256[rsp], eax
	cmp	r15d, DWORD PTR [rdx+44]
	jl	$LL10@canRemoveV
$LN9@canRemoveV:

; 644  : 				}
; 645  : 			}
; 646  : 		}
; 647  : 	}
; 648  : 
; 649  : 	// There should be no more than 2 open edges.
; 650  : 	// This catches the case that two non-adjacent polygons
; 651  : 	// share the removed vertex. In that case, do not remove the vertex.
; 652  : 	int numOpenEdges = 0;
; 653  : 	for (int i = 0; i < nedges; ++i)

	movsxd	rdx, ebp
	test	ebp, ebp
	jle	SHORT $LN30@canRemoveV

; 616  : 		{
; 617  : 			if (p[j] == rem || p[k] == rem)

	lea	rcx, QWORD PTR [rbx+8]
	npad	6
$LL19@canRemoveV:

; 644  : 				}
; 645  : 			}
; 646  : 		}
; 647  : 	}
; 648  : 
; 649  : 	// There should be no more than 2 open edges.
; 650  : 	// This catches the case that two non-adjacent polygons
; 651  : 	// share the removed vertex. In that case, do not remove the vertex.
; 652  : 	int numOpenEdges = 0;
; 653  : 	for (int i = 0; i < nedges; ++i)

	lea	eax, DWORD PTR [r13+1]
	cmp	DWORD PTR [rcx], 2
	cmovge	eax, r13d
	lea	rcx, QWORD PTR [rcx+12]
	mov	r13d, eax
	sub	rdx, 1
	jne	SHORT $LL19@canRemoveV

; 654  : 	{
; 655  : 		if (edges[i*3+2] < 2)
; 656  : 			numOpenEdges++;
; 657  : 	}
; 658  : 	if (numOpenEdges > 2)

	cmp	eax, 2
	jle	SHORT $LN30@canRemoveV
	xor	dil, dil
	jmp	SHORT $LN34@canRemoveV
$LN30@canRemoveV:

; 661  : 	return true;

	mov	dil, 1
$LN34@canRemoveV:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rbx, rbx
	je	SHORT $LN85@canRemoveV

; 28   : 	free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
	npad	1
$LN85@canRemoveV:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 661  : 	return true;

	movzx	eax, dil
	jmp	SHORT $LN1@canRemoveV
$LN126@canRemoveV:

; 597  : 		return false;

	xor	al, al
$LN1@canRemoveV:

; 662  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z ENDP ; canRemoveVertex
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
rem$1$ = 32
nedges$1$ = 36
tv1254 = 40
mesh$1$ = 48
tv1256 = 56
edges$ = 56
__$ArrayPad$ = 64
ctx$ = 128
mesh$ = 136
rem$ = 144
?dtor$0@?0??canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z@4HA PROC ; `canRemoveVertex'::`1'::dtor$0
	lea	rcx, QWORD PTR edges$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$0@?0??canRemoveVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@G@Z@4HA ENDP ; `canRemoveVertex'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$rcScopedDelete@H@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$rcScopedDelete@H@@QEAAX_K@Z PROC	; rcScopedDelete<int>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$rcScopedDelete@H@@QEAAX_K@Z ENDP	; rcScopedDelete<int>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp
;	COMDAT ?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z
_TEXT	SEGMENT
$T1 = 48
n$1$ = 52
bestEb$1$ = 52
bestPb$1$ = 56
a$1$ = 56
i$1$ = 56
tv8057 = 56
tv7850 = 56
tv7732 = 56
tv7729 = 56
tv7711 = 56
tv7662 = 56
npolys$1$ = 60
ntris$1$ = 60
tv7767 = 60
mini$1$ = 64
bestEa$1$ = 64
tv7676 = 64
nedges$1$ = 64
$T2 = 72
$T3 = 72
d0$1$ = 72
tv7738 = 72
tv7670 = 72
tv7646 = 72
nvp$1$ = 80
tv8062 = 84
tv8041 = 84
tv7808 = 84
tv7765 = 84
tv7718 = 84
minLen$2$ = 88
bestPa$1$ = 88
tv7734 = 88
$T4 = 96
tv7789 = 96
tv7781 = 96
eb$5 = 96
$T6 = 104
$T7 = 104
$T8 = 104
tv7747 = 104
tv7739 = 104
d1$1$ = 112
d0$1$ = 112
ea$9 = 112
ctx$GSCopy$1$ = 120
j$1$ = 128
tv7849 = 128
dst$1$ = 136
tv7766 = 136
tv7645 = 136
$T10 = 144
tv7717 = 144
tv7683 = 144
tv7678 = 144
$T11 = 152
mesh$GSCopy$1$ = 160
harea$1$ = 168
$T12 = 176
tv7722 = 176
maxTris$GSCopy$1$ = 184
hreg$1$ = 192
hole$1$ = 200
tris$1$ = 208
tv8063 = 208
tv7720 = 216
p$1$ = 224
tmpPoly$1$ = 224
$T13 = 232
tv7668 = 240
tv7715 = 248
thole$1$ = 256
tverts$1$ = 264
$T14 = 272
edges$1$ = 280
pregs$1$ = 288
pareas$1$ = 296
edges$ = 304
hole$ = 312
hreg$ = 320
harea$ = 328
tris$ = 336
tverts$ = 344
thole$ = 352
polys$ = 360
pregs$ = 368
pareas$ = 376
__$ArrayPad$ = 384
ctx$ = 480
mesh$ = 488
rem$ = 496
maxTris$ = 504
?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z PROC ; removeVertex, COMDAT

; 665  : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 408				; 00000198H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR maxTris$GSCopy$1$[rsp], r9d
	movzx	r14d, r8w
	mov	QWORD PTR mesh$GSCopy$1$[rsp], rdx
	mov	rbp, rcx
	mov	QWORD PTR ctx$GSCopy$1$[rsp], rcx

; 666  : 	const int nvp = mesh.nvp;

	movsxd	r13, DWORD PTR [rdx+52]
	mov	DWORD PTR nvp$1$[rsp], r13d

; 667  : 
; 668  : 	// Count number of polygons to remove.
; 669  : 	int numRemovedVerts = 0;

	xor	r11d, r11d
	mov	QWORD PTR $T14[rsp], r11
	mov	esi, r11d

; 670  : 	for (int i = 0; i < mesh.npolys; ++i)

	mov	r12, r13
	mov	QWORD PTR $T11[rsp], r13
	mov	ecx, DWORD PTR [rdx+44]
	mov	r8d, 65535				; 0000ffffH
	test	ecx, ecx
	jle	SHORT $LN3@removeVert

; 671  : 	{
; 672  : 		unsigned short* p = &mesh.polys[i*nvp*2];

	lea	eax, DWORD PTR [r13*2]
	movsxd	r10, eax
	add	r10, r10
	mov	rdi, QWORD PTR [rdx+8]
	mov	r9d, ecx
	npad	10
$LL4@removeVert:

; 455  : 	for (int i = 0; i < nvp; ++i)

	mov	edx, r11d
	mov	rax, r11
	test	r13d, r13d
	jle	SHORT $LN486@removeVert
	npad	5
$LL487@removeVert:

; 456  : 		if (p[i] == RC_MESH_NULL_IDX)

	cmp	WORD PTR [rdi+rax*2], r8w
	je	SHORT $LN484@removeVert

; 449  : 	
; 450  : 	return ntris;
; 451  : }
; 452  : 
; 453  : static int countPolyVerts(const unsigned short* p, const int nvp)
; 454  : {
; 455  : 	for (int i = 0; i < nvp; ++i)

	inc	edx
	inc	rax
	cmp	rax, r12
	jl	SHORT $LL487@removeVert
$LN486@removeVert:

; 457  : 			return i;
; 458  : 	return nvp;

	mov	edx, r13d
$LN484@removeVert:

; 673  : 		const int nv = countPolyVerts(p, nvp);
; 674  : 		for (int j = 0; j < nv; ++j)

	mov	rcx, r11
	movsxd	r8, edx
	test	edx, edx
	jle	SHORT $LN2@removeVert
	npad	2
$LL1384@removeVert:
	lea	eax, DWORD PTR [rsi+1]
	cmp	WORD PTR [rdi+rcx*2], r14w
	cmovne	eax, esi
	mov	esi, eax
	inc	rcx
	cmp	rcx, r8
	jl	SHORT $LL1384@removeVert
$LN2@removeVert:

; 670  : 	for (int i = 0; i < mesh.npolys; ++i)

	add	rdi, r10
	sub	r9, 1
	mov	r8d, 65535				; 0000ffffH
	jne	SHORT $LL4@removeVert
$LN3@removeVert:

; 675  : 		{
; 676  : 			if (p[j] == rem)
; 677  : 				numRemovedVerts++;
; 678  : 		}
; 679  : 	}
; 680  : 	
; 681  : 	int nedges = 0;

	mov	r15d, r11d
	mov	DWORD PTR nedges$1$[rsp], r11d

; 682  : 	rcScopedDelete<int> edges((int*)rcAlloc(sizeof(int)*numRemovedVerts*nvp*4, RC_ALLOC_TEMP));

	movsxd	rbx, esi
	imul	rbx, r12
	mov	rcx, rbx
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
	mov	QWORD PTR edges$1$[rsp], rax
	mov	QWORD PTR edges$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 683  : 	if (!edges)

	test	rax, rax
	jne	SHORT $LN56@removeVert

; 684  : 	{
; 685  : 		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'edges' (%d).", numRemovedVerts*nvp*4);

	imul	esi, r13d
	shl	esi, 2
	mov	r9d, esi
	lea	r8, OFFSET FLAT:??_C@_0CK@IOAOCBA@removeVertex?3?5Out?5of?5memory?5?8ed@
	lea	edx, QWORD PTR [rax+2]
	mov	rcx, rbp
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	sil, sil
	jmp	$LN128@removeVert
$LN56@removeVert:

; 686  : 		return false;
; 687  : 	}
; 688  : 
; 689  : 	int nhole = 0;
; 690  : 	rcScopedDelete<int> hole((int*)rcAlloc(sizeof(int)*numRemovedVerts*nvp, RC_ALLOC_TEMP));

	lea	rbx, QWORD PTR [rbx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	rbp, rax
	mov	QWORD PTR hole$1$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR hole$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 691  : 	if (!hole)

	test	rax, rax
	jne	SHORT $LN57@removeVert

; 692  : 	{
; 693  : 		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'hole' (%d).", numRemovedVerts*nvp);

	imul	esi, r13d
	mov	r9d, esi
	lea	r8, OFFSET FLAT:??_C@_0CJ@MEHPLN@removeVertex?3?5Out?5of?5memory?5?8ho@
	lea	edx, QWORD PTR [rax+2]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	sil, sil
	jmp	$LN138@removeVert
$LN57@removeVert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	r12, rax
	mov	QWORD PTR hreg$1$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR hreg$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 699  : 	if (!hreg)

	test	rax, rax
	jne	SHORT $LN58@removeVert

; 700  : 	{
; 701  : 		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'hreg' (%d).", numRemovedVerts*nvp);

	imul	esi, r13d
	mov	r9d, esi
	lea	r8, OFFSET FLAT:??_C@_0CJ@LHEFPFDN@removeVertex?3?5Out?5of?5memory?5?8hr@
	lea	edx, QWORD PTR [rax+2]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	sil, sil
	jmp	$LN148@removeVert
$LN58@removeVert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	r13, rax
	mov	QWORD PTR harea$1$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR harea$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 707  : 	if (!harea)

	test	rax, rax
	jne	SHORT $LN59@removeVert

; 708  : 	{
; 709  : 		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'harea' (%d).", numRemovedVerts*nvp);

	imul	esi, DWORD PTR nvp$1$[rsp]
	mov	r9d, esi
	lea	r8, OFFSET FLAT:??_C@_0CK@IKPIPHAA@removeVertex?3?5Out?5of?5memory?5?8ha@
	lea	edx, QWORD PTR [rax+2]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	al, al
	mov	BYTE PTR $T1[rsp], al
	jmp	$LN158@removeVert
$LN59@removeVert:

; 710  : 		return false;
; 711  : 	}
; 712  : 	
; 713  : 	for (int i = 0; i < mesh.npolys; ++i)

	xor	r11d, r11d
	mov	esi, r11d
	mov	DWORD PTR i$1$[rsp], r11d
	mov	QWORD PTR tv8063[rsp], 1
	mov	r10, QWORD PTR mesh$GSCopy$1$[rsp]
	cmp	DWORD PTR [r10+44], r11d
	jle	$LN9@removeVert
	mov	r9d, r11d
	mov	r15d, r11d
	mov	r8d, r11d
	mov	DWORD PTR tv7767[rsp], r11d
	mov	ecx, DWORD PTR nvp$1$[rsp]
	lea	eax, DWORD PTR [rcx+rcx]
	mov	DWORD PTR tv7766[rsp], eax
	mov	eax, ecx
	neg	eax
	add	eax, eax
	mov	ebp, r11d
	mov	r12d, eax
	mov	r13d, DWORD PTR tv7766[rsp]
	npad	3
$LL10@removeVert:

; 714  : 	{
; 715  : 		unsigned short* p = &mesh.polys[i*nvp*2];

	movsxd	rcx, r8d
	mov	rax, QWORD PTR [r10+8]
	lea	rbx, QWORD PTR [rax+rcx*2]

; 455  : 	for (int i = 0; i < nvp; ++i)

	mov	rdx, r11
	mov	rax, QWORD PTR $T11[rsp]
	test	rax, rax
	jle	SHORT $LN502@removeVert
	mov	ecx, 65535				; 0000ffffH
$LL503@removeVert:

; 456  : 		if (p[i] == RC_MESH_NULL_IDX)

	cmp	WORD PTR [rbx+rdx*2], cx
	je	SHORT $LN500@removeVert

; 449  : 	
; 450  : 	return ntris;
; 451  : }
; 452  : 
; 453  : static int countPolyVerts(const unsigned short* p, const int nvp)
; 454  : {
; 455  : 	for (int i = 0; i < nvp; ++i)

	inc	rdx
	cmp	rdx, rax
	jl	SHORT $LL503@removeVert
$LN502@removeVert:

; 457  : 			return i;
; 458  : 	return nvp;

	mov	rdx, rax
$LN500@removeVert:

; 716  : 		const int nv = countPolyVerts(p, nvp);
; 717  : 		bool hasRem = false;

	xor	al, al
	mov	rcx, r11

; 718  : 		for (int j = 0; j < nv; ++j)

	test	rdx, rdx
	jle	$LN8@removeVert
	npad	1
$LL1387@removeVert:

; 719  : 			if (p[j] == rem) hasRem = true;

	movzx	eax, al
	cmp	WORD PTR [rbx+rcx*2], r14w
	cmove	eax, DWORD PTR tv8063[rsp]

; 718  : 		for (int j = 0; j < nv; ++j)

	inc	rcx
	cmp	rcx, rdx
	jl	SHORT $LL1387@removeVert

; 720  : 		if (hasRem)

	test	al, al
	je	$LN8@removeVert

; 721  : 		{
; 722  : 			// Collect edges which does not touch the removed vertex.
; 723  : 			for (int j = 0, k = nv-1; j < nv; k = j++)

	lea	rcx, QWORD PTR [rdx*2-2]
	mov	rsi, rbx
	mov	r8, r9
	shl	r8, 4
	add	r8, 8
	add	r8, rdi
	npad	7
$LL16@removeVert:

; 724  : 			{
; 725  : 				if (p[j] != rem && p[k] != rem)

	cmp	WORD PTR [rsi], r14w
	je	SHORT $LN14@removeVert
	movzx	eax, WORD PTR [rcx+rbx]
	cmp	ax, r14w
	je	SHORT $LN14@removeVert

; 726  : 				{
; 727  : 					int* e = &edges[nedges*4];
; 728  : 					e[0] = p[k];

	mov	DWORD PTR [r8-8], eax

; 729  : 					e[1] = p[j];

	movzx	eax, WORD PTR [rsi]
	mov	DWORD PTR [r8-4], eax

; 730  : 					e[2] = mesh.regs[i];

	mov	rax, QWORD PTR [r10+16]
	movzx	ecx, WORD PTR [rax+r15*2]
	mov	DWORD PTR [r8], ecx

; 731  : 					e[3] = mesh.areas[i];

	mov	rax, QWORD PTR [r10+32]
	movzx	ecx, BYTE PTR [rax+r15]
	mov	DWORD PTR [r8+4], ecx

; 732  : 					nedges++;

	inc	ebp
	inc	r9
	add	r8, 16
$LN14@removeVert:

; 721  : 		{
; 722  : 			// Collect edges which does not touch the removed vertex.
; 723  : 			for (int j = 0, k = nv-1; j < nv; k = j++)

	mov	rcx, rsi
	sub	rcx, rbx
	add	rsi, 2
	sub	rdx, 1
	jne	SHORT $LL16@removeVert
	mov	DWORD PTR nedges$1$[rsp], ebp
	mov	QWORD PTR $T6[rsp], r9

; 733  : 				}
; 734  : 			}
; 735  : 			// Remove the polygon.
; 736  : 			unsigned short* p2 = &mesh.polys[(mesh.npolys-1)*nvp*2];

	mov	eax, DWORD PTR [r10+44]
	lea	eax, DWORD PTR [rax*2-2]
	imul	eax, DWORD PTR nvp$1$[rsp]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r10+8]
	lea	rdx, QWORD PTR [rax+rcx*2]
	mov	rax, QWORD PTR $T11[rsp]
	lea	rsi, QWORD PTR [rax+rax]

; 737  : 			if (p != p2)

	cmp	rbx, rdx
	je	SHORT $LN1428@removeVert

; 738  : 				memcpy(p,p2,sizeof(unsigned short)*nvp);

	mov	r8, rsi
	mov	rcx, rbx
	call	memcpy
$LN1428@removeVert:

; 739  : 			memset(p+nvp,0xff,sizeof(unsigned short)*nvp);

	lea	rcx, QWORD PTR [rsi+rbx]
	mov	r8, rsi
	mov	edx, 255				; 000000ffH
	call	memset

; 740  : 			mesh.regs[i] = mesh.regs[mesh.npolys-1];

	mov	r10, QWORD PTR mesh$GSCopy$1$[rsp]
	mov	rdx, QWORD PTR [r10+16]
	movsxd	rax, DWORD PTR [r10+44]
	movzx	ecx, WORD PTR [rdx+rax*2-2]
	mov	WORD PTR [rdx+r15*2], cx

; 741  : 			mesh.areas[i] = mesh.areas[mesh.npolys-1];

	mov	rdx, QWORD PTR [r10+32]
	movsxd	rax, DWORD PTR [r10+44]
	movzx	ecx, BYTE PTR [rax+rdx-1]
	mov	BYTE PTR [rdx+r15], cl

; 742  : 			mesh.npolys--;

	dec	DWORD PTR [r10+44]

; 743  : 			--i;

	mov	esi, DWORD PTR i$1$[rsp]
	dec	esi
	mov	r8d, DWORD PTR tv7767[rsp]
	add	r8d, r12d
	dec	r15
	mov	r9, QWORD PTR $T6[rsp]
	xor	r11d, r11d
$LN8@removeVert:

; 710  : 		return false;
; 711  : 	}
; 712  : 	
; 713  : 	for (int i = 0; i < mesh.npolys; ++i)

	inc	esi
	mov	DWORD PTR i$1$[rsp], esi
	add	r8d, r13d
	mov	DWORD PTR tv7767[rsp], r8d
	inc	r15
	cmp	esi, DWORD PTR [r10+44]
	jl	$LL10@removeVert
	mov	rbp, QWORD PTR hole$1$[rsp]
	mov	r12, QWORD PTR hreg$1$[rsp]
	mov	r13, QWORD PTR harea$1$[rsp]
	mov	r15d, DWORD PTR nedges$1$[rsp]
$LN9@removeVert:

; 744  : 		}
; 745  : 	}
; 746  : 	
; 747  : 	// Remove vertex.
; 748  : 	for (int i = (int)rem; i < mesh.nverts - 1; ++i)

	mov	rsi, r14
	mov	ecx, DWORD PTR [r10+40]
	lea	eax, DWORD PTR [rcx-1]
	cmp	r14d, eax
	jge	SHORT $LN18@removeVert
	lea	rdx, QWORD PTR [r14+r14*2]
	add	rdx, rdx
	npad	12
$LL19@removeVert:

; 749  : 	{
; 750  : 		mesh.verts[i*3+0] = mesh.verts[(i+1)*3+0];

	mov	rcx, QWORD PTR [r10]
	movzx	eax, WORD PTR [rcx+rdx+6]
	mov	WORD PTR [rcx+rdx], ax

; 751  : 		mesh.verts[i*3+1] = mesh.verts[(i+1)*3+1];

	mov	rcx, QWORD PTR [r10]
	movzx	eax, WORD PTR [rcx+rdx+8]
	mov	WORD PTR [rcx+rdx+2], ax

; 752  : 		mesh.verts[i*3+2] = mesh.verts[(i+1)*3+2];

	mov	rcx, QWORD PTR [r10]
	movzx	eax, WORD PTR [rcx+rdx+10]
	mov	WORD PTR [rcx+rdx+4], ax

; 744  : 		}
; 745  : 	}
; 746  : 	
; 747  : 	// Remove vertex.
; 748  : 	for (int i = (int)rem; i < mesh.nverts - 1; ++i)

	inc	esi
	lea	rdx, QWORD PTR [rdx+6]
	mov	ecx, DWORD PTR [r10+40]
	lea	eax, DWORD PTR [rcx-1]
	cmp	esi, eax
	jl	SHORT $LL19@removeVert
$LN18@removeVert:

; 753  : 	}
; 754  : 	mesh.nverts--;

	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [r10+40], eax

; 755  : 
; 756  : 	// Adjust indices to match the removed vertex layout.
; 757  : 	for (int i = 0; i < mesh.npolys; ++i)

	mov	r8d, r11d
	cmp	DWORD PTR [r10+44], 0
	jle	$LN21@removeVert

; 753  : 	}
; 754  : 	mesh.nverts--;

	mov	esi, r11d
	mov	r13d, DWORD PTR nvp$1$[rsp]
	lea	r10d, DWORD PTR [r13*2]
	mov	rbx, QWORD PTR mesh$GSCopy$1$[rsp]
	npad	12
$LL22@removeVert:

; 758  : 	{
; 759  : 		unsigned short* p = &mesh.polys[i*nvp*2];

	movsxd	rcx, esi
	mov	rax, QWORD PTR [rbx+8]
	lea	rdx, QWORD PTR [rax+rcx*2]

; 455  : 	for (int i = 0; i < nvp; ++i)

	mov	ecx, r11d
	mov	rax, r11
	cmp	QWORD PTR $T11[rsp], 0
	jle	SHORT $LN470@removeVert
	npad	4
$LL471@removeVert:

; 456  : 		if (p[i] == RC_MESH_NULL_IDX)

	mov	r12d, 65535				; 0000ffffH
	cmp	WORD PTR [rdx+rax*2], r12w
	mov	r12, QWORD PTR hreg$1$[rsp]
	je	SHORT $LN468@removeVert

; 449  : 	
; 450  : 	return ntris;
; 451  : }
; 452  : 
; 453  : static int countPolyVerts(const unsigned short* p, const int nvp)
; 454  : {
; 455  : 	for (int i = 0; i < nvp; ++i)

	inc	ecx
	inc	rax
	cmp	rax, QWORD PTR $T11[rsp]
	jl	SHORT $LL471@removeVert
$LN470@removeVert:

; 457  : 			return i;
; 458  : 	return nvp;

	mov	rcx, r13
$LN468@removeVert:

; 760  : 		const int nv = countPolyVerts(p, nvp);
; 761  : 		for (int j = 0; j < nv; ++j)

	test	ecx, ecx
	jle	SHORT $LN20@removeVert
	npad	5
$LL1390@removeVert:

; 762  : 			if (p[j] > rem) p[j]--;

	movzx	eax, WORD PTR [rdx]
	cmp	ax, r14w
	jbe	SHORT $LN1391@removeVert
	dec	ax
	mov	WORD PTR [rdx], ax
$LN1391@removeVert:

; 760  : 		const int nv = countPolyVerts(p, nvp);
; 761  : 		for (int j = 0; j < nv; ++j)

	add	rdx, 2
	sub	rcx, 1
	jne	SHORT $LL1390@removeVert
$LN20@removeVert:

; 755  : 
; 756  : 	// Adjust indices to match the removed vertex layout.
; 757  : 	for (int i = 0; i < mesh.npolys; ++i)

	inc	r8d
	add	esi, r10d
	cmp	r8d, DWORD PTR [rbx+44]
	jl	SHORT $LL22@removeVert
	mov	r13, QWORD PTR harea$1$[rsp]
$LN21@removeVert:

; 763  : 	}
; 764  : 	for (int i = 0; i < nedges; ++i)

	movsxd	r10, r15d
	mov	QWORD PTR $T4[rsp], r10
	test	r15d, r15d
	jle	SHORT $LN1511@removeVert

; 738  : 				memcpy(p,p2,sizeof(unsigned short)*nvp);

	mov	rcx, rdi
	mov	rdx, r10
$LL28@removeVert:

; 765  : 	{
; 766  : 		if (edges[i*4+0] > rem) edges[i*4+0]--;

	mov	eax, DWORD PTR [rcx]
	cmp	eax, r14d
	jle	SHORT $LN65@removeVert
	dec	eax
	mov	DWORD PTR [rcx], eax
$LN65@removeVert:

; 767  : 		if (edges[i*4+1] > rem) edges[i*4+1]--;

	mov	eax, DWORD PTR [rcx+4]
	cmp	eax, r14d
	jle	SHORT $LN26@removeVert
	dec	eax
	mov	DWORD PTR [rcx+4], eax
$LN26@removeVert:

; 763  : 	}
; 764  : 	for (int i = 0; i < nedges; ++i)

	add	rcx, 16
	sub	rdx, 1
	jne	SHORT $LL28@removeVert

; 768  : 	}
; 769  : 
; 770  : 	if (nedges == 0)

	test	r15d, r15d
$LN1511@removeVert:
	jne	SHORT $LN67@removeVert

; 771  : 		return true;

	mov	BYTE PTR $T1[rsp], 1
	jmp	$LN158@removeVert
$LN67@removeVert:

; 560  : 	arr[an] = v;

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rbp], eax

; 561  : 	an++;

	mov	ecx, 1
	mov	r9d, ecx
	mov	DWORD PTR n$1$[rsp], ecx

; 560  : 	arr[an] = v;

	mov	eax, DWORD PTR [rdi+8]
	mov	DWORD PTR [r12], eax
	mov	eax, DWORD PTR [rdi+12]
	mov	DWORD PTR [r13], eax

; 791  : 			{
; 792  : 				// The segment matches the beginning of the hole boundary.
; 793  : 				pushFront(ea, hole, nhole);
; 794  : 				pushFront(r, hreg, nhreg);
; 795  : 				pushFront(a, harea, nharea);

	mov	r14d, ecx
	mov	QWORD PTR $T12[rsp], rcx
	mov	r15d, ecx
	npad	2
$LL29@removeVert:

; 780  : 	{
; 781  : 		bool match = false;

	xor	bl, bl

; 782  : 		
; 783  : 		for (int i = 0; i < nedges; ++i)

	test	r10, r10
	jle	$LN1350@removeVert

; 780  : 	{
; 781  : 		bool match = false;

	mov	rdx, rdi
	mov	rcx, r10
	shl	rcx, 4
	add	rdi, -12
	add	rcx, rdi
	mov	QWORD PTR tv7747[rsp], rcx
	lea	rcx, QWORD PTR [r14*4-4]
	add	rcx, rbp
	mov	QWORD PTR $T2[rsp], rcx
	mov	rdi, QWORD PTR $T12[rsp]
	npad	7
$LL33@removeVert:

; 784  : 		{
; 785  : 			const int ea = edges[i*4+0];

	mov	esi, DWORD PTR [rdx]

; 786  : 			const int eb = edges[i*4+1];

	mov	eax, DWORD PTR [rdx+4]

; 787  : 			const int r = edges[i*4+2];

	mov	r8d, DWORD PTR [rdx+8]

; 788  : 			const int a = edges[i*4+3];

	mov	r13d, DWORD PTR [rdx+12]
	mov	DWORD PTR a$1$[rsp], r13d

; 789  : 			bool add = false;
; 790  : 			if (hole[0] == eb)

	cmp	DWORD PTR [rbp], eax
	mov	r13, QWORD PTR harea$1$[rsp]
	jne	SHORT $LN68@removeVert

; 553  : 	an++;

	mov	rcx, r14

; 554  : 	for (int i = an-1; i > 0; --i) arr[i] = arr[i-1];

	test	r14, r14
	jle	SHORT $LN241@removeVert
	npad	9
$LL242@removeVert:
	mov	eax, DWORD PTR [rbp+rcx*4-4]
	mov	DWORD PTR [rbp+rcx*4], eax
	dec	rcx
	test	rcx, rcx
	jg	SHORT $LL242@removeVert
$LN241@removeVert:

; 555  : 	arr[0] = v;

	mov	DWORD PTR [rbp], esi
	mov	rcx, rdi

; 554  : 	for (int i = an-1; i > 0; --i) arr[i] = arr[i-1];

	test	rdi, rdi
	jle	SHORT $LN231@removeVert
	npad	5
$LL232@removeVert:
	mov	eax, DWORD PTR [r12+rcx*4-4]
	mov	DWORD PTR [r12+rcx*4], eax
	dec	rcx
	test	rcx, rcx
	jg	SHORT $LL232@removeVert
$LN231@removeVert:

; 555  : 	arr[0] = v;

	mov	DWORD PTR [r12], r8d
	mov	rax, r15

; 554  : 	for (int i = an-1; i > 0; --i) arr[i] = arr[i-1];

	test	r15, r15
	jle	SHORT $LN236@removeVert
	npad	3
$LL237@removeVert:
	mov	ecx, DWORD PTR [r13+rax*4-4]
	mov	DWORD PTR [r13+rax*4], ecx
	dec	rax
	test	rax, rax
	jg	SHORT $LL237@removeVert
$LN236@removeVert:

; 555  : 	arr[0] = v;

	mov	eax, DWORD PTR a$1$[rsp]
	mov	DWORD PTR [r13], eax

; 796  : 				add = true;
; 797  : 			}

	jmp	SHORT $LN1512@removeVert
$LN68@removeVert:

; 798  : 			else if (hole[nhole-1] == ea)

	cmp	DWORD PTR [rcx], esi
	jne	$LN31@removeVert

; 560  : 	arr[an] = v;

	mov	DWORD PTR [rbp+r14*4], eax
	mov	DWORD PTR [r12+rdi*4], r8d
	mov	eax, DWORD PTR a$1$[rsp]
	mov	DWORD PTR [r13+r15*4], eax

; 561  : 	an++;

	mov	QWORD PTR $T2[rsp], rcx
	mov	DWORD PTR n$1$[rsp], r9d
$LN1512@removeVert:

; 799  : 			{
; 800  : 				// The segment matches the end of the hole boundary.
; 801  : 				pushBack(eb, hole, nhole);
; 802  : 				pushBack(r, hreg, nhreg);
; 803  : 				pushBack(a, harea, nharea);
; 804  : 				add = true;
; 805  : 			}
; 806  : 			if (add)
; 807  : 			{
; 808  : 				// The edge segment was added, remove it.
; 809  : 				edges[i*4+0] = edges[(nedges-1)*4+0];

	mov	eax, 1
	mov	r10d, eax
	mov	r9d, eax
	mov	r8d, eax
	mov	esi, eax
	lea	ecx, QWORD PTR [rax+3]
	mov	rbx, QWORD PTR tv7747[rsp]
	mov	eax, DWORD PTR [rbx-4]
	mov	DWORD PTR [rdx], eax

; 810  : 				edges[i*4+1] = edges[(nedges-1)*4+1];

	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rdx+4], eax

; 811  : 				edges[i*4+2] = edges[(nedges-1)*4+2];

	mov	eax, DWORD PTR [rbx+4]
	mov	DWORD PTR [rdx+8], eax

; 812  : 				edges[i*4+3] = edges[(nedges-1)*4+3];

	mov	eax, DWORD PTR [rbx+8]
	mov	DWORD PTR [rdx+12], eax

; 813  : 				--nedges;

	dec	QWORD PTR $T4[rsp]
	sub	rbx, 16
	mov	QWORD PTR tv7747[rsp], rbx

; 814  : 				match = true;

	movzx	ebx, r8b

; 815  : 				--i;

	dec	r11
	sub	rdx, 16

; 799  : 			{
; 800  : 				// The segment matches the end of the hole boundary.
; 801  : 				pushBack(eb, hole, nhole);
; 802  : 				pushBack(r, hreg, nhreg);
; 803  : 				pushBack(a, harea, nharea);
; 804  : 				add = true;
; 805  : 			}
; 806  : 			if (add)
; 807  : 			{
; 808  : 				// The edge segment was added, remove it.
; 809  : 				edges[i*4+0] = edges[(nedges-1)*4+0];

	add	QWORD PTR $T2[rsp], rcx
	add	DWORD PTR n$1$[rsp], esi
	add	r15, r8
	add	rdi, r8
	add	r14, r8
	mov	rcx, QWORD PTR $T2[rsp]
	mov	r10, QWORD PTR $T4[rsp]
	mov	r9d, DWORD PTR n$1$[rsp]
$LN31@removeVert:

; 782  : 		
; 783  : 		for (int i = 0; i < nedges; ++i)

	inc	r11
	add	rdx, 16
	cmp	r11, r10
	jl	$LL33@removeVert
	mov	QWORD PTR $T12[rsp], rdi
	mov	rdi, QWORD PTR edges$1$[rsp]

; 816  : 			}
; 817  : 		}
; 818  : 		
; 819  : 		if (!match)

	test	bl, bl
	je	SHORT $LN1350@removeVert

; 772  : 
; 773  : 	// Start with one vertex, keep appending connected
; 774  : 	// segments to the start and end of the hole.
; 775  : 	pushBack(edges[0], hole, nhole);
; 776  : 	pushBack(edges[2], hreg, nhreg);
; 777  : 	pushBack(edges[3], harea, nharea);
; 778  : 	
; 779  : 	while (nedges)

	test	r10, r10
	mov	r11d, 0
	jne	$LL29@removeVert
$LN1350@removeVert:

; 820  : 			break;
; 821  : 	}
; 822  : 
; 823  : 	rcScopedDelete<int> tris((int*)rcAlloc(sizeof(int)*nhole*3, RC_ALLOC_TEMP));

	movsxd	rbx, r9d
	lea	rcx, QWORD PTR [rbx+rbx*2]
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
	mov	QWORD PTR tris$1$[rsp], rax
	mov	QWORD PTR tris$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 824  : 	if (!tris)

	test	rax, rax
	jne	SHORT $LN73@removeVert

; 825  : 	{
; 826  : 		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'tris' (%d).", nhole*3);

	mov	eax, DWORD PTR n$1$[rsp]
	lea	r9d, DWORD PTR [rax+rax*2]
	lea	r8, OFFSET FLAT:??_C@_0CJ@FFEHKGLD@removeVertex?3?5Out?5of?5memory?5?8tr@
	lea	edx, QWORD PTR [rdi+2]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	al, al
	mov	BYTE PTR $T1[rsp], al
	jmp	$LN168@removeVert
$LN73@removeVert:

; 827  : 		return false;
; 828  : 	}
; 829  : 
; 830  : 	rcScopedDelete<int> tverts((int*)rcAlloc(sizeof(int)*nhole*4, RC_ALLOC_TEMP));

	mov	rcx, rbx
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	r15, rax
	mov	QWORD PTR tverts$1$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR tverts$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 831  : 	if (!tverts)

	test	rax, rax
	jne	SHORT $LN74@removeVert

; 832  : 	{
; 833  : 		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'tverts' (%d).", nhole*4);

	mov	r8d, DWORD PTR n$1$[rsp]
	lea	r9d, DWORD PTR [r8*4]
	lea	r8, OFFSET FLAT:??_C@_0CL@BDNMMAMJ@removeVertex?3?5Out?5of?5memory?5?8tv@
	lea	edx, QWORD PTR [rax+2]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	al, al
	mov	BYTE PTR $T1[rsp], al
	jmp	$LN178@removeVert
$LN74@removeVert:

; 834  : 		return false;
; 835  : 	}
; 836  : 
; 837  : 	rcScopedDelete<int> thole((int*)rcAlloc(sizeof(int)*nhole, RC_ALLOC_TEMP));

	lea	rcx, QWORD PTR [rbx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	r14, rax
	mov	QWORD PTR thole$1$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR thole$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 838  : 	if (!thole)

	test	rax, rax
	jne	SHORT $LN75@removeVert

; 839  : 	{
; 840  : 		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'thole' (%d).", nhole);

	mov	r9d, DWORD PTR n$1$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0CK@PNHHCBLK@removeVertex?3?5Out?5of?5memory?5?8th@
	lea	edx, QWORD PTR [rax+2]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	al, al
	mov	BYTE PTR $T1[rsp], al
	jmp	$LN188@removeVert
$LN75@removeVert:

; 841  : 		return false;
; 842  : 	}
; 843  : 
; 844  : 	// Generate temp vertex array for triangulation.
; 845  : 	for (int i = 0; i < nhole; ++i)

	xor	edx, edx
	mov	r9d, edx
	test	rbx, rbx
	jle	SHORT $LN35@removeVert

; 815  : 				--i;

	mov	r8, r14
	lea	rsi, QWORD PTR [r15+8]
	mov	r10, rbp
	sub	r10, r14
	mov	r11, QWORD PTR mesh$GSCopy$1$[rsp]
	npad	11
$LL36@removeVert:

; 846  : 	{
; 847  : 		const int pi = hole[i];

	mov	eax, DWORD PTR [r10+r8]

; 848  : 		tverts[i*4+0] = mesh.verts[pi*3+0];

	lea	eax, DWORD PTR [rax+rax*2]
	movsxd	rdx, eax
	mov	rax, QWORD PTR [r11]
	movzx	ecx, WORD PTR [rax+rdx*2]
	mov	DWORD PTR [rsi-8], ecx

; 849  : 		tverts[i*4+1] = mesh.verts[pi*3+1];

	mov	rax, QWORD PTR [r11]
	movzx	ecx, WORD PTR [rax+rdx*2+2]
	mov	DWORD PTR [rsi-4], ecx

; 850  : 		tverts[i*4+2] = mesh.verts[pi*3+2];

	mov	rax, QWORD PTR [r11]
	movzx	ecx, WORD PTR [rax+rdx*2+4]
	mov	DWORD PTR [rsi], ecx

; 851  : 		tverts[i*4+3] = 0;

	xor	edx, edx
	mov	DWORD PTR [rsi+4], edx

; 852  : 		thole[i] = i;

	mov	DWORD PTR [r8], r9d

; 841  : 		return false;
; 842  : 	}
; 843  : 
; 844  : 	// Generate temp vertex array for triangulation.
; 845  : 	for (int i = 0; i < nhole; ++i)

	inc	r9d
	lea	rsi, QWORD PTR [rsi+16]
	lea	r8, QWORD PTR [r8+4]
	sub	rbx, 1
	jne	SHORT $LL36@removeVert
$LN35@removeVert:

; 341  : 	int ntris = 0;

	mov	DWORD PTR ntris$1$[rsp], edx

; 342  : 	int* dst = tris;

	mov	QWORD PTR dst$1$[rsp], rdi

; 853  : 	}
; 854  : 
; 855  : 	// Triangulate the hole.
; 856  : 	int ntris = triangulate(nhole, &tverts[0], &thole[0], tris);

	mov	edi, edx

; 345  : 	for (int i = 0; i < n; i++)

	mov	ebx, DWORD PTR n$1$[rsp]
	test	ebx, ebx
	jle	$LN1335@removeVert

; 815  : 				--i;

	mov	r13, rdx
	mov	ebp, 1
	npad	12
$LL249@removeVert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	lea	ecx, DWORD PTR [rdi+1]
	mov	DWORD PTR tv8041[rsp], ecx
	lea	rsi, QWORD PTR [r13+1]
	mov	r13, rsi
	cmp	ecx, ebx
	cmovge	rsi, rdx
	lea	eax, DWORD PTR [rcx+1]
	cmovge	eax, ebp
	mov	ebx, edx
	mov	r12d, DWORD PTR n$1$[rsp]
	cmp	eax, r12d
	cmovl	ebx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	QWORD PTR [rsp+32], r14
	mov	r9, r15
	mov	r8d, r12d
	mov	edx, ebx
	mov	ecx, edi
	call	?inCone@@YA_NHHHPEBHPEAH@Z		; inCone
	test	al, al
	je	SHORT $LN247@removeVert
	mov	QWORD PTR [rsp+32], r14
	mov	r9, r15
	mov	r8d, r12d
	mov	edx, ebx
	mov	ecx, edi
	call	?diagonalie@@YA_NHHHPEBHPEAH@Z		; diagonalie
	test	al, al
	je	SHORT $LN247@removeVert

; 350  : 			indices[i1] |= 0x80000000;

	or	DWORD PTR [r14+rsi*4], -2147483648	; ffffffff80000000H
$LN247@removeVert:

; 343  : 	
; 344  : 	// The last bit of the index is used to indicate if the vertex can be removed.
; 345  : 	for (int i = 0; i < n; i++)

	mov	edi, DWORD PTR tv8041[rsp]
	mov	ebx, r12d
	cmp	edi, ebx
	mov	edx, 0
	jl	SHORT $LL249@removeVert
	mov	rbp, QWORD PTR hole$1$[rsp]
	mov	r12, QWORD PTR hreg$1$[rsp]
	mov	r13, QWORD PTR harea$1$[rsp]
$LN1335@removeVert:

; 351  : 	}
; 352  : 	
; 353  : 	while (n > 3)

	cmp	ebx, 3
	jle	$LN1496@removeVert
$LL250@removeVert:

; 354  : 	{
; 355  : 		int minLen = -1;

	mov	DWORD PTR tv8057[rsp], ebx
	mov	r8d, -1

; 356  : 		int mini = -1;

	mov	r11d, r8d

; 354  : 	{
; 355  : 		int minLen = -1;

	mov	rcx, rdx
	mov	r12d, 1
	mov	edi, r12d
	mov	ebp, ebx
	npad	5
$LL254@removeVert:

; 358  : 		{
; 359  : 			int i1 = next(i, n);
; 360  : 			if (indices[i1] & 0x80000000)

	mov	r10d, edi
	lea	rsi, QWORD PTR [rcx+1]
	mov	rax, rsi
	cmp	edi, ebx
	cmovge	rax, rdx
	lea	r9, QWORD PTR [rax*4]
	cmp	DWORD PTR [r14+r9], 0
	jge	SHORT $LN252@removeVert

; 361  : 			{
; 362  : 				const int* p0 = &verts[(indices[i] & 0x0fffffff) * 4];

	mov	eax, DWORD PTR [r14+rcx*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rdx, QWORD PTR [r15+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	lea	ecx, DWORD PTR [rdi+1]
	cmp	edi, ebx
	cmovge	ecx, r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 363  : 				const int* p2 = &verts[(indices[next(i1, n)] & 0x0fffffff) * 4];

	lea	rax, QWORD PTR [r9+4]
	add	rax, r14
	cmp	ecx, ebp
	cmovge	rax, r14
	mov	ecx, DWORD PTR [rax]
	and	ecx, 268435455				; 0fffffffH
	shl	ecx, 2
	mov	eax, ecx

; 364  : 				
; 365  : 				int dx = p2[0] - p0[0];

	mov	ecx, DWORD PTR [r15+rcx*4]
	sub	ecx, DWORD PTR [rdx]

; 366  : 				int dy = p2[2] - p0[2];

	mov	eax, DWORD PTR [r15+rax*4+8]
	sub	eax, DWORD PTR [rdx+8]

; 367  : 				int len = dx*dx + dy*dy;

	imul	eax, eax
	imul	ecx, ecx
	add	eax, ecx

; 368  : 				
; 369  : 				if (minLen < 0 || len < minLen)

	test	r8d, r8d
	js	SHORT $LN264@removeVert
	cmp	eax, r8d
	jge	SHORT $LN1510@removeVert
$LN264@removeVert:

; 370  : 				{
; 371  : 					minLen = len;

	mov	r8d, eax

; 372  : 					mini = i;

	lea	r11d, DWORD PTR [rdi-1]
$LN1510@removeVert:

; 357  : 		for (int i = 0; i < n; i++)

	xor	edx, edx
$LN252@removeVert:
	inc	edi
	mov	rcx, rsi
	cmp	r10d, ebx
	jl	$LL254@removeVert
	mov	rbp, QWORD PTR hole$1$[rsp]
	mov	r12, QWORD PTR hreg$1$[rsp]

; 373  : 				}
; 374  : 			}
; 375  : 		}
; 376  : 		
; 377  : 		if (mini == -1)

	cmp	r11d, -1
	jne	$LN269@removeVert

; 378  : 		{
; 379  : 			// We might get here because the contour has overlapping segments, like this:
; 380  : 			//
; 381  : 			//  A o-o=====o---o B
; 382  : 			//   /  |C   D|    \.
; 383  : 			//  o   o     o     o
; 384  : 			//  :   :     :     :
; 385  : 			// We'll try to recover by loosing up the inCone test a bit so that a diagonal
; 386  : 			// like A-B or C-D can be found and we can continue.
; 387  : 			minLen = -1;

	mov	DWORD PTR minLen$2$[rsp], r11d

; 388  : 			mini = -1;

	mov	DWORD PTR mini$1$[rsp], r11d

; 378  : 		{
; 379  : 			// We might get here because the contour has overlapping segments, like this:
; 380  : 			//
; 381  : 			//  A o-o=====o---o B
; 382  : 			//   /  |C   D|    \.
; 383  : 			//  o   o     o     o
; 384  : 			//  :   :     :     :
; 385  : 			// We'll try to recover by loosing up the inCone test a bit so that a diagonal
; 386  : 			// like A-B or C-D can be found and we can continue.
; 387  : 			minLen = -1;

	mov	esi, edx

; 389  : 			for (int i = 0; i < n; i++)

	cmp	ebx, 0
	jbe	$LN1353@removeVert

; 378  : 		{
; 379  : 			// We might get here because the contour has overlapping segments, like this:
; 380  : 			//
; 381  : 			//  A o-o=====o---o B
; 382  : 			//   /  |C   D|    \.
; 383  : 			//  o   o     o     o
; 384  : 			//  :   :     :     :
; 385  : 			// We'll try to recover by loosing up the inCone test a bit so that a diagonal
; 386  : 			// like A-B or C-D can be found and we can continue.
; 387  : 			minLen = -1;

	mov	ecx, 2
	mov	QWORD PTR tv7739[rsp], rcx
	mov	QWORD PTR tv7738[rsp], r14

; 389  : 			for (int i = 0; i < n; i++)

	lea	r13d, QWORD PTR [r11+2]
	jmp	SHORT $LN257@removeVert
	npad	3
$LL1509@removeVert:
	xor	edx, edx
$LN257@removeVert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	lea	eax, DWORD PTR [rsi+1]
	mov	DWORD PTR tv8062[rsp], eax
	lea	edi, DWORD PTR [rax+1]
	cmp	eax, ebx
	cmovge	edi, r13d
	mov	r8d, DWORD PTR n$1$[rsp]
	cmp	edi, ebx
	jge	SHORT $LN370@removeVert
	mov	rbx, rcx
	cmp	eax, r8d
	cmovge	rbx, r13
	jmp	SHORT $LN371@removeVert
$LN370@removeVert:
	mov	edi, edx
	mov	rbx, rdx
$LN371@removeVert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 335  : 	return inConeLoose(i, j, n, verts, indices) && diagonalieLoose(i, j, n, verts, indices);

	mov	QWORD PTR [rsp+32], r14
	mov	r9, r15
	mov	edx, edi
	mov	ecx, esi
	call	?inConeLoose@@YA_NHHHPEBHPEAH@Z		; inConeLoose
	test	al, al
	je	SHORT $LN1501@removeVert
	mov	QWORD PTR [rsp+32], r14
	mov	r9, r15
	mov	r8d, DWORD PTR n$1$[rsp]
	mov	edx, edi
	mov	ecx, esi
	call	?diagonalieLoose@@YA_NHHHPEBHPEAH@Z	; diagonalieLoose
	test	al, al
	je	SHORT $LN1501@removeVert

; 395  : 					const int* p0 = &verts[(indices[i] & 0x0fffffff) * 4];

	mov	rax, QWORD PTR tv7738[rsp]
	mov	eax, DWORD PTR [rax]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rdx, QWORD PTR [r15+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	lea	eax, DWORD PTR [rdi+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 396  : 					const int* p2 = &verts[(indices[next(i2, n)] & 0x0fffffff) * 4];

	lea	rcx, QWORD PTR [rbx+1]
	mov	ebx, DWORD PTR n$1$[rsp]
	cmp	eax, ebx
	mov	r8d, 0
	cmovge	rcx, r8
	mov	eax, DWORD PTR [r14+rcx*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2

; 397  : 					int dx = p2[0] - p0[0];

	mov	ecx, DWORD PTR [r15+rax*4]
	sub	ecx, DWORD PTR [rdx]

; 398  : 					int dy = p2[2] - p0[2];

	mov	eax, DWORD PTR [r15+rax*4+8]
	sub	eax, DWORD PTR [rdx+8]

; 399  : 					int len = dx*dx + dy*dy;

	imul	eax, eax
	imul	ecx, ecx
	add	eax, ecx

; 400  : 					
; 401  : 					if (minLen < 0 || len < minLen)

	mov	edx, DWORD PTR minLen$2$[rsp]
	test	edx, edx
	js	SHORT $LN268@removeVert
	cmp	eax, edx
	jge	SHORT $LN1502@removeVert
$LN268@removeVert:

; 402  : 					{
; 403  : 						minLen = len;

	mov	DWORD PTR minLen$2$[rsp], eax

; 404  : 						mini = i;

	mov	r11d, esi
	mov	DWORD PTR mini$1$[rsp], esi

; 335  : 	return inConeLoose(i, j, n, verts, indices) && diagonalieLoose(i, j, n, verts, indices);

	jmp	SHORT $LN255@removeVert
$LN1501@removeVert:

; 389  : 			for (int i = 0; i < n; i++)

	mov	ebx, DWORD PTR n$1$[rsp]
$LN1502@removeVert:
	mov	r11d, DWORD PTR mini$1$[rsp]
$LN255@removeVert:
	mov	esi, DWORD PTR tv8062[rsp]
	mov	rcx, QWORD PTR tv7739[rsp]
	inc	rcx
	mov	QWORD PTR tv7739[rsp], rcx
	add	QWORD PTR tv7738[rsp], 4
	cmp	esi, ebx
	jl	$LL1509@removeVert
	mov	r13, QWORD PTR harea$1$[rsp]

; 405  : 					}
; 406  : 				}
; 407  : 			}
; 408  : 			if (mini == -1)

	cmp	r11d, -1
	je	$LN1353@removeVert
$LN269@removeVert:

; 413  : 			}
; 414  : 		}
; 415  : 		
; 416  : 		int i = mini;

	lea	r8d, DWORD PTR [r11+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	cmp	r8d, ebx
	mov	r10d, 0
	cmovge	r8d, r10d
	lea	edx, DWORD PTR [r8+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 420  : 		*dst++ = indices[i] & 0x0fffffff;

	movsxd	rax, r11d
	mov	ecx, DWORD PTR [r14+rax*4]
	and	ecx, 268435455				; 0fffffffH
	mov	rsi, QWORD PTR dst$1$[rsp]
	mov	DWORD PTR [rsi], ecx

; 421  : 		*dst++ = indices[i1] & 0x0fffffff;

	movsxd	r9, r8d
	lea	rdi, QWORD PTR [r14+r9*4]
	mov	eax, DWORD PTR [rdi]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR [rsi+4], eax

; 420  : 		*dst++ = indices[i] & 0x0fffffff;

	cmp	edx, ebx
	cmovge	edx, r10d

; 422  : 		*dst++ = indices[i2] & 0x0fffffff;

	movsxd	rax, edx
	mov	ecx, DWORD PTR [r14+rax*4]
	and	ecx, 268435455				; 0fffffffH
	mov	DWORD PTR [rsi+8], ecx
	add	rsi, 12
	mov	QWORD PTR dst$1$[rsp], rsi

; 423  : 		ntris++;

	inc	DWORD PTR ntris$1$[rsp]

; 424  : 		
; 425  : 		// Removes P[i1] by copying P[i+1]...P[n-1] left one index.
; 426  : 		n--;

	dec	ebx
	mov	DWORD PTR n$1$[rsp], ebx

; 427  : 		for (int k = i1; k < n; k++)

	mov	eax, DWORD PTR tv8057[rsp]
	dec	rax
	mov	QWORD PTR $T7[rsp], rax
	cmp	r9, rax
	jge	SHORT $LN1393@removeVert

; 815  : 				--i;

	lea	rsi, QWORD PTR [rdi+4]
	mov	rcx, rax
	sub	rcx, r9
	rep movsd
$LN1393@removeVert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 467  : inline int prev(int i, int n) { return i-1 >= 0 ? i-1 : n-1; }

	mov	esi, r10d
	cmp	r8d, ebx
	cmovl	esi, r8d
	mov	DWORD PTR tv7676[rsp], esi
	mov	ecx, esi
	test	esi, esi
	cmovle	ecx, ebx
	dec	ecx
	mov	DWORD PTR tv7662[rsp], ecx
	lea	eax, DWORD PTR [rcx-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	mov	edi, ecx
	test	eax, eax
	cmovs	edi, ebx
	lea	ecx, DWORD PTR [rdi-1]
	mov	QWORD PTR [rsp+32], r14
	mov	r9, r15
	mov	r8d, ebx
	mov	edx, esi
	call	?inCone@@YA_NHHHPEBHPEAH@Z		; inCone
	test	al, al
	je	$LN286@removeVert

; 245  : 	const int* d0 = &verts[(indices[i] & 0x0fffffff) * 4];

	movsxd	rdi, edi
	dec	rdi
	mov	QWORD PTR tv7646[rsp], rdi
	mov	eax, DWORD PTR [r14+rdi*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	r10, QWORD PTR [r15+rax*4]
	mov	QWORD PTR d0$1$[rsp], r10

; 246  : 	const int* d1 = &verts[(indices[j] & 0x0fffffff) * 4];

	movsxd	rsi, esi
	mov	QWORD PTR tv7789[rsp], rsi
	mov	eax, DWORD PTR [r14+rsi*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rbx, QWORD PTR [r15+rax*4]

; 247  : 	
; 248  : 	// For each edge (k,k+1) of P
; 249  : 	for (int k = 0; k < n; k++)

	xor	r8d, r8d
	mov	eax, r8d
	mov	edx, DWORD PTR n$1$[rsp]
	test	edx, edx
	jle	$LN290@removeVert

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	r11d, 1
	mov	DWORD PTR tv7734[rsp], r11d
	npad	9
$LL291@removeVert:

; 253  : 		if (!((k == i) || (k1 == i) || (k == j) || (k1 == j)))

	lea	rcx, QWORD PTR [rax+1]
	mov	QWORD PTR tv7683[rsp], rcx
	cmp	r11d, edx
	cmovge	rcx, r8
	cmp	rax, rdi
	je	$LN289@removeVert
	cmp	rcx, rdi
	je	$LN289@removeVert
	cmp	rax, rsi
	je	$LN289@removeVert
	cmp	rcx, rsi
	je	$LN289@removeVert

; 254  : 		{
; 255  : 			const int* p0 = &verts[(indices[k] & 0x0fffffff) * 4];

	mov	eax, DWORD PTR [r14+rax*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rsi, QWORD PTR [r15+rax*4]

; 256  : 			const int* p1 = &verts[(indices[k1] & 0x0fffffff) * 4];

	mov	eax, DWORD PTR [r14+rcx*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rdi, QWORD PTR [r15+rax*4]

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	r9d, DWORD PTR [r10]
	mov	edx, DWORD PTR [rsi]
	cmp	r9d, edx
	jne	SHORT $LN1478@removeVert
	mov	eax, DWORD PTR [rsi+8]
	cmp	DWORD PTR [r10+8], eax
	je	$LN1513@removeVert
$LN1478@removeVert:
	mov	r8d, DWORD PTR [rbx]
	cmp	r8d, edx
	jne	SHORT $LN1492@removeVert
	mov	eax, DWORD PTR [rsi+8]
	cmp	DWORD PTR [rbx+8], eax
	je	$LN1505@removeVert
$LN1492@removeVert:
	mov	ecx, DWORD PTR [rdi]
	cmp	r9d, ecx
	jne	SHORT $LN1431@removeVert
	mov	eax, DWORD PTR [rdi+8]
	cmp	DWORD PTR [r10+8], eax
	je	$LN1505@removeVert
$LN1431@removeVert:
	cmp	r8d, ecx
	jne	SHORT $LN1490@removeVert
	mov	eax, DWORD PTR [rdi+8]
	cmp	DWORD PTR [rbx+8], eax
	je	SHORT $LN1505@removeVert
$LN1490@removeVert:

; 226  : 	if (intersectProp(a, b, c, d))

	mov	r9, rdi
	mov	r8, rsi
	mov	rdx, rbx
	mov	rcx, r10
	call	?intersectProp@@YA_NPEBH000@Z		; intersectProp
	test	al, al
	jne	$LN286@removeVert

; 227  : 		return true;
; 228  : 
; 229  : 	if (between(a, b, c) || between(a, b, d) ||
; 230  : 		between(c, d, a) || between(c, d, b))

	mov	r8, rsi
	mov	rdx, rbx
	mov	rcx, QWORD PTR d0$1$[rsp]
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	$LN286@removeVert
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR d0$1$[rsp]
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN286@removeVert
	mov	r8, QWORD PTR d0$1$[rsp]
	mov	rdx, rdi
	mov	rcx, rsi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN286@removeVert
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN286@removeVert
	mov	r10, QWORD PTR d0$1$[rsp]

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	r11d, DWORD PTR tv7734[rsp]
$LN1505@removeVert:

; 249  : 	for (int k = 0; k < n; k++)

	xor	r8d, r8d
$LN1513@removeVert:
	mov	edx, DWORD PTR n$1$[rsp]
	mov	rdi, QWORD PTR tv7646[rsp]
	mov	rsi, QWORD PTR tv7789[rsp]
$LN289@removeVert:
	inc	r11d
	mov	DWORD PTR tv7734[rsp], r11d
	mov	rax, QWORD PTR tv7683[rsp]
	cmp	rax, QWORD PTR $T7[rsp]
	jl	$LL291@removeVert
$LN290@removeVert:

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	movsxd	rcx, DWORD PTR tv7662[rsp]
	lea	rax, QWORD PTR [r14+rcx*4]

; 434  : 			indices[i] |= 0x80000000;

	mov	edi, DWORD PTR [rax]
	or	edi, -2147483648			; ffffffff80000000H
	jmp	SHORT $LN1514@removeVert
$LN286@removeVert:

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	movsxd	rcx, DWORD PTR tv7662[rsp]
	lea	rax, QWORD PTR [r14+rcx*4]

; 436  : 			indices[i] &= 0x0fffffff;

	mov	edi, DWORD PTR [rax]
	and	edi, 268435455				; 0fffffffH
$LN1514@removeVert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	mov	rsi, rcx
	mov	DWORD PTR [rax], edi
	mov	ebx, DWORD PTR tv7676[rsp]
	inc	ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	cmp	ebx, DWORD PTR n$1$[rsp]
	mov	r8d, 0
	cmovge	ebx, r8d
	mov	QWORD PTR [rsp+32], r14
	mov	r9, r15
	mov	r8d, DWORD PTR n$1$[rsp]
	mov	edx, ebx
	call	?inCone@@YA_NHHHPEBHPEAH@Z		; inCone
	test	al, al
	je	$LN328@removeVert

; 245  : 	const int* d0 = &verts[(indices[i] & 0x0fffffff) * 4];

	and	edi, 268435455				; 0fffffffH
	shl	edi, 2
	lea	r8, QWORD PTR [r15+rdi*4]
	mov	QWORD PTR d0$1$[rsp], r8

; 246  : 	const int* d1 = &verts[(indices[j] & 0x0fffffff) * 4];

	movsxd	r11, ebx
	mov	QWORD PTR tv7781[rsp], r11
	mov	eax, DWORD PTR [r14+r11*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	r10, QWORD PTR [r15+rax*4]
	mov	QWORD PTR d1$1$[rsp], r10

; 247  : 	
; 248  : 	// For each edge (k,k+1) of P
; 249  : 	for (int k = 0; k < n; k++)

	xor	ebx, ebx
	mov	eax, ebx
	mov	edx, DWORD PTR n$1$[rsp]
	test	edx, edx
	jle	$LN332@removeVert

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	ecx, 1
	mov	edi, ecx
	mov	DWORD PTR tv7732[rsp], ecx
	npad	9
$LL333@removeVert:

; 253  : 		if (!((k == i) || (k1 == i) || (k == j) || (k1 == j)))

	lea	rcx, QWORD PTR [rax+1]
	mov	QWORD PTR tv7678[rsp], rcx
	cmp	edi, edx
	cmovge	rcx, rbx
	cmp	rax, rsi
	je	$LN331@removeVert
	cmp	rcx, rsi
	je	$LN331@removeVert
	cmp	rax, r11
	je	$LN331@removeVert
	cmp	rcx, r11
	je	$LN331@removeVert

; 254  : 		{
; 255  : 			const int* p0 = &verts[(indices[k] & 0x0fffffff) * 4];

	mov	eax, DWORD PTR [r14+rax*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rbx, QWORD PTR [r15+rax*4]

; 256  : 			const int* p1 = &verts[(indices[k1] & 0x0fffffff) * 4];

	mov	eax, DWORD PTR [r14+rcx*4]
	and	eax, 268435455				; 0fffffffH
	shl	eax, 2
	lea	rdi, QWORD PTR [r15+rax*4]

; 238  : 	return a[0] == b[0] && a[2] == b[2];

	mov	edx, DWORD PTR [rbx]
	mov	r11d, DWORD PTR [r8]
	cmp	r11d, edx
	jne	SHORT $LN1481@removeVert
	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [r8+8], eax
	je	$LN1515@removeVert
$LN1481@removeVert:
	mov	r8d, DWORD PTR [r10]
	cmp	r8d, edx
	jne	SHORT $LN1487@removeVert
	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [r10+8], eax
	je	$LN1516@removeVert
$LN1487@removeVert:
	mov	ecx, DWORD PTR [rdi]
	cmp	r11d, ecx
	mov	r11, QWORD PTR d0$1$[rsp]
	jne	SHORT $LN1434@removeVert
	mov	eax, DWORD PTR [rdi+8]
	cmp	DWORD PTR [r11+8], eax
	jne	SHORT $LN1434@removeVert
	mov	r8, r11
	jmp	$LN1515@removeVert
$LN1434@removeVert:
	cmp	r8d, ecx
	jne	SHORT $LN1485@removeVert
	mov	eax, DWORD PTR [rdi+8]
	cmp	DWORD PTR [r10+8], eax
	je	SHORT $LN1516@removeVert
$LN1485@removeVert:

; 226  : 	if (intersectProp(a, b, c, d))

	mov	r9, rdi
	mov	r8, rbx
	mov	rdx, r10
	mov	rcx, r11
	call	?intersectProp@@YA_NPEBH000@Z		; intersectProp
	test	al, al
	jne	$LN328@removeVert

; 227  : 		return true;
; 228  : 
; 229  : 	if (between(a, b, c) || between(a, b, d) ||
; 230  : 		between(c, d, a) || between(c, d, b))

	mov	r8, rbx
	mov	rdx, QWORD PTR d1$1$[rsp]
	mov	rcx, QWORD PTR d0$1$[rsp]
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	$LN328@removeVert
	mov	r8, rdi
	mov	rdx, QWORD PTR d1$1$[rsp]
	mov	rcx, QWORD PTR d0$1$[rsp]
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN328@removeVert
	mov	r8, QWORD PTR d0$1$[rsp]
	mov	rdx, rdi
	mov	rcx, rbx
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN328@removeVert
	mov	r8, QWORD PTR d1$1$[rsp]
	mov	rdx, rdi
	mov	rcx, rbx
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN328@removeVert
	mov	r10, QWORD PTR d1$1$[rsp]
$LN1516@removeVert:

; 249  : 	for (int k = 0; k < n; k++)

	mov	r8, QWORD PTR d0$1$[rsp]
$LN1515@removeVert:
	mov	edx, DWORD PTR n$1$[rsp]
	mov	r11, QWORD PTR tv7781[rsp]
	xor	ebx, ebx
$LN331@removeVert:
	inc	DWORD PTR tv7732[rsp]
	mov	rax, QWORD PTR tv7678[rsp]
	cmp	rax, QWORD PTR $T7[rsp]
	mov	edi, DWORD PTR tv7732[rsp]
	jl	$LL333@removeVert
$LN332@removeVert:

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	movsxd	rax, DWORD PTR tv7676[rsp]
	lea	rcx, QWORD PTR [r14+rax*4]

; 439  : 			indices[i1] |= 0x80000000;

	mov	eax, DWORD PTR [rcx]
	or	eax, -2147483648			; ffffffff80000000H
	jmp	SHORT $LN274@removeVert
$LN328@removeVert:

; 289  : 	return inCone(i, j, n, verts, indices) && diagonalie(i, j, n, verts, indices);

	movsxd	rax, DWORD PTR tv7676[rsp]
	lea	rcx, QWORD PTR [r14+rax*4]

; 441  : 			indices[i1] &= 0x0fffffff;

	mov	eax, DWORD PTR [rcx]
	and	eax, 268435455				; 0fffffffH
$LN274@removeVert:

; 351  : 	}
; 352  : 	
; 353  : 	while (n > 3)

	mov	DWORD PTR [rcx], eax
	mov	ebx, DWORD PTR n$1$[rsp]
	cmp	ebx, 3
	jle	SHORT $LN1496@removeVert
	xor	edx, edx
	jmp	$LL250@removeVert
$LN1353@removeVert:

; 409  : 			{
; 410  : 				// The contour is messed up. This sometimes happens
; 411  : 				// if the contour simplification is too aggressive.
; 412  : 				return -ntris;

	mov	ebx, DWORD PTR ntris$1$[rsp]
	neg	ebx
	jmp	SHORT $LN1517@removeVert
$LN1496@removeVert:

; 442  : 	}
; 443  : 	
; 444  : 	// Append the remaining triangle.
; 445  : 	*dst++ = indices[0] & 0x0fffffff;

	mov	eax, DWORD PTR [r14]
	and	eax, 268435455				; 0fffffffH
	mov	rcx, QWORD PTR dst$1$[rsp]
	mov	DWORD PTR [rcx], eax

; 446  : 	*dst++ = indices[1] & 0x0fffffff;

	mov	eax, DWORD PTR [r14+4]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR [rcx+4], eax

; 447  : 	*dst++ = indices[2] & 0x0fffffff;

	mov	eax, DWORD PTR [r14+8]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR [rcx+8], eax

; 448  : 	ntris++;

	mov	ebx, DWORD PTR ntris$1$[rsp]
	inc	ebx
$LN1517@removeVert:

; 857  : 	if (ntris < 0)

	mov	DWORD PTR ntris$1$[rsp], ebx
	test	ebx, ebx
	jns	SHORT $LN76@removeVert

; 858  : 	{
; 859  : 		ntris = -ntris;

	neg	ebx
	mov	DWORD PTR ntris$1$[rsp], ebx

; 860  : 		ctx->log(RC_LOG_WARNING, "removeVertex: triangulate() returned bad results.");

	lea	r8, OFFSET FLAT:??_C@_0DC@OAIHHLAF@removeVertex?3?5triangulate?$CI?$CJ?5ret@
	mov	edx, 2
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
$LN76@removeVert:

; 861  : 	}
; 862  : 	
; 863  : 	// Merge the hole triangles back to polygons.
; 864  : 	rcScopedDelete<unsigned short> polys((unsigned short*)rcAlloc(sizeof(unsigned short)*(ntris+1)*nvp, RC_ALLOC_TEMP));

	lea	esi, DWORD PTR [rbx+1]
	movsxd	rcx, ebx
	inc	rcx
	imul	rcx, QWORD PTR $T11[rsp]
	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR polys$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 865  : 	if (!polys)

	test	rax, rax
	jne	SHORT $LN77@removeVert

; 866  : 	{
; 867  : 		ctx->log(RC_LOG_ERROR, "removeVertex: Out of memory 'polys' (%d).", (ntris+1)*nvp);

	imul	esi, DWORD PTR nvp$1$[rsp]
	mov	r9d, esi
	lea	r8, OFFSET FLAT:??_C@_0CK@MOOJLFPF@removeVertex?3?5Out?5of?5memory?5?8po@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	al, al
	mov	BYTE PTR $T1[rsp], al
	jmp	$LN198@removeVert
$LN77@removeVert:

; 868  : 		return false;
; 869  : 	}
; 870  : 	rcScopedDelete<unsigned short> pregs((unsigned short*)rcAlloc(sizeof(unsigned short)*ntris, RC_ALLOC_TEMP));

	movsxd	rbx, ebx
	mov	QWORD PTR $T10[rsp], rbx
	lea	rcx, QWORD PTR [rbx+rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
	mov	QWORD PTR pregs$1$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR pregs$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 871  : 	if (!pregs)

	test	rax, rax
	jne	SHORT $LN78@removeVert

; 872  : 	{
; 873  : 		ctx->log(RC_LOG_ERROR, "removeVertex: Out of memory 'pregs' (%d).", ntris);

	mov	r9d, DWORD PTR ntris$1$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0CK@BOHENGDJ@removeVertex?3?5Out?5of?5memory?5?8pr@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	al, al
	mov	BYTE PTR $T1[rsp], al
	jmp	$LN208@removeVert
$LN78@removeVert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	rbx, rax
	mov	QWORD PTR pareas$1$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR pareas$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 877  : 	if (!pareas)

	test	rax, rax
	jne	SHORT $LN79@removeVert

; 878  : 	{
; 879  : 		ctx->log(RC_LOG_ERROR, "removeVertex: Out of memory 'pareas' (%d).", ntris);

	mov	r9d, DWORD PTR ntris$1$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0CL@PNMOHAMH@removeVertex?3?5Out?5of?5memory?5?8pa@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	al, al
	mov	BYTE PTR $T1[rsp], al
	jmp	$LN116@removeVert
$LN79@removeVert:

; 880  : 		return false;
; 881  : 	}
; 882  : 	
; 883  : 	unsigned short* tmpPoly = &polys[ntris*nvp];

	mov	eax, DWORD PTR ntris$1$[rsp]
	imul	eax, DWORD PTR nvp$1$[rsp]
	cdqe
	lea	r8, QWORD PTR [rax+rax]
	lea	rax, QWORD PTR [rdi+r8]
	mov	QWORD PTR tmpPoly$1$[rsp], rax

; 884  : 			
; 885  : 	// Build initial polygons.
; 886  : 	int npolys = 0;
; 887  : 	memset(polys, 0xff, ntris*nvp*sizeof(unsigned short));

	mov	edx, 255				; 000000ffH
	mov	rcx, rdi
	call	memset

; 888  : 	for (int j = 0; j < ntris; ++j)

	mov	r11, QWORD PTR $T10[rsp]
	test	r11, r11
	jle	$LN1471@removeVert

; 815  : 				--i;

	xor	edx, edx
	mov	r9d, edx
	mov	DWORD PTR tv7729[rsp], edx
	mov	r10d, edx
	mov	rax, QWORD PTR tris$1$[rsp]
	mov	r15d, edx
	mov	r14d, DWORD PTR nvp$1$[rsp]
	npad	5
$LL39@removeVert:

; 889  : 	{
; 890  : 		int* t = &tris[j*3];
; 891  : 		if (t[0] != t[1] && t[0] != t[2] && t[1] != t[2])

	mov	r8d, DWORD PTR [r10+rax+4]
	movsxd	rcx, DWORD PTR [r10+rax]
	cmp	ecx, r8d
	je	$LN37@removeVert
	mov	edx, DWORD PTR [r10+rax+8]
	cmp	ecx, edx
	je	$LN1508@removeVert
	cmp	r8d, edx
	je	$LN1508@removeVert

; 892  : 		{
; 893  : 			polys[npolys*nvp+0] = (unsigned short)hole[t[0]];

	movzx	edx, WORD PTR [rbp+rcx*4]
	movsxd	r8, DWORD PTR tv7729[rsp]
	mov	WORD PTR [rdi+r8*2], dx

; 894  : 			polys[npolys*nvp+1] = (unsigned short)hole[t[1]];

	movsxd	rcx, DWORD PTR [r10+rax+4]
	movzx	ecx, WORD PTR [rbp+rcx*4]
	mov	WORD PTR [rdi+r8*2+2], cx

; 895  : 			polys[npolys*nvp+2] = (unsigned short)hole[t[2]];

	movsxd	rcx, DWORD PTR [r10+rax+8]
	movzx	ecx, WORD PTR [rbp+rcx*4]
	mov	WORD PTR [rdi+r8*2+4], cx

; 896  : 
; 897  : 			// If this polygon covers multiple region types then
; 898  : 			// mark it as such
; 899  : 			if (hreg[t[0]] != hreg[t[1]] || hreg[t[1]] != hreg[t[2]])

	movsxd	rdx, DWORD PTR [r10+rax]
	movsxd	rcx, DWORD PTR [r10+rax+4]
	mov	ecx, DWORD PTR [r12+rcx*4]
	mov	DWORD PTR tv7808[rsp], ecx
	mov	r8d, DWORD PTR [r12+rdx*4]
	cmp	r8d, ecx
	jne	SHORT $LN83@removeVert
	movsxd	rcx, DWORD PTR [r10+rax+8]
	mov	edx, DWORD PTR tv7808[rsp]
	cmp	edx, DWORD PTR [r12+rcx*4]
	jne	SHORT $LN83@removeVert

; 901  : 			else
; 902  : 				pregs[npolys] = (unsigned short)hreg[t[0]];

	xor	edx, edx
	jmp	SHORT $LN82@removeVert
$LN83@removeVert:

; 900  : 				pregs[npolys] = RC_MULTIPLE_REGS;

	xor	edx, edx
	movzx	r8d, dx
$LN82@removeVert:

; 903  : 
; 904  : 			pareas[npolys] = (unsigned char)harea[t[0]];

	mov	WORD PTR [rsi+r9*2], r8w
	movsxd	rcx, DWORD PTR [r10+rax]
	movzx	ecx, BYTE PTR [r13+rcx*4]
	mov	BYTE PTR [rbx+r9], cl

; 905  : 			npolys++;

	inc	r15d
	add	DWORD PTR tv7729[rsp], r14d
	inc	r9

; 889  : 	{
; 890  : 		int* t = &tris[j*3];
; 891  : 		if (t[0] != t[1] && t[0] != t[2] && t[1] != t[2])

	jmp	SHORT $LN37@removeVert
$LN1508@removeVert:

; 888  : 	for (int j = 0; j < ntris; ++j)

	xor	edx, edx
$LN37@removeVert:
	add	r10, 12
	sub	r11, 1
	jne	$LL39@removeVert
	mov	DWORD PTR npolys$1$[rsp], r15d

; 906  : 		}
; 907  : 	}
; 908  : 	if (!npolys)

	test	r15d, r15d
	mov	r14, QWORD PTR thole$1$[rsp]
	mov	r15, QWORD PTR tverts$1$[rsp]
	je	$LN1471@removeVert

; 909  : 		return true;
; 910  : 	
; 911  : 	// Merge polygons.
; 912  : 	if (nvp > 3)

	mov	ecx, DWORD PTR nvp$1$[rsp]
	cmp	ecx, 3
	jle	$LN87@removeVert
	movsxd	rax, DWORD PTR npolys$1$[rsp]
	mov	r12, rax
	lea	r15d, DWORD PTR [rax-1]
	dec	rax
	add	rax, rbx
	mov	QWORD PTR tv7717[rsp], rax
	mov	eax, r15d
	imul	eax, ecx
	mov	DWORD PTR tv7645[rsp], eax
	lea	rax, QWORD PTR [r12-1]
	lea	rax, QWORD PTR [rsi+rax*2]
	mov	QWORD PTR tv7715[rsp], rax
$LN1518@removeVert:

; 913  : 	{
; 914  : 		for (;;)
; 915  : 		{
; 916  : 			// Find best polygons to merge.
; 917  : 			int bestMergeVal = 0;

	mov	DWORD PTR tv7718[rsp], r15d
	mov	QWORD PTR $T8[rsp], r12
	mov	r14d, edx

; 918  : 			int bestPa = 0, bestPb = 0, bestEa = 0, bestEb = 0;

	mov	r8d, edx
	mov	DWORD PTR bestPa$1$[rsp], edx
	mov	QWORD PTR $T13[rsp], rdx
	mov	QWORD PTR $T3[rsp], rdx
	mov	r11d, edx
	mov	DWORD PTR bestEa$1$[rsp], edx
	mov	r9d, edx
	mov	DWORD PTR bestEb$1$[rsp], edx

; 913  : 	{
; 914  : 		for (;;)
; 915  : 		{
; 916  : 			// Find best polygons to merge.
; 917  : 			int bestMergeVal = 0;

	mov	ecx, edx
	mov	DWORD PTR j$1$[rsp], edx

; 919  : 			
; 920  : 			for (int j = 0; j < npolys-1; ++j)

	test	r15d, r15d
	jle	$LN1498@removeVert

; 913  : 	{
; 914  : 		for (;;)
; 915  : 		{
; 916  : 			// Find best polygons to merge.
; 917  : 			int bestMergeVal = 0;

	mov	eax, 1
	mov	QWORD PTR tv7722[rsp], rax
	mov	rdx, QWORD PTR $T11[rsp]
	add	rdx, rdx
	mov	QWORD PTR tv7668[rsp], rdx
	mov	r10, rdi
	mov	QWORD PTR tv7720[rsp], rdi
	mov	ebx, ecx
	mov	rsi, QWORD PTR $T3[rsp]
$LL45@removeVert:

; 921  : 			{
; 922  : 				unsigned short* pj = &polys[j*nvp];

	inc	ecx
	mov	DWORD PTR tv7670[rsp], ecx
	mov	r15d, ecx
	mov	rbp, rax

; 923  : 				for (int k = j+1; k < npolys; ++k)

	cmp	rax, r12
	jge	$LN43@removeVert
	mov	r12, QWORD PTR tv7722[rsp]
	mov	r13d, DWORD PTR j$1$[rsp]
	npad	11
$LL48@removeVert:

; 924  : 				{
; 925  : 					unsigned short* pk = &polys[k*nvp];

	mov	DWORD PTR tv7849[rsp], r14d
	mov	DWORD PTR tv7850[rsp], r14d
	mov	eax, r15d
	mov	ecx, DWORD PTR nvp$1$[rsp]
	imul	eax, ecx
	cdqe
	lea	rdx, QWORD PTR [rdi+rax*2]

; 926  : 					int ea, eb;
; 927  : 					int v = getPolyMergeValue(pj, pk, mesh.verts, ea, eb, nvp);

	mov	DWORD PTR [rsp+40], ecx
	lea	rax, QWORD PTR eb$5[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR ea$9[rsp]
	mov	rax, QWORD PTR mesh$GSCopy$1$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rcx, r10
	call	?getPolyMergeValue@@YAHPEAG0PEBGAEAH2H@Z ; getPolyMergeValue
	mov	edx, eax

; 928  : 					if (v > bestMergeVal)

	cmp	eax, r14d
	jle	SHORT $LN1503@removeVert

; 929  : 					{
; 930  : 						bestMergeVal = v;

	mov	r14d, eax

; 931  : 						bestPa = j;

	mov	r8d, r13d
	mov	DWORD PTR bestPa$1$[rsp], r13d
	lea	r9, QWORD PTR [r12-1]
	mov	QWORD PTR $T13[rsp], r9

; 932  : 						bestPb = k;
; 933  : 						bestEa = ea;

	mov	r11d, DWORD PTR ea$9[rsp]
	mov	DWORD PTR bestEa$1$[rsp], r11d

; 934  : 						bestEb = eb;

	mov	r9d, DWORD PTR eb$5[rsp]
	mov	DWORD PTR bestEb$1$[rsp], r9d

; 928  : 					if (v > bestMergeVal)

	jmp	SHORT $LN46@removeVert
$LN1503@removeVert:
	mov	r8d, DWORD PTR bestPa$1$[rsp]
	mov	r11d, DWORD PTR bestEa$1$[rsp]
	mov	r9d, DWORD PTR bestEb$1$[rsp]
$LN46@removeVert:

; 923  : 				for (int k = j+1; k < npolys; ++k)

	mov	rcx, rbp
	cmp	edx, DWORD PTR tv7849[rsp]
	cmovle	rcx, rsi
	mov	rsi, rcx
	mov	eax, r15d
	cmp	edx, DWORD PTR tv7850[rsp]
	cmovle	eax, ebx
	mov	ebx, eax
	inc	r15d
	inc	rbp
	cmp	rbp, QWORD PTR $T8[rsp]
	mov	r10, QWORD PTR tv7720[rsp]
	jl	$LL48@removeVert
	mov	rax, r12
	mov	r12, QWORD PTR $T8[rsp]
	mov	ecx, DWORD PTR tv7670[rsp]
	mov	rdx, QWORD PTR tv7668[rsp]
$LN43@removeVert:

; 919  : 			
; 920  : 			for (int j = 0; j < npolys-1; ++j)

	mov	DWORD PTR j$1$[rsp], ecx
	add	r10, rdx
	mov	QWORD PTR tv7720[rsp], r10
	inc	rax
	mov	QWORD PTR tv7722[rsp], rax
	mov	r15d, DWORD PTR tv7718[rsp]
	cmp	ecx, r15d
	jl	$LL45@removeVert
	mov	QWORD PTR $T3[rsp], rsi
	mov	DWORD PTR bestPb$1$[rsp], ebx
	mov	rsi, QWORD PTR pregs$1$[rsp]
	mov	rbx, QWORD PTR pareas$1$[rsp]

; 935  : 					}
; 936  : 				}
; 937  : 			}
; 938  : 			
; 939  : 			if (bestMergeVal > 0)

	test	r14d, r14d
	jle	$LN1506@removeVert

; 943  : 				unsigned short* pb = &polys[bestPb*nvp];

	mov	eax, DWORD PTR bestPb$1$[rsp]
	mov	edx, DWORD PTR nvp$1$[rsp]
	imul	eax, edx
	cdqe
	lea	r14, QWORD PTR [rdi+rax*2]

; 940  : 			{
; 941  : 				// Found best, merge.
; 942  : 				unsigned short* pa = &polys[bestPa*nvp];

	imul	r8d, edx
	movsxd	rax, r8d
	lea	rcx, QWORD PTR [rdi+rax*2]

; 944  : 				mergePolyVerts(pa, pb, bestEa, bestEb, tmpPoly, nvp);

	mov	DWORD PTR [rsp+40], edx
	mov	rax, QWORD PTR tmpPoly$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r8d, r11d
	mov	rdx, r14
	call	?mergePolyVerts@@YAXPEAG0HH0H@Z		; mergePolyVerts

; 945  : 				if (pregs[bestPa] != pregs[bestPb])

	mov	rbp, QWORD PTR $T3[rsp]
	movzx	eax, WORD PTR [rsi+rbp*2]
	mov	rcx, QWORD PTR $T13[rsp]
	cmp	WORD PTR [rsi+rcx*2], ax
	je	SHORT $LN89@removeVert

; 946  : 					pregs[bestPa] = RC_MULTIPLE_REGS;

	xor	eax, eax
	mov	WORD PTR [rsi+rcx*2], ax
$LN89@removeVert:

; 947  : 
; 948  : 				unsigned short* last = &polys[(npolys-1)*nvp];

	movsxd	r13, DWORD PTR tv7645[rsp]
	lea	rdx, QWORD PTR [rdi+r13*2]

; 949  : 				if (pb != last)

	cmp	r14, rdx
	je	SHORT $LN90@removeVert

; 950  : 					memcpy(pb, last, sizeof(unsigned short)*nvp);

	mov	r8, QWORD PTR tv7668[rsp]
	mov	rcx, r14
	call	memcpy
$LN90@removeVert:

; 951  : 				pregs[bestPb] = pregs[npolys-1];

	mov	r10, QWORD PTR tv7715[rsp]
	movzx	eax, WORD PTR [r10]
	mov	WORD PTR [rsi+rbp*2], ax

; 952  : 				pareas[bestPb] = pareas[npolys-1];

	mov	rdx, QWORD PTR tv7717[rsp]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rbx+rbp], al

; 953  : 				npolys--;

	dec	DWORD PTR npolys$1$[rsp]
	sub	r13d, DWORD PTR nvp$1$[rsp]
	mov	DWORD PTR tv7645[rsp], r13d
	dec	r15d
	dec	r12
	sub	r10, 2
	mov	QWORD PTR tv7715[rsp], r10
	dec	rdx
	mov	QWORD PTR tv7717[rsp], rdx

; 954  : 			}
; 955  : 			else
; 956  : 			{
; 957  : 				// Could not merge any polygons, stop.
; 958  : 				break;
; 959  : 			}
; 960  : 		}

	xor	edx, edx
	jmp	$LN1518@removeVert
$LN1506@removeVert:

; 935  : 					}
; 936  : 				}
; 937  : 			}
; 938  : 			
; 939  : 			if (bestMergeVal > 0)

	xor	edx, edx
$LN1498@removeVert:
	mov	r14, QWORD PTR thole$1$[rsp]
	mov	r15, QWORD PTR tverts$1$[rsp]
	mov	rbp, QWORD PTR hole$1$[rsp]
	mov	r12, QWORD PTR hreg$1$[rsp]
	mov	r13, QWORD PTR harea$1$[rsp]
	mov	ecx, DWORD PTR nvp$1$[rsp]
$LN87@removeVert:

; 961  : 	}
; 962  : 	
; 963  : 	// Store polygons.
; 964  : 	for (int i = 0; i < npolys; ++i)

	movsxd	rax, DWORD PTR npolys$1$[rsp]
	test	rax, rax
	jle	$LN1471@removeVert

; 815  : 				--i;

	mov	DWORD PTR tv7711[rsp], edx
	mov	r11, QWORD PTR mesh$GSCopy$1$[rsp]
	npad	1
$LL51@removeVert:

; 965  : 	{
; 966  : 		if (mesh.npolys >= maxTris) break;

	mov	eax, DWORD PTR [r11+44]
	cmp	eax, DWORD PTR maxTris$GSCopy$1$[rsp]
	jge	$LN1471@removeVert

; 967  : 		unsigned short* p = &mesh.polys[mesh.npolys*nvp*2];

	imul	eax, ecx
	add	eax, eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r11+8]
	lea	rcx, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR p$1$[rsp], rcx

; 968  : 		memset(p,0xff,sizeof(unsigned short)*nvp*2);

	mov	rax, QWORD PTR $T11[rsp]
	lea	r8, QWORD PTR [rax*4]
	mov	edx, 255				; 000000ffH
	call	memset

; 969  : 		for (int j = 0; j < nvp; ++j)

	mov	rdx, QWORD PTR $T11[rsp]
	test	rdx, rdx
	jle	SHORT $LN1499@removeVert

; 970  : 			p[j] = polys[i*nvp+j];

	movsxd	r10, DWORD PTR tv7711[rsp]
	lea	r8, QWORD PTR [r10+r10]
	mov	rcx, QWORD PTR p$1$[rsp]
	sub	r8, rcx
	add	r8, rdi
	npad	9
$LL1395@removeVert:
	movzx	eax, WORD PTR [r8+rcx]
	mov	WORD PTR [rcx], ax

; 969  : 		for (int j = 0; j < nvp; ++j)

	lea	rcx, QWORD PTR [rcx+2]
	sub	rdx, 1
	jne	SHORT $LL1395@removeVert
	jmp	SHORT $LN53@removeVert
$LN1499@removeVert:
	mov	r10d, DWORD PTR tv7711[rsp]
$LN53@removeVert:

; 971  : 		mesh.regs[mesh.npolys] = pregs[i];

	mov	r8, QWORD PTR $T14[rsp]
	movzx	edx, WORD PTR [rsi+r8*2]
	mov	r11, QWORD PTR mesh$GSCopy$1$[rsp]
	movsxd	rcx, DWORD PTR [r11+44]
	mov	rax, QWORD PTR [r11+16]
	mov	WORD PTR [rax+rcx*2], dx

; 972  : 		mesh.areas[mesh.npolys] = pareas[i];

	movzx	edx, BYTE PTR [rbx+r8]
	movsxd	rcx, DWORD PTR [r11+44]
	mov	rax, QWORD PTR [r11+32]
	mov	BYTE PTR [rcx+rax], dl

; 973  : 		mesh.npolys++;

	mov	r9d, DWORD PTR [r11+44]
	inc	r9d
	mov	DWORD PTR [r11+44], r9d

; 974  : 		if (mesh.npolys > maxTris)

	mov	eax, DWORD PTR maxTris$GSCopy$1$[rsp]
	cmp	r9d, eax
	jg	$LN1355@removeVert

; 961  : 	}
; 962  : 	
; 963  : 	// Store polygons.
; 964  : 	for (int i = 0; i < npolys; ++i)

	add	r10d, DWORD PTR nvp$1$[rsp]
	mov	DWORD PTR tv7711[rsp], r10d
	inc	r8
	mov	QWORD PTR $T14[rsp], r8
	movsxd	rcx, DWORD PTR npolys$1$[rsp]
	cmp	r8, rcx
	mov	ecx, DWORD PTR nvp$1$[rsp]
	jl	$LL51@removeVert
$LN1471@removeVert:

; 978  : 		}
; 979  : 	}
; 980  : 	
; 981  : 	return true;

	mov	BYTE PTR $T1[rsp], 1
$LN116@removeVert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rbx, rbx
	je	SHORT $LN213@removeVert

; 28   : 	free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
	npad	1
$LN213@removeVert:
$LN208@removeVert:

; 47   : 	if (ptr != NULL)

	test	rsi, rsi
	je	SHORT $LN203@removeVert

; 28   : 	free(ptr);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
	npad	1
$LN203@removeVert:
$LN198@removeVert:

; 47   : 	if (ptr != NULL)

	test	rdi, rdi
	je	SHORT $LN193@removeVert

; 28   : 	free(ptr);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
	npad	1
$LN193@removeVert:
	mov	rdi, QWORD PTR tris$1$[rsp]
$LN188@removeVert:

; 47   : 	if (ptr != NULL)

	test	r14, r14
	je	SHORT $LN183@removeVert

; 28   : 	free(ptr);

	mov	rcx, r14
	call	QWORD PTR __imp_free
	npad	1
$LN183@removeVert:
$LN178@removeVert:

; 47   : 	if (ptr != NULL)

	test	r15, r15
	je	SHORT $LN173@removeVert

; 28   : 	free(ptr);

	mov	rcx, r15
	call	QWORD PTR __imp_free
	npad	1
$LN173@removeVert:
$LN168@removeVert:

; 47   : 	if (ptr != NULL)

	test	rdi, rdi
	je	SHORT $LN163@removeVert

; 28   : 	free(ptr);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
	npad	1
$LN163@removeVert:
	mov	rdi, QWORD PTR edges$1$[rsp]
$LN158@removeVert:

; 47   : 	if (ptr != NULL)

	test	r13, r13
	je	SHORT $LN153@removeVert

; 28   : 	free(ptr);

	mov	rcx, r13
	call	QWORD PTR __imp_free
	npad	1
$LN153@removeVert:
	movzx	esi, BYTE PTR $T1[rsp]
$LN148@removeVert:

; 47   : 	if (ptr != NULL)

	test	r12, r12
	je	SHORT $LN143@removeVert

; 28   : 	free(ptr);

	mov	rcx, r12
	call	QWORD PTR __imp_free
	npad	1
$LN143@removeVert:
$LN138@removeVert:

; 47   : 	if (ptr != NULL)

	test	rbp, rbp
	je	SHORT $LN133@removeVert

; 28   : 	free(ptr);

	mov	rcx, rbp
	call	QWORD PTR __imp_free
	npad	1
$LN133@removeVert:
$LN128@removeVert:

; 47   : 	if (ptr != NULL)

	test	rdi, rdi
	je	SHORT $LN1497@removeVert

; 28   : 	free(ptr);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
	npad	1
$LN1497@removeVert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastMesh.cpp

; 982  : }

	movzx	eax, sil
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 408				; 00000198H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN1355@removeVert:

; 975  : 		{
; 976  : 			ctx->log(RC_LOG_ERROR, "removeVertex: Too many polygons %d (max:%d).", mesh.npolys, maxTris);

	mov	DWORD PTR [rsp+32], eax
	lea	r8, OFFSET FLAT:??_C@_0CN@GJNOFLAJ@removeVertex?3?5Too?5many?5polygons@
	mov	edx, 3
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log

; 977  : 			return false;

	xor	al, al
	mov	BYTE PTR $T1[rsp], al
	jmp	$LN116@removeVert
	int	3
?removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z ENDP ; removeVertex
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
n$1$ = 52
bestEb$1$ = 52
bestPb$1$ = 56
a$1$ = 56
i$1$ = 56
tv8057 = 56
tv7850 = 56
tv7732 = 56
tv7729 = 56
tv7711 = 56
tv7662 = 56
npolys$1$ = 60
ntris$1$ = 60
tv7767 = 60
mini$1$ = 64
bestEa$1$ = 64
tv7676 = 64
nedges$1$ = 64
$T2 = 72
$T3 = 72
d0$1$ = 72
tv7738 = 72
tv7670 = 72
tv7646 = 72
nvp$1$ = 80
tv8062 = 84
tv8041 = 84
tv7808 = 84
tv7765 = 84
tv7718 = 84
minLen$2$ = 88
bestPa$1$ = 88
tv7734 = 88
$T4 = 96
tv7789 = 96
tv7781 = 96
eb$5 = 96
$T6 = 104
$T7 = 104
$T8 = 104
tv7747 = 104
tv7739 = 104
d1$1$ = 112
d0$1$ = 112
ea$9 = 112
ctx$GSCopy$1$ = 120
j$1$ = 128
tv7849 = 128
dst$1$ = 136
tv7766 = 136
tv7645 = 136
$T10 = 144
tv7717 = 144
tv7683 = 144
tv7678 = 144
$T11 = 152
mesh$GSCopy$1$ = 160
harea$1$ = 168
$T12 = 176
tv7722 = 176
maxTris$GSCopy$1$ = 184
hreg$1$ = 192
hole$1$ = 200
tris$1$ = 208
tv8063 = 208
tv7720 = 216
p$1$ = 224
tmpPoly$1$ = 224
$T13 = 232
tv7668 = 240
tv7715 = 248
thole$1$ = 256
tverts$1$ = 264
$T14 = 272
edges$1$ = 280
pregs$1$ = 288
pareas$1$ = 296
edges$ = 304
hole$ = 312
hreg$ = 320
harea$ = 328
tris$ = 336
tverts$ = 344
thole$ = 352
polys$ = 360
pregs$ = 368
pareas$ = 376
__$ArrayPad$ = 384
ctx$ = 480
mesh$ = 488
rem$ = 496
maxTris$ = 504
?dtor$0@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA PROC ; `removeVertex'::`1'::dtor$0
	lea	rcx, QWORD PTR edges$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$0@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA ENDP ; `removeVertex'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
n$1$ = 52
bestEb$1$ = 52
bestPb$1$ = 56
a$1$ = 56
i$1$ = 56
tv8057 = 56
tv7850 = 56
tv7732 = 56
tv7729 = 56
tv7711 = 56
tv7662 = 56
npolys$1$ = 60
ntris$1$ = 60
tv7767 = 60
mini$1$ = 64
bestEa$1$ = 64
tv7676 = 64
nedges$1$ = 64
$T2 = 72
$T3 = 72
d0$1$ = 72
tv7738 = 72
tv7670 = 72
tv7646 = 72
nvp$1$ = 80
tv8062 = 84
tv8041 = 84
tv7808 = 84
tv7765 = 84
tv7718 = 84
minLen$2$ = 88
bestPa$1$ = 88
tv7734 = 88
$T4 = 96
tv7789 = 96
tv7781 = 96
eb$5 = 96
$T6 = 104
$T7 = 104
$T8 = 104
tv7747 = 104
tv7739 = 104
d1$1$ = 112
d0$1$ = 112
ea$9 = 112
ctx$GSCopy$1$ = 120
j$1$ = 128
tv7849 = 128
dst$1$ = 136
tv7766 = 136
tv7645 = 136
$T10 = 144
tv7717 = 144
tv7683 = 144
tv7678 = 144
$T11 = 152
mesh$GSCopy$1$ = 160
harea$1$ = 168
$T12 = 176
tv7722 = 176
maxTris$GSCopy$1$ = 184
hreg$1$ = 192
hole$1$ = 200
tris$1$ = 208
tv8063 = 208
tv7720 = 216
p$1$ = 224
tmpPoly$1$ = 224
$T13 = 232
tv7668 = 240
tv7715 = 248
thole$1$ = 256
tverts$1$ = 264
$T14 = 272
edges$1$ = 280
pregs$1$ = 288
pareas$1$ = 296
edges$ = 304
hole$ = 312
hreg$ = 320
harea$ = 328
tris$ = 336
tverts$ = 344
thole$ = 352
polys$ = 360
pregs$ = 368
pareas$ = 376
__$ArrayPad$ = 384
ctx$ = 480
mesh$ = 488
rem$ = 496
maxTris$ = 504
?dtor$1@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA PROC ; `removeVertex'::`1'::dtor$1
	lea	rcx, QWORD PTR hole$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$1@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA ENDP ; `removeVertex'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
n$1$ = 52
bestEb$1$ = 52
bestPb$1$ = 56
a$1$ = 56
i$1$ = 56
tv8057 = 56
tv7850 = 56
tv7732 = 56
tv7729 = 56
tv7711 = 56
tv7662 = 56
npolys$1$ = 60
ntris$1$ = 60
tv7767 = 60
mini$1$ = 64
bestEa$1$ = 64
tv7676 = 64
nedges$1$ = 64
$T2 = 72
$T3 = 72
d0$1$ = 72
tv7738 = 72
tv7670 = 72
tv7646 = 72
nvp$1$ = 80
tv8062 = 84
tv8041 = 84
tv7808 = 84
tv7765 = 84
tv7718 = 84
minLen$2$ = 88
bestPa$1$ = 88
tv7734 = 88
$T4 = 96
tv7789 = 96
tv7781 = 96
eb$5 = 96
$T6 = 104
$T7 = 104
$T8 = 104
tv7747 = 104
tv7739 = 104
d1$1$ = 112
d0$1$ = 112
ea$9 = 112
ctx$GSCopy$1$ = 120
j$1$ = 128
tv7849 = 128
dst$1$ = 136
tv7766 = 136
tv7645 = 136
$T10 = 144
tv7717 = 144
tv7683 = 144
tv7678 = 144
$T11 = 152
mesh$GSCopy$1$ = 160
harea$1$ = 168
$T12 = 176
tv7722 = 176
maxTris$GSCopy$1$ = 184
hreg$1$ = 192
hole$1$ = 200
tris$1$ = 208
tv8063 = 208
tv7720 = 216
p$1$ = 224
tmpPoly$1$ = 224
$T13 = 232
tv7668 = 240
tv7715 = 248
thole$1$ = 256
tverts$1$ = 264
$T14 = 272
edges$1$ = 280
pregs$1$ = 288
pareas$1$ = 296
edges$ = 304
hole$ = 312
hreg$ = 320
harea$ = 328
tris$ = 336
tverts$ = 344
thole$ = 352
polys$ = 360
pregs$ = 368
pareas$ = 376
__$ArrayPad$ = 384
ctx$ = 480
mesh$ = 488
rem$ = 496
maxTris$ = 504
?dtor$2@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA PROC ; `removeVertex'::`1'::dtor$2
	lea	rcx, QWORD PTR hreg$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$2@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA ENDP ; `removeVertex'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
n$1$ = 52
bestEb$1$ = 52
bestPb$1$ = 56
a$1$ = 56
i$1$ = 56
tv8057 = 56
tv7850 = 56
tv7732 = 56
tv7729 = 56
tv7711 = 56
tv7662 = 56
npolys$1$ = 60
ntris$1$ = 60
tv7767 = 60
mini$1$ = 64
bestEa$1$ = 64
tv7676 = 64
nedges$1$ = 64
$T2 = 72
$T3 = 72
d0$1$ = 72
tv7738 = 72
tv7670 = 72
tv7646 = 72
nvp$1$ = 80
tv8062 = 84
tv8041 = 84
tv7808 = 84
tv7765 = 84
tv7718 = 84
minLen$2$ = 88
bestPa$1$ = 88
tv7734 = 88
$T4 = 96
tv7789 = 96
tv7781 = 96
eb$5 = 96
$T6 = 104
$T7 = 104
$T8 = 104
tv7747 = 104
tv7739 = 104
d1$1$ = 112
d0$1$ = 112
ea$9 = 112
ctx$GSCopy$1$ = 120
j$1$ = 128
tv7849 = 128
dst$1$ = 136
tv7766 = 136
tv7645 = 136
$T10 = 144
tv7717 = 144
tv7683 = 144
tv7678 = 144
$T11 = 152
mesh$GSCopy$1$ = 160
harea$1$ = 168
$T12 = 176
tv7722 = 176
maxTris$GSCopy$1$ = 184
hreg$1$ = 192
hole$1$ = 200
tris$1$ = 208
tv8063 = 208
tv7720 = 216
p$1$ = 224
tmpPoly$1$ = 224
$T13 = 232
tv7668 = 240
tv7715 = 248
thole$1$ = 256
tverts$1$ = 264
$T14 = 272
edges$1$ = 280
pregs$1$ = 288
pareas$1$ = 296
edges$ = 304
hole$ = 312
hreg$ = 320
harea$ = 328
tris$ = 336
tverts$ = 344
thole$ = 352
polys$ = 360
pregs$ = 368
pareas$ = 376
__$ArrayPad$ = 384
ctx$ = 480
mesh$ = 488
rem$ = 496
maxTris$ = 504
?dtor$3@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA PROC ; `removeVertex'::`1'::dtor$3
	lea	rcx, QWORD PTR harea$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$3@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA ENDP ; `removeVertex'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
n$1$ = 52
bestEb$1$ = 52
bestPb$1$ = 56
a$1$ = 56
i$1$ = 56
tv8057 = 56
tv7850 = 56
tv7732 = 56
tv7729 = 56
tv7711 = 56
tv7662 = 56
npolys$1$ = 60
ntris$1$ = 60
tv7767 = 60
mini$1$ = 64
bestEa$1$ = 64
tv7676 = 64
nedges$1$ = 64
$T2 = 72
$T3 = 72
d0$1$ = 72
tv7738 = 72
tv7670 = 72
tv7646 = 72
nvp$1$ = 80
tv8062 = 84
tv8041 = 84
tv7808 = 84
tv7765 = 84
tv7718 = 84
minLen$2$ = 88
bestPa$1$ = 88
tv7734 = 88
$T4 = 96
tv7789 = 96
tv7781 = 96
eb$5 = 96
$T6 = 104
$T7 = 104
$T8 = 104
tv7747 = 104
tv7739 = 104
d1$1$ = 112
d0$1$ = 112
ea$9 = 112
ctx$GSCopy$1$ = 120
j$1$ = 128
tv7849 = 128
dst$1$ = 136
tv7766 = 136
tv7645 = 136
$T10 = 144
tv7717 = 144
tv7683 = 144
tv7678 = 144
$T11 = 152
mesh$GSCopy$1$ = 160
harea$1$ = 168
$T12 = 176
tv7722 = 176
maxTris$GSCopy$1$ = 184
hreg$1$ = 192
hole$1$ = 200
tris$1$ = 208
tv8063 = 208
tv7720 = 216
p$1$ = 224
tmpPoly$1$ = 224
$T13 = 232
tv7668 = 240
tv7715 = 248
thole$1$ = 256
tverts$1$ = 264
$T14 = 272
edges$1$ = 280
pregs$1$ = 288
pareas$1$ = 296
edges$ = 304
hole$ = 312
hreg$ = 320
harea$ = 328
tris$ = 336
tverts$ = 344
thole$ = 352
polys$ = 360
pregs$ = 368
pareas$ = 376
__$ArrayPad$ = 384
ctx$ = 480
mesh$ = 488
rem$ = 496
maxTris$ = 504
?dtor$4@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA PROC ; `removeVertex'::`1'::dtor$4
	lea	rcx, QWORD PTR tris$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$4@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA ENDP ; `removeVertex'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
n$1$ = 52
bestEb$1$ = 52
bestPb$1$ = 56
a$1$ = 56
i$1$ = 56
tv8057 = 56
tv7850 = 56
tv7732 = 56
tv7729 = 56
tv7711 = 56
tv7662 = 56
npolys$1$ = 60
ntris$1$ = 60
tv7767 = 60
mini$1$ = 64
bestEa$1$ = 64
tv7676 = 64
nedges$1$ = 64
$T2 = 72
$T3 = 72
d0$1$ = 72
tv7738 = 72
tv7670 = 72
tv7646 = 72
nvp$1$ = 80
tv8062 = 84
tv8041 = 84
tv7808 = 84
tv7765 = 84
tv7718 = 84
minLen$2$ = 88
bestPa$1$ = 88
tv7734 = 88
$T4 = 96
tv7789 = 96
tv7781 = 96
eb$5 = 96
$T6 = 104
$T7 = 104
$T8 = 104
tv7747 = 104
tv7739 = 104
d1$1$ = 112
d0$1$ = 112
ea$9 = 112
ctx$GSCopy$1$ = 120
j$1$ = 128
tv7849 = 128
dst$1$ = 136
tv7766 = 136
tv7645 = 136
$T10 = 144
tv7717 = 144
tv7683 = 144
tv7678 = 144
$T11 = 152
mesh$GSCopy$1$ = 160
harea$1$ = 168
$T12 = 176
tv7722 = 176
maxTris$GSCopy$1$ = 184
hreg$1$ = 192
hole$1$ = 200
tris$1$ = 208
tv8063 = 208
tv7720 = 216
p$1$ = 224
tmpPoly$1$ = 224
$T13 = 232
tv7668 = 240
tv7715 = 248
thole$1$ = 256
tverts$1$ = 264
$T14 = 272
edges$1$ = 280
pregs$1$ = 288
pareas$1$ = 296
edges$ = 304
hole$ = 312
hreg$ = 320
harea$ = 328
tris$ = 336
tverts$ = 344
thole$ = 352
polys$ = 360
pregs$ = 368
pareas$ = 376
__$ArrayPad$ = 384
ctx$ = 480
mesh$ = 488
rem$ = 496
maxTris$ = 504
?dtor$5@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA PROC ; `removeVertex'::`1'::dtor$5
	lea	rcx, QWORD PTR tverts$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$5@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA ENDP ; `removeVertex'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
n$1$ = 52
bestEb$1$ = 52
bestPb$1$ = 56
a$1$ = 56
i$1$ = 56
tv8057 = 56
tv7850 = 56
tv7732 = 56
tv7729 = 56
tv7711 = 56
tv7662 = 56
npolys$1$ = 60
ntris$1$ = 60
tv7767 = 60
mini$1$ = 64
bestEa$1$ = 64
tv7676 = 64
nedges$1$ = 64
$T2 = 72
$T3 = 72
d0$1$ = 72
tv7738 = 72
tv7670 = 72
tv7646 = 72
nvp$1$ = 80
tv8062 = 84
tv8041 = 84
tv7808 = 84
tv7765 = 84
tv7718 = 84
minLen$2$ = 88
bestPa$1$ = 88
tv7734 = 88
$T4 = 96
tv7789 = 96
tv7781 = 96
eb$5 = 96
$T6 = 104
$T7 = 104
$T8 = 104
tv7747 = 104
tv7739 = 104
d1$1$ = 112
d0$1$ = 112
ea$9 = 112
ctx$GSCopy$1$ = 120
j$1$ = 128
tv7849 = 128
dst$1$ = 136
tv7766 = 136
tv7645 = 136
$T10 = 144
tv7717 = 144
tv7683 = 144
tv7678 = 144
$T11 = 152
mesh$GSCopy$1$ = 160
harea$1$ = 168
$T12 = 176
tv7722 = 176
maxTris$GSCopy$1$ = 184
hreg$1$ = 192
hole$1$ = 200
tris$1$ = 208
tv8063 = 208
tv7720 = 216
p$1$ = 224
tmpPoly$1$ = 224
$T13 = 232
tv7668 = 240
tv7715 = 248
thole$1$ = 256
tverts$1$ = 264
$T14 = 272
edges$1$ = 280
pregs$1$ = 288
pareas$1$ = 296
edges$ = 304
hole$ = 312
hreg$ = 320
harea$ = 328
tris$ = 336
tverts$ = 344
thole$ = 352
polys$ = 360
pregs$ = 368
pareas$ = 376
__$ArrayPad$ = 384
ctx$ = 480
mesh$ = 488
rem$ = 496
maxTris$ = 504
?dtor$6@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA PROC ; `removeVertex'::`1'::dtor$6
	lea	rcx, QWORD PTR thole$[rdx]
	jmp	??1?$rcScopedDelete@H@@QEAA@XZ		; rcScopedDelete<int>::~rcScopedDelete<int>
?dtor$6@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA ENDP ; `removeVertex'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
n$1$ = 52
bestEb$1$ = 52
bestPb$1$ = 56
a$1$ = 56
i$1$ = 56
tv8057 = 56
tv7850 = 56
tv7732 = 56
tv7729 = 56
tv7711 = 56
tv7662 = 56
npolys$1$ = 60
ntris$1$ = 60
tv7767 = 60
mini$1$ = 64
bestEa$1$ = 64
tv7676 = 64
nedges$1$ = 64
$T2 = 72
$T3 = 72
d0$1$ = 72
tv7738 = 72
tv7670 = 72
tv7646 = 72
nvp$1$ = 80
tv8062 = 84
tv8041 = 84
tv7808 = 84
tv7765 = 84
tv7718 = 84
minLen$2$ = 88
bestPa$1$ = 88
tv7734 = 88
$T4 = 96
tv7789 = 96
tv7781 = 96
eb$5 = 96
$T6 = 104
$T7 = 104
$T8 = 104
tv7747 = 104
tv7739 = 104
d1$1$ = 112
d0$1$ = 112
ea$9 = 112
ctx$GSCopy$1$ = 120
j$1$ = 128
tv7849 = 128
dst$1$ = 136
tv7766 = 136
tv7645 = 136
$T10 = 144
tv7717 = 144
tv7683 = 144
tv7678 = 144
$T11 = 152
mesh$GSCopy$1$ = 160
harea$1$ = 168
$T12 = 176
tv7722 = 176
maxTris$GSCopy$1$ = 184
hreg$1$ = 192
hole$1$ = 200
tris$1$ = 208
tv8063 = 208
tv7720 = 216
p$1$ = 224
tmpPoly$1$ = 224
$T13 = 232
tv7668 = 240
tv7715 = 248
thole$1$ = 256
tverts$1$ = 264
$T14 = 272
edges$1$ = 280
pregs$1$ = 288
pareas$1$ = 296
edges$ = 304
hole$ = 312
hreg$ = 320
harea$ = 328
tris$ = 336
tverts$ = 344
thole$ = 352
polys$ = 360
pregs$ = 368
pareas$ = 376
__$ArrayPad$ = 384
ctx$ = 480
mesh$ = 488
rem$ = 496
maxTris$ = 504
?dtor$7@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA PROC ; `removeVertex'::`1'::dtor$7
	lea	rcx, QWORD PTR polys$[rdx]
	jmp	??1?$rcScopedDelete@G@@QEAA@XZ		; rcScopedDelete<unsigned short>::~rcScopedDelete<unsigned short>
?dtor$7@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA ENDP ; `removeVertex'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
n$1$ = 52
bestEb$1$ = 52
bestPb$1$ = 56
a$1$ = 56
i$1$ = 56
tv8057 = 56
tv7850 = 56
tv7732 = 56
tv7729 = 56
tv7711 = 56
tv7662 = 56
npolys$1$ = 60
ntris$1$ = 60
tv7767 = 60
mini$1$ = 64
bestEa$1$ = 64
tv7676 = 64
nedges$1$ = 64
$T2 = 72
$T3 = 72
d0$1$ = 72
tv7738 = 72
tv7670 = 72
tv7646 = 72
nvp$1$ = 80
tv8062 = 84
tv8041 = 84
tv7808 = 84
tv7765 = 84
tv7718 = 84
minLen$2$ = 88
bestPa$1$ = 88
tv7734 = 88
$T4 = 96
tv7789 = 96
tv7781 = 96
eb$5 = 96
$T6 = 104
$T7 = 104
$T8 = 104
tv7747 = 104
tv7739 = 104
d1$1$ = 112
d0$1$ = 112
ea$9 = 112
ctx$GSCopy$1$ = 120
j$1$ = 128
tv7849 = 128
dst$1$ = 136
tv7766 = 136
tv7645 = 136
$T10 = 144
tv7717 = 144
tv7683 = 144
tv7678 = 144
$T11 = 152
mesh$GSCopy$1$ = 160
harea$1$ = 168
$T12 = 176
tv7722 = 176
maxTris$GSCopy$1$ = 184
hreg$1$ = 192
hole$1$ = 200
tris$1$ = 208
tv8063 = 208
tv7720 = 216
p$1$ = 224
tmpPoly$1$ = 224
$T13 = 232
tv7668 = 240
tv7715 = 248
thole$1$ = 256
tverts$1$ = 264
$T14 = 272
edges$1$ = 280
pregs$1$ = 288
pareas$1$ = 296
edges$ = 304
hole$ = 312
hreg$ = 320
harea$ = 328
tris$ = 336
tverts$ = 344
thole$ = 352
polys$ = 360
pregs$ = 368
pareas$ = 376
__$ArrayPad$ = 384
ctx$ = 480
mesh$ = 488
rem$ = 496
maxTris$ = 504
?dtor$8@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA PROC ; `removeVertex'::`1'::dtor$8
	lea	rcx, QWORD PTR pregs$[rdx]
	jmp	??1?$rcScopedDelete@G@@QEAA@XZ		; rcScopedDelete<unsigned short>::~rcScopedDelete<unsigned short>
?dtor$8@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA ENDP ; `removeVertex'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
n$1$ = 52
bestEb$1$ = 52
bestPb$1$ = 56
a$1$ = 56
i$1$ = 56
tv8057 = 56
tv7850 = 56
tv7732 = 56
tv7729 = 56
tv7711 = 56
tv7662 = 56
npolys$1$ = 60
ntris$1$ = 60
tv7767 = 60
mini$1$ = 64
bestEa$1$ = 64
tv7676 = 64
nedges$1$ = 64
$T2 = 72
$T3 = 72
d0$1$ = 72
tv7738 = 72
tv7670 = 72
tv7646 = 72
nvp$1$ = 80
tv8062 = 84
tv8041 = 84
tv7808 = 84
tv7765 = 84
tv7718 = 84
minLen$2$ = 88
bestPa$1$ = 88
tv7734 = 88
$T4 = 96
tv7789 = 96
tv7781 = 96
eb$5 = 96
$T6 = 104
$T7 = 104
$T8 = 104
tv7747 = 104
tv7739 = 104
d1$1$ = 112
d0$1$ = 112
ea$9 = 112
ctx$GSCopy$1$ = 120
j$1$ = 128
tv7849 = 128
dst$1$ = 136
tv7766 = 136
tv7645 = 136
$T10 = 144
tv7717 = 144
tv7683 = 144
tv7678 = 144
$T11 = 152
mesh$GSCopy$1$ = 160
harea$1$ = 168
$T12 = 176
tv7722 = 176
maxTris$GSCopy$1$ = 184
hreg$1$ = 192
hole$1$ = 200
tris$1$ = 208
tv8063 = 208
tv7720 = 216
p$1$ = 224
tmpPoly$1$ = 224
$T13 = 232
tv7668 = 240
tv7715 = 248
thole$1$ = 256
tverts$1$ = 264
$T14 = 272
edges$1$ = 280
pregs$1$ = 288
pareas$1$ = 296
edges$ = 304
hole$ = 312
hreg$ = 320
harea$ = 328
tris$ = 336
tverts$ = 344
thole$ = 352
polys$ = 360
pregs$ = 368
pareas$ = 376
__$ArrayPad$ = 384
ctx$ = 480
mesh$ = 488
rem$ = 496
maxTris$ = 504
?dtor$9@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA PROC ; `removeVertex'::`1'::dtor$9
	lea	rcx, QWORD PTR pareas$[rdx]
	jmp	??1?$rcScopedDelete@E@@QEAA@XZ		; rcScopedDelete<unsigned char>::~rcScopedDelete<unsigned char>
?dtor$9@?0??removeVertex@@YA_NPEAVrcContext@@AEAUrcPolyMesh@@GH@Z@4HA ENDP ; `removeVertex'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$rcScopedDelete@G@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$rcScopedDelete@G@@QEAAX_K@Z PROC	; rcScopedDelete<unsigned short>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$rcScopedDelete@G@@QEAAX_K@Z ENDP	; rcScopedDelete<unsigned short>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??B?$rcScopedDelete@G@@QEAAPEAGXZ
_TEXT	SEGMENT
this$ = 8
??B?$rcScopedDelete@G@@QEAAPEAGXZ PROC			; rcScopedDelete<unsigned short>::operator unsigned short *, COMDAT

; 364  : 	inline operator T*() { return ptr; }

	mov	rax, QWORD PTR [rcx]
	ret	0
??B?$rcScopedDelete@G@@QEAAPEAGXZ ENDP			; rcScopedDelete<unsigned short>::operator unsigned short *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??1?$rcScopedDelete@G@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$rcScopedDelete@G@@QEAA@XZ PROC			; rcScopedDelete<unsigned short>::~rcScopedDelete<unsigned short>, COMDAT

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

$LN12:
	mov	rcx, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN6@rcScopedDe

; 28   : 	free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN6@rcScopedDe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

	ret	0
??1?$rcScopedDelete@G@@QEAA@XZ ENDP			; rcScopedDelete<unsigned short>::~rcScopedDelete<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcScopedDelete@G@@QEAA@PEAG@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
??0?$rcScopedDelete@G@@QEAA@PEAG@Z PROC			; rcScopedDelete<unsigned short>::rcScopedDelete<unsigned short>, COMDAT

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$rcScopedDelete@G@@QEAA@PEAG@Z ENDP			; rcScopedDelete<unsigned short>::rcScopedDelete<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??B?$rcScopedDelete@H@@QEAAPEAHXZ
_TEXT	SEGMENT
this$ = 8
??B?$rcScopedDelete@H@@QEAAPEAHXZ PROC			; rcScopedDelete<int>::operator int *, COMDAT

; 364  : 	inline operator T*() { return ptr; }

	mov	rax, QWORD PTR [rcx]
	ret	0
??B?$rcScopedDelete@H@@QEAAPEAHXZ ENDP			; rcScopedDelete<int>::operator int *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??1?$rcScopedDelete@H@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$rcScopedDelete@H@@QEAA@XZ PROC			; rcScopedDelete<int>::~rcScopedDelete<int>, COMDAT

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

$LN12:
	mov	rcx, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN6@rcScopedDe

; 28   : 	free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN6@rcScopedDe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

	ret	0
??1?$rcScopedDelete@H@@QEAA@XZ ENDP			; rcScopedDelete<int>::~rcScopedDelete<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcScopedDelete@H@@QEAA@PEAH@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
??0?$rcScopedDelete@H@@QEAA@PEAH@Z PROC			; rcScopedDelete<int>::rcScopedDelete<int>, COMDAT

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$rcScopedDelete@H@@QEAA@PEAH@Z ENDP			; rcScopedDelete<int>::rcScopedDelete<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
;	COMDAT ??$rcSwap@G@@YAXAEAG0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$rcSwap@G@@YAXAEAG0@Z PROC				; rcSwap<unsigned short>, COMDAT

; 652  : template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }

	movzx	r8d, WORD PTR [rcx]
	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax
	mov	WORD PTR [rdx], r8w
	ret	0
??$rcSwap@G@@YAXAEAG0@Z ENDP				; rcSwap<unsigned short>
_TEXT	ENDS
END
