; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@GPMKFGFF@EXBDecoder@			; `string'
PUBLIC	??_C@_0BG@LJAGCNKK@Can?5not?5find?5string?5?$CC@ ; `string'
PUBLIC	??_C@_0CA@FGDDDNGP@Wrong?5magic?0?5expected?5magic?5EXB@ ; `string'
PUBLIC	??_C@_03OAGGBFIJ@LHS@				; `string'
PUBLIC	??_C@_03FAKADFCF@RHS@				; `string'
PUBLIC	??_C@_0BN@BNNPNAJP@Wrong?5version?0?5expected?50x02@ ; `string'
PUBLIC	??_C@_04EBONIFJK@EXB?5@				; `string'
PUBLIC	??_C@_0BE@MABBHOKL@MapEditor_EXB_NoVal@		; `string'
EXTRN	__std_find_trivial_4:PROC
;	COMDAT ??_C@_0BE@MABBHOKL@MapEditor_EXB_NoVal@
CONST	SEGMENT
??_C@_0BE@MABBHOKL@MapEditor_EXB_NoVal@ DB 'MapEditor_EXB_NoVal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBONIFJK@EXB?5@
CONST	SEGMENT
??_C@_04EBONIFJK@EXB?5@ DB 'EXB ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BNNPNAJP@Wrong?5version?0?5expected?50x02@
CONST	SEGMENT
??_C@_0BN@BNNPNAJP@Wrong?5version?0?5expected?50x02@ DB 'Wrong version, e'
	DB	'xpected 0x02', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03FAKADFCF@RHS@
CONST	SEGMENT
??_C@_03FAKADFCF@RHS@ DB 'RHS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OAGGBFIJ@LHS@
CONST	SEGMENT
??_C@_03OAGGBFIJ@LHS@ DB 'LHS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FGDDDNGP@Wrong?5magic?0?5expected?5magic?5EXB@
CONST	SEGMENT
??_C@_0CA@FGDDDNGP@Wrong?5magic?0?5expected?5magic?5EXB@ DB 'Wrong magic,'
	DB	' expected magic EXB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LJAGCNKK@Can?5not?5find?5string?5?$CC@
CONST	SEGMENT
??_C@_0BG@LJAGCNKK@Can?5not?5find?5string?5?$CC@ DB 'Can not find string '
	DB	'"', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GPMKFGFF@EXBDecoder@
CONST	SEGMENT
??_C@_0L@GPMKFGFF@EXBDecoder@ DB 'EXBDecoder', 00H	; `string'
PUBLIC	??$?R$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$03@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$03@1@@Z ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&,4>
PUBLIC	??$?R$$QEAVVector3F@@$02@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAVVector3F@@$02@1@@Z ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<Vector3F &&,3>
PUBLIC	??$?R$$QEAM$01@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAM$01@1@@Z ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<float &&,2>
PUBLIC	??$?R$$QEAI$00@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAI$00@1@@Z ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<unsigned int &&,1>
PUBLIC	??$?R$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$0?0@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$0?0@1@@Z ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &&,-1>
PUBLIC	??$?R$$QEA_N$0A@@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEA_N$0A@@1@@Z ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<bool &&,0>
PUBLIC	??$_Visit@U?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@?$_Variant_raw_visit1@$01@std@@SAX_K$$QEAU?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Variant_raw_visit1<2>::_Visit<std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Variant_raw_visit@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAX_K$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Variant_raw_visit<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$move@AEAV?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ; std::move<std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	??$?0VVector3F@@@?$_Variant_storage_@$0A@VVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAVVector3F@@@Z ; std::_Variant_storage_<0,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Vector3F>
PUBLIC	??$?0$00I$0A@@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ; std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
PUBLIC	?_Get@?$_Variant_storage_@$0A@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Variant_storage_<0,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get
PUBLIC	?_Get@?$_Variant_storage_@$0A@VVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAVVector3F@@XZ ; std::_Variant_storage_<0,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get
PUBLIC	?_Get@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAMXZ ; std::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get
PUBLIC	?_Get@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAIXZ ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get
PUBLIC	?_Get@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEA_NXZ ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get
PUBLIC	?_Storage@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Storage
PUBLIC	??$_Variant_raw_get@$03V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Variant_raw_get<4,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Variant_raw_get@$02V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Variant_raw_get<3,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Variant_raw_get@$01V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Variant_raw_get<2,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Variant_raw_get@$00V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Variant_raw_get<1,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Variant_raw_get@$0A@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Variant_raw_get<0,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Construct_from@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAX$$QEAV12@@Z ; std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Construct_from
PUBLIC	??0?$_Non_trivial_copy@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ; std::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$_Non_trivial_move@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z ; std::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$_Non_trivial_copy_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z ; std::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$_Non_trivial_move_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z ; std::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0InstructionStruct@EXB@@QEAA@$$QEAU01@@Z	; EXB::InstructionStruct::InstructionStruct
PUBLIC	??$construct_at@UInstructionStruct@EXB@@U12@$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@$$QEAU12@@Z ; std::construct_at<EXB::InstructionStruct,EXB::InstructionStruct,0>
PUBLIC	??$?0$00VVector3F@@$0A@@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAVVector3F@@@Z ; std::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,Vector3F,0>
PUBLIC	??$?0M@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAM@Z ; std::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><float>
PUBLIC	??$?0$00I$0A@@?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ; std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
PUBLIC	??$construct_at@UInstructionStruct@EXB@@$$V$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@@Z ; std::construct_at<EXB::InstructionStruct,0>
PUBLIC	??$construct@UInstructionStruct@EXB@@U12@@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<EXB::InstructionStruct> >::construct<EXB::InstructionStruct,EXB::InstructionStruct>
PUBLIC	??$forward@UInstructionStruct@EXB@@@std@@YA$$QEAUInstructionStruct@EXB@@AEAU12@@Z ; std::forward<EXB::InstructionStruct>
PUBLIC	??$?0AEAG@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@AEAG@Z ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned short &>
PUBLIC	??$?0$01VVector3F@@$0A@@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$01@1@$$QEAVVector3F@@@Z ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><2,Vector3F,0>
PUBLIC	??$?0$00M$0A@@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAM@Z ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,float,0>
PUBLIC	??$?0I@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAI@Z ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int>
PUBLIC	??$?0$00I$0A@@?$_Non_trivial_copy@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ; std::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > ><1,unsigned int,0>
PUBLIC	??$construct_at@UInstructionStruct@EXB@@AEBU12@$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@AEBU12@@Z ; std::construct_at<EXB::InstructionStruct,EXB::InstructionStruct const &,0>
PUBLIC	??$construct@UInstructionStruct@EXB@@$$V@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@@Z ; std::_Default_allocator_traits<std::allocator<EXB::InstructionStruct> >::construct<EXB::InstructionStruct>
PUBLIC	??$_Emplace_back@UInstructionStruct@EXB@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX$$QEAUInstructionStruct@EXB@@@Z ; std::_Uninitialized_backout_al<std::allocator<EXB::InstructionStruct> >::_Emplace_back<EXB::InstructionStruct>
PUBLIC	??$move@AEAUInstructionStruct@EXB@@@std@@YA$$QEAUInstructionStruct@EXB@@AEAU12@@Z ; std::move<EXB::InstructionStruct &>
PUBLIC	??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@AEAG$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$00@0@AEAG@Z ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned short &,0>
PUBLIC	??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$02@2@VVector3F@@$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$02@0@$$QEAVVector3F@@@Z ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,3>,Vector3F,0>
PUBLIC	??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$01@2@M$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$01@0@$$QEAM@Z ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,2>,float,0>
PUBLIC	??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@I$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$00@0@$$QEAI@Z ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned int,0>
PUBLIC	??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$0A@@2@_N$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$0A@@0@$$QEA_N@Z ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,0>,bool,0>
PUBLIC	??$?0$00AEAG$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@AEAG@Z ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned short &,0>
PUBLIC	??$?0$02VVector3F@@$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$02@1@$$QEAVVector3F@@@Z ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><3,Vector3F,0>
PUBLIC	??$?0$01M$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$01@1@$$QEAM@Z ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><2,float,0>
PUBLIC	??$?0$00I$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAI@Z ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
PUBLIC	??$?0_N@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEA_N@Z ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><bool>
PUBLIC	??$?0$00I$0A@@?$_Non_trivial_move@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ; std::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
PUBLIC	??$_Refancy@PEAH$0A@@std@@YAPEAHPEAH@Z		; std::_Refancy<int *,0>
PUBLIC	??$construct@UInstructionStruct@EXB@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<EXB::InstructionStruct> >::construct<EXB::InstructionStruct,EXB::InstructionStruct const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<EXB::InstructionStruct> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ; std::_Uninitialized_move<EXB::InstructionStruct *,std::allocator<EXB::InstructionStruct> >
PUBLIC	??$_Get_unwrapped@AEBQEAUInstructionStruct@EXB@@@std@@YA?A_TAEBQEAUInstructionStruct@EXB@@@Z ; std::_Get_unwrapped<EXB::InstructionStruct * const &>
PUBLIC	??$forward@PEAH@std@@YA$$QEAPEAHAEAPEAH@Z	; std::forward<int *>
PUBLIC	??$__std_find_trivial@HH@@YAPEAHPEAH0H@Z	; __std_find_trivial<int,int>
PUBLIC	??$_Could_compare_equal_to_value_type@PEAHH@std@@YA_NAEBH@Z ; std::_Could_compare_equal_to_value_type<int *,int>
PUBLIC	??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@AEAG@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$00@0@AEAG@Z ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned short &>
PUBLIC	??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$02@2@VVector3F@@@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$02@0@$$QEAVVector3F@@@Z ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,3>,Vector3F>
PUBLIC	??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$01@2@M@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$01@0@$$QEAM@Z ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,2>,float>
PUBLIC	??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@I@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$00@0@$$QEAI@Z ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned int>
PUBLIC	??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$0A@@2@_N@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$0A@@0@$$QEA_N@Z ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,0>,bool>
PUBLIC	??$?0$00I$0A@@?$_Non_trivial_copy_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ; std::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
PUBLIC	?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Change_array
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAXPEBH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Seek_to
PUBLIC	??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_reallocate<EXB::InstructionStruct const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_back_with_unused_capacity<EXB::InstructionStruct const &>
PUBLIC	??$forward@AEBUInstructionStruct@EXB@@@std@@YAAEBUInstructionStruct@EXB@@AEBU12@@Z ; std::forward<EXB::InstructionStruct const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<EXB::InstructionStruct> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PEAH@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@$$QEAPEAH@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *>
PUBLIC	??$_Find_unchecked@PEAHH@std@@YAPEAHPEAHQEAHAEBH@Z ; std::_Find_unchecked<int *,int>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	??$_Emplace_valueless@$00AEAG@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAIAEAG@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<1,unsigned short &>
PUBLIC	??$_Emplace_valueless@$03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<4,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Emplace_valueless@$02VVector3F@@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAVVector3F@@$$QEAV2@@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<3,Vector3F>
PUBLIC	??$_Emplace_valueless@$01M@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAM$$QEAM@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<2,float>
PUBLIC	??$_Emplace_valueless@$00I@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAI$$QEAI@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<1,unsigned int>
PUBLIC	??$_Emplace_valueless@$0A@_N@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEA_N$$QEA_N@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<0,bool>
PUBLIC	??$?0$00I$0A@@?$_Non_trivial_move_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ; std::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
PUBLIC	?_Orphan_range@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEBAXPEAUInstructionStruct@EXB@@0@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Orphan_range
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBA_JAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator-
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAPEAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unwrapped
PUBLIC	??$_Emplace_one_at_back@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_one_at_back<EXB::InstructionStruct const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Resize<std::_Value_init_tag>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??$distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ; std::distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > const &>
PUBLIC	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > &>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBH@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
PUBLIC	??$?4AEAG$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@AEAG@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<unsigned short &,0>
PUBLIC	??$?4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
PUBLIC	??$?4VVector3F@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAVVector3F@@@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<Vector3F,0>
PUBLIC	??$?4M$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAM@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<float,0>
PUBLIC	??$?4I$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAI@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<unsigned int,0>
PUBLIC	??$?4_N$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEA_N@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<bool,0>
PUBLIC	??$?0I$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAI@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int,0>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Compat
PUBLIC	?push_back@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXAEBUInstructionStruct@EXB@@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::push_back
PUBLIC	?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::resize
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ ; std::vector<int,std::allocator<int> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ ; std::vector<int,std::allocator<int> >::_Unchecked_end
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
PUBLIC	?__autoclassinit2@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::__autoclassinit2
PUBLIC	??0InstructionStruct@EXB@@QEAA@XZ		; EXB::InstructionStruct::InstructionStruct
PUBLIC	?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z ; EXB::ReadStringFromStringPool
PUBLIC	?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; EXB::GetOffsetInStringTable
PUBLIC	?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; EXB::AddToStringTable
PUBLIC	?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z ; EXB::ToBinary
PUBLIC	??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z ; EXB::EXB
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0InstructionStruct@EXB@@QEAA@$$QEAU01@@Z DD imagerel $LN41
	DD	imagerel $LN41+157
	DD	imagerel $unwind$??0InstructionStruct@EXB@@QEAA@$$QEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UInstructionStruct@EXB@@U12@$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@$$QEAU12@@Z DD imagerel $LN44
	DD	imagerel $LN44+157
	DD	imagerel $unwind$??$construct_at@UInstructionStruct@EXB@@U12@$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@$$QEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UInstructionStruct@EXB@@U12@@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@$$QEAU34@@Z DD imagerel $LN46
	DD	imagerel $LN46+160
	DD	imagerel $unwind$??$construct@UInstructionStruct@EXB@@U12@@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@$$QEAU34@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@UInstructionStruct@EXB@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX$$QEAUInstructionStruct@EXB@@@Z DD imagerel $LN48
	DD	imagerel $LN48+172
	DD	imagerel $unwind$??$_Emplace_back@UInstructionStruct@EXB@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX$$QEAUInstructionStruct@EXB@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+75
	DD	imagerel $unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z DD imagerel $LN87
	DD	imagerel $LN87+24
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z DD imagerel $LN87+24
	DD	imagerel $LN87+239
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z DD imagerel $LN87+239
	DD	imagerel $LN87+248
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z DD imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z DD imagerel $LN47+39
	DD	imagerel $LN47+122
	DD	imagerel $chain$0$?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z DD imagerel $LN47+122
	DD	imagerel $LN47+209
	DD	imagerel $chain$1$?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z DD imagerel $LN26
	DD	imagerel $LN26+313
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z@4HA+52
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z DD imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+160
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN19
	DD	imagerel $LN19+219
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA DD imagerel ?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA+49
	DD	imagerel $unwind$?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z DD imagerel $LN12
	DD	imagerel $LN12+64
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+50
	DD	imagerel $LN28+126
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+126
	DD	imagerel $LN28+197
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBH@Z DD imagerel $LN20
	DD	imagerel $LN20+41
	DD	imagerel $unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4AEAG$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@AEAG@Z DD imagerel $LN76
	DD	imagerel $LN76+124
	DD	imagerel $unwind$??$?4AEAG$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@AEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN168
	DD	imagerel $LN168+164
	DD	imagerel $unwind$??$?4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4VVector3F@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAVVector3F@@@Z DD imagerel $LN88
	DD	imagerel $LN88+144
	DD	imagerel $unwind$??$?4VVector3F@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAVVector3F@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4M$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAM@Z DD imagerel $LN82
	DD	imagerel $LN82+124
	DD	imagerel $unwind$??$?4M$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4I$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAI@Z DD imagerel $LN60
	DD	imagerel $LN60+124
	DD	imagerel $unwind$??$?4I$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4_N$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEA_N@Z DD imagerel $LN60
	DD	imagerel $LN60+124
	DD	imagerel $unwind$??$?4_N$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXAEBUInstructionStruct@EXB@@@Z DD imagerel $LN14
	DD	imagerel $LN14+57
	DD	imagerel $unwind$?push_back@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXAEBUInstructionStruct@EXB@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+50
	DD	imagerel $LN30+126
	DD	imagerel $chain$1$?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+126
	DD	imagerel $LN30+197
	DD	imagerel $chain$2$?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0InstructionStruct@EXB@@QEAA@XZ DD imagerel $LN72
	DD	imagerel $LN72+108
	DD	imagerel $unwind$??0InstructionStruct@EXB@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z DD imagerel ??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z
	DD	imagerel ??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z+2112
	DD	imagerel $unwind$??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z DD imagerel $LN63
	DD	imagerel $LN63+214
	DD	imagerel $unwind$?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z@4HA DD imagerel ?dtor$0@?0??ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z@4HA
	DD	imagerel ?dtor$0@?0??ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z DD imagerel $LN255
	DD	imagerel $LN255+637
	DD	imagerel $unwind$?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z DD imagerel $LN81
	DD	imagerel $LN81+198
	DD	imagerel $unwind$?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z DD imagerel $LN2232
	DD	imagerel $LN2232+9108
	DD	imagerel $unwind$?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DD imagerel $LN993
	DD	imagerel $LN993+2604
	DD	imagerel $unwind$??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB ' '
	DB	'e', 03H
	DB	06H
	DB	'('
	DB	08H
	DB	018H
	DB	06H
	DB	'|'
	DB	0aH
	DB	'a', 03H
	DB	0cH
	DB	'^'
	DB	0eH
	DB	094H
	DB	010H
	DB	')', 05H
	DB	02H
	DB	'9', 05H
	DB	010H
	DB	0fdH, 02H
	DB	02H
	DB	'Z'
	DB	010H
	DB	'>'
	DB	0aH
	DB	0d9H, 08H
	DB	06H
	DB	'm', 02H
	DB	00H
	DB	'x'
	DB	06H
	DB	'('
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 010H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	03eH
	DD	imagerel ?dtor$1@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA
	DB	02cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	050H
	DB	05aH
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	041H
	DB	05H
	DB	03eH
	DD	imagerel ?dtor$12@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$13@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA
	DB	08aH
	DD	imagerel ??1InstructionStruct@EXB@@QEAA@XZ
	DB	01H
	DB	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	imagerel $ip2state$??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DD 0d3219H
	DD	0176824H
	DD	03a341cH
	DD	030011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	016aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z DB 'N'
	DB	0e8H
	DB	04H
	DB	0a9H, 06H
	DB	06H
	DB	'1', 03H
	DB	08H
	DB	01cH
	DB	0aH
	DB	','
	DB	06H
	DB	'1', 04H
	DB	0cH
	DB	01cH
	DB	0eH
	DB	','
	DB	06H
	DB	0b1H, 03H
	DB	010H
	DB	01cH
	DB	012H
	DB	','
	DB	06H
	DB	'y', 05H
	DB	04H
	DB	096H
	DB	014H
	DB	0baH
	DB	016H
	DB	01cH
	DB	018H
	DB	','
	DB	01aH
	DB	':'
	DB	01cH
	DB	'L'
	DB	016H
	DB	0f4H
	DB	014H
	DB	086H
	DB	01eH
	DB	0f0H
	DB	' '
	DB	01cH
	DB	'"'
	DB	'.'
	DB	'$'
	DB	0b5H, 011H
	DB	01eH
	DB	0d5H, 06H
	DB	'&'
	DB	01eH
	DB	'('
	DB	'2'
	DB	'$'
	DB	0adH, 0dH
	DB	'*'
	DB	08dH, 02H
	DB	'$'
	DB	'u', 012H
	DB	'*'
	DB	08dH, 02H
	DB	'$'
	DB	'M', 05H
	DB	01eH
	DB	0e1H, 04H
	DB	','
	DB	'%', 03H
	DB	01eH
	DB	0b5H, 015H
	DB	014H
	DB	01H, 05H
	DB	00H
	DB	'@'
	DB	01eH
	DB	0cH
	DB	'$'
	DB	'`'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z DB 02cH
	DB	0aH
	DD	imagerel ??1BinaryVectorWriter@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
	DB	041H
	DB	06H
	DB	03aH
	DD	imagerel ??1CommandInfoStruct@EXB@@QEAA@XZ
	DB	021H
	DB	03H
	DB	03eH
	DD	imagerel ?dtor$114@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$115@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	08eH
	DD	imagerel ?dtor$103@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$104@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	0deH
	DD	imagerel ?dtor$59@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$60@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	0c5H
	DB	02H
	DD	imagerel ??1?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAA@XZ
	DB	01H
	DB	07H
	DB	042H
	DD	imagerel ??1CommandInfoStruct@EXB@@QEAA@XZ
	DB	021H
	DB	03H
	DB	03eH
	DD	imagerel ?dtor$96@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$97@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	08aH
	DD	imagerel ??1InstructionStruct@EXB@@QEAA@XZ
	DB	01H
	DB	04H
	DB	05H
	DB	02H
	DD	imagerel ??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ
	DB	0a1H
	DB	06H
	DB	046H
	DD	imagerel ?dtor$100@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$101@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	092H
	DD	imagerel ??1InstructionStruct@EXB@@QEAA@XZ
	DB	01H
	DB	04H
	DB	0ceH
	DD	imagerel ?dtor$43@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$44@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA
	DB	08cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	095H
	DB	02H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z DB 028H
	DD	imagerel $stateUnwindMap$?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z
	DD	imagerel $ip2state$?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z DD 0b3019H
	DD	046341fH
	DD	03c011fH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z
	DD	01daH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z DB 04H
	DB	015H, 02H
	DB	02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z DB 028H
	DD	imagerel $stateUnwindMap$?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z
	DD	imagerel $ip2state$?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z DD 081f19H
	DD	0c3410H
	DD	0f00c5210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z
	DD	02aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z DB 0cH
	DB	0a5H, 04H
	DB	02H
	DB	0d4H
	DB	04H
	DB	0a4H
	DB	06H
	DB	01aH
	DB	04H
	DB	0b2H
	DB	00H
	DB	'L'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z
	DD	imagerel $ip2state$?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z DD 0d3219H
	DD	0217424H
	DD	0206424H
	DD	01e3424H
	DD	0180124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z
	DD	0baH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z DB 02H
	DB	08dH, 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z DB 028H
	DD	imagerel $stateUnwindMap$?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z
	DD	imagerel $ip2state$?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z DD 060f11H
	DD	0b640fH
	DD	08340fH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z DB 06H
	DB	0d5H, 014H
	DB	02H
	DB	'i', 09H
	DB	00H
	DB	'r'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0d0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z
	DD	imagerel $ip2state$??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z DD 0d2e19H
	DD	08681fH
	DD	01d3417H
	DD	0120117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z
	DD	072H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0InstructionStruct@EXB@@QEAA@XZ DB 02H
	DB	0baH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0InstructionStruct@EXB@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0InstructionStruct@EXB@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0InstructionStruct@EXB@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0InstructionStruct@EXB@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0InstructionStruct@EXB@@QEAA@XZ
	DD	imagerel $ip2state$??0InstructionStruct@EXB@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0InstructionStruct@EXB@@QEAA@XZ DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0InstructionStruct@EXB@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXAEBUInstructionStruct@EXB@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4_N$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEA_N@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4I$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4M$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAM@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4VVector3F@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAVVector3F@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4AEAG$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@AEAG@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 06H
	DB	0eaH
	DB	00H
	DB	'T'
	DB	02H
	DB	'l'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
	DD	imagerel $tryMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
	DD	imagerel $ip2state$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 061019H
	DD	0f00c5210H
	DD	07008e00aH
	DD	030066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z DB 04H
	DB	0dcH
	DB	02H
	DB	'D'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z DD 041919H
	DD	0a340aH
	DD	07006720aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z DB 06H
	DB	08dH, 02H
	DB	00H
	DB	'l'
	DB	02H
	DB	0b4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z DD 081419H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	030066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z DD 021H
	DD	imagerel $LN87
	DD	imagerel $LN87+24
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z DD 020521H
	DD	077405H
	DD	imagerel $LN87
	DD	imagerel $LN87+24
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@UInstructionStruct@EXB@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX$$QEAUInstructionStruct@EXB@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UInstructionStruct@EXB@@U12@@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@$$QEAU34@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UInstructionStruct@EXB@@U12@$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@$$QEAU12@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0InstructionStruct@EXB@@QEAA@$$QEAU01@@Z DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
<range>$L0$1$ = 32
$T1 = 32
$T2 = 32
<end>$L0$1$ = 40
$T3 = 40
$T4 = 40
<begin>$L0$1$ = 48
InstructionCount$1$ = 48
_My_data$1$ = 56
this$GSCopy$1$ = 64
Bytes$GSCopy$1$ = 72
Func$5 = 80
$T6 = 80
this$GSCopy$ = 112
Bytes$GSCopy$ = 128
Reader$ = 136
_Temp$7 = 152
$T8 = 152
$T9 = 152
$T10 = 152
$T11 = 152
$T12 = 152
Instruction$13 = 192
SignatureOffsets$ = 336
__$ArrayPad$ = 360
this$ = 448
Bytes$ = 456
??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; EXB::EXB, COMDAT

; 57   : {

$LN993:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-128]
	sub	rsp, 384				; 00000180H
	movaps	XMMWORD PTR [rsp+368], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rdi, rdx
	mov	QWORD PTR Bytes$GSCopy$1$[rsp], rdx
	mov	r15, rcx
	mov	QWORD PTR this$GSCopy$1$[rsp], rcx

; 56   : EXB::EXB(std::vector<unsigned char> Bytes)

	mov	QWORD PTR this$GSCopy$[rsp], rcx
	mov	QWORD PTR Bytes$GSCopy$[rbp-256], rdx

; 57   : {

	call	??0HeaderStruct@EXB@@QEAA@XZ
	lea	rsi, QWORD PTR [rcx+48]
	mov	QWORD PTR <range>$L0$1$[rsp], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	r14d, r14d
	mov	QWORD PTR [rsi], r14
	mov	QWORD PTR [rsi+8], r14
	mov	QWORD PTR [rsi+16], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 57   : {

	lea	r13, QWORD PTR [rcx+72]
	mov	QWORD PTR _My_data$1$[rsp], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r13], r14
	mov	QWORD PTR [r13+8], r14
	mov	QWORD PTR [r13+16], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.h

; 127  : 	bool Loaded = false;

	mov	BYTE PTR [rcx+96], r14b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 6    : BinaryVectorReader::BinaryVectorReader(std::vector<unsigned char>& Bytes, bool BigEndian) : m_Bytes(Bytes) {}

	mov	QWORD PTR Reader$[rbp-256], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.h

; 39   : 	int m_Offset = -1;

	mov	rax, -1
	mov	DWORD PTR Reader$[rbp-248], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 60   : 	Reader.ReadStruct(&Header, sizeof(HeaderStruct));

	lea	r8d, QWORD PTR [r14+44]
	mov	rdx, rcx
	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?ReadStruct@BinaryVectorReader@@QEAAXPEAXIH@Z ; BinaryVectorReader::ReadStruct

; 61   : 
; 62   : 	if (Header.Magic[0] != 'E' || Header.Magic[1] != 'X' || Header.Magic[2] != 'B')

	cmp	BYTE PTR [r15], 69			; 00000045H
	jne	$LN18@EXB
	cmp	BYTE PTR [r15+1], 88			; 00000058H
	jne	$LN18@EXB
	cmp	BYTE PTR [r15+2], 66			; 00000042H
	jne	$LN18@EXB

; 65   : 		return;
; 66   : 	}
; 67   : 	if (Header.Version != 0x02)

	cmp	DWORD PTR [r15+4], 2
	je	SHORT $LN19@EXB

; 68   : 	{
; 69   : 		Logger::Error("EXBDecoder", "Wrong version, expected 0x02");

	lea	rax, QWORD PTR $T11[rbp-256]
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, OFFSET FLAT:??_C@_0BN@BNNPNAJP@Wrong?5version?0?5expected?50x02@
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
$LN990@EXB:

; 177  : }

	lea	rdx, OFFSET FLAT:??_C@_0L@GPMKFGFF@EXBDecoder@
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rbx
	mov	rcx, rax
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	jmp	$LN106@EXB
$LN19@EXB:

; 70   : 		return;
; 71   : 	}
; 72   : 
; 73   : 	//Signature Offsets
; 74   : 	Reader.Seek(Header.SignatureTableOffset, BinaryVectorReader::Position::Begin);

	xor	r8d, r8d
	mov	edx, DWORD PTR [r15+32]
	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 75   : 	uint32_t SignatureCount = Reader.ReadUInt32();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	ebx, eax

; 76   : 	std::vector<uint32_t> SignatureOffsets(SignatureCount);

	lea	rcx, QWORD PTR SignatureOffsets$[rbp-256]
	call	?__autoclassinit2@?$vector@IV?$allocator@I@std@@@std@@QEAAX_K@Z
	mov	edi, ebx
	mov	edx, ebx
	lea	rcx, QWORD PTR SignatureOffsets$[rbp-256]
	call	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@_KAEBV?$allocator@I@1@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	npad	1

; 77   : 	for (int i = 0; i < SignatureCount; i++)

	test	ebx, ebx
	je	SHORT $LN3@EXB
	mov	r10, r14
	npad	2
$LL4@EXB:

; 78   : 	{
; 79   : 		SignatureOffsets[i] = Reader.ReadUInt32();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	edx, eax
	mov	rax, QWORD PTR SignatureOffsets$[rbp-256]
	mov	DWORD PTR [r10+rax], edx

; 77   : 	for (int i = 0; i < SignatureCount; i++)

	lea	r10, QWORD PTR [r10+4]
	sub	rdi, 1
	jne	SHORT $LL4@EXB
$LN3@EXB:

; 80   : 	}
; 81   : 
; 82   : 	//Command Info
; 83   : 	Reader.Seek(Header.CommandInfoOffset, BinaryVectorReader::Position::Begin);

	xor	r8d, r8d
	mov	edx, DWORD PTR [r15+24]
	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 84   : 	uint32_t InfoCount = Reader.ReadUInt32();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	edi, eax

; 85   : 	Commands.resize(InfoCount);

	mov	edx, eax
	mov	rcx, rsi
	call	?resize@?$vector@UCommandInfoStruct@EXB@@V?$allocator@UCommandInfoStruct@EXB@@@std@@@std@@QEAAX_K@Z ; std::vector<EXB::CommandInfoStruct,std::allocator<EXB::CommandInfoStruct> >::resize

; 80   : 	}
; 81   : 
; 82   : 	//Command Info
; 83   : 	Reader.Seek(Header.CommandInfoOffset, BinaryVectorReader::Position::Begin);

	mov	ebx, r14d

; 86   : 	for (int i = 0; i < InfoCount; i++)

	test	edi, edi
	je	SHORT $LN6@EXB
	npad	3
$LL7@EXB:

; 88   : 		Reader.ReadStruct(&Commands[i], 28); //28 = sizeof(CommandInfoStruct) - Instruction vector

	movsxd	rax, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rdx, rax, 56				; 00000038H
	add	rdx, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 88   : 		Reader.ReadStruct(&Commands[i], 28); //28 = sizeof(CommandInfoStruct) - Instruction vector

	mov	r8d, 28
	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?ReadStruct@BinaryVectorReader@@QEAAXPEAXIH@Z ; BinaryVectorReader::ReadStruct

; 86   : 	for (int i = 0; i < InfoCount; i++)

	inc	ebx
	cmp	ebx, edi
	jb	SHORT $LL7@EXB
$LN6@EXB:

; 89   : 	}
; 90   : 
; 91   : 	//Command Instructions
; 92   : 	Reader.Seek(Header.CommandTableOffset, BinaryVectorReader::Position::Begin);

	xor	r8d, r8d
	mov	edx, DWORD PTR [r15+28]
	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 93   : 	uint32_t InstructionCount = Reader.ReadUInt32();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	r12d, eax
	mov	DWORD PTR InstructionCount$1$[rsp], r12d

; 94   : 	Instructions.resize(InstructionCount);

	mov	edx, eax
	mov	rcx, r13
	call	?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::resize

; 95   : 	for (int i = 0; i < InstructionCount; i++)

	xor	ebx, ebx
	mov	r14d, ebx
	test	r12d, r12d
	je	$LN9@EXB
	mov	edi, ebx
$LN989@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, 65535				; 0000ffffH
	mov	BYTE PTR Instruction$13[rbp-256], 30
	mov	WORD PTR Instruction$13[rbp-254], bx
	mov	DWORD PTR Instruction$13[rbp-252], -62709 ; ffff0b0bH
	mov	WORD PTR Instruction$13[rbp-248], ax
	mov	DWORD PTR Instruction$13[rbp-240], -1	; ffffffffH

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR Instruction$13[rbp-208], 1

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR Instruction$13[rbp-200], -1	; ffffffffH

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR Instruction$13[rbp-168], 1
	mov	WORD PTR Instruction$13[rbp-160], ax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Instruction$13[rbp-152], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR Instruction$13[rbp-136], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR Instruction$13[rbp-128], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 19
	lea	rdx, OFFSET FLAT:??_C@_0BE@MABBHOKL@MapEditor_EXB_NoVal@
	lea	rcx, QWORD PTR Instruction$13[rbp-152]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	mov	eax, DWORD PTR Reader$[rbp-248]
	inc	eax
	mov	DWORD PTR Reader$[rbp-248], eax
	movsxd	rcx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Reader$[rbp-256]
	add	rcx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 98   : 		Instruction.Type = static_cast<EXB::Command>(Reader.ReadUInt8());

	movzx	r9d, BYTE PTR [rcx]
	mov	BYTE PTR Instruction$13[rbp-256], r9b

; 99   : 		if (Instruction.Type == EXB::Command::Terminator)

	lea	rcx, QWORD PTR Reader$[rbp-256]

; 98   : 		Instruction.Type = static_cast<EXB::Command>(Reader.ReadUInt8());

	cmp	r9b, 1

; 99   : 		if (Instruction.Type == EXB::Command::Terminator)

	jne	SHORT $LN20@EXB

; 100  : 		{
; 101  : 			Reader.Seek(7, BinaryVectorReader::Position::Current);

	movzx	r8d, r9b
	mov	edx, 7
	call	?Seek@BinaryVectorReader@@QEAAXHW4Position@1@@Z ; BinaryVectorReader::Seek

; 102  : 			Instructions[i] = Instruction;

	movsxd	rax, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rcx, rax, 136				; 00000088H
	add	rcx, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 102  : 			Instructions[i] = Instruction;

	lea	rdx, QWORD PTR Instruction$13[rbp-256]
	call	??4InstructionStruct@EXB@@QEAAAEAU01@AEBU01@@Z
	npad	1

; 103  : 			continue;

	lea	rcx, QWORD PTR Instruction$13[rbp-256]
	call	??1InstructionStruct@EXB@@QEAA@XZ
	jmp	$LN8@EXB
$LN20@EXB:

; 104  : 		}
; 105  : 		Instruction.DataType = static_cast<EXB::Type>(Reader.ReadUInt8());

	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	movzx	r8d, al
	mov	WORD PTR Instruction$13[rbp-254], r8w

; 106  : 		if (Instruction.Type != EXB::Command::UserFunction)

	lea	rcx, QWORD PTR Reader$[rbp-256]

; 104  : 		}
; 105  : 		Instruction.DataType = static_cast<EXB::Type>(Reader.ReadUInt8());

	cmp	r9b, 27

; 106  : 		if (Instruction.Type != EXB::Command::UserFunction)

	je	$LN21@EXB

; 107  : 		{
; 108  : 			Instruction.LHSSource = static_cast<EXB::Source>(Reader.ReadUInt8());

	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	mov	BYTE PTR Instruction$13[rbp-252], al

; 109  : 			Instruction.RHSSource = static_cast<EXB::Source>(Reader.ReadUInt8());

	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?ReadUInt8@BinaryVectorReader@@QEAAEXZ	; BinaryVectorReader::ReadUInt8
	mov	BYTE PTR Instruction$13[rbp-251], al

; 110  : 			Instruction.LHSIndexValue = Reader.ReadUInt16();

	xor	edx, edx
	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	mov	WORD PTR Instruction$13[rbp-250], ax

; 111  : 			Instruction.RHSIndexValue = Reader.ReadUInt16();

	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	mov	WORD PTR Instruction$13[rbp-248], ax

; 151  : 				};

	lea	rax, QWORD PTR Instruction$13[rbp-256]
	mov	QWORD PTR Func$5[rsp], rax
	lea	rax, QWORD PTR Reader$[rbp-256]
	mov	QWORD PTR Func$5[rsp+8], rax

; 152  : 
; 153  : 			Func("LHS", this);

	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r8, r15
	mov	rdx, rax
	lea	rcx, QWORD PTR Func$5[rsp]
	call	??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z ; `EXB::EXB'::`20'::<lambda_1>::operator()

; 154  : 			Func("RHS", this);

	lea	rdx, OFFSET FLAT:??_C@_03FAKADFCF@RHS@
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r8, r15
	mov	rdx, rax
	lea	rcx, QWORD PTR Func$5[rsp]
	call	??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z ; `EXB::EXB'::`20'::<lambda_1>::operator()

; 155  : 		}

	jmp	SHORT $LN901@EXB
$LN21@EXB:

; 156  : 		else
; 157  : 		{
; 158  : 			Instruction.StaticMemoryIndex = Reader.ReadUInt16();

	xor	edx, edx
	call	?ReadUInt16@BinaryVectorReader@@QEAAG_N@Z ; BinaryVectorReader::ReadUInt16
	mov	WORD PTR Instruction$13[rbp-160], ax

; 159  : 			Instruction.Signature = ReadStringFromStringPool(&Reader, SignatureOffsets[Reader.ReadUInt32()]);

	lea	rcx, QWORD PTR Reader$[rbp-256]
	call	?ReadUInt32@BinaryVectorReader@@QEAAI_N@Z ; BinaryVectorReader::ReadUInt32
	mov	edx, eax
	mov	r9, QWORD PTR SignatureOffsets$[rbp-256]
	mov	r9d, DWORD PTR [r9+rdx*4]
	lea	r8, QWORD PTR Reader$[rbp-256]
	lea	rdx, QWORD PTR $T8[rbp-256]
	mov	rcx, r15
	call	?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z ; EXB::ReadStringFromStringPool
	mov	rdx, rax
	lea	rcx, QWORD PTR Instruction$13[rbp-152]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T8[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN901@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rsi, QWORD PTR [r13]
	movzx	eax, BYTE PTR Instruction$13[rbp-256]
	mov	BYTE PTR [rdi+rsi], al
	movzx	eax, WORD PTR Instruction$13[rbp-254]
	mov	WORD PTR [rdi+rsi+2], ax
	movzx	eax, BYTE PTR Instruction$13[rbp-252]
	mov	BYTE PTR [rdi+rsi+4], al
	movzx	eax, BYTE PTR Instruction$13[rbp-251]
	mov	BYTE PTR [rdi+rsi+5], al
	movzx	eax, WORD PTR Instruction$13[rbp-250]
	mov	WORD PTR [rdi+rsi+6], ax
	movzx	eax, WORD PTR Instruction$13[rbp-248]
	mov	WORD PTR [rdi+rsi+8], ax
	lea	rbx, QWORD PTR [rsi+16]
	add	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Instruction$13[rbp-208]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN984@EXB[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN369@EXB:

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rbx+32]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN983@EXB[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN406@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN423@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], -1

; 763  :     }

	jmp	$LN887@EXB
$LN370@EXB:

; 740  :             if (_Self._Which == _Idx) { // same alternative: assign directly

	movsx	rax, BYTE PTR [rbx+32]
	test	al, al
	jne	SHORT $LN436@EXB

; 741  :                 auto& _Target = _STD _Variant_raw_get<_Idx>(_Self._Storage());
; 742  :                 _Target       = static_cast<_Ty&&>(_Source._Val);

	movzx	eax, BYTE PTR Instruction$13[rbp-240]
	mov	BYTE PTR [rbx], al

; 743  :             } else { // different alternative

	jmp	$LN887@EXB
$LN436@EXB:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN982@EXB[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN455@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN472@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], -1

; 748  :                         _STD _Construct_in_place(_Self._Storage(), integral_constant<size_t, _Idx>{}, _Source._Val);

	movzx	eax, BYTE PTR Instruction$13[rbp-240]
	mov	BYTE PTR [rbx], al

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 0

; 763  :     }

	jmp	$LN887@EXB
$LN371@EXB:

; 740  :             if (_Self._Which == _Idx) { // same alternative: assign directly

	movsx	rax, BYTE PTR [rbx+32]
	cmp	al, 1
	jne	SHORT $LN486@EXB

; 741  :                 auto& _Target = _STD _Variant_raw_get<_Idx>(_Self._Storage());
; 742  :                 _Target       = static_cast<_Ty&&>(_Source._Val);

	mov	eax, DWORD PTR Instruction$13[rbp-240]
	mov	DWORD PTR [rbx], eax

; 743  :             } else { // different alternative

	jmp	$LN887@EXB
$LN486@EXB:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN981@EXB[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN505@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN522@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], -1

; 748  :                         _STD _Construct_in_place(_Self._Storage(), integral_constant<size_t, _Idx>{}, _Source._Val);

	mov	eax, DWORD PTR Instruction$13[rbp-240]
	mov	DWORD PTR [rbx], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 1

; 763  :     }

	jmp	$LN887@EXB
$LN372@EXB:

; 740  :             if (_Self._Which == _Idx) { // same alternative: assign directly

	movsx	rax, BYTE PTR [rbx+32]
	cmp	al, 2
	jne	SHORT $LN536@EXB

; 741  :                 auto& _Target = _STD _Variant_raw_get<_Idx>(_Self._Storage());
; 742  :                 _Target       = static_cast<_Ty&&>(_Source._Val);

	movss	xmm0, DWORD PTR Instruction$13[rbp-240]
	movss	DWORD PTR [rbx], xmm0

; 743  :             } else { // different alternative

	jmp	$LN887@EXB
$LN536@EXB:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN980@EXB[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN555@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN572@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], -1

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movss	xmm0, DWORD PTR Instruction$13[rbp-240]
	movss	DWORD PTR [rbx], xmm0

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 2

; 763  :     }

	jmp	$LN887@EXB
$LN373@EXB:

; 740  :             if (_Self._Which == _Idx) { // same alternative: assign directly

	movsx	rax, BYTE PTR [rbx+32]
	cmp	al, 3
	jne	SHORT $LN608@EXB

; 741  :                 auto& _Target = _STD _Variant_raw_get<_Idx>(_Self._Storage());
; 742  :                 _Target       = static_cast<_Ty&&>(_Source._Val);

	movsd	xmm0, QWORD PTR Instruction$13[rbp-240]
	movsd	QWORD PTR [rbx], xmm0
	mov	eax, DWORD PTR Instruction$13[rbp-232]
	mov	DWORD PTR [rbx+8], eax

; 743  :             } else { // different alternative

	jmp	$LN887@EXB
$LN608@EXB:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN979@EXB[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN627@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN644@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], -1

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR Instruction$13[rbp-240]
	movsd	QWORD PTR [rbx], xmm0
	mov	eax, DWORD PTR Instruction$13[rbp-232]
	mov	DWORD PTR [rbx+8], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 3

; 763  :     }

	jmp	$LN887@EXB
$LN374@EXB:

; 740  :             if (_Self._Which == _Idx) { // same alternative: assign directly

	cmp	BYTE PTR [rbx+32], 4
	jne	SHORT $LN686@EXB
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Instruction$13[rbp-240]
	cmp	rbx, rax
	je	$LN887@EXB

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Instruction$13[rbp-240]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Instruction$13[rbp-216], 16
	cmovae	rdx, QWORD PTR Instruction$13[rbp-240]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Instruction$13[rbp-224]
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 743  :             } else { // different alternative

	jmp	$LN887@EXB
$LN686@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	mov	QWORD PTR _Temp$7[rbp-248], 0

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r13, QWORD PTR Instruction$13[rbp-224]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r12, QWORD PTR Instruction$13[rbp-240]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Instruction$13[rbp-216], 16
	cmovae	r12, QWORD PTR Instruction$13[rbp-240]

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	r13, rax
	ja	$LN933@EXB

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r13, 16
	jae	SHORT $LN715@EXB

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR _Temp$7[rbp-240], r13

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR _Temp$7[rbp-232], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm6, XMMWORD PTR [r12]

; 2647 :             return;

	jmp	SHORT $LN731@EXB
$LN715@EXB:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	r15, r13
	or	r15, 15
	cmp	r15, rax

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN726@EXB

; 4716 :             return _Max;

	mov	r15, rax
	jmp	SHORT $LN725@EXB
$LN726@EXB:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	r15, 22
	mov	eax, 22
	cmovb	r15, rax
$LN725@EXB:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, r15
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR _Temp$7[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR _Temp$7[rbp-240], r13

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR _Temp$7[rbp-232], r15

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r13+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	movups	xmm6, XMMWORD PTR _Temp$7[rbp-256]
	mov	r15, QWORD PTR this$GSCopy$1$[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
$LN731@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rbx+32]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN978@EXB[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN755@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN772@EXB:

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [rbx], xmm6
	movups	xmm0, XMMWORD PTR _Temp$7[rbp-240]
	movups	XMMWORD PTR [rbx+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 4
	mov	r12d, DWORD PTR InstructionCount$1$[rsp]
	lea	r13, QWORD PTR [r15+72]
$LN887@EXB:
	lea	rcx, QWORD PTR [rsi+56]
	add	rcx, rdi
	lea	rdx, QWORD PTR Instruction$13[rbp-200]
	call	??4?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@AEBV01@@Z
	movzx	eax, WORD PTR Instruction$13[rbp-160]
	mov	WORD PTR [rdi+rsi+96], ax
	lea	rcx, QWORD PTR [rsi+104]
	add	rcx, rdi
	lea	rdx, QWORD PTR Instruction$13[rbp-152]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$13[rbp-152]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Instruction$13[rbp-168]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rsi, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN977@EXB[rsi+rax*4+4]
	add	rax, rsi
	jmp	rax
$LN259@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$13[rbp-200]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN276@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Instruction$13[rbp-208]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN976@EXB[rsi+rax*4+4]
	add	rax, rsi
	jmp	rax
$LN322@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$13[rbp-240]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN987@EXB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 95   : 	for (int i = 0; i < InstructionCount; i++)

	xor	ebx, ebx
$LN8@EXB:
	inc	r14d
	add	rdi, 136				; 00000088H
	cmp	r14d, r12d
	jb	$LN989@EXB
	mov	rsi, QWORD PTR <range>$L0$1$[rsp]
$LN9@EXB:

; 160  : 		}
; 161  : 		Instructions[i] = Instruction;
; 162  : 	}
; 163  : 
; 164  : 	//Match instructions to commands
; 165  : 	uint32_t InstructionIndex = 0;

	mov	r13d, ebx

; 166  : 	for (EXB::CommandInfoStruct& Command : Commands)

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR <end>$L0$1$[rsp], rcx

; 160  : 		}
; 161  : 		Instructions[i] = Instruction;
; 162  : 	}
; 163  : 
; 164  : 	//Match instructions to commands
; 165  : 	uint32_t InstructionIndex = 0;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR <begin>$L0$1$[rsp], rax

; 166  : 	for (EXB::CommandInfoStruct& Command : Commands)

	cmp	rax, rcx
	je	$LN12@EXB

; 160  : 		}
; 161  : 		Instructions[i] = Instruction;
; 162  : 	}
; 163  : 
; 164  : 	//Match instructions to commands
; 165  : 	uint32_t InstructionIndex = 0;

	lea	r15, QWORD PTR [rax+40]
	mov	r9, -1085102592571150095		; f0f0f0f0f0f0f0f1H
	npad	12
$LL13@EXB:

; 167  : 	{
; 168  : 		Command.Instructions.resize(Command.InstructionCount);

	mov	edx, DWORD PTR [r15-28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [r15]
	mov	r8, QWORD PTR [r15-8]
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN132@EXB

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rsi, rdx, 136				; 00000088H
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN138@EXB
$LL139@EXB:
	mov	rcx, rbx
	call	??1InstructionStruct@EXB@@QEAA@XZ
	add	rbx, 136				; 00000088H
	cmp	rbx, rdi
	jne	SHORT $LL139@EXB
$LN138@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [r15], rsi

; 1564 :             return;

	xor	ebx, ebx
	jmp	SHORT $LN133@EXB
$LN418@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN467@EXB:
$LN517@EXB:
$LN567@EXB:
$LN639@EXB:
$LN334@EXB:
$LN271@EXB:
$LN767@EXB:
$LN386@EXB:
$LN132@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN133@EXB

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r15+8]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN134@EXB

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	lea	rcx, QWORD PTR [r15-8]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN133@EXB
$LN134@EXB:

; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	lea	r8, QWORD PTR [r15-8]
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<EXB::InstructionStruct> >
	mov	QWORD PTR [r15], rax
$LN133@EXB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 169  : 		for (int i = 0; i < Command.InstructionCount; i++)

	mov	r14d, ebx
	cmp	DWORD PTR [r15-28], 0
	jbe	$LN15@EXB
	mov	rsi, rbx
	npad	1
$LL16@EXB:

; 170  : 		{
; 171  : 			Command.Instructions[i] = this->Instructions[InstructionIndex + i];

	lea	ecx, DWORD PTR [r14+r13]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rdi, rcx, 136				; 00000088H
	mov	rax, QWORD PTR _My_data$1$[rsp]
	add	rdi, QWORD PTR [rax]
	mov	rbx, QWORD PTR [r15-8]
	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR [rsi+rbx], al
	movzx	eax, WORD PTR [rdi+2]
	mov	WORD PTR [rsi+rbx+2], ax
	movzx	eax, BYTE PTR [rdi+4]
	mov	BYTE PTR [rsi+rbx+4], al
	movzx	eax, BYTE PTR [rdi+5]
	mov	BYTE PTR [rsi+rbx+5], al
	movzx	eax, WORD PTR [rdi+6]
	mov	WORD PTR [rsi+rbx+6], ax
	movzx	eax, WORD PTR [rdi+8]
	mov	WORD PTR [rsi+rbx+8], ax
	lea	r8, QWORD PTR [rdi+16]
	lea	rax, QWORD PTR [rbx+16]
	add	rax, rsi
	mov	QWORD PTR $T2[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rcx, BYTE PTR [r8+32]

; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]

	inc	rcx

; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));

	lea	rdx, QWORD PTR $T2[rsp]
	call	??$_Visit@U?$_Variant_assign_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEBV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@?$_Variant_raw_visit1@$01@std@@SAX_K$$QEAU?$_Variant_assign_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEBV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Variant_raw_visit1<2>::_Visit<std::_Variant_assign_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>
	lea	r8, QWORD PTR [rdi+56]
	lea	rax, QWORD PTR [rbx+56]
	add	rax, rsi
	mov	QWORD PTR $T1[rsp], rax

; 803  :         return static_cast<size_t>(_Which);

	movsx	rcx, BYTE PTR [r8+32]

; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]

	inc	rcx

; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));

	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Visit@U?$_Variant_assign_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEBV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@?$_Variant_raw_visit1@$01@std@@SAX_K$$QEAU?$_Variant_assign_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEBV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Variant_raw_visit1<2>::_Visit<std::_Variant_assign_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>
	movzx	eax, WORD PTR [rdi+96]
	mov	WORD PTR [rsi+rbx+96], ax
	lea	rdx, QWORD PTR [rdi+104]
	lea	rcx, QWORD PTR [rbx+104]
	add	rcx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN14@EXB

; 3157 :             return *this;
; 3158 :         }
; 3159 : 
; 3160 :         auto& _Al             = _Getal();
; 3161 :         const auto& _Right_al = _Right._Getal();
; 3162 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3163 :             if (_Al != _Right_al) {
; 3164 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3165 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3166 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3167 : 
; 3168 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3169 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3170 :                     const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3171 :                     auto _Right_al_non_const = _Right_al;
; 3172 :                     const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity + 1); // throws
; 3173 : 
; 3174 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_size + 1);
; 3175 : 
; 3176 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3177 :                     _Tidy_deallocate();
; 3178 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3179 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3180 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3181 :                 } else {
; 3182 :                     _Copy_assign_val_from_small(_Right);
; 3183 :                 }
; 3184 : 
; 3185 :                 _Pocca(_Al, _Right_al);
; 3186 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3187 :                 return *this;
; 3188 :             }
; 3189 :         }
; 3190 : 
; 3191 :         _Pocca(_Al, _Right_al);
; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdx+24], 16
	jb	SHORT $LN68@EXB

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN68@EXB:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN14@EXB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 169  : 		for (int i = 0; i < Command.InstructionCount; i++)

	inc	r14d
	add	rsi, 136				; 00000088H
	cmp	r14d, DWORD PTR [r15-28]
	jb	$LL16@EXB
	xor	ebx, ebx
$LN15@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r15]
	sub	rax, QWORD PTR [r15-8]
	sar	rax, 3
	mov	r9, -1085102592571150095		; f0f0f0f0f0f0f0f1H
	imul	rax, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 173  : 		InstructionIndex += Command.Instructions.size();

	add	r13d, eax

; 166  : 	for (EXB::CommandInfoStruct& Command : Commands)

	mov	rax, QWORD PTR <begin>$L0$1$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR <begin>$L0$1$[rsp], rax
	add	r15, 56					; 00000038H
	cmp	rax, QWORD PTR <end>$L0$1$[rsp]
	jne	$LL13@EXB
	mov	r15, QWORD PTR this$GSCopy$1$[rsp]
$LN12@EXB:

; 174  : 	}
; 175  : 
; 176  : 	this->Loaded = true;

	mov	BYTE PTR [r15+96], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR SignatureOffsets$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN986@EXB

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR SignatureOffsets$[rbp-240]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN124@EXB

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN124@EXB
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN124@EXB:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN986@EXB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 177  : }

	xor	r14d, r14d
	mov	rdi, QWORD PTR Bytes$GSCopy$1$[rsp]
$LN106@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN79@EXB

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN97@EXB

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN94@EXB

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN97@EXB:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rdi], r14

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], r14

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], r14
$LN79@EXB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 177  : }

	mov	rax, r15
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+464]
	movaps	xmm6, XMMWORD PTR [rsp+368]
	add	rsp, 384				; 00000180H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN18@EXB:

; 63   : 	{
; 64   : 		Logger::Error("EXBDecoder", "Wrong magic, expected magic EXB");

	lea	rax, QWORD PTR $T12[rbp-256]
	mov	QWORD PTR $T4[rsp], rax
	lea	rdx, OFFSET FLAT:??_C@_0CA@FGDDDNGP@Wrong?5magic?0?5expected?5magic?5EXB@
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	jmp	$LN990@EXB
$LN94@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN933@EXB:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN988@EXB:
	npad	2
$LN984@EXB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 177  : }

	DD	$LN369@EXB
	DD	$LN370@EXB
	DD	$LN371@EXB
	DD	$LN372@EXB
	DD	$LN373@EXB
	DD	$LN374@EXB
$LN983@EXB:
	DD	$LN423@EXB
	DD	$LN423@EXB
	DD	$LN423@EXB
	DD	$LN423@EXB
	DD	$LN423@EXB
	DD	$LN406@EXB
$LN982@EXB:
	DD	$LN472@EXB
	DD	$LN472@EXB
	DD	$LN472@EXB
	DD	$LN472@EXB
	DD	$LN472@EXB
	DD	$LN455@EXB
$LN981@EXB:
	DD	$LN522@EXB
	DD	$LN522@EXB
	DD	$LN522@EXB
	DD	$LN522@EXB
	DD	$LN522@EXB
	DD	$LN505@EXB
$LN980@EXB:
	DD	$LN572@EXB
	DD	$LN572@EXB
	DD	$LN572@EXB
	DD	$LN572@EXB
	DD	$LN572@EXB
	DD	$LN555@EXB
$LN979@EXB:
	DD	$LN644@EXB
	DD	$LN644@EXB
	DD	$LN644@EXB
	DD	$LN644@EXB
	DD	$LN644@EXB
	DD	$LN627@EXB
$LN978@EXB:
	DD	$LN772@EXB
	DD	$LN772@EXB
	DD	$LN772@EXB
	DD	$LN772@EXB
	DD	$LN772@EXB
	DD	$LN755@EXB
$LN977@EXB:
	DD	$LN276@EXB
	DD	$LN276@EXB
	DD	$LN276@EXB
	DD	$LN276@EXB
	DD	$LN276@EXB
	DD	$LN259@EXB
$LN976@EXB:
	DD	$LN987@EXB
	DD	$LN987@EXB
	DD	$LN987@EXB
	DD	$LN987@EXB
	DD	$LN987@EXB
	DD	$LN322@EXB
??0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; EXB::EXB
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
<range>$L0$1$ = 32
$T1 = 32
$T2 = 32
<end>$L0$1$ = 40
$T3 = 40
$T4 = 40
<begin>$L0$1$ = 48
InstructionCount$1$ = 48
_My_data$1$ = 56
this$GSCopy$1$ = 64
Bytes$GSCopy$1$ = 72
Func$5 = 80
$T6 = 80
this$GSCopy$ = 112
Bytes$GSCopy$ = 128
Reader$ = 136
_Temp$7 = 152
$T8 = 152
$T9 = 152
$T10 = 152
$T11 = 152
$T12 = 152
Instruction$13 = 192
SignatureOffsets$ = 336
__$ArrayPad$ = 360
this$ = 448
Bytes$ = 456
?dtor$0@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `EXB::EXB'::`1'::dtor$0
	mov	rcx, QWORD PTR Bytes$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `EXB::EXB'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
<range>$L0$1$ = 32
$T1 = 32
$T2 = 32
<end>$L0$1$ = 40
$T3 = 40
$T4 = 40
<begin>$L0$1$ = 48
InstructionCount$1$ = 48
_My_data$1$ = 56
this$GSCopy$1$ = 64
Bytes$GSCopy$1$ = 72
Func$5 = 80
$T6 = 80
this$GSCopy$ = 112
Bytes$GSCopy$ = 128
Reader$ = 136
_Temp$7 = 152
$T8 = 152
$T9 = 152
$T10 = 152
$T11 = 152
$T12 = 152
Instruction$13 = 192
SignatureOffsets$ = 336
__$ArrayPad$ = 360
this$ = 448
Bytes$ = 456
?dtor$1@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `EXB::EXB'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1?$vector@UCommandInfoStruct@EXB@@V?$allocator@UCommandInfoStruct@EXB@@@std@@@std@@QEAA@XZ ; std::vector<EXB::CommandInfoStruct,std::allocator<EXB::CommandInfoStruct> >::~vector<EXB::CommandInfoStruct,std::allocator<EXB::CommandInfoStruct> >
?dtor$1@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `EXB::EXB'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
<range>$L0$1$ = 32
$T1 = 32
$T2 = 32
<end>$L0$1$ = 40
$T3 = 40
$T4 = 40
<begin>$L0$1$ = 48
InstructionCount$1$ = 48
_My_data$1$ = 56
this$GSCopy$1$ = 64
Bytes$GSCopy$1$ = 72
Func$5 = 80
$T6 = 80
this$GSCopy$ = 112
Bytes$GSCopy$ = 128
Reader$ = 136
_Temp$7 = 152
$T8 = 152
$T9 = 152
$T10 = 152
$T11 = 152
$T12 = 152
Instruction$13 = 192
SignatureOffsets$ = 336
__$ArrayPad$ = 360
this$ = 448
Bytes$ = 456
?dtor$2@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `EXB::EXB'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 72					; 00000048H
	jmp	??1?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAA@XZ ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::~vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >
?dtor$2@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `EXB::EXB'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
<range>$L0$1$ = 32
$T1 = 32
$T2 = 32
<end>$L0$1$ = 40
$T3 = 40
$T4 = 40
<begin>$L0$1$ = 48
InstructionCount$1$ = 48
_My_data$1$ = 56
this$GSCopy$1$ = 64
Bytes$GSCopy$1$ = 72
Func$5 = 80
$T6 = 80
this$GSCopy$ = 112
Bytes$GSCopy$ = 128
Reader$ = 136
_Temp$7 = 152
$T8 = 152
$T9 = 152
$T10 = 152
$T11 = 152
$T12 = 152
Instruction$13 = 192
SignatureOffsets$ = 336
__$ArrayPad$ = 360
this$ = 448
Bytes$ = 456
?dtor$3@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `EXB::EXB'::`1'::dtor$3
	mov	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `EXB::EXB'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
<range>$L0$1$ = 32
$T1 = 32
$T2 = 32
<end>$L0$1$ = 40
$T3 = 40
$T4 = 40
<begin>$L0$1$ = 48
InstructionCount$1$ = 48
_My_data$1$ = 56
this$GSCopy$1$ = 64
Bytes$GSCopy$1$ = 72
Func$5 = 80
$T6 = 80
this$GSCopy$ = 112
Bytes$GSCopy$ = 128
Reader$ = 136
_Temp$7 = 152
$T8 = 152
$T9 = 152
$T10 = 152
$T11 = 152
$T12 = 152
Instruction$13 = 192
SignatureOffsets$ = 336
__$ArrayPad$ = 360
this$ = 448
Bytes$ = 456
?dtor$5@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `EXB::EXB'::`1'::dtor$5
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `EXB::EXB'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
<range>$L0$1$ = 32
$T1 = 32
$T2 = 32
<end>$L0$1$ = 40
$T3 = 40
$T4 = 40
<begin>$L0$1$ = 48
InstructionCount$1$ = 48
_My_data$1$ = 56
this$GSCopy$1$ = 64
Bytes$GSCopy$1$ = 72
Func$5 = 80
$T6 = 80
this$GSCopy$ = 112
Bytes$GSCopy$ = 128
Reader$ = 136
_Temp$7 = 152
$T8 = 152
$T9 = 152
$T10 = 152
$T11 = 152
$T12 = 152
Instruction$13 = 192
SignatureOffsets$ = 336
__$ArrayPad$ = 360
this$ = 448
Bytes$ = 456
?dtor$7@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `EXB::EXB'::`1'::dtor$7
	lea	rcx, QWORD PTR SignatureOffsets$[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$7@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `EXB::EXB'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
<range>$L0$1$ = 32
$T1 = 32
$T2 = 32
<end>$L0$1$ = 40
$T3 = 40
$T4 = 40
<begin>$L0$1$ = 48
InstructionCount$1$ = 48
_My_data$1$ = 56
this$GSCopy$1$ = 64
Bytes$GSCopy$1$ = 72
Func$5 = 80
$T6 = 80
this$GSCopy$ = 112
Bytes$GSCopy$ = 128
Reader$ = 136
_Temp$7 = 152
$T8 = 152
$T9 = 152
$T10 = 152
$T11 = 152
$T12 = 152
Instruction$13 = 192
SignatureOffsets$ = 336
__$ArrayPad$ = 360
this$ = 448
Bytes$ = 456
?dtor$12@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `EXB::EXB'::`1'::dtor$12
	lea	rcx, QWORD PTR Instruction$13[rdx]
	add	rcx, 16
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$12@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `EXB::EXB'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
<range>$L0$1$ = 32
$T1 = 32
$T2 = 32
<end>$L0$1$ = 40
$T3 = 40
$T4 = 40
<begin>$L0$1$ = 48
InstructionCount$1$ = 48
_My_data$1$ = 56
this$GSCopy$1$ = 64
Bytes$GSCopy$1$ = 72
Func$5 = 80
$T6 = 80
this$GSCopy$ = 112
Bytes$GSCopy$ = 128
Reader$ = 136
_Temp$7 = 152
$T8 = 152
$T9 = 152
$T10 = 152
$T11 = 152
$T12 = 152
Instruction$13 = 192
SignatureOffsets$ = 336
__$ArrayPad$ = 360
this$ = 448
Bytes$ = 456
?dtor$13@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `EXB::EXB'::`1'::dtor$13
	lea	rcx, QWORD PTR Instruction$13[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$13@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `EXB::EXB'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
<range>$L0$1$ = 32
$T1 = 32
$T2 = 32
<end>$L0$1$ = 40
$T3 = 40
$T4 = 40
<begin>$L0$1$ = 48
InstructionCount$1$ = 48
_My_data$1$ = 56
this$GSCopy$1$ = 64
Bytes$GSCopy$1$ = 72
Func$5 = 80
$T6 = 80
this$GSCopy$ = 112
Bytes$GSCopy$ = 128
Reader$ = 136
_Temp$7 = 152
$T8 = 152
$T9 = 152
$T10 = 152
$T11 = 152
$T12 = 152
Instruction$13 = 192
SignatureOffsets$ = 336
__$ArrayPad$ = 360
this$ = 448
Bytes$ = 456
?dtor$8@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `EXB::EXB'::`1'::dtor$8
	lea	rcx, QWORD PTR Instruction$13[rdx]
	jmp	??1InstructionStruct@EXB@@QEAA@XZ
?dtor$8@?0???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `EXB::EXB'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z
_TEXT	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z PROC ; EXB::ToBinary, COMDAT

; 180  : {

$LN2232:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-224]
	sub	rsp, 480				; 000001e0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	DWORD PTR EXBInstanceCount$1$[rsp], r8d
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-256], rdx
	mov	r13, rcx
	mov	QWORD PTR this$GSCopy$1$[rsp], rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	edi, edi
	xorps	xmm0, xmm0
	movups	XMMWORD PTR Writer$[rbp-240], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Writer$[rbp-256], xmm1
	mov	QWORD PTR Writer$[rbp-240], rdi
	mov	DWORD PTR Writer$[rbp-232], edi
	movdqu	XMMWORD PTR StringTable$[rbp-256], xmm1
	mov	QWORD PTR StringTable$[rbp-240], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	lea	edx, QWORD PTR [rdi+4]
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 180  : {

	lea	r8, OFFSET FLAT:??_C@_04EBONIFJK@EXB?5@+1
	mov	eax, DWORD PTR Writer$[rbp-232]
	npad	10
$LL1794@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL1794@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 2

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-232], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	lea	eax, DWORD PTR [r8+36]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN1758@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+37]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
$LN1758@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	r8d, 36					; 00000024H
	mov	DWORD PTR Writer$[rbp-232], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [r13+56]
	sub	rdx, QWORD PTR [r13+48]
	sar	rdx, 3
	mov	rax, 7905747460161236407		; 6db6db6db6db6db7H
	imul	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 192  : 	Writer.WriteInteger(this->Commands.size(), sizeof(uint32_t));

	mov	r8d, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 193  : 
; 194  : 	uint32_t InstructionIndex = 0;

	mov	r12d, edi

; 195  : 	uint32_t MaxStatic = 0;

	mov	DWORD PTR MaxStatic$1$[rsp], edi

; 196  : 	uint32_t Max32 = 0;

	mov	DWORD PTR Max32$1$[rsp], edi

; 197  : 	uint32_t Max64 = 0;

	mov	DWORD PTR Max64$1$[rsp], edi

; 198  : 	for (EXB::CommandInfoStruct Cmd : this->Commands)

	mov	r14, QWORD PTR [r13+48]
	mov	r15, QWORD PTR [r13+56]
	mov	QWORD PTR <end>$L0$1$[rsp], r15
	mov	rbx, -1085102592571150095		; f0f0f0f0f0f0f0f1H
	cmp	r14, r15
	je	$LN2190@ToBinary
$LL4@ToBinary:
	mov	rdx, r14
	lea	rcx, QWORD PTR Cmd$14[rbp-256]
	call	??0CommandInfoStruct@EXB@@QEAA@AEBU01@@Z
	npad	1

; 199  : 	{
; 200  : 		Writer.WriteInteger((int32_t)Cmd.BaseIndexPreCommandEntry, sizeof(int32_t));

	movsxd	rdx, DWORD PTR Cmd$14[rbp-256]
	mov	r8d, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 201  : 		Writer.WriteInteger(Cmd.PreEntryStaticMemoryUsage, sizeof(uint32_t));

	mov	edx, DWORD PTR Cmd$14[rbp-252]
	mov	r8d, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 202  : 		Writer.WriteInteger(InstructionIndex, sizeof(uint32_t));

	mov	edx, r12d
	mov	r8d, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Cmd$14[rbp-216]
	sub	rdx, QWORD PTR Cmd$14[rbp-224]
	sar	rdx, 3
	imul	rdx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 203  : 		Writer.WriteInteger(Cmd.Instructions.size(), sizeof(uint32_t));

	mov	r8d, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rsi, QWORD PTR Cmd$14[rbp-216]
	mov	rax, rsi
	mov	rdi, QWORD PTR Cmd$14[rbp-224]
	sub	rax, rdi
	sar	rax, 3
	imul	rax, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 204  : 		InstructionIndex += Cmd.Instructions.size();

	add	r12d, eax

; 205  : 		uint32_t StaticSize = 0;

	xor	ebx, ebx

; 206  : 		for (EXB::InstructionStruct Instruction : Cmd.Instructions)

	cmp	rdi, rsi
	je	$LN6@ToBinary

; 198  : 	for (EXB::CommandInfoStruct Cmd : this->Commands)

	add	rdi, 4
	lea	r13d, QWORD PTR [rbx+12]
	mov	r15d, 65535				; 0000ffffH
	npad	10
$LL7@ToBinary:
	movzx	eax, BYTE PTR [rdi-4]
	mov	BYTE PTR Instruction$20[rbp-256], al
	movzx	eax, WORD PTR [rdi-2]
	mov	WORD PTR Instruction$20[rbp-254], ax
	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR Instruction$20[rbp-252], al
	movzx	eax, BYTE PTR [rdi+1]
	mov	BYTE PTR Instruction$20[rbp-251], al
	movzx	eax, WORD PTR [rdi+2]
	mov	WORD PTR Instruction$20[rbp-250], ax
	movzx	eax, WORD PTR [rdi+4]
	mov	WORD PTR Instruction$20[rbp-248], ax
	lea	rdx, QWORD PTR [rdi+12]
	lea	rcx, QWORD PTR Instruction$20[rbp-240]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	lea	rdx, QWORD PTR [rdi+52]
	lea	rcx, QWORD PTR Instruction$20[rbp-200]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	movzx	eax, WORD PTR [rdi+92]
	mov	WORD PTR Instruction$20[rbp-160], ax
	lea	rdx, QWORD PTR [rdi+100]
	lea	rcx, QWORD PTR Instruction$20[rbp-152]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 207  : 		{
; 208  : 			if (Instruction.LHSSource != EXB::Source::Unknown || Instruction.RHSSource != EXB::Source::Unknown)

	movzx	edx, BYTE PTR Instruction$20[rbp-251]
	movzx	eax, BYTE PTR Instruction$20[rbp-252]
	cmp	al, 11
	jne	SHORT $LN34@ToBinary
	cmp	dl, al
	jne	SHORT $LN34@ToBinary

; 215  : 			}
; 216  : 			else if (Instruction.StaticMemoryIndex != 0xFFFF)

	movzx	ecx, WORD PTR Instruction$20[rbp-160]
	cmp	cx, r15w
	je	SHORT $LN36@ToBinary

; 217  : 			{
; 218  : 				uint32_t Size = Instruction.DataType == EXB::Type::Vec3f ? 12 : 4;

	mov	eax, 4
	cmp	WORD PTR Instruction$20[rbp-254], 6
	cmove	eax, r13d

; 219  : 				StaticSize = std::max(StaticSize, Instruction.StaticMemoryIndex + Size);

	add	ecx, eax
	cmp	ebx, ecx
	cmovb	ebx, ecx
	jmp	SHORT $LN36@ToBinary
$LN34@ToBinary:

; 209  : 			{
; 210  : 				uint32_t Size = Instruction.DataType == EXB::Type::Vec3f ? 12 : 4;

	mov	ecx, 4
	cmp	WORD PTR Instruction$20[rbp-254], 6
	cmove	ecx, r13d

; 211  : 				if (Instruction.LHSSource == EXB::Source::StaticMem)

	cmp	al, 2
	jne	SHORT $LN35@ToBinary

; 212  : 					StaticSize = std::max(StaticSize, Instruction.LHSIndexValue + Size);

	movzx	eax, WORD PTR Instruction$20[rbp-250]
	add	eax, ecx
	cmp	ebx, eax
	cmovb	ebx, eax
$LN35@ToBinary:

; 213  : 				if (Instruction.RHSSource == EXB::Source::StaticMem)

	cmp	dl, 2
	jne	SHORT $LN36@ToBinary

; 214  : 					StaticSize = std::max(StaticSize, Instruction.RHSIndexValue + Size);

	movzx	eax, WORD PTR Instruction$20[rbp-248]
	add	eax, ecx
	cmp	ebx, eax
	cmovb	ebx, eax
$LN36@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$20[rbp-152]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR Instruction$20[rbp-200]
	call	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	lea	rcx, QWORD PTR Instruction$20[rbp-240]
	call	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 206  : 		for (EXB::InstructionStruct Instruction : Cmd.Instructions)

	add	rdi, 136				; 00000088H
	lea	rax, QWORD PTR [rdi-4]
	cmp	rax, rsi
	jne	$LL7@ToBinary
	mov	r15, QWORD PTR <end>$L0$1$[rsp]
	mov	r13, QWORD PTR this$GSCopy$1$[rsp]
$LN6@ToBinary:

; 220  : 			}
; 221  : 		}
; 222  : 		MaxStatic = std::max(MaxStatic, StaticSize);

	mov	eax, DWORD PTR MaxStatic$1$[rsp]
	cmp	eax, ebx
	cmovb	eax, ebx
	mov	DWORD PTR MaxStatic$1$[rsp], eax

; 223  : 		Writer.WriteInteger(StaticSize, sizeof(uint32_t));

	mov	edx, ebx
	mov	r8d, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 224  : 		
; 225  : 		uint32_t Scratch32Size = 0;

	xor	ebx, ebx

; 226  : 		for (EXB::InstructionStruct Instruction : Cmd.Instructions)

	mov	rsi, QWORD PTR Cmd$14[rbp-216]
	mov	rdi, QWORD PTR Cmd$14[rbp-224]
	cmp	rdi, rsi
	je	$LN9@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	add	rdi, 4
	lea	r13d, QWORD PTR [rbx+12]
	npad	2
$LL10@ToBinary:
	movzx	eax, BYTE PTR [rdi-4]
	mov	BYTE PTR Instruction$19[rbp-256], al
	movzx	eax, WORD PTR [rdi-2]
	mov	WORD PTR Instruction$19[rbp-254], ax
	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR Instruction$19[rbp-252], al
	movzx	eax, BYTE PTR [rdi+1]
	mov	BYTE PTR Instruction$19[rbp-251], al
	movzx	eax, WORD PTR [rdi+2]
	mov	WORD PTR Instruction$19[rbp-250], ax
	movzx	eax, WORD PTR [rdi+4]
	mov	WORD PTR Instruction$19[rbp-248], ax
	lea	rdx, QWORD PTR [rdi+12]
	lea	rcx, QWORD PTR Instruction$19[rbp-240]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	lea	rdx, QWORD PTR [rdi+52]
	lea	rcx, QWORD PTR Instruction$19[rbp-200]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	movzx	eax, WORD PTR [rdi+92]
	mov	WORD PTR Instruction$19[rbp-160], ax
	lea	rdx, QWORD PTR [rdi+100]
	lea	rcx, QWORD PTR Instruction$19[rbp-152]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 228  : 			if (Instruction.LHSSource != EXB::Source::Unknown || Instruction.RHSSource != EXB::Source::Unknown)

	movzx	edx, BYTE PTR Instruction$19[rbp-251]
	movzx	eax, BYTE PTR Instruction$19[rbp-252]
	cmp	al, 11
	jne	SHORT $LN39@ToBinary
	cmp	dl, al
	je	SHORT $LN41@ToBinary
$LN39@ToBinary:

; 229  : 			{
; 230  : 				uint32_t Size = Instruction.DataType == EXB::Type::Vec3f ? 12 : 4;

	mov	ecx, 4
	cmp	WORD PTR Instruction$19[rbp-254], 6
	cmove	ecx, r13d

; 231  : 				if (Instruction.LHSSource == EXB::Source::Scratch32)

	cmp	al, 7
	jne	SHORT $LN40@ToBinary

; 232  : 					Scratch32Size = std::max(Scratch32Size, Instruction.LHSIndexValue + Size);

	movzx	eax, WORD PTR Instruction$19[rbp-250]
	add	eax, ecx
	cmp	ebx, eax
	cmovb	ebx, eax
$LN40@ToBinary:

; 233  : 				if (Instruction.RHSSource == EXB::Source::Scratch32)

	cmp	dl, 7
	jne	SHORT $LN41@ToBinary

; 234  : 					Scratch32Size = std::max(Scratch32Size, Instruction.RHSIndexValue + Size);

	movzx	eax, WORD PTR Instruction$19[rbp-248]
	add	eax, ecx
	cmp	ebx, eax
	cmovb	ebx, eax
$LN41@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$19[rbp-152]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR Instruction$19[rbp-200]
	call	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	lea	rcx, QWORD PTR Instruction$19[rbp-240]
	call	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 226  : 		for (EXB::InstructionStruct Instruction : Cmd.Instructions)

	add	rdi, 136				; 00000088H
	lea	rax, QWORD PTR [rdi-4]
	cmp	rax, rsi
	jne	$LL10@ToBinary
	mov	r13, QWORD PTR this$GSCopy$1$[rsp]
$LN9@ToBinary:

; 235  : 			}
; 236  : 		}
; 237  : 		Max32 = std::max(Max32, Scratch32Size);

	mov	eax, DWORD PTR Max32$1$[rsp]
	cmp	eax, ebx
	cmovb	eax, ebx
	mov	DWORD PTR Max32$1$[rsp], eax

; 238  : 		Writer.WriteInteger(Scratch32Size, sizeof(uint16_t));

	mov	edx, ebx
	mov	r8d, 2
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 239  : 		
; 240  : 		uint32_t Scratch64Size = 0;

	xor	ebx, ebx

; 241  : 		for (EXB::InstructionStruct Instruction : Cmd.Instructions)

	mov	rsi, QWORD PTR Cmd$14[rbp-216]
	mov	rdi, QWORD PTR Cmd$14[rbp-224]
	cmp	rdi, rsi
	je	$LN12@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	add	rdi, 4
	npad	12
$LL13@ToBinary:
	movzx	eax, BYTE PTR [rdi-4]
	mov	BYTE PTR Instruction$18[rbp-256], al
	movzx	eax, WORD PTR [rdi-2]
	mov	WORD PTR Instruction$18[rbp-254], ax
	movzx	eax, BYTE PTR [rdi]
	mov	BYTE PTR Instruction$18[rbp-252], al
	movzx	eax, BYTE PTR [rdi+1]
	mov	BYTE PTR Instruction$18[rbp-251], al
	movzx	eax, WORD PTR [rdi+2]
	mov	WORD PTR Instruction$18[rbp-250], ax
	movzx	eax, WORD PTR [rdi+4]
	mov	WORD PTR Instruction$18[rbp-248], ax
	lea	rdx, QWORD PTR [rdi+12]
	lea	rcx, QWORD PTR Instruction$18[rbp-240]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	lea	rdx, QWORD PTR [rdi+52]
	lea	rcx, QWORD PTR Instruction$18[rbp-200]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	movzx	eax, WORD PTR [rdi+92]
	mov	WORD PTR Instruction$18[rbp-160], ax
	lea	rdx, QWORD PTR [rdi+100]
	lea	rcx, QWORD PTR Instruction$18[rbp-152]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 243  : 			if (Instruction.LHSSource != EXB::Source::Unknown || Instruction.RHSSource != EXB::Source::Unknown)

	movzx	edx, BYTE PTR Instruction$18[rbp-251]
	movzx	eax, BYTE PTR Instruction$18[rbp-252]
	cmp	al, 11
	jne	SHORT $LN43@ToBinary
	cmp	dl, al
	je	SHORT $LN45@ToBinary
$LN43@ToBinary:

; 244  : 			{
; 245  : 				uint32_t Size = Instruction.DataType == EXB::Type::Vec3f ? 12 : 4;

	mov	ecx, 4
	cmp	WORD PTR Instruction$18[rbp-254], 6
	mov	r8d, 12
	cmove	ecx, r8d

; 246  : 				if (Instruction.LHSSource == EXB::Source::Scratch32)

	cmp	al, 7
	jne	SHORT $LN44@ToBinary

; 247  : 					Scratch64Size = std::max(Scratch64Size, Instruction.LHSIndexValue + Size);

	movzx	eax, WORD PTR Instruction$18[rbp-250]
	add	eax, ecx
	cmp	ebx, eax
	cmovb	ebx, eax
$LN44@ToBinary:

; 248  : 				if (Instruction.RHSSource == EXB::Source::Scratch32)

	cmp	dl, 7
	jne	SHORT $LN45@ToBinary

; 249  : 					Scratch64Size = std::max(Scratch64Size, Instruction.RHSIndexValue + Size);

	movzx	eax, WORD PTR Instruction$18[rbp-248]
	add	eax, ecx
	cmp	ebx, eax
	cmovb	ebx, eax
$LN45@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$18[rbp-152]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Instruction$18[rbp-168]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN2203@ToBinary[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN1044@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$18[rbp-200]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, OFFSET FLAT:__ImageBase
$LN1061@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Instruction$18[rbp-208]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN2202@ToBinary[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN1107@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$18[rbp-240]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN11@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 241  : 		for (EXB::InstructionStruct Instruction : Cmd.Instructions)

	add	rdi, 136				; 00000088H
	lea	rax, QWORD PTR [rdi-4]
	cmp	rax, rsi
	jne	$LL13@ToBinary
$LN12@ToBinary:

; 250  : 			}
; 251  : 		}
; 252  : 		Max64 = std::max(Max64, Scratch64Size);

	mov	edi, DWORD PTR Max64$1$[rsp]
	cmp	edi, ebx
	cmovb	edi, ebx
	mov	DWORD PTR Max64$1$[rsp], edi

; 253  : 		Writer.WriteInteger(Scratch64Size, sizeof(uint16_t));

	mov	edx, ebx
	mov	r8d, 2
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR Cmd$14[rbp-216]
	mov	rdx, QWORD PTR Cmd$14[rbp-224]
	sub	rax, rdx
	sar	rax, 3
	mov	rbx, -1085102592571150095		; f0f0f0f0f0f0f0f1H
	imul	rax, rbx

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, -2
	imul	r8, rax, 136				; 00000088H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 255  : 		if (Cmd.Instructions[Cmd.Instructions.size() - 2].LHSSource != EXB::Source::Unknown && (Cmd.Instructions[Cmd.Instructions.size() - 2].LHSSource == EXB::Source::ParamTbl || Cmd.Instructions[Cmd.Instructions.size() - 2].LHSSource == EXB::Source::Output))

	movzx	eax, BYTE PTR [r8+rdx+4]
	cmp	al, 11
	je	SHORT $LN46@ToBinary
	sub	al, 3
	test	al, 253					; 000000fdH
	jne	SHORT $LN46@ToBinary

; 256  : 		{
; 257  : 			Writer.WriteInteger((uint16_t)Cmd.Instructions[Cmd.Instructions.size() - 2].DataType, sizeof(uint16_t));

	movzx	edx, WORD PTR [r8+rdx+2]

; 258  : 		}

	jmp	SHORT $LN2219@ToBinary
$LN46@ToBinary:

; 259  : 		else
; 260  : 		{
; 261  : 			Writer.WriteInteger(1, sizeof(uint16_t));

	mov	edx, 1
$LN2219@ToBinary:

; 262  : 		}
; 263  : 		if (Cmd.Instructions[0].RHSSource != EXB::Source::Unknown && (Cmd.Instructions[0].RHSSource == EXB::Source::ParamTbl || Cmd.Instructions[0].RHSSource == EXB::Source::Input))

	mov	r8d, 2
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
	mov	rdx, QWORD PTR Cmd$14[rbp-224]
	movzx	eax, BYTE PTR [rdx+5]
	cmp	al, 11
	je	SHORT $LN49@ToBinary
	cmp	al, 3
	je	SHORT $LN51@ToBinary
	cmp	al, 6
	jne	SHORT $LN49@ToBinary
$LN51@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR Cmd$14[rbp-216]
	sub	rax, rdx
	sar	rax, 3
	imul	rax, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 265  : 			Writer.WriteInteger((uint16_t)Cmd.Instructions[Cmd.Instructions.size() - 2].DataType, sizeof(uint16_t));

	add	rax, -2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rcx, rax, 136				; 00000088H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 265  : 			Writer.WriteInteger((uint16_t)Cmd.Instructions[Cmd.Instructions.size() - 2].DataType, sizeof(uint16_t));

	movzx	edx, WORD PTR [rcx+rdx+2]

; 266  : 		}

	jmp	SHORT $LN2220@ToBinary
$LN49@ToBinary:

; 267  : 		else
; 268  : 		{
; 269  : 			Writer.WriteInteger(1, sizeof(uint16_t));

	mov	edx, 1
$LN2220@ToBinary:

; 270  : 		}
; 271  : 	}

	mov	r8d, 2
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Cmd$14[rbp-224]
	call	?_Tidy@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXXZ ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Tidy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 198  : 	for (EXB::CommandInfoStruct Cmd : this->Commands)

	add	r14, 56					; 00000038H
	cmp	r14, r15
	jne	$LL4@ToBinary
	xor	edi, edi
$LN2190@ToBinary:
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR NewInstructions$[rbp-256], xmm1
	mov	QWORD PTR NewInstructions$[rbp-240], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 275  : 	for (EXB::CommandInfoStruct Cmd : this->Commands)

	mov	rsi, QWORD PTR [r13+48]
	mov	r14, QWORD PTR [r13+56]
	cmp	rsi, r14
	je	$LN15@ToBinary
	npad	9
$LL16@ToBinary:
	mov	rdx, rsi
	lea	rcx, QWORD PTR Cmd$13[rbp-256]
	call	??0CommandInfoStruct@EXB@@QEAA@AEBU01@@Z
	npad	1

; 277  : 		for (EXB::InstructionStruct Inst : Cmd.Instructions)

	mov	rdi, QWORD PTR Cmd$13[rbp-216]
	mov	rbx, QWORD PTR Cmd$13[rbp-224]
	cmp	rbx, rdi
	je	$LN18@ToBinary

; 275  : 	for (EXB::CommandInfoStruct Cmd : this->Commands)

	add	rbx, 4
	npad	14
$LL19@ToBinary:
	movzx	eax, BYTE PTR [rbx-4]
	mov	BYTE PTR Inst$17[rbp-256], al
	movzx	eax, WORD PTR [rbx-2]
	mov	WORD PTR Inst$17[rbp-254], ax
	movzx	eax, BYTE PTR [rbx]
	mov	BYTE PTR Inst$17[rbp-252], al
	movzx	eax, BYTE PTR [rbx+1]
	mov	BYTE PTR Inst$17[rbp-251], al
	movzx	eax, WORD PTR [rbx+2]
	mov	WORD PTR Inst$17[rbp-250], ax
	movzx	eax, WORD PTR [rbx+4]
	mov	WORD PTR Inst$17[rbp-248], ax
	lea	rdx, QWORD PTR [rbx+12]
	lea	rcx, QWORD PTR Inst$17[rbp-240]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	lea	rdx, QWORD PTR [rbx+52]
	lea	rcx, QWORD PTR Inst$17[rbp-200]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	movzx	eax, WORD PTR [rbx+92]
	mov	WORD PTR Inst$17[rbp-160], ax
	lea	rdx, QWORD PTR [rbx+100]
	lea	rcx, QWORD PTR Inst$17[rbp-152]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR NewInstructions$[rbp-248]
	cmp	rax, QWORD PTR NewInstructions$[rbp-240]
	je	SHORT $LN1385@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR Inst$17[rbp-256]
	mov	rcx, rax
	call	??0InstructionStruct@EXB@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR NewInstructions$[rbp-248], 136 ; 00000088H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN1384@ToBinary
$LN1119@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN1056@ToBinary:
$LN1385@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Inst$17[rbp-256]
	mov	rdx, rax
	lea	rcx, QWORD PTR NewInstructions$[rbp-256]
	call	??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_reallocate<EXB::InstructionStruct const &>
	npad	1
$LN1384@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Inst$17[rbp-152]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR Inst$17[rbp-200]
	call	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	lea	rcx, QWORD PTR Inst$17[rbp-240]
	call	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 277  : 		for (EXB::InstructionStruct Inst : Cmd.Instructions)

	add	rbx, 136				; 00000088H
	lea	rax, QWORD PTR [rbx-4]
	cmp	rax, rdi
	jne	$LL19@ToBinary
$LN18@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR Cmd$13[rbp-224]
	call	?_Tidy@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXXZ ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Tidy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 275  : 	for (EXB::CommandInfoStruct Cmd : this->Commands)

	add	rsi, 56					; 00000038H
	cmp	rsi, r14
	jne	$LL16@ToBinary
	mov	rbx, -1085102592571150095		; f0f0f0f0f0f0f0f1H
	xor	edi, edi
$LN15@ToBinary:

; 278  : 		{
; 279  : 			NewInstructions.push_back(Inst);
; 280  : 		}
; 281  : 	}
; 282  : 	this->Instructions = NewInstructions;

	lea	rcx, QWORD PTR [r13+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR NewInstructions$[rbp-256]
	cmp	rcx, rax
	je	SHORT $LN1680@ToBinary

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR NewInstructions$[rbp-248]
	mov	rdx, QWORD PTR NewInstructions$[rbp-256]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rbx
	call	??$_Assign_counted_range@PEAUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXPEAUInstructionStruct@EXB@@_K@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Assign_counted_range<EXB::InstructionStruct *>
$LN1680@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 284  : 	uint32_t CommandStart = Writer.GetPosition();

	mov	eax, DWORD PTR Writer$[rbp-232]
	mov	DWORD PTR CommandStart$1$[rsp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR NewInstructions$[rbp-248]
	sub	rdx, QWORD PTR NewInstructions$[rbp-256]
	sar	rdx, 3
	imul	rdx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 285  : 	Writer.WriteInteger(NewInstructions.size(), sizeof(uint32_t));

	mov	r8d, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR SignatureOffsets$[rbp-256], xmm1
	mov	QWORD PTR SignatureOffsets$[rbp-240], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 288  : 	for (EXB::InstructionStruct Instruction : NewInstructions)

	mov	r12, QWORD PTR NewInstructions$[rbp-248]
	mov	r15, 9223372036854775807		; 7fffffffffffffffH
	mov	r13, -1
	mov	r14, QWORD PTR NewInstructions$[rbp-256]
	cmp	r14, r12
	je	$LN21@ToBinary

; 284  : 	uint32_t CommandStart = Writer.GetPosition();

	add	r14, 4
	lea	rbx, OFFSET FLAT:__ImageBase
	npad	5
$LL22@ToBinary:
	movzx	eax, BYTE PTR [r14-4]
	mov	BYTE PTR Instruction$16[rbp-256], al
	movzx	eax, WORD PTR [r14-2]
	mov	WORD PTR Instruction$16[rbp-254], ax
	movzx	eax, BYTE PTR [r14]
	mov	BYTE PTR Instruction$16[rbp-252], al
	movzx	eax, BYTE PTR [r14+1]
	mov	BYTE PTR Instruction$16[rbp-251], al
	movzx	eax, WORD PTR [r14+2]
	mov	WORD PTR Instruction$16[rbp-250], ax
	movzx	eax, WORD PTR [r14+4]
	mov	WORD PTR Instruction$16[rbp-248], ax
	lea	rdx, QWORD PTR [r14+12]
	lea	rcx, QWORD PTR Instruction$16[rbp-240]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	lea	rdx, QWORD PTR [r14+52]
	lea	rcx, QWORD PTR Instruction$16[rbp-200]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	movzx	eax, WORD PTR [r14+92]
	mov	WORD PTR Instruction$16[rbp-160], ax
	lea	rdx, QWORD PTR [r14+100]
	lea	rcx, QWORD PTR Instruction$16[rbp-152]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 289  : 	{
; 290  : 		if (Instruction.Type != EXB::Command::Terminator)

	movzx	eax, BYTE PTR Instruction$16[rbp-256]
	cmp	al, 1
	je	$LN52@ToBinary

; 291  : 		{
; 292  : 			Writer.WriteInteger((uint8_t)Instruction.Type, sizeof(uint8_t));

	mov	edx, eax
	mov	r8d, 1
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 293  : 			Writer.WriteInteger((uint8_t)Instruction.DataType, sizeof(uint8_t));

	movzx	edx, BYTE PTR Instruction$16[rbp-254]
	mov	r8d, 1
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 294  : 			
; 295  : 			if (Instruction.LHSSource != EXB::Source::Unknown)

	movzx	eax, BYTE PTR Instruction$16[rbp-252]
	cmp	al, 11
	je	SHORT $LN54@ToBinary

; 296  : 				Writer.WriteInteger((uint8_t)Instruction.LHSSource, sizeof(uint8_t));

	mov	edx, eax
	mov	r8d, 1
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
$LN54@ToBinary:

; 297  : 			if (Instruction.RHSSource != EXB::Source::Unknown)

	movzx	eax, BYTE PTR Instruction$16[rbp-251]
	cmp	al, 11
	je	SHORT $LN55@ToBinary

; 298  : 				Writer.WriteInteger((uint8_t)Instruction.RHSSource, sizeof(uint8_t));

	mov	edx, eax
	mov	r8d, 1
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
$LN55@ToBinary:

; 299  : 			
; 300  : 			if (Instruction.LHSIndexValue != 0xFFFF)

	movzx	eax, WORD PTR Instruction$16[rbp-250]
	mov	ebx, 65535				; 0000ffffH
	cmp	ax, bx
	je	SHORT $LN56@ToBinary

; 301  : 				Writer.WriteInteger((uint16_t)Instruction.LHSIndexValue, sizeof(uint16_t));

	mov	edx, eax
	mov	r8d, 2
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
$LN56@ToBinary:

; 302  : 			if (Instruction.RHSIndexValue != 0xFFFF)

	movzx	eax, WORD PTR Instruction$16[rbp-248]
	cmp	ax, bx
	je	SHORT $LN57@ToBinary

; 303  : 				Writer.WriteInteger((uint16_t)Instruction.RHSIndexValue, sizeof(uint16_t));

	mov	edx, eax
	mov	r8d, 2
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
$LN57@ToBinary:

; 304  : 		
; 305  : 			if (Instruction.StaticMemoryIndex != 0xFFFF)

	movzx	eax, WORD PTR Instruction$16[rbp-160]
	cmp	ax, bx
	je	SHORT $LN58@ToBinary

; 306  : 				Writer.WriteInteger(Instruction.StaticMemoryIndex, sizeof(uint16_t));

	mov	edx, eax
	mov	r8d, 2
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
$LN58@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR Instruction$16[rbp-152]

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR Instruction$16[rbp-128], 16
	setae	r15b

; 2236 :         if (_Large_string_engaged()) {

	mov	rbx, QWORD PTR Instruction$16[rbp-152]
	cmovae	rcx, rbx

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	mov	rdi, QWORD PTR Instruction$16[rbp-136]
	cmp	rdi, 19
	jne	SHORT $LN1493@ToBinary

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0BE@MABBHOKL@MapEditor_EXB_NoVal@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN2216@ToBinary
$LN1493@ToBinary:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T4[rsp+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rsp+24], rax

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rsi, QWORD PTR Instruction$16[rbp-152]

; 2236 :         if (_Large_string_engaged()) {

	test	r15b, r15b
	cmovne	rsi, rbx

; 2620 :         if (_Count > max_size()) {

	mov	r15, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdi, r15
	ja	$LN1880@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T4[rsp+24], 15
	cmp	rdi, 16
	jae	SHORT $LN1560@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rsp+16], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T4[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN1568@ToBinary
$LN1560@ToBinary:

; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rdi
	lea	rcx, QWORD PTR $T4[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	cmovb	rdx, r13
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T4[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rsp+16], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T4[rsp+24], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
$LN1568@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 310  : 				AddToStringTable(Instruction.Signature, StringTable);

	lea	r8, QWORD PTR StringTable$[rbp-256]
	lea	rdx, QWORD PTR $T4[rsp]
	call	?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; EXB::AddToStringTable
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T7[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	ebx, ebx
	mov	QWORD PTR $T7[rbp-240], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T7[rbp-232], rbx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR Instruction$16[rbp-136]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rsi, QWORD PTR Instruction$16[rbp-152]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Instruction$16[rbp-128], 16
	cmovae	rsi, QWORD PTR Instruction$16[rbp-152]

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, r15
	ja	$LN1881@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T7[rbp-232], 15
	cmp	rdi, 16
	jae	SHORT $LN1592@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rbp-240], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T7[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN1600@ToBinary
$LN1592@ToBinary:

; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rdi
	lea	rcx, QWORD PTR $T7[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	cmovb	rdx, r13
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T7[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rbp-240], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T7[rbp-232], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
	xor	ebx, ebx
$LN1600@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 311  : 				if (std::find(SignatureOffsets.begin(), SignatureOffsets.end(), GetOffsetInStringTable(Instruction.Signature, StringTable)) == SignatureOffsets.end())

	lea	r8, QWORD PTR StringTable$[rbp-256]
	lea	rdx, QWORD PTR $T7[rsp]
	call	?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; EXB::GetOffsetInStringTable
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 124  :         return const_cast<_Ty*>(

	mov	r8d, eax
	mov	rdx, QWORD PTR SignatureOffsets$[rbp-248]
	mov	rcx, QWORD PTR SignatureOffsets$[rbp-256]
	call	__std_find_trivial_4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 311  : 				if (std::find(SignatureOffsets.begin(), SignatureOffsets.end(), GetOffsetInStringTable(Instruction.Signature, StringTable)) == SignatureOffsets.end())

	cmp	rax, QWORD PTR SignatureOffsets$[rbp-248]
	jne	$LN1727@ToBinary
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T12[rbp-240], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T12[rbp-232], rbx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR Instruction$16[rbp-136]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rsi, QWORD PTR Instruction$16[rbp-152]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Instruction$16[rbp-128], 16
	cmovae	rsi, QWORD PTR Instruction$16[rbp-152]

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, r15
	ja	$LN1882@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T12[rbp-232], 15
	cmp	rdi, 16
	jae	SHORT $LN1710@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T12[rbp-240], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T12[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN1718@ToBinary
$LN1710@ToBinary:

; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rdi
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	cmovb	rdx, r13
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T12[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T12[rbp-240], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T12[rbp-232], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
	xor	ebx, ebx
$LN1718@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 313  : 					SignatureOffsets.push_back(GetOffsetInStringTable(Instruction.Signature, StringTable));

	lea	r8, QWORD PTR StringTable$[rbp-256]
	lea	rdx, QWORD PTR $T12[rbp-256]
	call	?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; EXB::GetOffsetInStringTable
	mov	DWORD PTR $T1[rsp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR SignatureOffsets$[rbp-248]
	cmp	rdx, QWORD PTR SignatureOffsets$[rbp-240]
	je	SHORT $LN1728@ToBinary

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], eax

; 806  :         ++_Mylast;

	add	QWORD PTR SignatureOffsets$[rbp-248], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN1727@ToBinary
$LN1728@ToBinary:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR SignatureOffsets$[rbp-256]
	call	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAH$$QEAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
$LN1727@ToBinary:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T11[rbp-240], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T11[rbp-232], rbx

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR Instruction$16[rbp-136]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rsi, QWORD PTR Instruction$16[rbp-152]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Instruction$16[rbp-128], 16
	cmovae	rsi, QWORD PTR Instruction$16[rbp-152]

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, r15
	ja	$LN1883@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T11[rbp-232], 15
	cmp	rdi, 16
	jae	SHORT $LN1528@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T11[rbp-240], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T11[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN1536@ToBinary
$LN1528@ToBinary:

; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, rdi
	lea	rcx, QWORD PTR $T11[rbp-256]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	cmovb	rdx, r13
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T11[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T11[rbp-240], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T11[rbp-232], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
$LN1536@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 315  : 				Writer.WriteInteger((uint32_t)std::distance(SignatureOffsets.begin(), std::find(SignatureOffsets.begin(), SignatureOffsets.end(), GetOffsetInStringTable(Instruction.Signature, StringTable))), sizeof(uint32_t));

	lea	r8, QWORD PTR StringTable$[rbp-256]
	lea	rdx, QWORD PTR $T11[rbp-256]
	call	?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; EXB::GetOffsetInStringTable
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 124  :         return const_cast<_Ty*>(

	mov	r8d, eax
	mov	rdx, QWORD PTR SignatureOffsets$[rbp-248]
	mov	rcx, QWORD PTR SignatureOffsets$[rbp-256]
	call	__std_find_trivial_4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 154  :         return _Ptr - _Right._Ptr;

	sub	rax, QWORD PTR SignatureOffsets$[rbp-256]
	sar	rax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 315  : 				Writer.WriteInteger((uint32_t)std::distance(SignatureOffsets.begin(), std::find(SignatureOffsets.begin(), SignatureOffsets.end(), GetOffsetInStringTable(Instruction.Signature, StringTable))), sizeof(uint32_t));

	mov	edx, eax
	mov	r8d, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 316  : 			}
; 317  : 		}

	jmp	$LN2221@ToBinary
$LN52@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN1470@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN1470@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 1

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], 1

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, rax
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-232], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	lea	eax, DWORD PTR [r8+7]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN1457@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+8]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
$LN1457@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	r8d, 7
	mov	DWORD PTR Writer$[rbp-232], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	jmp	SHORT $LN1458@ToBinary
$LN2216@ToBinary:
	mov	r15, 9223372036854775807		; 7fffffffffffffffH
$LN2221@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 323  : 	}

	lea	rbx, OFFSET FLAT:__ImageBase
$LN1458@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$16[rbp-152]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Instruction$16[rbp-168]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN2201@ToBinary[rbx+rax*4+4]
	add	rax, rbx
	jmp	rax
$LN1283@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$16[rbp-200]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1300@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Instruction$16[rbp-208]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN2200@ToBinary[rbx+rax*4+4]
	add	rax, rbx
	jmp	rax
$LN1346@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$16[rbp-240]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN20@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 288  : 	for (EXB::InstructionStruct Instruction : NewInstructions)

	add	r14, 136				; 00000088H
	lea	rax, QWORD PTR [r14-4]
	cmp	rax, r12
	jne	$LL22@ToBinary
$LN21@ToBinary:

; 324  : 
; 325  : 	uint32_t SigStart = Writer.GetPosition();

	mov	eax, DWORD PTR Writer$[rbp-232]
	mov	DWORD PTR SigStart$1$[rsp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR SignatureOffsets$[rbp-248]
	sub	rdx, QWORD PTR SignatureOffsets$[rbp-256]
	sar	rdx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 326  : 	Writer.WriteInteger(SignatureOffsets.size(), sizeof(uint32_t));

	mov	r8d, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 327  : 	for (int Offset : SignatureOffsets)

	mov	rbx, QWORD PTR SignatureOffsets$[rbp-256]
	mov	rsi, QWORD PTR SignatureOffsets$[rbp-248]
	mov	r14d, DWORD PTR Writer$[rbp-232]
	cmp	rbx, rsi
	je	$LN2204@ToBinary
	npad	10
$LL25@ToBinary:
	mov	edi, DWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [r14+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN991@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN991@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	r8, rdi
	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], r8b
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r14d, DWORD PTR Writer$[rbp-232]
	add	r14d, 4
	mov	DWORD PTR Writer$[rbp-232], r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 327  : 	for (int Offset : SignatureOffsets)

	add	rbx, 4
	cmp	rbx, rsi
	jne	$LL25@ToBinary
$LN2204@ToBinary:

; 328  : 	{
; 329  : 		Writer.WriteInteger((uint32_t)Offset, sizeof(uint32_t));
; 330  : 	}
; 331  : 
; 332  : 	uint32_t ParamStart = Writer.GetPosition();
; 333  : 	uint32_t StringStart = ParamStart;

	mov	DWORD PTR ParamStart$1$[rsp], r14d
	mov	r13d, r14d

; 334  : 	for (EXB::InstructionStruct Instruction : NewInstructions)

	mov	r12, QWORD PTR NewInstructions$[rbp-256]
	mov	rbx, QWORD PTR NewInstructions$[rbp-248]
	mov	QWORD PTR <end>$L8$1$[rsp], rbx
	cmp	r12, rbx
	je	$LN27@ToBinary
	lea	rdi, OFFSET FLAT:__ImageBase
	npad	5
$LL28@ToBinary:
	movzx	eax, BYTE PTR [r12]
	mov	BYTE PTR Instruction$15[rbp-256], al
	movzx	eax, WORD PTR [r12+2]
	mov	WORD PTR Instruction$15[rbp-254], ax
	movzx	eax, BYTE PTR [r12+4]
	mov	BYTE PTR Instruction$15[rbp-252], al
	movzx	eax, BYTE PTR [r12+5]
	mov	BYTE PTR Instruction$15[rbp-251], al
	movzx	eax, WORD PTR [r12+6]
	mov	WORD PTR Instruction$15[rbp-250], ax
	movzx	eax, WORD PTR [r12+8]
	mov	WORD PTR Instruction$15[rbp-248], ax
	lea	rdx, QWORD PTR [r12+16]
	lea	rcx, QWORD PTR Instruction$15[rbp-240]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	lea	rdx, QWORD PTR [r12+56]
	lea	rcx, QWORD PTR Instruction$15[rbp-200]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@AEBV01@@Z
	npad	1
	movzx	eax, WORD PTR [r12+96]
	mov	WORD PTR Instruction$15[rbp-160], ax
	lea	rdx, QWORD PTR [r12+104]
	lea	rcx, QWORD PTR Instruction$15[rbp-152]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 335  : 	{
; 336  : 		if (*reinterpret_cast<uint32_t*>(&Instruction.LHSValue) != 0xFFFF)

	mov	edx, DWORD PTR Instruction$15[rbp-240]
	mov	eax, 65535				; 0000ffffH
	cmp	edx, eax
	je	$LN79@ToBinary

; 337  : 		{
; 338  : 			if (Instruction.LHSSource == EXB::Source::ParamTbl)

	cmp	BYTE PTR Instruction$15[rbp-252], 3
	jne	$LN2205@ToBinary

; 339  : 			{
; 340  : 				Writer.Seek(ParamStart + Instruction.LHSIndexValue, BinaryVectorWriter::Position::Begin);

	movzx	ebx, WORD PTR Instruction$15[rbp-250]
	add	ebx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Writer$[rbp-248]
	sub	rcx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, ebx
	cmp	rax, rcx
	jbe	SHORT $LN838@ToBinary

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	edx, DWORD PTR Instruction$15[rbp-240]
$LN838@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-232], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 341  : 				if (Instruction.DataType == EXB::Type::Vec3f)

	cmp	WORD PTR Instruction$15[rbp-254], 6
	jne	$LN63@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [rbx+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LL1171@ToBinary

; 71   : 	{
; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ebx, DWORD PTR Writer$[rbp-232]
	npad	13
$LL1171@ToBinary:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)
; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, ebx
	movzx	ecx, BYTE PTR Instruction$15[rbp-240]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-239]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-238]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-237]
	mov	BYTE PTR [rdx+rcx], al

; 77   : 	}
; 78   : 	this->m_Offset += Size;

	mov	edx, DWORD PTR Writer$[rbp-232]
	add	edx, 4
	mov	DWORD PTR Writer$[rbp-232], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR Writer$[rbp-248]
	mov	r9, QWORD PTR Writer$[rbp-256]
	sub	r8, r9
	lea	eax, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, r8
	jbe	SHORT $LL1159@ToBinary

; 71   : 	{
; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	lea	rdx, QWORD PTR [r8+4]
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	edx, DWORD PTR Writer$[rbp-232]
	mov	r9, QWORD PTR Writer$[rbp-256]
	npad	4
$LL1159@ToBinary:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)
; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, edx
	movzx	eax, BYTE PTR Instruction$15[rbp-236]
	mov	BYTE PTR [rcx+r9], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-235]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-234]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-233]
	mov	BYTE PTR [rdx+rcx], al

; 77   : 	}
; 78   : 	this->m_Offset += Size;

	mov	edx, DWORD PTR Writer$[rbp-232]
	add	edx, 4
	mov	DWORD PTR Writer$[rbp-232], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR Writer$[rbp-248]
	mov	r9, QWORD PTR Writer$[rbp-256]
	sub	r8, r9
	lea	eax, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, r8
	jbe	SHORT $LL1147@ToBinary

; 71   : 	{
; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	lea	rdx, QWORD PTR [r8+4]
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	edx, DWORD PTR Writer$[rbp-232]
	mov	r9, QWORD PTR Writer$[rbp-256]
	npad	7
$LL1147@ToBinary:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)
; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, edx
	movzx	eax, BYTE PTR Instruction$15[rbp-232]
	mov	BYTE PTR [rcx+r9], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-231]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-230]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rdx, eax
	movzx	eax, BYTE PTR Instruction$15[rbp-229]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 347  : 				}

	jmp	$LN2222@ToBinary
$LN1358@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN1295@ToBinary:
$LN63@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 348  : 				else if (Instruction.DataType == EXB::Type::S32)

	cmp	WORD PTR Instruction$15[rbp-254], 3
	jne	SHORT $LN65@ToBinary

; 349  : 				{
; 350  : 					Writer.WriteInteger(*reinterpret_cast<uint32_t*>(&Instruction.LHSValue), sizeof(uint32_t));

	mov	r8d, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 351  : 					StringStart = std::max(StringStart, (uint32_t)Writer.GetPosition());

	cmp	r13d, DWORD PTR Writer$[rbp-232]
	cmovb	r13d, DWORD PTR Writer$[rbp-232]

; 352  : 				}

	jmp	$LN2205@ToBinary
$LN65@ToBinary:

; 353  : 				else if (Instruction.DataType == EXB::Type::F32)

	cmp	WORD PTR Instruction$15[rbp-254], 4
	jne	$LN2205@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [rbx+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LL1431@ToBinary

; 71   : 	{
; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ebx, DWORD PTR Writer$[rbp-232]
	npad	10
$LL1431@ToBinary:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)
; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, ebx
	movzx	ecx, BYTE PTR Instruction$15[rbp-240]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-239]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-238]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rdx, eax
	movzx	eax, BYTE PTR Instruction$15[rbp-237]
$LN2222@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 364  : 			if (Instruction.LHSSource == EXB::Source::ParamTblStr)

	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	cmp	r13d, eax
	cmovb	r13d, eax
	mov	DWORD PTR Writer$[rbp-232], eax
$LN2205@ToBinary:
	cmp	BYTE PTR Instruction$15[rbp-252], 4
	jne	$LN70@ToBinary

; 365  : 			{
; 366  : 				Writer.Seek(ParamStart + Instruction.LHSIndexValue, BinaryVectorWriter::Position::Begin);

	movzx	ebx, WORD PTR Instruction$15[rbp-250]
	add	ebx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Writer$[rbp-248]
	sub	rcx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, ebx
	cmp	rax, rcx
	jbe	SHORT $LN755@ToBinary

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN755@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-232], ebx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T3[rsp+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rsp+24], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR Instruction$15[rbp-224]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdi, QWORD PTR Instruction$15[rbp-240]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Instruction$15[rbp-216], 16
	cmovae	rdi, QWORD PTR Instruction$15[rbp-240]

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, r15
	ja	$LN1886@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN607@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T3[rsp+16], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	eax, 15
	mov	QWORD PTR $T3[rsp+24], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR $T3[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN623@ToBinary
$LN607@ToBinary:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 15
	mov	rbx, rsi
	or	rbx, 15

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	rbx, r15

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN618@ToBinary

; 4716 :             return _Max;

	mov	rbx, r15
	jmp	SHORT $LN617@ToBinary
$LN618@ToBinary:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN617@ToBinary:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T3[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T3[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T3[rsp+24], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rdi
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR $T3[rsp+24]
	mov	rsi, QWORD PTR $T3[rsp+16]
$LN623@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 367  : 				AddToStringTable(*reinterpret_cast<std::string*>(&Instruction.LHSValue), StringTable);

	lea	rcx, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T6[rsp], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5851 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

	mov	rbx, QWORD PTR StringTable$[rbp-256]
	mov	rdi, QWORD PTR StringTable$[rbp-248]
	cmp	rbx, rdi

; 5836 :     for (; _First != _Last; ++_First) {

	je	SHORT $LN2224@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rax, 16
	setae	r14b
	mov	r15, QWORD PTR $T3[rsp]
	npad	6
$LL790@ToBinary:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T3[rsp]

; 2236 :         if (_Large_string_engaged()) {

	test	r14b, r14b
	cmovne	rdx, r15

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN803@ToBinary

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN803@ToBinary:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rsi
	jne	SHORT $LN809@ToBinary

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN2213@ToBinary
$LN809@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5836 :     for (; _First != _Last; ++_First) {

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL790@ToBinary
$LN2213@ToBinary:
	mov	r14d, DWORD PTR ParamStart$1$[rsp]
	mov	r15, 9223372036854775807		; 7fffffffffffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 11   : 	if (it == StringTable.end())

	cmp	rbx, rdi
	jne	SHORT $LN823@ToBinary
$LN2224@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdi, QWORD PTR StringTable$[rbp-240]
	je	SHORT $LN824@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR StringTable$[rbp-248], 32	; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN823@ToBinary
$LN824@ToBinary:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T3[rsp]
	mov	rdx, rdi
	lea	rcx, QWORD PTR StringTable$[rbp-256]
	call	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	npad	1
$LN823@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T3[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T10[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T10[rbp-240], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T10[rbp-232], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR Instruction$15[rbp-224]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rsi, QWORD PTR Instruction$15[rbp-240]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Instruction$15[rbp-216], 16
	cmovae	rsi, QWORD PTR Instruction$15[rbp-240]

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, r15
	ja	$LN1887@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T10[rbp-232], 15
	cmp	rdi, 16
	jae	SHORT $LN913@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T10[rbp-240], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T10[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN929@ToBinary
$LN913@ToBinary:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	rbx, rdi
	or	rbx, 15

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	rbx, r15

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN924@ToBinary

; 4716 :             return _Max;

	mov	rbx, r15
	jmp	SHORT $LN923@ToBinary
$LN924@ToBinary:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN923@ToBinary:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T10[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T10[rbp-240], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T10[rbp-232], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
$LN929@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 368  : 				Writer.WriteInteger(GetOffsetInStringTable(*reinterpret_cast<std::string*>(&Instruction.LHSValue), StringTable), sizeof(uint32_t));

	lea	r8, QWORD PTR StringTable$[rbp-256]
	lea	rdx, QWORD PTR $T10[rbp-256]
	call	?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; EXB::GetOffsetInStringTable
	movsxd	rbx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN886@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN886@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], bl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 369  : 				StringStart = std::max(StringStart, (uint32_t)Writer.GetPosition());

	cmp	r13d, eax
	cmovb	r13d, eax
$LN70@ToBinary:

; 370  : 			}
; 371  : 
; 372  : 			if (Instruction.RHSSource == EXB::Source::ParamTbl)

	cmp	BYTE PTR Instruction$15[rbp-251], 3
	jne	$LN2206@ToBinary

; 373  : 			{
; 374  : 				Writer.Seek(ParamStart + Instruction.RHSIndexValue, BinaryVectorWriter::Position::Begin);

	movzx	ebx, WORD PTR Instruction$15[rbp-248]
	add	ebx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Writer$[rbp-248]
	sub	rcx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, ebx
	cmp	rax, rcx
	jbe	SHORT $LN868@ToBinary

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN868@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-232], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 375  : 				if (Instruction.DataType == EXB::Type::Vec3f)

	cmp	WORD PTR Instruction$15[rbp-254], 6
	jne	$LN72@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [rbx+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LL1183@ToBinary

; 71   : 	{
; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ebx, DWORD PTR Writer$[rbp-232]
	npad	11
$LL1183@ToBinary:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)
; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, ebx
	movzx	ecx, BYTE PTR Instruction$15[rbp-200]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-199]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-198]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-197]
	mov	BYTE PTR [rdx+rcx], al

; 77   : 	}
; 78   : 	this->m_Offset += Size;

	mov	edx, DWORD PTR Writer$[rbp-232]
	add	edx, 4
	mov	DWORD PTR Writer$[rbp-232], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR Writer$[rbp-248]
	mov	r9, QWORD PTR Writer$[rbp-256]
	sub	r8, r9
	lea	eax, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, r8
	jbe	SHORT $LL1195@ToBinary

; 71   : 	{
; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	lea	rdx, QWORD PTR [r8+4]
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	edx, DWORD PTR Writer$[rbp-232]
	mov	r9, QWORD PTR Writer$[rbp-256]
	npad	4
$LL1195@ToBinary:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)
; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, edx
	movzx	eax, BYTE PTR Instruction$15[rbp-196]
	mov	BYTE PTR [rcx+r9], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-195]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-194]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-193]
	mov	BYTE PTR [rdx+rcx], al

; 77   : 	}
; 78   : 	this->m_Offset += Size;

	mov	edx, DWORD PTR Writer$[rbp-232]
	add	edx, 4
	mov	DWORD PTR Writer$[rbp-232], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR Writer$[rbp-248]
	mov	r9, QWORD PTR Writer$[rbp-256]
	sub	r8, r9
	lea	eax, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, r8
	jbe	SHORT $LL1207@ToBinary

; 71   : 	{
; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	lea	rdx, QWORD PTR [r8+4]
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	edx, DWORD PTR Writer$[rbp-232]
	mov	r9, QWORD PTR Writer$[rbp-256]
	npad	7
$LL1207@ToBinary:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)
; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, edx
	movzx	eax, BYTE PTR Instruction$15[rbp-192]
	mov	BYTE PTR [rcx+r9], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-191]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-190]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rdx, eax
	movzx	eax, BYTE PTR Instruction$15[rbp-189]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 381  : 				}

	jmp	$LN2225@ToBinary
$LN72@ToBinary:

; 382  : 				else if (Instruction.DataType == EXB::Type::S32)

	cmp	WORD PTR Instruction$15[rbp-254], 3
	jne	SHORT $LN74@ToBinary

; 383  : 				{
; 384  : 					Writer.WriteInteger(*reinterpret_cast<uint32_t*>(&Instruction.RHSValue), sizeof(uint32_t));

	mov	edx, DWORD PTR Instruction$15[rbp-200]
	mov	r8d, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger

; 385  : 					StringStart = std::max(StringStart, (uint32_t)Writer.GetPosition());

	cmp	r13d, DWORD PTR Writer$[rbp-232]
	cmovb	r13d, DWORD PTR Writer$[rbp-232]

; 386  : 				}

	jmp	$LN2206@ToBinary
$LN74@ToBinary:

; 387  : 				else if (Instruction.DataType == EXB::Type::F32)

	cmp	WORD PTR Instruction$15[rbp-254], 4
	jne	$LN2206@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [rbx+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LL1443@ToBinary

; 71   : 	{
; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ebx, DWORD PTR Writer$[rbp-232]
	npad	7
$LL1443@ToBinary:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)
; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, ebx
	movzx	ecx, BYTE PTR Instruction$15[rbp-200]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-199]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	mov	rcx, QWORD PTR Writer$[rbp-256]
	movzx	eax, BYTE PTR Instruction$15[rbp-198]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rdx, eax
	movzx	eax, BYTE PTR Instruction$15[rbp-197]
$LN2225@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 398  : 			if (Instruction.RHSSource == EXB::Source::ParamTblStr)

	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	cmp	r13d, eax
	cmovb	r13d, eax
	mov	DWORD PTR Writer$[rbp-232], eax
$LN2206@ToBinary:
	cmp	BYTE PTR Instruction$15[rbp-251], 4
	jne	$LN2215@ToBinary

; 399  : 			{
; 400  : 				Writer.Seek(ParamStart + Instruction.RHSIndexValue, BinaryVectorWriter::Position::Begin);

	movzx	ebx, WORD PTR Instruction$15[rbp-248]
	add	ebx, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Writer$[rbp-248]
	sub	rcx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, ebx
	cmp	rax, rcx
	jbe	SHORT $LN853@ToBinary

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN853@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-232], ebx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T2[rsp+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rsp+24], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR Instruction$15[rbp-184]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdi, QWORD PTR Instruction$15[rbp-200]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Instruction$15[rbp-176], 16
	cmovae	rdi, QWORD PTR Instruction$15[rbp-200]

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, r15
	ja	$LN1888@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN953@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rsp+16], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	eax, 15
	mov	QWORD PTR $T2[rsp+24], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR $T2[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN969@ToBinary
$LN953@ToBinary:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	QWORD PTR $T2[rsp+24], 15
	mov	rbx, rsi
	or	rbx, 15

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	rbx, r15

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN964@ToBinary

; 4716 :             return _Max;

	mov	rbx, r15
	jmp	SHORT $LN963@ToBinary
$LN964@ToBinary:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN963@ToBinary:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T2[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T2[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T2[rsp+24], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rdi
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR $T2[rsp+24]
	mov	rsi, QWORD PTR $T2[rsp+16]
$LN969@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 401  : 				AddToStringTable(*reinterpret_cast<std::string*>(&Instruction.RHSValue), StringTable);

	lea	rcx, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T5[rsp], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5851 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

	mov	rbx, QWORD PTR StringTable$[rbp-256]
	mov	rdi, QWORD PTR StringTable$[rbp-248]
	cmp	rbx, rdi

; 5836 :     for (; _First != _Last; ++_First) {

	je	SHORT $LN2227@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rax, 16
	setae	r14b
	mov	r15, QWORD PTR $T2[rsp]
	npad	6
$LL707@ToBinary:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T2[rsp]

; 2236 :         if (_Large_string_engaged()) {

	test	r14b, r14b
	cmovne	rdx, r15

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN720@ToBinary

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN720@ToBinary:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, rsi
	jne	SHORT $LN726@ToBinary

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN2214@ToBinary
$LN726@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5836 :     for (; _First != _Last; ++_First) {

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL707@ToBinary
$LN2214@ToBinary:
	mov	r14d, DWORD PTR ParamStart$1$[rsp]
	mov	r15, 9223372036854775807		; 7fffffffffffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 11   : 	if (it == StringTable.end())

	cmp	rbx, rdi
	jne	SHORT $LN740@ToBinary
$LN2227@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdi, QWORD PTR StringTable$[rbp-240]
	je	SHORT $LN741@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR StringTable$[rbp-248], 32	; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN740@ToBinary
$LN741@ToBinary:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T2[rsp]
	mov	rdx, rdi
	lea	rcx, QWORD PTR StringTable$[rbp-256]
	call	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	npad	1
$LN740@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T2[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T9[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T9[rbp-240], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T9[rbp-232], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR Instruction$15[rbp-184]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rsi, QWORD PTR Instruction$15[rbp-200]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Instruction$15[rbp-176], 16
	cmovae	rsi, QWORD PTR Instruction$15[rbp-200]

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, r15
	ja	$LN1889@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T9[rbp-232], 15
	cmp	rdi, 16
	jae	SHORT $LN661@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T9[rbp-240], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T9[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN677@ToBinary
$LN661@ToBinary:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	rbx, rdi
	or	rbx, 15

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	rbx, r15

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN672@ToBinary

; 4716 :             return _Max;

	mov	rbx, r15
	jmp	SHORT $LN671@ToBinary
$LN672@ToBinary:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN671@ToBinary:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T9[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T9[rbp-240], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T9[rbp-232], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
$LN677@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 402  : 				Writer.WriteInteger(GetOffsetInStringTable(*reinterpret_cast<std::string*>(&Instruction.RHSValue), StringTable), sizeof(uint32_t));

	lea	r8, QWORD PTR StringTable$[rbp-256]
	lea	rdx, QWORD PTR $T9[rbp-256]
	call	?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; EXB::GetOffsetInStringTable
	movsxd	rbx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN634@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN634@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], bl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 403  : 				StringStart = std::max(StringStart, (uint32_t)Writer.GetPosition());

	cmp	r13d, eax
	cmovb	r13d, eax
$LN2215@ToBinary:

; 404  : 			}
; 405  : 		}
; 406  : 	}

	lea	rdi, OFFSET FLAT:__ImageBase
	mov	rbx, QWORD PTR <end>$L8$1$[rsp]
$LN79@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$15[rbp-152]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Instruction$15[rbp-168]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN2199@ToBinary[rdi+rax*4+4]
	add	rax, rdi
	jmp	rax
$LN477@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$15[rbp-200]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN494@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR Instruction$15[rbp-208]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN2198@ToBinary[rdi+rax*4+4]
	add	rax, rdi
	jmp	rax
$LN540@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Instruction$15[rbp-240]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN26@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 334  : 	for (EXB::InstructionStruct Instruction : NewInstructions)

	add	r12, 136				; 00000088H
	cmp	r12, rbx
	jne	$LL28@ToBinary
$LN27@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Writer$[rbp-248]
	sub	rcx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, r13d
	cmp	rax, rcx
	jbe	SHORT $LN578@ToBinary

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [r13+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN578@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	r8d, r13d
	mov	DWORD PTR Writer$[rbp-232], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 409  : 	for (std::string String : StringTable)

	mov	r15, QWORD PTR StringTable$[rbp-256]
	mov	r12, QWORD PTR StringTable$[rbp-248]
$LN2229@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	cmp	r15, r12
	je	$LN30@ToBinary
	xorps	xmm0, xmm0
	movups	XMMWORD PTR String$8[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR String$8[rbp-240], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR String$8[rbp-232], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rbx, QWORD PTR [r15+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rsi, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN198@ToBinary

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [r15]
$LN198@ToBinary:

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rbx, rax
	ja	$LN1890@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rbx, 16
	jae	SHORT $LN204@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR String$8[rbp-240], rbx

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	edi, 15
	mov	QWORD PTR String$8[rbp-232], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR String$8[rbp-256], xmm0

; 2647 :             return;

	movq	r14, xmm0
	jmp	SHORT $LN220@ToBinary
$LN552@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN489@ToBinary:
$LN204@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rbx
	or	rdi, 15
	cmp	rdi, rax

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN215@ToBinary

; 4716 :             return _Max;

	mov	rdi, rax
	jmp	SHORT $LN214@ToBinary
$LN215@ToBinary:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	mov	eax, 22
	cmovb	rdi, rax
$LN214@ToBinary:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	r14, rax

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR String$8[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR String$8[rbp-240], rbx

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR String$8[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rbx+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
	mov	r8d, DWORD PTR Writer$[rbp-232]
$LN220@ToBinary:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR String$8[rbp-256]

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rdi, 16
	setae	sil

; 2236 :         if (_Large_string_engaged()) {

	cmovae	rbx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	mov	r11, -1
	mov	rcx, r11
	npad	6
$LL2197@ToBinary:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL2197@ToBinary
	movsxd	rax, r8d
	add	rax, rcx
	cmp	rax, rdx
	jbe	SHORT $LN343@ToBinary

; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, rcx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
	mov	r11, -1
$LN343@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	xor	r10d, r10d
	mov	rax, r11
$LL2196@ToBinary:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r10b
	jne	SHORT $LL2196@ToBinary
	test	rax, rax
	je	SHORT $LN2212@ToBinary
	mov	r9, rbx
$LL342@ToBinary:

; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r9]
	movsxd	rcx, r8d
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-232], r8d

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	inc	r10d
	lea	r9, QWORD PTR [r9+1]
	mov	rcx, r11
$LL2195@ToBinary:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL2195@ToBinary
	movsxd	rax, r10d
	cmp	rax, rcx
	jb	SHORT $LL342@ToBinary
$LN2212@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], 0

; 14   : 	this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-232], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	test	sil, sil
	je	SHORT $LN422@ToBinary

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [rdi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r14

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN434@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r14, QWORD PTR [r14-8]
	sub	rax, r14

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN431@ToBinary
$LN434@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r14
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	r8d, DWORD PTR Writer$[rbp-232]
$LN422@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 409  : 	for (std::string String : StringTable)

	add	r15, 32					; 00000020H
	jmp	$LN2229@ToBinary
$LN431@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR Writer$[rbp-248]
	sub	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	cmp	rax, 8
	jae	SHORT $LN398@ToBinary

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	mov	edx, 9
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN398@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-232], 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 418  : 	Writer.WriteInteger(MaxStatic, sizeof(uint32_t));

	mov	ebx, DWORD PTR MaxStatic$1$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	cmp	rdx, 12
	jae	SHORT $LN385@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN385@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], bl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN329@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN329@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	r8d, DWORD PTR EXBInstanceCount$1$[rsp]
	mov	QWORD PTR [rax], r8

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], r8b
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 420  : 	Writer.WriteInteger(Max32, sizeof(uint32_t));

	mov	ebx, DWORD PTR Max32$1$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN231@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN231@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], bl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 421  : 	Writer.WriteInteger(Max64, sizeof(uint32_t));

	mov	ebx, DWORD PTR Max64$1$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN315@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN315@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], bl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN301@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN301@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 44			; 0000002cH

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], 44			; 0000002cH
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN287@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN287@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	r8d, DWORD PTR CommandStart$1$[rsp]
	mov	QWORD PTR [rax], r8

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], r8b
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN273@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN273@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	r8d, DWORD PTR SigStart$1$[rsp]
	mov	QWORD PTR [rax], r8

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], r8b
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN259@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN259@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	r8d, DWORD PTR ParamStart$1$[rsp]
	mov	QWORD PTR [rax], r8

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], r8b
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 426  : 	Writer.WriteInteger(StringStart, sizeof(uint32_t));

	mov	ebx, r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR Writer$[rbp-248]
	sub	r8, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rdx, eax
	cmp	rdx, r8
	jbe	SHORT $LN245@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	lea	rdx, QWORD PTR [r8+4]
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN245@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], bl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-232], 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 428  : 	return Writer.GetData();

	lea	rdx, QWORD PTR Writer$[rbp-256]
	mov	rsi, QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-256]
	mov	rcx, rsi
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR SignatureOffsets$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN164@ToBinary

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR SignatureOffsets$[rbp-240]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN182@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN182@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN182@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR SignatureOffsets$[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR SignatureOffsets$[rbp-240], 0
$LN164@ToBinary:

; 767  :         _Tidy();

	lea	rcx, QWORD PTR NewInstructions$[rbp-256]
	call	?_Tidy@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXXZ ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Tidy
	npad	1

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR StringTable$[rbp-256]
	test	rbx, rbx
	je	SHORT $LN113@ToBinary

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR StringTable$[rbp-248]
	cmp	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	je	SHORT $LN117@ToBinary
$LL118@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL118@ToBinary
	mov	rbx, QWORD PTR StringTable$[rbp-256]
$LN117@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR StringTable$[rbp-240]
	sub	rdx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H
	mov	rax, rbx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN146@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rbx, QWORD PTR [rbx-8]
	sub	rax, rbx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN146@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN146@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR StringTable$[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR StringTable$[rbp-240], 0
$LN113@ToBinary:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Writer$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN357@ToBinary

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Writer$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN375@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN375@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN375@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN357@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 428  : 	return Writer.GetData();

	mov	rax, rsi

; 429  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+560]
	add	rsp, 480				; 000001e0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN1890@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1882@ToBinary:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1883@ToBinary:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1881@ToBinary:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1880@ToBinary:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1887@ToBinary:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1886@ToBinary:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1889@ToBinary:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1888@ToBinary:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN2218@ToBinary:
$LN2203@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 429  : }

	DD	$LN1061@ToBinary
	DD	$LN1061@ToBinary
	DD	$LN1061@ToBinary
	DD	$LN1061@ToBinary
	DD	$LN1061@ToBinary
	DD	$LN1044@ToBinary
$LN2202@ToBinary:
	DD	$LN11@ToBinary
	DD	$LN11@ToBinary
	DD	$LN11@ToBinary
	DD	$LN11@ToBinary
	DD	$LN11@ToBinary
	DD	$LN1107@ToBinary
$LN2201@ToBinary:
	DD	$LN1300@ToBinary
	DD	$LN1300@ToBinary
	DD	$LN1300@ToBinary
	DD	$LN1300@ToBinary
	DD	$LN1300@ToBinary
	DD	$LN1283@ToBinary
$LN2200@ToBinary:
	DD	$LN20@ToBinary
	DD	$LN20@ToBinary
	DD	$LN20@ToBinary
	DD	$LN20@ToBinary
	DD	$LN20@ToBinary
	DD	$LN1346@ToBinary
$LN2199@ToBinary:
	DD	$LN494@ToBinary
	DD	$LN494@ToBinary
	DD	$LN494@ToBinary
	DD	$LN494@ToBinary
	DD	$LN494@ToBinary
	DD	$LN477@ToBinary
$LN2198@ToBinary:
	DD	$LN26@ToBinary
	DD	$LN26@ToBinary
	DD	$LN26@ToBinary
	DD	$LN26@ToBinary
	DD	$LN26@ToBinary
	DD	$LN540@ToBinary
?ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z ENDP ; EXB::ToBinary
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$0@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$0
	lea	rcx, QWORD PTR Writer$[rdx]
	jmp	??1BinaryVectorWriter@@QEAA@XZ
?dtor$0@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$1@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$1
	lea	rcx, QWORD PTR StringTable$[rdx]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$1@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$2@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$2
	lea	rcx, QWORD PTR Cmd$14[rdx]
	jmp	??1CommandInfoStruct@EXB@@QEAA@XZ
?dtor$2@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$114@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$114
	lea	rcx, QWORD PTR Instruction$20[rdx]
	add	rcx, 16
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$114@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$114
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$115@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$115
	lea	rcx, QWORD PTR Instruction$20[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$115@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$115
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$103@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$103
	lea	rcx, QWORD PTR Instruction$19[rdx]
	add	rcx, 16
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$103@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$103
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$104@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$104
	lea	rcx, QWORD PTR Instruction$19[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$104@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$104
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$59@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$59
	lea	rcx, QWORD PTR Instruction$18[rdx]
	add	rcx, 16
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$59@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$59
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$60@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$60
	lea	rcx, QWORD PTR Instruction$18[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$60@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$60
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$6@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$6
	lea	rcx, QWORD PTR NewInstructions$[rdx]
	jmp	??1?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAA@XZ ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::~vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >
?dtor$6@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$7@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$7
	lea	rcx, QWORD PTR Cmd$13[rdx]
	jmp	??1CommandInfoStruct@EXB@@QEAA@XZ
?dtor$7@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$96@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$96
	lea	rcx, QWORD PTR Inst$17[rdx]
	add	rcx, 16
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$96@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$96
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$97@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$97
	lea	rcx, QWORD PTR Inst$17[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$97@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$97
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$8@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$8
	lea	rcx, QWORD PTR Inst$17[rdx]
	jmp	??1InstructionStruct@EXB@@QEAA@XZ
?dtor$8@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$9@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$9
	lea	rcx, QWORD PTR SignatureOffsets$[rdx]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
?dtor$9@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$100@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$100
	lea	rcx, QWORD PTR Instruction$16[rdx]
	add	rcx, 16
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$100@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$100
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$101@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$101
	lea	rcx, QWORD PTR Instruction$16[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$101@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$101
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$10@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$10
	lea	rcx, QWORD PTR Instruction$16[rdx]
	jmp	??1InstructionStruct@EXB@@QEAA@XZ
?dtor$10@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$43@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$43
	lea	rcx, QWORD PTR Instruction$15[rdx]
	add	rcx, 16
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$43@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$43
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$44@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$44
	lea	rcx, QWORD PTR Instruction$15[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$44@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$44
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$15@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$15
	lea	rcx, QWORD PTR Instruction$15[rdx]
	jmp	??1InstructionStruct@EXB@@QEAA@XZ
?dtor$15@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$52@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$52
	mov	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$52@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$52
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$50@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$50
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$50@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$50
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ParamStart$1$ = 32
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
<end>$L8$1$ = 72
<end>$L0$1$ = 72
__$ReturnUdt$GSCopy$ = 72
MaxStatic$1$ = 80
Max32$1$ = 84
Max64$1$ = 88
$T5 = 96
$T6 = 96
this$GSCopy$1$ = 104
SigStart$1$ = 104
EXBInstanceCount$1$ = 112
CommandStart$1$ = 116
$T7 = 120
__$ReturnUdt$GSCopy$1$ = 160
Writer$ = 168
String$8 = 200
$T9 = 200
$T10 = 200
$T11 = 200
$T12 = 200
Cmd$13 = 200
Cmd$14 = 200
Instruction$15 = 256
Instruction$16 = 256
Inst$17 = 256
Instruction$18 = 256
Instruction$19 = 256
Instruction$20 = 256
StringTable$ = 400
SignatureOffsets$ = 424
NewInstructions$ = 448
__$ArrayPad$ = 472
this$ = 544
__$ReturnUdt$ = 552
EXBInstanceCount$ = 560
?dtor$20@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA PROC ; `EXB::ToBinary'::`1'::dtor$20
	lea	rcx, QWORD PTR String$8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$20@?0??ToBinary@EXB@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@I@Z@4HA ENDP ; `EXB::ToBinary'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z
_TEXT	SEGMENT
Value$GSCopy$ = 32
__$ArrayPad$ = 40
this$dead$ = 96
Value$ = 104
StringTable$ = 112
?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z PROC ; EXB::AddToStringTable, COMDAT

; 7    : {

$LN81:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, r8
	mov	rdi, rdx

; 6    : void EXB::AddToStringTable(std::string Value, std::vector<std::string>& StringTable)

	mov	QWORD PTR Value$GSCopy$[rsp], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rsi, QWORD PTR [r8+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5851 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

	mov	rbx, QWORD PTR [r8]

; 5836 :     for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN78@AddToStrin
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rbp, QWORD PTR [rdx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r15, QWORD PTR [rdx+16]
	npad	2
$LL24@AddToStrin:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	rbp, 16
	jb	SHORT $LN32@AddToStrin

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN32@AddToStrin:

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN37@AddToStrin

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN37@AddToStrin:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r15
	jne	SHORT $LN43@AddToStrin

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN75@AddToStrin
$LN43@AddToStrin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5836 :     for (; _First != _Last; ++_First) {

	add	rbx, 32					; 00000020H
	cmp	rbx, rsi
	jne	SHORT $LL24@AddToStrin
$LN75@AddToStrin:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 11   : 	if (it == StringTable.end())

	cmp	rbx, rsi
	jne	SHORT $LN57@AddToStrin
$LN78@AddToStrin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rsi, QWORD PTR [r14+16]
	je	SHORT $LN58@AddToStrin
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rdi
	mov	rcx, rsi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [r14+8], 32			; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN57@AddToStrin
$LN58@AddToStrin:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, r14
	call	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	npad	1
$LN57@AddToStrin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 15   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ENDP ; EXB::AddToStringTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Value$GSCopy$ = 32
__$ArrayPad$ = 40
this$dead$ = 96
Value$ = 104
StringTable$ = 112
?dtor$0@?0??AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z@4HA PROC ; `EXB::AddToStringTable'::`1'::dtor$0
	mov	rcx, QWORD PTR Value$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??AddToStringTable@EXB@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z@4HA ENDP ; `EXB::AddToStringTable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 96
$T3 = 104
$T4 = 136
Value$GSCopy$ = 176
__$ArrayPad$ = 184
this$dead$ = 240
Value$ = 248
StringTable$ = 256
?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z PROC ; EXB::GetOffsetInStringTable, COMDAT

; 18   : {

$LN255:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-137], rax
	mov	rdi, rdx
	mov	QWORD PTR Value$GSCopy$[rbp-137], rdx
	xor	r14d, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rsi, QWORD PTR [r8+8]
	mov	r13, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5851 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

	mov	rbx, r13

; 5836 :     for (; _First != _Last; ++_First) {

	cmp	r13, rsi
	je	SHORT $LN248@GetOffsetI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r15, QWORD PTR [rdx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r12, QWORD PTR [rdx+16]
$LL38@GetOffsetI:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	r15, 16
	jb	SHORT $LN249@GetOffsetI

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN249@GetOffsetI:

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN51@GetOffsetI

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN51@GetOffsetI:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r12
	jne	SHORT $LN57@GetOffsetI

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN248@GetOffsetI
$LN57@GetOffsetI:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5836 :     for (; _First != _Last; ++_First) {

	add	rbx, 32					; 00000020H
	cmp	rbx, rsi
	jne	SHORT $LL38@GetOffsetI
$LN248@GetOffsetI:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 22   : 	if (it != StringTable.end())

	cmp	rbx, rsi
	je	SHORT $LN247@GetOffsetI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	sub	rbx, r13

; 154  :         return _Ptr - _Right._Ptr;

	sar	rbx, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 27   : 	if (Index == -1)

	cmp	ebx, -1
	je	SHORT $LN247@GetOffsetI

; 31   : 	}
; 32   : 
; 33   : 	int Offset = 0;
; 34   : 
; 35   : 	for (int i = 0; i < Index; i++)

	test	ebx, ebx
	jle	SHORT $LN3@GetOffsetI
	movsxd	r8, ebx
	mov	rcx, r14
	sub	rsi, r13
	sar	rsi, 5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1904 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	lea	rdx, QWORD PTR [r13+16]
	npad	3
$LL4@GetOffsetI:
	cmp	rsi, rcx
	jbe	$LN204@GetOffsetI
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 37   : 		Offset += StringTable.at(i).length() + 1;

	inc	r14d
	add	r14d, DWORD PTR [rdx]

; 31   : 	}
; 32   : 
; 33   : 	int Offset = 0;
; 34   : 
; 35   : 	for (int i = 0; i < Index; i++)

	inc	rcx
	add	rdx, 32					; 00000020H
	cmp	rcx, r8
	jl	SHORT $LL4@GetOffsetI
$LN3@GetOffsetI:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 40   : 	return Offset;

	mov	eax, r14d
	jmp	$LN1@GetOffsetI
$LN247@GetOffsetI:

; 29   : 		Logger::Warning("EXBDecoder", "Can not find string \"" + Value + "\" in StringTable");

	lea	rsi, QWORD PTR $T3[rbp-137]
	mov	QWORD PTR $T2[rbp-137], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rcx, QWORD PTR [rdi+16]

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	sub	rax, rcx
	cmp	rax, 21
	jb	$LN253@GetOffsetI

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN87@GetOffsetI

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN87@GetOffsetI:

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 21
	lea	r9, OFFSET FLAT:??_C@_0BG@LJAGCNKK@Can?5not?5find?5string?5?$CC@
	lea	rcx, QWORD PTR $T1[rbp-137]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T1[rbp-121]
	mov	rdx, QWORD PTR $T1[rbp-113]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 16
	jb	SHORT $LN100@GetOffsetI

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR $T1[rbp-121], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR $T1[rbp-137]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rbx, QWORD PTR $T1[rbp-137]

; 3275 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	rbx, rcx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8d, 16
	lea	rdx, OFFSET FLAT:??_C@_0BB@GMPDJJNF@?$CC?5in?5StringTable@
	mov	rcx, rbx
	call	memmove

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+16], 0

; 3277 :             return *this;

	lea	rax, QWORD PTR $T1[rbp-137]
	jmp	SHORT $LN99@GetOffsetI
$LN100@GetOffsetI:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 16
	lea	r9, OFFSET FLAT:??_C@_0BB@GMPDJJNF@?$CC?5in?5StringTable@
	mov	edx, 16
	lea	rcx, QWORD PTR $T1[rbp-137]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN99@GetOffsetI:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rbp-137], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T3[rbp-121], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rbp-113], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T3[rbp-137], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T3[rbp-121], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 29   : 		Logger::Warning("EXBDecoder", "Can not find string \"" + Value + "\" in StringTable");

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rbp-137], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T4[rbp-121], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rbp-113], r14

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 10
	lea	rdx, OFFSET FLAT:??_C@_0L@GPMKFGFF@EXBDecoder@
	lea	rcx, QWORD PTR $T4[rbp-137]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 29   : 		Logger::Warning("EXBDecoder", "Can not find string \"" + Value + "\" in StringTable");

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T4[rbp-137]
	call	?Warning@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Warning
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T1[rbp-113]
	cmp	rdx, 16
	jb	SHORT $LN176@GetOffsetI

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T1[rbp-137]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN188@GetOffsetI

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN188@GetOffsetI
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN188@GetOffsetI:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN176@GetOffsetI:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 30   : 		return -1;

	mov	eax, -1
$LN1@GetOffsetI:

; 41   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-137]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN253@GetOffsetI:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4917 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN204@GetOffsetI:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1905 :             _Xrange();

	call	?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
	int	3
$LN251@GetOffsetI:
?GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ENDP ; EXB::GetOffsetInStringTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 96
$T3 = 104
$T4 = 136
Value$GSCopy$ = 176
__$ArrayPad$ = 184
this$dead$ = 240
Value$ = 248
StringTable$ = 256
?dtor$0@?0??GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z@4HA PROC ; `EXB::GetOffsetInStringTable'::`1'::dtor$0
	mov	rcx, QWORD PTR Value$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z@4HA ENDP ; `EXB::GetOffsetInStringTable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 96
$T3 = 104
$T4 = 136
Value$GSCopy$ = 176
__$ArrayPad$ = 184
this$dead$ = 240
Value$ = 248
StringTable$ = 256
?dtor$1@?0??GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z@4HA PROC ; `EXB::GetOffsetInStringTable'::`1'::dtor$1
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z@4HA ENDP ; `EXB::GetOffsetInStringTable'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 96
$T3 = 104
$T4 = 136
Value$GSCopy$ = 176
__$ArrayPad$ = 184
this$dead$ = 240
Value$ = 248
StringTable$ = 256
?dtor$2@?0??GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z@4HA PROC ; `EXB::GetOffsetInStringTable'::`1'::dtor$2
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??GetOffsetInStringTable@EXB@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z@4HA ENDP ; `EXB::GetOffsetInStringTable'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
this$ = 64
__$ReturnUdt$ = 72
Reader$ = 80
Offset$ = 88
?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z PROC ; EXB::ReadStringFromStringPool, COMDAT

; 43   : std::string EXB::ReadStringFromStringPool(BinaryVectorReader* Reader, uint32_t Offset) {

$LN63:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r8
	mov	rdi, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	edx, edx
	mov	DWORD PTR $T1[rsp], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 26   : 	return this->m_Offset + 1;

	mov	esi, DWORD PTR [r8+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 45   : 	Reader->Seek(Header.StringOffset + Offset, BinaryVectorReader::Position::Begin);

	mov	ecx, DWORD PTR [rcx+40]
	dec	ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	add	ecx, r9d
	mov	DWORD PTR [r8+8], ecx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdi], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], dl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 53   : 	return Result;

	mov	DWORD PTR $T1[rsp], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	inc	DWORD PTR [r8+8]

; 51   : 	return this->m_Bytes[this->m_Offset];

	movsxd	rdx, DWORD PTR [r8+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 51   : 	return this->m_Bytes[this->m_Offset];

	mov	rcx, QWORD PTR [rax]
	movzx	r8d, BYTE PTR [rdx+rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 48   : 	while (CurrentCharacter != 0x00) {

	test	r8b, r8b
	je	SHORT $LN60@ReadString
	npad	12
$LL2@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN37@ReadString

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2227 :         if (_Large_string_engaged()) {

	jb	SHORT $LN40@ReadString

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN40@ReadString:

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r8b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 4053 :             return;

	jmp	SHORT $LN36@ReadString
$LN37@ReadString:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	movzx	r9d, r8b
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN36@ReadString:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 50   : 	this->m_Offset++;

	inc	DWORD PTR [rbx+8]

; 51   : 	return this->m_Bytes[this->m_Offset];

	movsxd	r8, DWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 51   : 	return this->m_Bytes[this->m_Offset];

	mov	rdx, QWORD PTR [rcx]
	movzx	r8d, BYTE PTR [r8+rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 48   : 	while (CurrentCharacter != 0x00) {

	test	r8b, r8b
	jne	SHORT $LL2@ReadString
$LN60@ReadString:

; 54   : }

	mov	rax, rdi
	mov	DWORD PTR [rbx+8], esi
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
	int	3
?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z ENDP ; EXB::ReadStringFromStringPool
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
this$ = 64
__$ReturnUdt$ = 72
Reader$ = 80
Offset$ = 88
?dtor$0@?0??ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z@4HA PROC ; `EXB::ReadStringFromStringPool'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z@4HA ENDP ; `EXB::ReadStringFromStringPool'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z
_TEXT	SEGMENT
Jumpback$1$ = 32
EXBFile$GSCopy$1$ = 40
$T1 = 48
tv1479 = 64
$T2 = 72
$T3 = 72
i$GSCopy$ = 104
__$ArrayPad$ = 112
this$ = 208
i$ = 216
EXBFile$ = 224
??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z PROC ; `EXB::EXB'::`20'::<lambda_1>::operator(), COMDAT

; 113  : 				{

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H
	movaps	XMMWORD PTR [rsp+128], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, r8
	mov	QWORD PTR EXBFile$GSCopy$1$[rsp], r8
	mov	r14, rdx
	mov	r13, rcx

; 112  : 			auto Func = [&Instruction, &Reader](std::string i, EXB* EXBFile)

	mov	QWORD PTR i$GSCopy$[rsp], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	rbx, QWORD PTR [rdx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rdx

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdi, QWORD PTR [rdx+24]

; 2236 :         if (_Large_string_engaged()) {

	cmp	rdi, 16
	jb	SHORT $LN901@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdx]
$LN901@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rbx, 3
	jne	SHORT $LN14@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rbx
	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN14@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 114  : 					if ((i == "LHS" ? Instruction.LHSSource : Instruction.RHSSource) == EXB::Source::ParamTbl)

	mov	r15, QWORD PTR [r13]
	movzx	eax, BYTE PTR [r15+4]
	jmp	SHORT $LN15@operator
$LN14@operator:
	mov	r15, QWORD PTR [r13]
	movzx	eax, BYTE PTR [r15+5]
$LN15@operator:
	mov	r12d, 16
	cmp	al, 3
	jne	$LN905@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 26   : 	return this->m_Offset + 1;

	mov	rbp, QWORD PTR [r13+8]
	mov	eax, DWORD PTR [rbp+8]
	inc	eax
	mov	DWORD PTR Jumpback$1$[rsp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	rdi, r12
	jb	SHORT $LN902@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN902@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rbx, 3
	jne	SHORT $LN16@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rbx
	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN16@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 117  : 						Reader.Seek(EXBFile->Header.ParameterRegionOffset + (i == "LHS" ? Instruction.LHSIndexValue : Instruction.RHSIndexValue), BinaryVectorReader::Position::Begin);

	movzx	eax, WORD PTR [r15+6]
	jmp	SHORT $LN17@operator
$LN16@operator:
	movzx	eax, WORD PTR [r15+8]
$LN17@operator:
	movzx	ecx, ax
	mov	r8d, DWORD PTR [rsi+36]
	add	r8d, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	lea	eax, DWORD PTR [r8-1]
	mov	DWORD PTR [rbp+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 118  : 						if (Instruction.DataType == EXB::Type::Bool)

	movzx	eax, WORD PTR [r15+2]
	cmp	ax, 2
	jne	$LN3@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	ecx, DWORD PTR [r8+3]
	mov	DWORD PTR [rbp+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbp]

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r10, ecx
	movsxd	rax, ecx
	movsxd	rcx, ecx
	movsxd	r8, r8d
	movzx	r9d, BYTE PTR [rax+rdx-1]
	shl	r9d, 8
	movzx	eax, BYTE PTR [rcx+rdx-2]
	or	r9d, eax
	shl	r9d, 8
	movzx	eax, BYTE PTR [r10+rdx]
	shl	eax, 24
	or	r9d, eax
	movzx	eax, BYTE PTR [r8+rdx]
	or	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 120  : 							(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = (bool)Reader.ReadUInt32();

	setne	dil
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	r8, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], r12
	jb	SHORT $LN449@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN449@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, 3
	jne	SHORT $LN18@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 120  : 							(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = (bool)Reader.ReadUInt32();

	mov	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	je	SHORT $LN19@operator
$LN18@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 120  : 							(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = (bool)Reader.ReadUInt32();

	mov	eax, 56					; 00000038H
$LN19@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	lea	rbx, QWORD PTR [r15+rax]
	movsx	rax, BYTE PTR [rbx+32]

; 1031 :         if (index() == _TargetIdx) {

	test	rax, rax
	je	SHORT $LN512@operator

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN919@operator[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN481@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN498@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 0
$LN512@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 121  : 						}

	mov	BYTE PTR [rbx], dil
$LN885@operator:

; 134  : 						Reader.Seek(Jumpback, BinaryVectorReader::Position::Begin);

	mov	rcx, QWORD PTR [r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	eax, DWORD PTR Jumpback$1$[rsp]
	dec	eax
	mov	DWORD PTR [rcx+8], eax
$LN905@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	rdi, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r15, QWORD PTR [r14+24]

; 2236 :         if (_Large_string_engaged()) {

	cmp	r15, r12
	jb	SHORT $LN906@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN906@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 3
	jne	$LN26@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	$LN26@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 136  : 					if ((i == "LHS" ? Instruction.LHSSource : Instruction.RHSSource) == EXB::Source::ParamTblStr)

	mov	rbx, QWORD PTR [r13]
	movzx	eax, BYTE PTR [rbx+4]
	jmp	$LN27@operator
$LN493@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN3@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 122  : 						else if (Instruction.DataType == EXB::Type::S32)

	cmp	ax, 3
	jne	$LN5@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	ecx, DWORD PTR [r8+3]
	mov	DWORD PTR [rbp+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbp]

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r9, ecx
	movsxd	rax, ecx
	movsxd	rcx, ecx
	movsxd	r8, r8d
	movzx	ebx, BYTE PTR [rax+rdx-1]
	shl	ebx, 8
	movzx	eax, BYTE PTR [rcx+rdx-2]
	or	ebx, eax
	shl	ebx, 8
	movzx	eax, BYTE PTR [r9+rdx]
	shl	eax, 24
	or	ebx, eax
	movzx	eax, BYTE PTR [r8+rdx]
	or	ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	r8, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], r12
	jb	SHORT $LN540@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN540@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, 3
	jne	SHORT $LN20@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 124  : 							(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = Reader.ReadUInt32();

	mov	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	je	SHORT $LN21@operator
$LN20@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 124  : 							(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = Reader.ReadUInt32();

	mov	eax, 56					; 00000038H
$LN21@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	lea	rdi, QWORD PTR [rax+r15]
	movsx	rax, BYTE PTR [rdi+32]

; 1031 :         if (index() == _TargetIdx) {

	cmp	rax, 1
	je	$LN603@operator

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN918@operator[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN572@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN589@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rdi+32], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 134  : 						Reader.Seek(Jumpback, BinaryVectorReader::Position::Begin);

	mov	DWORD PTR [rdi], ebx
	jmp	$LN885@operator
$LN584@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN5@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 126  : 						else if (Instruction.DataType == EXB::Type::F32)

	cmp	ax, 4
	jne	$LN7@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	ecx, DWORD PTR [r8+3]
	mov	DWORD PTR [rbp+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbp]

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r9, ecx
	movsxd	rax, ecx
	movsxd	rcx, ecx
	movsxd	r8, r8d
	movzx	ebx, BYTE PTR [rax+rdx-1]
	shl	ebx, 8
	movzx	eax, BYTE PTR [rcx+rdx-2]
	or	ebx, eax
	shl	ebx, 8
	movzx	eax, BYTE PTR [r9+rdx]
	shl	eax, 24
	or	ebx, eax
	movzx	eax, BYTE PTR [r8+rdx]
	or	ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	r8, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], r12
	jb	SHORT $LN633@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN633@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, 3
	jne	SHORT $LN22@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 128  : 							(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = Reader.ReadFloat();

	mov	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	je	SHORT $LN23@operator
$LN22@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 128  : 							(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = Reader.ReadFloat();

	mov	eax, 56					; 00000038H
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	lea	rdi, QWORD PTR [rax+r15]
	movsx	rax, BYTE PTR [rdi+32]

; 1031 :         if (index() == _TargetIdx) {

	cmp	rax, 2
	jne	SHORT $LN644@operator
$LN603@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 134  : 						Reader.Seek(Jumpback, BinaryVectorReader::Position::Begin);

	mov	DWORD PTR [rdi], ebx
	jmp	$LN885@operator
$LN644@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rbp, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN917@operator[rbp+rax*4+4]
	add	rax, rbp
	jmp	rax
$LN665@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN682@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR [rdi], ebx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rdi+32], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 129  : 						}

	jmp	$LN885@operator
$LN677@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN7@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 130  : 						else if (Instruction.DataType == EXB::Type::Vec3f)

	cmp	ax, 6
	jne	$LN885@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	ebx, DWORD PTR [r8+3]
	mov	DWORD PTR [rbp+8], ebx

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	mov	rdi, QWORD PTR [rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r9, ebx
	movsxd	rax, ebx
	movsxd	rcx, ebx
	movsxd	r8, r8d
	movzx	esi, BYTE PTR [rax+rdx-1]
	shl	esi, 8
	movzx	eax, BYTE PTR [rcx+rdx-2]
	or	esi, eax
	shl	esi, 8
	movzx	eax, BYTE PTR [r9+rdx]
	shl	eax, 24
	or	esi, eax
	movzx	eax, BYTE PTR [r8+rdx]
	or	esi, eax

; 76   : 	this->m_Offset += 4;

	lea	eax, DWORD PTR [rbx+4]
	mov	DWORD PTR [rbp+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r10, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r9, ebx
	movsxd	rdx, ebx
	lea	eax, DWORD PTR [rbx+2]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [rbx+1]
	movsxd	r8, eax
	movzx	r11d, BYTE PTR [rdx+r10+3]
	shl	r11d, 8
	movzx	eax, BYTE PTR [rcx+r10]
	or	r11d, eax
	shl	r11d, 8
	movzx	eax, BYTE PTR [r9+r10+4]
	shl	eax, 24
	or	r11d, eax
	movzx	eax, BYTE PTR [r8+r10]
	or	r11d, eax

; 76   : 	this->m_Offset += 4;

	lea	edx, DWORD PTR [rbx+8]
	mov	DWORD PTR [rbp+8], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r10, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r9, edx
	movsxd	rax, edx
	movsxd	rcx, edx
	movsxd	r8, edx
	movzx	edx, BYTE PTR [rax+r10-1]
	shl	edx, 8
	movzx	eax, BYTE PTR [rcx+r10-2]
	or	edx, eax
	shl	edx, 8
	movzx	eax, BYTE PTR [r9+r10]
	shl	eax, 24
	or	edx, eax
	movzx	eax, BYTE PTR [r8+r10-3]
	or	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 8    : 	this->m_Data[0] = x;

	mov	DWORD PTR $T1[rsp], edx

; 9    : 	this->m_Data[1] = y;

	mov	DWORD PTR $T1[rsp+4], r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	r8, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], r12
	jb	SHORT $LN904@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN904@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, 3
	jne	SHORT $LN24@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 132  : 							(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = Vector3F(Reader.ReadFloat(), Reader.ReadFloat(), Reader.ReadFloat());

	mov	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	je	SHORT $LN25@operator
$LN24@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 132  : 							(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = Vector3F(Reader.ReadFloat(), Reader.ReadFloat(), Reader.ReadFloat());

	mov	eax, 56					; 00000038H
$LN25@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	lea	rbx, QWORD PTR [rax+r15]
	movsx	rax, BYTE PTR [rbx+32]

; 1031 :         if (index() == _TargetIdx) {

	cmp	rax, 3
	jne	SHORT $LN805@operator

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	movsd	xmm0, QWORD PTR $T1[rsp]
	movsd	QWORD PTR [rbx], xmm0
	mov	DWORD PTR [rbx+8], esi

; 1034 :         } else {

	jmp	$LN885@operator
$LN805@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rbp, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN916@operator[rbp+rax*4+4]
	add	rax, rbp
	jmp	rax
$LN826@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN843@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR $T1[rsp]
	movsd	QWORD PTR [rbx], xmm0
	mov	DWORD PTR [rbx+8], esi

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 3
	jmp	$LN885@operator
$LN838@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN26@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 136  : 					if ((i == "LHS" ? Instruction.LHSSource : Instruction.RHSSource) == EXB::Source::ParamTblStr)

	mov	rbx, QWORD PTR [r13]
	movzx	eax, BYTE PTR [rbx+5]
$LN27@operator:
	cmp	al, 4
	jne	$LN920@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 26   : 	return this->m_Offset + 1;

	mov	rsi, QWORD PTR [r13+8]
	mov	ebp, DWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	r15, r12
	jb	SHORT $LN907@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN907@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 3
	jne	SHORT $LN28@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN28@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 139  : 						Reader.Seek(EXBFile->Header.ParameterRegionOffset + (i == "LHS" ? Instruction.LHSIndexValue : Instruction.RHSIndexValue), BinaryVectorReader::Position::Begin);

	movzx	eax, WORD PTR [rbx+6]
	jmp	SHORT $LN29@operator
$LN28@operator:
	movzx	eax, WORD PTR [rbx+8]
$LN29@operator:
	movzx	ecx, ax
	mov	r15, QWORD PTR EXBFile$GSCopy$1$[rsp]
	mov	r8d, DWORD PTR [r15+36]
	add	r8d, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	eax, DWORD PTR [r8+3]
	mov	DWORD PTR [rsi+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rsi]

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r11, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r10, r8d
	movsxd	rdx, r8d
	lea	eax, DWORD PTR [r8+1]
	movsxd	rcx, eax
	movsxd	r8, r8d
	movzx	r9d, BYTE PTR [rdx+r11+2]
	shl	r9d, 8
	movzx	eax, BYTE PTR [rcx+r11]
	or	r9d, eax
	shl	r9d, 8
	movzx	eax, BYTE PTR [r10+r11+3]
	shl	eax, 24
	or	r9d, eax
	movzx	eax, BYTE PTR [r8+r11]
	or	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 140  : 						(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = EXBFile->ReadStringFromStringPool(&Reader, Reader.ReadUInt32());

	mov	r8, rsi
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, r15
	call	?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z ; EXB::ReadStringFromStringPool
	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	r8, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], r12
	jb	SHORT $LN908@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN908@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, 3
	jne	SHORT $LN30@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 140  : 						(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = EXBFile->ReadStringFromStringPool(&Reader, Reader.ReadUInt32());

	mov	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	je	SHORT $LN31@operator
$LN30@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 140  : 						(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = EXBFile->ReadStringFromStringPool(&Reader, Reader.ReadUInt32());

	mov	eax, 56					; 00000038H
$LN31@operator:
	lea	rcx, QWORD PTR [rbx+rax]
	mov	rdx, rdi
	call	??$?4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T3[rsp+24]
	cmp	rdx, r12
	jb	SHORT $LN174@operator

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T3[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN186@operator

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN186@operator
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN186@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN174@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	DWORD PTR [rsi+8], ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 136  : 					if ((i == "LHS" ? Instruction.LHSSource : Instruction.RHSSource) == EXB::Source::ParamTblStr)

	jmp	SHORT $LN196@operator
$LN920@operator:
	mov	r15, QWORD PTR EXBFile$GSCopy$1$[rsp]
$LN196@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	rdi, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rbp, QWORD PTR [r14+24]

; 2236 :         if (_Large_string_engaged()) {

	cmp	rbp, r12
	jb	SHORT $LN909@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN909@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 3
	jne	SHORT $LN32@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN32@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 143  : 					if ((i == "LHS" ? Instruction.LHSSource : Instruction.RHSSource) == EXB::Source::Imm)

	movzx	eax, BYTE PTR [rbx+4]
	jmp	SHORT $LN33@operator
$LN32@operator:
	movzx	eax, BYTE PTR [rbx+5]
$LN33@operator:
	test	al, al
	jne	SHORT $LN305@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	rbp, r12
	jb	SHORT $LN910@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN910@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 3
	jne	SHORT $LN36@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 145  : 						(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = (i == "LHS" ? Instruction.LHSIndexValue : Instruction.RHSIndexValue);

	lea	esi, QWORD PTR [rdi+3]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	je	SHORT $LN37@operator
$LN36@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 145  : 						(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = (i == "LHS" ? Instruction.LHSIndexValue : Instruction.RHSIndexValue);

	mov	esi, 8
$LN37@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	rbp, r12
	jb	SHORT $LN912@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN912@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 3
	jne	SHORT $LN34@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 145  : 						(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = (i == "LHS" ? Instruction.LHSIndexValue : Instruction.RHSIndexValue);

	mov	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	je	SHORT $LN35@operator
$LN34@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 145  : 						(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = (i == "LHS" ? Instruction.LHSIndexValue : Instruction.RHSIndexValue);

	mov	eax, 56					; 00000038H
$LN35@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	lea	rdi, QWORD PTR [rax+rbx]
	movsx	rax, BYTE PTR [rdi+32]

; 1031 :         if (index() == _TargetIdx) {

	cmp	rax, 1
	jne	SHORT $LN237@operator

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	movzx	eax, WORD PTR [rbx+rsi]
	mov	DWORD PTR [rdi], eax
$LN305@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	rdi, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rsi, QWORD PTR [r14+24]

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, r12
	jb	SHORT $LN913@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN913@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 3
	jne	SHORT $LN38@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN38@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 147  : 					if ((i == "LHS" ? Instruction.LHSSource : Instruction.RHSSource) == EXB::Source::ImmStr)

	movzx	eax, BYTE PTR [rbx+4]
	jmp	SHORT $LN39@operator
$LN237@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN915@operator[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN258@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN275@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rdi+32], -1

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movzx	eax, WORD PTR [rbx+rsi]
	mov	DWORD PTR [rdi], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rdi+32], 1
	jmp	SHORT $LN305@operator
$LN270@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN38@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 147  : 					if ((i == "LHS" ? Instruction.LHSSource : Instruction.RHSSource) == EXB::Source::ImmStr)

	movzx	eax, BYTE PTR [rbx+5]
$LN39@operator:
	cmp	al, 1
	jne	$LN369@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, r12
	jb	SHORT $LN914@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN914@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 3
	jne	SHORT $LN42@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN42@operator
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 149  : 						(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = EXBFile->ReadStringFromStringPool(&Reader, (i == "LHS" ? Instruction.LHSIndexValue : Instruction.RHSIndexValue));

	movzx	eax, WORD PTR [rbx+6]
	jmp	SHORT $LN43@operator
$LN42@operator:
	movzx	eax, WORD PTR [rbx+8]
$LN43@operator:
	movzx	r9d, ax
	mov	r8, QWORD PTR [r13+8]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, r15
	call	?ReadStringFromStringPool@EXB@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVBinaryVectorReader@@I@Z ; EXB::ReadStringFromStringPool
	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	r8, QWORD PTR [r14+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], r12
	jb	SHORT $LN347@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN347@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, 3
	jne	SHORT $LN40@operator

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	lea	rdx, OFFSET FLAT:??_C@_03OAGGBFIJ@LHS@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN41@operator
$LN40@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 149  : 						(i == "LHS" ? Instruction.LHSValue : Instruction.RHSValue) = EXBFile->ReadStringFromStringPool(&Reader, (i == "LHS" ? Instruction.LHSIndexValue : Instruction.RHSIndexValue));

	mov	r12d, 56				; 00000038H
$LN41@operator:
	lea	rcx, QWORD PTR [r12+rbx]
	mov	rdx, rdi
	call	??$?4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T2[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN369@operator

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T2[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN381@operator

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN381@operator
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN381@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN369@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, r14
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

; 151  : 				};

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+232]
	movaps	xmm6, XMMWORD PTR [rsp+128]
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN921@operator:
	npad	1
$LN919@operator:
	DD	$LN498@operator
	DD	$LN498@operator
	DD	$LN498@operator
	DD	$LN498@operator
	DD	$LN498@operator
	DD	$LN481@operator
$LN918@operator:
	DD	$LN589@operator
	DD	$LN589@operator
	DD	$LN589@operator
	DD	$LN589@operator
	DD	$LN589@operator
	DD	$LN572@operator
$LN917@operator:
	DD	$LN682@operator
	DD	$LN682@operator
	DD	$LN682@operator
	DD	$LN682@operator
	DD	$LN682@operator
	DD	$LN665@operator
$LN916@operator:
	DD	$LN843@operator
	DD	$LN843@operator
	DD	$LN843@operator
	DD	$LN843@operator
	DD	$LN843@operator
	DD	$LN826@operator
$LN915@operator:
	DD	$LN275@operator
	DD	$LN275@operator
	DD	$LN275@operator
	DD	$LN275@operator
	DD	$LN275@operator
	DD	$LN258@operator
??R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z ENDP ; `EXB::EXB'::`20'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Jumpback$1$ = 32
EXBFile$GSCopy$1$ = 40
$T1 = 48
tv1479 = 64
$T2 = 72
$T3 = 72
i$GSCopy$ = 104
__$ArrayPad$ = 112
this$ = 208
i$ = 216
EXBFile$ = 224
?dtor$0@?0???R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z@4HA PROC ; ``EXB::EXB'::`20'::<lambda_1>::operator()'::`1'::dtor$0
	mov	rcx, QWORD PTR i$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???R<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEBA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PEAV1@@Z@4HA ENDP ; ``EXB::EXB'::`20'::<lambda_1>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ??0<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEAA@AEAUInstructionStruct@1@AEAVBinaryVectorReader@@@Z
_TEXT	SEGMENT
this$ = 8
__Instruction$ = 16
__Reader$ = 24
??0<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEAA@AEAUInstructionStruct@1@AEAVBinaryVectorReader@@@Z PROC ; `EXB::EXB'::`20'::<lambda_1>::<lambda_1>, COMDAT

; 151  : 				};

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0<lambda_1>@?BE@???0EXB@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@QEAA@AEAUInstructionStruct@1@AEAVBinaryVectorReader@@@Z ENDP ; `EXB::EXB'::`20'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0InstructionStruct@EXB@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0InstructionStruct@EXB@@QEAA@XZ PROC			; EXB::InstructionStruct::InstructionStruct, COMDAT
$LN72:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	BYTE PTR [rcx], 30
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	xor	edx, edx
	mov	WORD PTR [rcx+2], dx
	mov	DWORD PTR [rcx+4], -62709		; ffff0b0bH
	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR [rcx+8], ax
	mov	DWORD PTR [rcx+16], -1			; ffffffffH

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rcx+48], 1

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR [rcx+56], -1			; ffffffffH

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rcx+88], 1
	mov	WORD PTR [rcx+96], ax
	add	rcx, 104				; 00000068H
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rdx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdx+19]
	lea	rdx, OFFSET FLAT:??_C@_0BE@MABBHOKL@MapEditor_EXB_NoVal@
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0InstructionStruct@EXB@@QEAA@XZ ENDP			; EXB::InstructionStruct::InstructionStruct
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0InstructionStruct@EXB@@QEAA@XZ@4HA PROC	; `EXB::InstructionStruct::InstructionStruct'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 16
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$0@?0???0InstructionStruct@EXB@@QEAA@XZ@4HA ENDP	; `EXB::InstructionStruct::InstructionStruct'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0InstructionStruct@EXB@@QEAA@XZ@4HA PROC	; `EXB::InstructionStruct::InstructionStruct'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
?dtor$1@?0???0InstructionStruct@EXB@@QEAA@XZ@4HA ENDP	; `EXB::InstructionStruct::InstructionStruct'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==, COMDAT

; 162  :         _Compat(_Right);
; 163  :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 164  :     }

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1870 :     }

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ PROC ; std::vector<int,std::allocator<int> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ PROC ; std::vector<int,std::allocator<int> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1805 :         auto& _My_data = _Mypair._Myval2;
; 1806 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	rax, rdx

; 1807 :     }

	ret	0
?end@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1795 :         auto& _My_data = _Mypair._Myval2;
; 1796 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rax, rdx

; 1797 :     }

	ret	0
?begin@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN30:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, -1085102592571150095		; f0f0f0f0f0f0f0f1H
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rsi, rdx, 136				; 00000088H
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN10@resize
	npad	2
$LL11@resize:
	mov	rcx, rbx
	call	??1InstructionStruct@EXB@@QEAA@XZ
	add	rbx, 136				; 00000088H
	cmp	rbx, rdi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	r8, r14
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<EXB::InstructionStruct> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXAEBUInstructionStruct@EXB@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXAEBUInstructionStruct@EXB@@@Z PROC ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::push_back, COMDAT

; 872  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rcx+8]

; 872  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	rbx, rcx

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rax, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, rax
	call	??0InstructionStruct@EXB@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [rbx+8], 136			; 00000088H

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rax

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_reallocate<EXB::InstructionStruct const &>
?push_back@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXAEBUInstructionStruct@EXB@@@Z ENDP ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Right$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Compat, COMDAT

; 195  :         // test for compatible iterator pair
; 196  : #if _ITERATOR_DEBUG_LEVEL == 0
; 197  :         (void) _Right;
; 198  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 199  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 200  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 201  :     }

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx

; 44   :         this->_Adopt(_Pvector);
; 45   :     }

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0I$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAI@Z
_TEXT	SEGMENT
this$ = 8
_Obj$ = 16
??$?0I$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAI@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int,0>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 988  :         // initialize to the type selected by passing _Obj to the overload set f(Types)...
; 989  :     }

	mov	rax, rcx

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rcx+32], 1

; 988  :         // initialize to the type selected by passing _Obj to the overload set f(Types)...
; 989  :     }

	ret	0
??$?0I$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAI@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?4_N$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 48
_Obj$ = 56
??$?4_N$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEA_N@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<bool,0>, COMDAT

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

$LN60:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rcx+32]

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

	mov	rdi, rdx
	mov	rbx, rcx

; 1029 :         // assign/emplace the alternative chosen by overload resolution of _Obj with f(_Types)...
; 1030 :         constexpr size_t _TargetIdx = _Variant_init_index<_Ty, _Types...>::value;
; 1031 :         if (index() == _TargetIdx) {

	test	rax, rax
	jne	SHORT $LN2@operator

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	movzx	eax, BYTE PTR [rdx]

; 1034 :         } else {
; 1035 :             using _TargetTy = _Variant_init_type<_Ty, _Types...>;
; 1036 :             if constexpr (_Variant_should_directly_construct_v<_TargetTy, _Ty>) {
; 1037 :                 this->_Reset();
; 1038 :                 _Emplace_valueless<_TargetIdx>(static_cast<_Ty&&>(_Obj));
; 1039 :             } else {
; 1040 :                 _TargetTy _Temp(static_cast<_Ty&&>(_Obj));
; 1041 :                 this->_Reset();
; 1042 :                 _Emplace_valueless<_TargetIdx>(_STD move(_Temp));
; 1043 :             }
; 1044 :         }
; 1045 : 
; 1046 :         return *this;

	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN55@operator[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN40@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], -1

; 1170 :         _STD _Construct_in_place(_Storage(), integral_constant<size_t, _Idx>{}, static_cast<_ArgTypes&&>(_Args)...);

	movzx	eax, BYTE PTR [rdi]

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 0

; 1034 :         } else {
; 1035 :             using _TargetTy = _Variant_init_type<_Ty, _Types...>;
; 1036 :             if constexpr (_Variant_should_directly_construct_v<_TargetTy, _Ty>) {
; 1037 :                 this->_Reset();
; 1038 :                 _Emplace_valueless<_TargetIdx>(static_cast<_Ty&&>(_Obj));
; 1039 :             } else {
; 1040 :                 _TargetTy _Temp(static_cast<_Ty&&>(_Obj));
; 1041 :                 this->_Reset();
; 1042 :                 _Emplace_valueless<_TargetIdx>(_STD move(_Temp));
; 1043 :             }
; 1044 :         }
; 1045 : 
; 1046 :         return *this;

	mov	BYTE PTR [rbx], al
	mov	rax, rbx

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN35@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN57@operator:
	npad	1
$LN55@operator:

; 1047 :     }

	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN23@operator
??$?4_N$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEA_N@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?4I$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAI@Z
_TEXT	SEGMENT
this$ = 48
_Obj$ = 56
??$?4I$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAI@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<unsigned int,0>, COMDAT

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

$LN60:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rcx+32]

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

	mov	rdi, rdx
	mov	rbx, rcx

; 1029 :         // assign/emplace the alternative chosen by overload resolution of _Obj with f(_Types)...
; 1030 :         constexpr size_t _TargetIdx = _Variant_init_index<_Ty, _Types...>::value;
; 1031 :         if (index() == _TargetIdx) {

	cmp	rax, 1
	jne	SHORT $LN2@operator

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	mov	eax, DWORD PTR [rdx]

; 1034 :         } else {
; 1035 :             using _TargetTy = _Variant_init_type<_Ty, _Types...>;
; 1036 :             if constexpr (_Variant_should_directly_construct_v<_TargetTy, _Ty>) {
; 1037 :                 this->_Reset();
; 1038 :                 _Emplace_valueless<_TargetIdx>(static_cast<_Ty&&>(_Obj));
; 1039 :             } else {
; 1040 :                 _TargetTy _Temp(static_cast<_Ty&&>(_Obj));
; 1041 :                 this->_Reset();
; 1042 :                 _Emplace_valueless<_TargetIdx>(_STD move(_Temp));
; 1043 :             }
; 1044 :         }
; 1045 : 
; 1046 :         return *this;

	mov	DWORD PTR [rcx], eax
	mov	rax, rcx

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN55@operator[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN40@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], -1

; 1170 :         _STD _Construct_in_place(_Storage(), integral_constant<size_t, _Idx>{}, static_cast<_ArgTypes&&>(_Args)...);

	mov	eax, DWORD PTR [rdi]

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 1

; 1034 :         } else {
; 1035 :             using _TargetTy = _Variant_init_type<_Ty, _Types...>;
; 1036 :             if constexpr (_Variant_should_directly_construct_v<_TargetTy, _Ty>) {
; 1037 :                 this->_Reset();
; 1038 :                 _Emplace_valueless<_TargetIdx>(static_cast<_Ty&&>(_Obj));
; 1039 :             } else {
; 1040 :                 _TargetTy _Temp(static_cast<_Ty&&>(_Obj));
; 1041 :                 this->_Reset();
; 1042 :                 _Emplace_valueless<_TargetIdx>(_STD move(_Temp));
; 1043 :             }
; 1044 :         }
; 1045 : 
; 1046 :         return *this;

	mov	DWORD PTR [rbx], eax
	mov	rax, rbx

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN35@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN57@operator:
	npad	2
$LN55@operator:

; 1047 :     }

	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN23@operator
??$?4I$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAI@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?4M$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAM@Z
_TEXT	SEGMENT
this$ = 48
_Obj$ = 56
??$?4M$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAM@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<float,0>, COMDAT

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

$LN82:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rcx+32]

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

	mov	rdi, rdx
	mov	rbx, rcx

; 1029 :         // assign/emplace the alternative chosen by overload resolution of _Obj with f(_Types)...
; 1030 :         constexpr size_t _TargetIdx = _Variant_init_index<_Ty, _Types...>::value;
; 1031 :         if (index() == _TargetIdx) {

	cmp	rax, 2
	jne	SHORT $LN2@operator

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 1034 :         } else {
; 1035 :             using _TargetTy = _Variant_init_type<_Ty, _Types...>;
; 1036 :             if constexpr (_Variant_should_directly_construct_v<_TargetTy, _Ty>) {
; 1037 :                 this->_Reset();
; 1038 :                 _Emplace_valueless<_TargetIdx>(static_cast<_Ty&&>(_Obj));
; 1039 :             } else {
; 1040 :                 _TargetTy _Temp(static_cast<_Ty&&>(_Obj));
; 1041 :                 this->_Reset();
; 1042 :                 _Emplace_valueless<_TargetIdx>(_STD move(_Temp));
; 1043 :             }
; 1044 :         }
; 1045 : 
; 1046 :         return *this;

	mov	rax, rcx

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN77@operator[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN40@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], -1

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rbx], eax

; 1034 :         } else {
; 1035 :             using _TargetTy = _Variant_init_type<_Ty, _Types...>;
; 1036 :             if constexpr (_Variant_should_directly_construct_v<_TargetTy, _Ty>) {
; 1037 :                 this->_Reset();
; 1038 :                 _Emplace_valueless<_TargetIdx>(static_cast<_Ty&&>(_Obj));
; 1039 :             } else {
; 1040 :                 _TargetTy _Temp(static_cast<_Ty&&>(_Obj));
; 1041 :                 this->_Reset();
; 1042 :                 _Emplace_valueless<_TargetIdx>(_STD move(_Temp));
; 1043 :             }
; 1044 :         }
; 1045 : 
; 1046 :         return *this;

	mov	rax, rbx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 2

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN35@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN79@operator:
	npad	2
$LN77@operator:

; 1047 :     }

	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN23@operator
??$?4M$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAM@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?4VVector3F@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAVVector3F@@@Z
_TEXT	SEGMENT
this$ = 48
_Obj$ = 56
??$?4VVector3F@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAVVector3F@@@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<Vector3F,0>, COMDAT

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

$LN88:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rcx+32]

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

	mov	rdi, rdx
	mov	rbx, rcx

; 1029 :         // assign/emplace the alternative chosen by overload resolution of _Obj with f(_Types)...
; 1030 :         constexpr size_t _TargetIdx = _Variant_init_index<_Ty, _Types...>::value;
; 1031 :         if (index() == _TargetIdx) {

	cmp	rax, 3
	jne	SHORT $LN2@operator

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax

; 1034 :         } else {
; 1035 :             using _TargetTy = _Variant_init_type<_Ty, _Types...>;
; 1036 :             if constexpr (_Variant_should_directly_construct_v<_TargetTy, _Ty>) {
; 1037 :                 this->_Reset();
; 1038 :                 _Emplace_valueless<_TargetIdx>(static_cast<_Ty&&>(_Obj));
; 1039 :             } else {
; 1040 :                 _TargetTy _Temp(static_cast<_Ty&&>(_Obj));
; 1041 :                 this->_Reset();
; 1042 :                 _Emplace_valueless<_TargetIdx>(_STD move(_Temp));
; 1043 :             }
; 1044 :         }
; 1045 : 
; 1046 :         return *this;

	mov	rax, rcx

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN83@operator[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN40@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], -1

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [rdi]
	movsd	QWORD PTR [rbx], xmm0
	mov	eax, DWORD PTR [rdi+8]
	mov	DWORD PTR [rbx+8], eax

; 1034 :         } else {
; 1035 :             using _TargetTy = _Variant_init_type<_Ty, _Types...>;
; 1036 :             if constexpr (_Variant_should_directly_construct_v<_TargetTy, _Ty>) {
; 1037 :                 this->_Reset();
; 1038 :                 _Emplace_valueless<_TargetIdx>(static_cast<_Ty&&>(_Obj));
; 1039 :             } else {
; 1040 :                 _TargetTy _Temp(static_cast<_Ty&&>(_Obj));
; 1041 :                 this->_Reset();
; 1042 :                 _Emplace_valueless<_TargetIdx>(_STD move(_Temp));
; 1043 :             }
; 1044 :         }
; 1045 : 
; 1046 :         return *this;

	mov	rax, rbx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 3

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN35@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN85@operator:
	npad	2
$LN83@operator:

; 1047 :     }

	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN23@operator
??$?4VVector3F@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAVVector3F@@@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<Vector3F,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Obj$ = 56
??$?4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>, COMDAT

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

$LN168:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rcx+32]

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

	mov	rdi, rdx
	mov	rbx, rcx

; 1029 :         // assign/emplace the alternative chosen by overload resolution of _Obj with f(_Types)...
; 1030 :         constexpr size_t _TargetIdx = _Variant_init_index<_Ty, _Types...>::value;
; 1031 :         if (index() == _TargetIdx) {

	cmp	rax, 4
	jne	SHORT $LN2@operator

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 1046 :         return *this;

	mov	rax, rbx

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN163@operator[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN40@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rbx], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rbx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rax

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1046 :         return *this;

	mov	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 4

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN35@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN165@operator:
	npad	1
$LN163@operator:

; 1047 :     }

	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN23@operator
??$?4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?4AEAG$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@AEAG@Z
_TEXT	SEGMENT
this$ = 48
_Obj$ = 56
??$?4AEAG$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@AEAG@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<unsigned short &,0>, COMDAT

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

$LN76:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rcx+32]

; 1028 :             is_nothrow_constructible_v<_Variant_init_type<_Ty, _Types...>, _Ty>) {

	mov	rdi, rdx
	mov	rbx, rcx

; 1029 :         // assign/emplace the alternative chosen by overload resolution of _Obj with f(_Types)...
; 1030 :         constexpr size_t _TargetIdx = _Variant_init_index<_Ty, _Types...>::value;
; 1031 :         if (index() == _TargetIdx) {

	cmp	rax, 1
	jne	SHORT $LN2@operator

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	movzx	eax, WORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 1034 :         } else {
; 1035 :             using _TargetTy = _Variant_init_type<_Ty, _Types...>;
; 1036 :             if constexpr (_Variant_should_directly_construct_v<_TargetTy, _Ty>) {
; 1037 :                 this->_Reset();
; 1038 :                 _Emplace_valueless<_TargetIdx>(static_cast<_Ty&&>(_Obj));
; 1039 :             } else {
; 1040 :                 _TargetTy _Temp(static_cast<_Ty&&>(_Obj));
; 1041 :                 this->_Reset();
; 1042 :                 _Emplace_valueless<_TargetIdx>(_STD move(_Temp));
; 1043 :             }
; 1044 :         }
; 1045 : 
; 1046 :         return *this;

	mov	rax, rcx

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN71@operator[rcx+rax*4+4]
	add	rax, rcx
	jmp	rax
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN40@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], -1

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movzx	eax, WORD PTR [rdi]
	mov	DWORD PTR [rbx], eax

; 1034 :         } else {
; 1035 :             using _TargetTy = _Variant_init_type<_Ty, _Types...>;
; 1036 :             if constexpr (_Variant_should_directly_construct_v<_TargetTy, _Ty>) {
; 1037 :                 this->_Reset();
; 1038 :                 _Emplace_valueless<_TargetIdx>(static_cast<_Ty&&>(_Obj));
; 1039 :             } else {
; 1040 :                 _TargetTy _Temp(static_cast<_Ty&&>(_Obj));
; 1041 :                 this->_Reset();
; 1042 :                 _Emplace_valueless<_TargetIdx>(_STD move(_Temp));
; 1043 :             }
; 1044 :         }
; 1045 : 
; 1046 :         return *this;

	mov	rax, rbx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx+32], 1

; 1047 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN35@operator:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN73@operator:
$LN71@operator:

; 1047 :     }

	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN40@operator
	DD	$LN23@operator
??$?4AEAG$0A@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAAEAV01@AEAG@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator=<unsigned short &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBH@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_First$ = 56
_Last$ = 64
_Val$ = 72
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBH@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>, COMDAT

; 5846 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r10, r8
	mov	r11, rdx

; 124  :         return const_cast<_Ty*>(

	mov	r8d, DWORD PTR [r9]

; 5846 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

	mov	rbx, rcx

; 124  :         return const_cast<_Ty*>(

	mov	rdx, r10
	mov	rcx, r11
	call	__std_find_trivial_4

; 5847 :     _Adl_verify_range(_First, _Last);
; 5848 :     if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
; 5849 :         return _Find_vbool(_First, _Last, _Val);
; 5850 :     } else {
; 5851 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
; 5852 :         return _First;

	mov	QWORD PTR [rbx], rax
	mov	rax, rbx

; 5853 :     }
; 5854 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@AEBH@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;
; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;
; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z PROC ; std::distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 154  :         return _Ptr - _Right._Ptr;

	sub	rdx, rcx
	sar	rdx, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	mov	rax, rdx

; 1423 :     } else {
; 1424 :         _Adl_verify_range(_First, _Last);
; 1425 :         auto _UFirst             = _Get_unwrapped(_First);
; 1426 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1427 :         _Iter_diff_t<_InIt> _Off = 0;
; 1428 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1429 :             ++_Off;
; 1430 :         }
; 1431 : 
; 1432 :         return _Off;
; 1433 :     }
; 1434 : }

	ret	0
??$distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ENDP ; std::distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN28:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, -1085102592571150095		; f0f0f0f0f0f0f0f1H
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rsi, rdx, 136				; 00000088H
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN8@Resize
	npad	2
$LL9@Resize:
	mov	rcx, rbx
	call	??1InstructionStruct@EXB@@QEAA@XZ
	add	rbx, 136				; 00000088H
	cmp	rbx, rdi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	r8, r14
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<EXB::InstructionStruct> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_one_at_back@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z PROC ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_one_at_back<EXB::InstructionStruct const &>, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [rcx+8]
	mov	rbx, rcx
	cmp	rax, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, rax
	call	??0InstructionStruct@EXB@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+136]
	mov	QWORD PTR [rbx+8], rdx

; 786  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rax

; 786  :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_reallocate<EXB::InstructionStruct const &>
??$_Emplace_one_at_back@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z ENDP ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_one_at_back<EXB::InstructionStruct const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAPEAHXZ
_TEXT	SEGMENT
this$ = 8
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAPEAHXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unwrapped, COMDAT

; 342  :         return _Unfancy(this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 343  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAPEAHXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBA_JAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBA_JAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator-, COMDAT

; 153  :         _Compat(_Right);
; 154  :         return _Ptr - _Right._Ptr;

	mov	rax, QWORD PTR [rcx]
	sub	rax, QWORD PTR [rdx]
	sar	rax, 2

; 155  :     }

	ret	0
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBA_JAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEBAXPEAUInstructionStruct@EXB@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEBAXPEAUInstructionStruct@EXB@@0@Z PROC ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEBAXPEAUInstructionStruct@EXB@@0@Z ENDP ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ??$?0$00I$0A@@?$_Non_trivial_move_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z
_TEXT	SEGMENT
this$ = 8
__param0$dead$ = 16
__param1$ = 24
??$?0$00I$0A@@?$_Non_trivial_move_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z PROC ; std::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rcx+32], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

	ret	0
??$?0$00I$0A@@?$_Non_trivial_move_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ENDP ; std::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Emplace_valueless@$0A@_N@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEA_N$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
<_Args_0>$ = 16
??$_Emplace_valueless@$0A@_N@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEA_N$$QEA_N@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<0,bool>, COMDAT

; 1168 :         // initialize alternative _Idx from _Args...
; 1169 :         _STL_INTERNAL_CHECK(valueless_by_exception());
; 1170 :         _STD _Construct_in_place(_Storage(), integral_constant<size_t, _Idx>{}, static_cast<_ArgTypes&&>(_Args)...);

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al

; 1171 :         this->_Set_index(_Idx);
; 1172 :         return _STD _Variant_raw_get<_Idx>(_Storage());

	mov	rax, rcx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 0

; 1173 :     }

	ret	0
??$_Emplace_valueless@$0A@_N@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEA_N$$QEA_N@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<0,bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Emplace_valueless@$00I@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAI$$QEAI@Z
_TEXT	SEGMENT
this$ = 8
<_Args_0>$ = 16
??$_Emplace_valueless@$00I@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAI$$QEAI@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<1,unsigned int>, COMDAT

; 1168 :         // initialize alternative _Idx from _Args...
; 1169 :         _STL_INTERNAL_CHECK(valueless_by_exception());
; 1170 :         _STD _Construct_in_place(_Storage(), integral_constant<size_t, _Idx>{}, static_cast<_ArgTypes&&>(_Args)...);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 1171 :         this->_Set_index(_Idx);
; 1172 :         return _STD _Variant_raw_get<_Idx>(_Storage());

	mov	rax, rcx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 1

; 1173 :     }

	ret	0
??$_Emplace_valueless@$00I@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAI$$QEAI@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<1,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Emplace_valueless@$01M@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAM$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
<_Args_0>$ = 16
??$_Emplace_valueless@$01M@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAM$$QEAM@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<2,float>, COMDAT

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 1168 :         // initialize alternative _Idx from _Args...
; 1169 :         _STL_INTERNAL_CHECK(valueless_by_exception());
; 1170 :         _STD _Construct_in_place(_Storage(), integral_constant<size_t, _Idx>{}, static_cast<_ArgTypes&&>(_Args)...);
; 1171 :         this->_Set_index(_Idx);
; 1172 :         return _STD _Variant_raw_get<_Idx>(_Storage());

	mov	rax, rcx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 2

; 1173 :     }

	ret	0
??$_Emplace_valueless@$01M@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAM$$QEAM@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<2,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Emplace_valueless@$02VVector3F@@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAVVector3F@@$$QEAV2@@Z
_TEXT	SEGMENT
this$ = 8
<_Args_0>$ = 16
??$_Emplace_valueless@$02VVector3F@@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAVVector3F@@$$QEAV2@@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<3,Vector3F>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax

; 1168 :         // initialize alternative _Idx from _Args...
; 1169 :         _STL_INTERNAL_CHECK(valueless_by_exception());
; 1170 :         _STD _Construct_in_place(_Storage(), integral_constant<size_t, _Idx>{}, static_cast<_ArgTypes&&>(_Args)...);
; 1171 :         this->_Set_index(_Idx);
; 1172 :         return _STD _Variant_raw_get<_Idx>(_Storage());

	mov	rax, rcx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 3

; 1173 :     }

	ret	0
??$_Emplace_valueless@$02VVector3F@@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAVVector3F@@$$QEAV2@@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<3,Vector3F>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Emplace_valueless@$03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Args_0>$ = 16
??$_Emplace_valueless@$03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<4,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1172 :         return _STD _Variant_raw_get<_Idx>(_Storage());

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 4

; 1173 :     }

	ret	0
??$_Emplace_valueless@$03V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<4,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Emplace_valueless@$00AEAG@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAIAEAG@Z
_TEXT	SEGMENT
this$ = 8
<_Args_0>$ = 16
??$_Emplace_valueless@$00AEAG@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAIAEAG@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<1,unsigned short &>, COMDAT

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	movzx	eax, WORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 1168 :         // initialize alternative _Idx from _Args...
; 1169 :         _STL_INTERNAL_CHECK(valueless_by_exception());
; 1170 :         _STD _Construct_in_place(_Storage(), integral_constant<size_t, _Idx>{}, static_cast<_ArgTypes&&>(_Args)...);
; 1171 :         this->_Set_index(_Idx);
; 1172 :         return _STD _Variant_raw_get<_Idx>(_Storage());

	mov	rax, rcx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 1

; 1173 :     }

	ret	0
??$_Emplace_valueless@$00AEAG@?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@AEAAAEAIAEAG@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Emplace_valueless<1,unsigned short &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Find_unchecked@PEAHH@std@@YAPEAHPEAHQEAHAEBH@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Find_unchecked@PEAHH@std@@YAPEAHPEAHQEAHAEBH@Z PROC	; std::_Find_unchecked<int *,int>, COMDAT

; 124  :         return const_cast<_Ty*>(

	mov	r8d, DWORD PTR [r8]
	jmp	__std_find_trivial_4
??$_Find_unchecked@PEAHH@std@@YAPEAHPEAHQEAHAEBH@Z ENDP	; std::_Find_unchecked<int *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PEAH@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@$$QEAPEAH@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PEAH@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@$$QEAPEAH@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *>, COMDAT

; 1256 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1257 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1258 :     } else {
; 1259 :         _It = _STD forward<_UIter>(_UIt);
; 1260 :     }
; 1261 : }

	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PEAH@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@$$QEAPEAH@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_Newvec$ = 32
this$ = 96
_Newcapacity$ = 104
_Newsize$ = 104
_Val$dead$ = 112
_Appended_last$ = 112
_Appended_first$ = 120
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN19:
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rsi, rdx
	mov	rdi, rcx

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 135637824071393761			; 01e1e1e1e1e1e1e1H
	cmp	rdx, rbx
	ja	$LN18@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r15, QWORD PTR [rcx+8]
	sub	r15, QWORD PTR [rcx]
	sar	r15, 3
	mov	rdx, -1085102592571150095		; f0f0f0f0f0f0f0f1H
	imul	r15, rdx

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rdi]
	sar	rcx, 3
	imul	rcx, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rsi
	cmovb	rbx, rsi
$LN16@Resize_rea:

; 1522 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1523 : 
; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	call	?allocate@?$allocator@UInstructionStruct@EXB@@@std@@QEAAPEAUInstructionStruct@EXB@@_K@Z ; std::allocator<EXB::InstructionStruct>::allocate
	mov	r14, rax
	mov	QWORD PTR _Newvec$[rsp], rax

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	imul	rcx, r15, 136				; 00000088H
	add	rcx, rax
	mov	QWORD PTR _Appended_first$[rsp], rcx

; 1526 :         pointer _Appended_last        = _Appended_first;

	mov	QWORD PTR _Appended_last$[rsp], rcx

; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, rsi
	sub	rdx, r15
	mov	r8, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<EXB::InstructionStruct> >
	mov	QWORD PTR _Appended_last$[rsp], rax

; 1534 :         }
; 1535 : 
; 1536 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r8, r14
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rdi]
	call	??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ; std::_Uninitialized_move<EXB::InstructionStruct *,std::allocator<EXB::InstructionStruct> >
	npad	1

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, rdi

; 1548 :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Change_array
$LN18@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@CAXXZ ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Xlength
	int	3
$LN15@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
this$ = 96
_Newcapacity$ = 104
_Newsize$ = 104
_Val$dead$ = 112
_Appended_last$ = 112
_Appended_first$ = 120
?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA PROC ; `std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Resize_reallocate<std::_Value_init_tag>'::`1'::catch$0

; 1541 :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z$0:

; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);

	mov	rdx, QWORD PTR _Appended_last$[rbp]
	mov	rcx, QWORD PTR _Appended_first$[rbp]
	call	??$_Destroy_range@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAXPEAUInstructionStruct@EXB@@QEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ; std::_Destroy_range<std::allocator<EXB::InstructionStruct> >

; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	call	?deallocate@?$allocator@UInstructionStruct@EXB@@@std@@QEAAXQEAUInstructionStruct@EXB@@_K@Z ; std::allocator<EXB::InstructionStruct>::deallocate

; 1544 :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA ENDP ; `std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Resize_reallocate<std::_Value_init_tag>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Al$ = 96
??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<EXB::InstructionStruct> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN44:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], rcx
	mov	QWORD PTR _Backout$[rsp+8], rcx
	mov	QWORD PTR _Backout$[rsp+16], r8

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN41@Uninitiali
	npad	5
$LL4@Uninitiali:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	movups	XMMWORD PTR [rbx], xmm0
	movups	XMMWORD PTR [rbx+16], xmm0
	movups	XMMWORD PTR [rbx+32], xmm0
	movups	XMMWORD PTR [rbx+48], xmm0
	movups	XMMWORD PTR [rbx+64], xmm0
	movups	XMMWORD PTR [rbx+80], xmm0
	movups	XMMWORD PTR [rbx+96], xmm0
	movups	XMMWORD PTR [rbx+112], xmm0
	mov	QWORD PTR [rbx+128], rax
	mov	rcx, rbx
	call	??0InstructionStruct@EXB@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 136				; 00000088H
	mov	QWORD PTR _Backout$[rsp+8], rbx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdi, 1
	jne	SHORT $LL4@Uninitiali
$LN41@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<EXB::InstructionStruct> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Al$ = 96
?dtor$0@?0???$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z@4HA PROC ; `std::_Uninitialized_value_construct_n<std::allocator<EXB::InstructionStruct> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<EXB::InstructionStruct> >::~_Uninitialized_backout_al<std::allocator<EXB::InstructionStruct> >
?dtor$0@?0???$_Uninitialized_value_construct_n@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@PEAU12@_KAEAV?$allocator@UInstructionStruct@EXB@@@0@@Z@4HA ENDP ; `std::_Uninitialized_value_construct_n<std::allocator<EXB::InstructionStruct> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBUInstructionStruct@EXB@@@std@@YAAEBUInstructionStruct@EXB@@AEBU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUInstructionStruct@EXB@@@std@@YAAEBUInstructionStruct@EXB@@AEBU12@@Z PROC ; std::forward<EXB::InstructionStruct const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBUInstructionStruct@EXB@@@std@@YAAEBUInstructionStruct@EXB@@AEBU12@@Z ENDP ; std::forward<EXB::InstructionStruct const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_back_with_unused_capacity@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z PROC ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_back_with_unused_capacity<EXB::InstructionStruct const &>, COMDAT

; 789  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
	call	??0InstructionStruct@EXB@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+136]
	mov	QWORD PTR [rbx+8], rdx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Emplace_back_with_unused_capacity@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAAEAUInstructionStruct@EXB@@AEBU23@@Z ENDP ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_back_with_unused_capacity<EXB::InstructionStruct const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z PROC ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_reallocate<EXB::InstructionStruct const &>, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN26:
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r13, rdx
	mov	rsi, rcx

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	r10, QWORD PTR [rcx]
	mov	r9, rdx
	sub	r9, r10
	mov	rax, 8680820740569200761		; 7878787878787879H
	imul	r9
	mov	r14, rdx
	sar	r14, 6
	mov	rax, r14
	shr	rax, 63					; 0000003fH
	add	r14, rax

; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r12, QWORD PTR [rcx+8]
	sub	r12, r10
	sar	r12, 3
	mov	rax, -1085102592571150095		; f0f0f0f0f0f0f0f1H
	imul	r12, rax

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 135637824071393761			; 01e1e1e1e1e1e1e1H
	cmp	r12, rbx
	je	$LN25@Emplace_re

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	inc	r12

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, r10
	sar	rcx, 3
	imul	rcx, rax

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN22@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, r12
	cmovb	rbx, r12
$LN22@Emplace_re:

; 829  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 830  : 
; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	call	?allocate@?$allocator@UInstructionStruct@EXB@@@std@@QEAAPEAUInstructionStruct@EXB@@_K@Z ; std::allocator<EXB::InstructionStruct>::allocate
	mov	rdi, rax
	mov	QWORD PTR _Newvec$[rsp], rax

; 832  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	imul	r14, r14, 136				; 00000088H
	add	r14, rax
	lea	r15, QWORD PTR [r14+136]
	mov	QWORD PTR _Constructed_last$[rsp], r15

; 833  :         pointer _Constructed_first      = _Constructed_last;

	mov	QWORD PTR _Constructed_first$[rsp], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR <_Val_0>$[rsp]
	mov	rcx, r14
	call	??0InstructionStruct@EXB@@QEAA@AEBU01@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 837  :         _Constructed_first = _Newvec + _Whereoff;

	mov	QWORD PTR _Constructed_first$[rsp], r14

; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	mov	r8, rdi
	cmp	r13, rdx
	je	SHORT $LN23@Emplace_re

; 840  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 841  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             } else {
; 843  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 844  :             }
; 845  :         } else { // provide basic guarantee
; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	rdx, r13
	call	??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ; std::_Uninitialized_move<EXB::InstructionStruct *,std::allocator<EXB::InstructionStruct> >

; 847  :             _Constructed_first = _Newvec;

	mov	QWORD PTR _Constructed_first$[rsp], rdi

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	r8, r15
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, r13
$LN23@Emplace_re:
	call	??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ; std::_Uninitialized_move<EXB::InstructionStruct *,std::allocator<EXB::InstructionStruct> >
	npad	1

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, r12
	mov	rdx, rdi
	mov	rcx, rsi
	call	?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Change_array

; 857  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 858  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN25@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@CAXXZ ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Xlength
	int	3
$LN21@Emplace_re:
??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z ENDP ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_reallocate<EXB::InstructionStruct const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?catch$0@?0???$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z@4HA PROC ; `std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_reallocate<EXB::InstructionStruct const &>'::`1'::catch$0

; 850  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z$0:

; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rdx, QWORD PTR _Constructed_last$[rbp]
	mov	rcx, QWORD PTR _Constructed_first$[rbp]
	call	??$_Destroy_range@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAXPEAUInstructionStruct@EXB@@QEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ; std::_Destroy_range<std::allocator<EXB::InstructionStruct> >

; 852  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	call	?deallocate@?$allocator@UInstructionStruct@EXB@@@std@@QEAAXQEAUInstructionStruct@EXB@@_K@Z ; std::allocator<EXB::InstructionStruct>::deallocate

; 853  :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Emplace_reallocate@AEBUInstructionStruct@EXB@@@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAPEAUInstructionStruct@EXB@@QEAU23@AEBU23@@Z@4HA ENDP ; `std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Emplace_reallocate<EXB::InstructionStruct const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAXPEBH@Z
_TEXT	SEGMENT
this$ = 8
_It$ = 16
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAXPEBH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Seek_to, COMDAT

; 218  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

	mov	QWORD PTR [rcx], rdx

; 219  :     }

	ret	0
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAAXPEBH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z PROC ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r14, r9
	mov	r15, r8
	mov	rbp, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN20@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
	mov	rcx, rbx
	call	??1InstructionStruct@EXB@@QEAA@XZ
	add	rbx, 136				; 00000088H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -1085102592571150095		; f0f0f0f0f0f0f0f1H
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 136				; 00000088H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	QWORD PTR [rsi], rbp
	imul	rax, r15, 136				; 00000088H
	add	rax, rbp
	mov	QWORD PTR [rsi+8], rax
	imul	rax, r14, 136				; 00000088H
	add	rax, rbp
	mov	rbp, QWORD PTR [rsp+88]
	mov	QWORD PTR [rsi+16], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN29@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@Change_arr:
?_Change_array@?$vector@UInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@AEAAXQEAUInstructionStruct@EXB@@_K1@Z ENDP ; std::vector<EXB::InstructionStruct,std::allocator<EXB::InstructionStruct> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ??$?0$00I$0A@@?$_Non_trivial_copy_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z
_TEXT	SEGMENT
this$ = 8
__param0$dead$ = 16
__param1$ = 24
??$?0$00I$0A@@?$_Non_trivial_copy_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z PROC ; std::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rcx+32], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

	ret	0
??$?0$00I$0A@@?$_Non_trivial_copy_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ENDP ; std::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$0A@@2@_N@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$0A@@0@$$QEA_N@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$0A@@2@_N@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$0A@@0@$$QEA_N@Z PROC ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,0>,bool>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx], al
	ret	0
??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$0A@@2@_N@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$0A@@0@$$QEA_N@Z ENDP ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,0>,bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@I@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$00@0@$$QEAI@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@I@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$00@0@$$QEAI@Z PROC ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned int>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	ret	0
??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@I@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$00@0@$$QEAI@Z ENDP ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$01@2@M@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$01@0@$$QEAM@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$01@2@M@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$01@0@$$QEAM@Z PROC ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,2>,float>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	ret	0
??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$01@2@M@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$01@0@$$QEAM@Z ENDP ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,2>,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$02@2@VVector3F@@@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$02@0@$$QEAVVector3F@@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$02@2@VVector3F@@@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$02@0@$$QEAVVector3F@@@Z PROC ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,3>,Vector3F>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [r8]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 256  : }

	ret	0
??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$02@2@VVector3F@@@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$02@0@$$QEAVVector3F@@@Z ENDP ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,3>,Vector3F>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@AEAG@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$00@0@AEAG@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@AEAG@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$00@0@AEAG@Z PROC ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned short &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	movzx	eax, WORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	ret	0
??$_Construct_in_place@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@AEAG@std@@YAXAEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$integral_constant@_K$00@0@AEAG@Z ENDP ; std::_Construct_in_place<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned short &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Could_compare_equal_to_value_type@PEAHH@std@@YA_NAEBH@Z
_TEXT	SEGMENT
_Val$dead$ = 8
??$_Could_compare_equal_to_value_type@PEAHH@std@@YA_NAEBH@Z PROC ; std::_Could_compare_equal_to_value_type<int *,int>, COMDAT

; 5747 :     // check whether _Val is within the limits of _Elem
; 5748 :     _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);
; 5749 : 
; 5750 :     if constexpr (disjunction_v<
; 5751 : #ifdef __cpp_lib_byte
; 5752 :                       is_same<_Ty, byte>,
; 5753 : #endif // __cpp_lib_byte
; 5754 :                       is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
; 5755 :         return true;
; 5756 :     } else {
; 5757 :         using _Elem = _Iter_value_t<_InIt>;
; 5758 :         _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);
; 5759 : 
; 5760 :         if constexpr (is_same_v<_Elem, bool>) {
; 5761 :             return _Val == true || _Val == false;
; 5762 :         } else if constexpr (is_signed_v<_Elem>) {
; 5763 :             // use instead of numeric_limits::min/max; avoid <limits> dependency
; 5764 :             constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * CHAR_BIT - 1));
; 5765 :             constexpr _Elem _Max = static_cast<_Elem>(~_Min);
; 5766 : 
; 5767 :             if constexpr (is_signed_v<_Ty>) {
; 5768 :                 // signed _Elem, signed _Ty
; 5769 :                 return _Min <= _Val && _Val <= _Max;

	mov	al, 1

; 5770 :             } else {
; 5771 :                 // signed _Elem, unsigned _Ty
; 5772 :                 if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
; 5773 :                     // negative values of _Elem can compare equal to values of _Ty
; 5774 :                     return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
; 5775 :                 } else {
; 5776 :                     // negative values of _Elem cannot compare equal to values of _Ty
; 5777 :                     return _Val <= _Max;
; 5778 :                 }
; 5779 :             }
; 5780 :         } else {
; 5781 :             constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});
; 5782 : 
; 5783 :             if constexpr (is_unsigned_v<_Ty>) {
; 5784 :                 // unsigned _Elem, unsigned _Ty
; 5785 :                 return _Val <= _Max;
; 5786 :             } else {
; 5787 :                 // unsigned _Elem, signed _Ty
; 5788 :                 if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
; 5789 :                     // negative values of _Ty can compare equal to values of _Elem
; 5790 :                     return _Val <= _Max;
; 5791 :                 } else {
; 5792 :                     // negative values of _Ty cannot compare equal to values of _Elem
; 5793 :                     return 0 <= _Val && _Val <= _Max;
; 5794 :                 }
; 5795 :             }
; 5796 :         }
; 5797 :     }
; 5798 : }

	ret	0
??$_Could_compare_equal_to_value_type@PEAHH@std@@YA_NAEBH@Z ENDP ; std::_Could_compare_equal_to_value_type<int *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$__std_find_trivial@HH@@YAPEAHPEAH0H@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$__std_find_trivial@HH@@YAPEAHPEAH0H@Z PROC		; __std_find_trivial<int,int>, COMDAT

; 115  :     if constexpr (_STD is_pointer_v<_TVal> || _STD is_null_pointer_v<_TVal>) {
; 116  :         return __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
; 117  :     } else if constexpr (sizeof(_Ty) == 1) {
; 118  :         return const_cast<_Ty*>(
; 119  :             static_cast<const _Ty*>(__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 120  :     } else if constexpr (sizeof(_Ty) == 2) {
; 121  :         return const_cast<_Ty*>(
; 122  :             static_cast<const _Ty*>(__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 123  :     } else if constexpr (sizeof(_Ty) == 4) {
; 124  :         return const_cast<_Ty*>(

	jmp	__std_find_trivial_4
??$__std_find_trivial@HH@@YAPEAHPEAH0H@Z ENDP		; __std_find_trivial<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAH@std@@YA$$QEAPEAHAEAPEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAH@std@@YA$$QEAPEAHAEAPEAH@Z PROC		; std::forward<int *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAH@std@@YA$$QEAPEAHAEAPEAH@Z ENDP		; std::forward<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUInstructionStruct@EXB@@@std@@YA?A_TAEBQEAUInstructionStruct@EXB@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUInstructionStruct@EXB@@@std@@YA?A_TAEBQEAUInstructionStruct@EXB@@@Z PROC ; std::_Get_unwrapped<EXB::InstructionStruct * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUInstructionStruct@EXB@@@std@@YA?A_TAEBQEAUInstructionStruct@EXB@@@Z ENDP ; std::_Get_unwrapped<EXB::InstructionStruct * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z PROC ; std::_Uninitialized_move<EXB::InstructionStruct *,std::allocator<EXB::InstructionStruct> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN87:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r11, r8
	mov	rbx, rdx

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	$LN82@Uninitiali
	mov	r10, r8
	mov	QWORD PTR [rsp+56], rdi
	sub	r10, rcx
	lea	r9, QWORD PTR [rcx+128]
	xor	edi, edi
	npad	7
$LL4@Uninitiali:
	movzx	eax, BYTE PTR [r9-128]
	lea	rcx, QWORD PTR [r10-112]
	mov	BYTE PTR [r11], al
	lea	rdx, QWORD PTR [r9-112]
	movzx	eax, WORD PTR [r9-126]
	add	rcx, r9
	mov	WORD PTR [r9+r10-126], ax
	movzx	eax, BYTE PTR [r9-124]
	mov	BYTE PTR [r9+r10-124], al
	movzx	eax, BYTE PTR [r9-123]
	mov	BYTE PTR [r9+r10-123], al
	movzx	eax, WORD PTR [r9-122]
	mov	WORD PTR [r9+r10-122], ax
	movzx	eax, WORD PTR [r9-120]
	mov	WORD PTR [r9+r10-120], ax
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z
	lea	rcx, QWORD PTR [r10-72]
	add	rcx, r9
	lea	rdx, QWORD PTR [r9-72]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z
	movzx	ecx, WORD PTR [r9-32]
	xorps	xmm0, xmm0
	mov	WORD PTR [r9+r10-32], cx

; 1803 :         ++_Last;

	add	r11, 136				; 00000088H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r9+r10-24], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r9+r10-8], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r9+r10], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r9-24]
	movups	XMMWORD PTR [r9+r10-24], xmm0
	movups	xmm1, XMMWORD PTR [r9-8]
	movups	XMMWORD PTR [r9+r10-8], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [r9-8], rdi
	mov	QWORD PTR [r9], 15
	mov	BYTE PTR [r9-24], dil
	add	r9, 136					; 00000088H

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r9-128]
	cmp	rcx, rbx
	jne	$LL4@Uninitiali
	mov	rdi, QWORD PTR [rsp+56]
$LN82@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, r11
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAUInstructionStruct@EXB@@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@0PEAU12@AEAV?$allocator@UInstructionStruct@EXB@@@0@@Z ENDP ; std::_Uninitialized_move<EXB::InstructionStruct *,std::allocator<EXB::InstructionStruct> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<EXB::InstructionStruct> >::_Emplace_back<>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	xorps	xmm0, xmm0
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	movups	XMMWORD PTR [rcx+96], xmm0
	movups	XMMWORD PTR [rcx+112], xmm0
	mov	QWORD PTR [rcx+128], rax
	call	??0InstructionStruct@EXB@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rbx+8], 136			; 00000088H

; 1804 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<EXB::InstructionStruct> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UInstructionStruct@EXB@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@AEBU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UInstructionStruct@EXB@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@AEBU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<EXB::InstructionStruct> >::construct<EXB::InstructionStruct,EXB::InstructionStruct const &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, r8
	jmp	??0InstructionStruct@EXB@@QEAA@AEBU01@@Z
??$construct@UInstructionStruct@EXB@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@AEBU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<EXB::InstructionStruct> >::construct<EXB::InstructionStruct,EXB::InstructionStruct const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Refancy@PEAH$0A@@std@@YAPEAHPEAH@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEAH$0A@@std@@YAPEAHPEAH@Z PROC		; std::_Refancy<int *,0>, COMDAT

; 297  :     return _Ptr;

	mov	rax, rcx

; 298  : }

	ret	0
??$_Refancy@PEAH$0A@@std@@YAPEAHPEAH@Z ENDP		; std::_Refancy<int *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ??$?0$00I$0A@@?$_Non_trivial_move@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z
_TEXT	SEGMENT
this$ = 8
__param0$dead$ = 16
__param1$ = 24
??$?0$00I$0A@@?$_Non_trivial_move@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z PROC ; std::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rcx+32], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

	ret	0
??$?0$00I$0A@@?$_Non_trivial_move@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ENDP ; std::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0_N@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0_N@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEA_N@Z PROC ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><bool>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx
	ret	0
??$?0_N@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEA_N@Z ENDP ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0$00I$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAI@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0$00I$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAI@Z PROC ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax

; 436  :         : _Tail(integral_constant<size_t, _Idx - 1>{}, static_cast<_Types&&>(_Args)...) {} // initialize _Tail (recurse)

	mov	rax, rcx
	ret	0
??$?0$00I$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAI@Z ENDP ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0$01M$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$01@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0$01M$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$01@1@$$QEAM@Z PROC ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><2,float,0>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax

; 436  :         : _Tail(integral_constant<size_t, _Idx - 1>{}, static_cast<_Types&&>(_Args)...) {} // initialize _Tail (recurse)

	mov	rax, rcx
	ret	0
??$?0$01M$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$01@1@$$QEAM@Z ENDP ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><2,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0$02VVector3F@@$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$02@1@$$QEAVVector3F@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0$02VVector3F@@$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$02@1@$$QEAVVector3F@@@Z PROC ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><3,Vector3F,0>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [r8]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+8], eax

; 436  :         : _Tail(integral_constant<size_t, _Idx - 1>{}, static_cast<_Types&&>(_Args)...) {} // initialize _Tail (recurse)

	mov	rax, rcx
	ret	0
??$?0$02VVector3F@@$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$02@1@$$QEAVVector3F@@@Z ENDP ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><3,Vector3F,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0$00AEAG$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@AEAG@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0$00AEAG$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@AEAG@Z PROC ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned short &,0>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movzx	eax, WORD PTR [r8]
	mov	DWORD PTR [rcx], eax

; 436  :         : _Tail(integral_constant<size_t, _Idx - 1>{}, static_cast<_Types&&>(_Args)...) {} // initialize _Tail (recurse)

	mov	rax, rcx
	ret	0
??$?0$00AEAG$0A@@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@AEAG@Z ENDP ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned short &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$0A@@2@_N$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$0A@@0@$$QEA_N@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$0A@@2@_N$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$0A@@0@$$QEA_N@Z PROC ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,0>,bool,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$0A@@2@_N$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$0A@@0@$$QEA_N@Z ENDP ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,0>,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@I$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$00@0@$$QEAI@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@I$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$00@0@$$QEAI@Z PROC ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned int,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@I$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$00@0@$$QEAI@Z ENDP ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$01@2@M$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$01@0@$$QEAM@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$01@2@M$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$01@0@$$QEAM@Z PROC ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,2>,float,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$01@2@M$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$01@0@$$QEAM@Z ENDP ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,2>,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$02@2@VVector3F@@$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$02@0@$$QEAVVector3F@@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$02@2@VVector3F@@$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$02@0@$$QEAVVector3F@@@Z PROC ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,3>,Vector3F,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [r8]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$02@2@VVector3F@@$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$02@0@$$QEAVVector3F@@@Z ENDP ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,3>,Vector3F,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@AEAG$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$00@0@AEAG@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$dead$ = 16
<_Args_1>$ = 24
??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@AEAG$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$00@0@AEAG@Z PROC ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned short &,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movzx	eax, WORD PTR [r8]
	mov	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$integral_constant@_K$00@2@AEAG$0A@@std@@YAPEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@QEAV10@$$QEAU?$integral_constant@_K$00@0@AEAG@Z ENDP ; std::construct_at<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::integral_constant<unsigned __int64,1>,unsigned short &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUInstructionStruct@EXB@@@std@@YA$$QEAUInstructionStruct@EXB@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUInstructionStruct@EXB@@@std@@YA$$QEAUInstructionStruct@EXB@@AEAU12@@Z PROC ; std::move<EXB::InstructionStruct &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUInstructionStruct@EXB@@@std@@YA$$QEAUInstructionStruct@EXB@@AEAU12@@Z ENDP ; std::move<EXB::InstructionStruct &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UInstructionStruct@EXB@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX$$QEAUInstructionStruct@EXB@@@Z
_TEXT	SEGMENT
this$ = 48
<_Vals_0>$ = 56
??$_Emplace_back@UInstructionStruct@EXB@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX$$QEAUInstructionStruct@EXB@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<EXB::InstructionStruct> >::_Emplace_back<EXB::InstructionStruct>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN48:
	sub	rsp, 40					; 00000028H
	movzx	eax, BYTE PTR [rdx]
	mov	r10, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r9, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	r11, rcx
	mov	BYTE PTR [r9], al
	lea	rcx, QWORD PTR [r9+16]
	movzx	eax, WORD PTR [rdx+2]
	mov	WORD PTR [r9+2], ax
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [r9+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [r9+5], al
	movzx	eax, WORD PTR [rdx+6]
	mov	WORD PTR [r9+6], ax
	movzx	eax, WORD PTR [rdx+8]
	add	rdx, 16
	mov	WORD PTR [r9+8], ax
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z
	lea	rdx, QWORD PTR [r10+56]
	lea	rcx, QWORD PTR [r9+56]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z
	movzx	ecx, WORD PTR [r10+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	WORD PTR [r9+96], cx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r9+104], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r9+120], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r9+128], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r10+104]
	movups	XMMWORD PTR [r9+104], xmm0
	movups	xmm1, XMMWORD PTR [r10+120]
	movups	XMMWORD PTR [r9+120], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [r10+120], rax
	mov	QWORD PTR [r10+128], 15
	mov	BYTE PTR [r10+104], al
	add	QWORD PTR [r11+8], 136			; 00000088H

; 1804 :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Emplace_back@UInstructionStruct@EXB@@@?$_Uninitialized_backout_al@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@QEAAX$$QEAUInstructionStruct@EXB@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<EXB::InstructionStruct> >::_Emplace_back<EXB::InstructionStruct>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UInstructionStruct@EXB@@$$V@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UInstructionStruct@EXB@@$$V@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@@Z PROC ; std::_Default_allocator_traits<std::allocator<EXB::InstructionStruct> >::construct<EXB::InstructionStruct>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	movups	XMMWORD PTR [rdx], xmm0
	mov	rcx, rdx
	movups	XMMWORD PTR [rdx+16], xmm0
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	XMMWORD PTR [rdx+48], xmm0
	movups	XMMWORD PTR [rdx+64], xmm0
	movups	XMMWORD PTR [rdx+80], xmm0
	movups	XMMWORD PTR [rdx+96], xmm0
	movups	XMMWORD PTR [rdx+112], xmm0
	mov	QWORD PTR [rdx+128], rax
	jmp	??0InstructionStruct@EXB@@QEAA@XZ
??$construct@UInstructionStruct@EXB@@$$V@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<EXB::InstructionStruct> >::construct<EXB::InstructionStruct>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UInstructionStruct@EXB@@AEBU12@$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@AEBU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UInstructionStruct@EXB@@AEBU12@$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@AEBU12@@Z PROC ; std::construct_at<EXB::InstructionStruct,EXB::InstructionStruct const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	jmp	??0InstructionStruct@EXB@@QEAA@AEBU01@@Z
??$construct_at@UInstructionStruct@EXB@@AEBU12@$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@AEBU12@@Z ENDP ; std::construct_at<EXB::InstructionStruct,EXB::InstructionStruct const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ??$?0$00I$0A@@?$_Non_trivial_copy@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z
_TEXT	SEGMENT
this$ = 8
__param0$dead$ = 16
__param1$ = 24
??$?0$00I$0A@@?$_Non_trivial_copy@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z PROC ; std::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > ><1,unsigned int,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rcx+32], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

	ret	0
??$?0$00I$0A@@?$_Non_trivial_copy@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ENDP ; std::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > ><1,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0I@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAI@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0I@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAI@Z PROC ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??$?0I@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAI@Z ENDP ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0$00M$0A@@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0$00M$0A@@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAM@Z PROC ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,float,0>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax

; 436  :         : _Tail(integral_constant<size_t, _Idx - 1>{}, static_cast<_Types&&>(_Args)...) {} // initialize _Tail (recurse)

	mov	rax, rcx
	ret	0
??$?0$00M$0A@@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAM@Z ENDP ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0$01VVector3F@@$0A@@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$01@1@$$QEAVVector3F@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0$01VVector3F@@$0A@@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$01@1@$$QEAVVector3F@@@Z PROC ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><2,Vector3F,0>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [r8]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+8], eax

; 436  :         : _Tail(integral_constant<size_t, _Idx - 1>{}, static_cast<_Types&&>(_Args)...) {} // initialize _Tail (recurse)

	mov	rax, rcx
	ret	0
??$?0$01VVector3F@@$0A@@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$01@1@$$QEAVVector3F@@@Z ENDP ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><2,Vector3F,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0AEAG@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@AEAG@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0AEAG@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@AEAG@Z PROC ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned short &>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movzx	eax, WORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??$?0AEAG@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@AEAG@Z ENDP ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned short &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UInstructionStruct@EXB@@@std@@YA$$QEAUInstructionStruct@EXB@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UInstructionStruct@EXB@@@std@@YA$$QEAUInstructionStruct@EXB@@AEAU12@@Z PROC ; std::forward<EXB::InstructionStruct>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UInstructionStruct@EXB@@@std@@YA$$QEAUInstructionStruct@EXB@@AEAU12@@Z ENDP ; std::forward<EXB::InstructionStruct>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UInstructionStruct@EXB@@U12@@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@UInstructionStruct@EXB@@U12@@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<EXB::InstructionStruct> >::construct<EXB::InstructionStruct,EXB::InstructionStruct>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN46:
	sub	rsp, 40					; 00000028H
	movzx	eax, BYTE PTR [r8]
	mov	r9, rdx
	mov	BYTE PTR [rdx], al
	mov	r10, r8
	movzx	eax, WORD PTR [r8+2]
	mov	WORD PTR [rdx+2], ax
	movzx	eax, BYTE PTR [r8+4]
	lea	rcx, QWORD PTR [r9+16]
	mov	BYTE PTR [rdx+4], al
	movzx	eax, BYTE PTR [r8+5]
	mov	BYTE PTR [rdx+5], al
	movzx	eax, WORD PTR [r8+6]
	mov	WORD PTR [rdx+6], ax
	movzx	eax, WORD PTR [r8+8]
	mov	WORD PTR [rdx+8], ax
	lea	rdx, QWORD PTR [r8+16]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z
	lea	rdx, QWORD PTR [r10+56]
	lea	rcx, QWORD PTR [r9+56]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z
	movzx	ecx, WORD PTR [r10+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	WORD PTR [r9+96], cx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r9+104], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r9+120], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r9+128], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r10+104]
	movups	XMMWORD PTR [r9+104], xmm0
	movups	xmm1, XMMWORD PTR [r10+120]
	movups	XMMWORD PTR [r9+120], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	QWORD PTR [r10+120], rax
	mov	QWORD PTR [r10+128], 15
	mov	BYTE PTR [r10+104], al
	add	rsp, 40					; 00000028H
	ret	0
??$construct@UInstructionStruct@EXB@@U12@@?$_Default_allocator_traits@V?$allocator@UInstructionStruct@EXB@@@std@@@std@@SAXAEAV?$allocator@UInstructionStruct@EXB@@@1@QEAUInstructionStruct@EXB@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<EXB::InstructionStruct> >::construct<EXB::InstructionStruct,EXB::InstructionStruct>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UInstructionStruct@EXB@@$$V$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UInstructionStruct@EXB@@$$V$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@@Z PROC ; std::construct_at<EXB::InstructionStruct,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	xorps	xmm0, xmm0

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	movups	XMMWORD PTR [rcx+96], xmm0
	movups	XMMWORD PTR [rcx+112], xmm0
	mov	QWORD PTR [rcx+128], rax
	jmp	??0InstructionStruct@EXB@@QEAA@XZ
??$construct_at@UInstructionStruct@EXB@@$$V$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@@Z ENDP ; std::construct_at<EXB::InstructionStruct,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp
;	COMDAT ??$?0$00I$0A@@?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z
_TEXT	SEGMENT
this$ = 8
__param0$dead$ = 16
__param1$ = 24
??$?0$00I$0A@@?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z PROC ; std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	BYTE PTR [rcx+32], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\EXB.cpp

	ret	0
??$?0$00I$0A@@?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ENDP ; std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0M@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0M@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAM@Z PROC ; std::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><float>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??$?0M@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAM@Z ENDP ; std::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0$00VVector3F@@$0A@@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAVVector3F@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0$00VVector3F@@$0A@@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAVVector3F@@@Z PROC ; std::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,Vector3F,0>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [r8]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+8], eax

; 436  :         : _Tail(integral_constant<size_t, _Idx - 1>{}, static_cast<_Types&&>(_Args)...) {} // initialize _Tail (recurse)

	mov	rax, rcx
	ret	0
??$?0$00VVector3F@@$0A@@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$00@1@$$QEAVVector3F@@@Z ENDP ; std::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,Vector3F,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UInstructionStruct@EXB@@U12@$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$ = 56
??$construct_at@UInstructionStruct@EXB@@U12@$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<EXB::InstructionStruct,EXB::InstructionStruct,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN44:
	sub	rsp, 40					; 00000028H
	movzx	eax, BYTE PTR [rdx]
	mov	r9, rdx
	mov	BYTE PTR [rcx], al
	mov	r10, rcx
	movzx	eax, WORD PTR [rdx+2]
	mov	WORD PTR [rcx+2], ax
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, WORD PTR [rdx+6]
	mov	WORD PTR [rcx+6], ax
	movzx	eax, WORD PTR [rdx+8]
	add	rdx, 16
	mov	WORD PTR [rcx+8], ax
	add	rcx, 16
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z
	lea	rdx, QWORD PTR [r9+56]
	lea	rcx, QWORD PTR [r10+56]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z
	movzx	ecx, WORD PTR [r9+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	WORD PTR [r10+96], cx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r10+104], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+120], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+128], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r9+104]
	movups	XMMWORD PTR [r10+104], xmm0
	movups	xmm1, XMMWORD PTR [r9+120]
	movups	XMMWORD PTR [r10+120], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [r9+120], rax
	mov	QWORD PTR [r9+128], 15
	mov	BYTE PTR [r9+104], al
	mov	rax, r10

; 242  : }

	add	rsp, 40					; 00000028H
	ret	0
??$construct_at@UInstructionStruct@EXB@@U12@$0A@@std@@YAPEAUInstructionStruct@EXB@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<EXB::InstructionStruct,EXB::InstructionStruct,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0InstructionStruct@EXB@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0InstructionStruct@EXB@@QEAA@$$QEAU01@@Z PROC		; EXB::InstructionStruct::InstructionStruct, COMDAT
$LN41:
	sub	rsp, 40					; 00000028H
	movzx	eax, BYTE PTR [rdx]
	mov	r9, rdx
	mov	BYTE PTR [rcx], al
	mov	r10, rcx
	movzx	eax, WORD PTR [rdx+2]
	mov	WORD PTR [rcx+2], ax
	movzx	eax, BYTE PTR [rdx+4]
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+5]
	mov	BYTE PTR [rcx+5], al
	movzx	eax, WORD PTR [rdx+6]
	mov	WORD PTR [rcx+6], ax
	movzx	eax, WORD PTR [rdx+8]
	add	rdx, 16
	mov	WORD PTR [rcx+8], ax
	add	rcx, 16
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z
	lea	rdx, QWORD PTR [r9+56]
	lea	rcx, QWORD PTR [r10+56]
	call	??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z
	movzx	ecx, WORD PTR [r9+96]

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	WORD PTR [r10+96], cx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r10+104], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+120], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+128], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r9+104]
	movups	XMMWORD PTR [r10+104], xmm0
	movups	xmm1, XMMWORD PTR [r9+120]
	movups	XMMWORD PTR [r10+120], xmm1
	mov	QWORD PTR [r9+120], rax
	mov	QWORD PTR [r9+128], 15
	mov	BYTE PTR [r9+104], al
	mov	rax, r10
	add	rsp, 40					; 00000028H
	ret	0
??0InstructionStruct@EXB@@QEAA@$$QEAU01@@Z ENDP		; EXB::InstructionStruct::InstructionStruct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	r8, OFFSET FLAT:__ImageBase

; 788  :     _CONSTEXPR20 _Variant_base() noexcept : _Storage_t{}, _Which{_Invalid_index} {}

	mov	BYTE PTR [rcx+32], -1

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rdx+32]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN233@variant[r8+rax*4+4]
	add	rax, r8
	jmp	rax
$LN31@variant:

; 716  :             _STD _Construct_in_place(

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 0
	ret	0
$LN32@variant:

; 716  :             _STD _Construct_in_place(

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 1
	ret	0
$LN33@variant:

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 2
	ret	0
$LN34@variant:

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	rax, rcx

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 3
	ret	0
$LN35@variant:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 4
$LN27@variant:
	mov	rax, rcx
	ret	0
$LN47@variant:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN234@variant:
$LN233@variant:
	DD	$LN27@variant
	DD	$LN31@variant
	DD	$LN32@variant
	DD	$LN33@variant
	DD	$LN34@variant
	DD	$LN35@variant
??0?$variant@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::variant<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
;	COMDAT ??0?$_Non_trivial_move_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$_Non_trivial_move_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z PROC ; std::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	r8, OFFSET FLAT:__ImageBase

; 788  :     _CONSTEXPR20 _Variant_base() noexcept : _Storage_t{}, _Which{_Invalid_index} {}

	mov	BYTE PTR [rcx+32], -1

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rdx+32]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN229@Non_trivia[r8+rax*4+4]
	add	rax, r8
	jmp	rax
$LN28@Non_trivia:

; 716  :             _STD _Construct_in_place(

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 129  :     _Non_trivial_move_assign(_Non_trivial_move_assign&&)                 = default;

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 129  :     _Non_trivial_move_assign(_Non_trivial_move_assign&&)                 = default;

	ret	0
$LN29@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 716  :             _STD _Construct_in_place(

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 129  :     _Non_trivial_move_assign(_Non_trivial_move_assign&&)                 = default;

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 129  :     _Non_trivial_move_assign(_Non_trivial_move_assign&&)                 = default;

	ret	0
$LN30@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 129  :     _Non_trivial_move_assign(_Non_trivial_move_assign&&)                 = default;

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 129  :     _Non_trivial_move_assign(_Non_trivial_move_assign&&)                 = default;

	ret	0
$LN31@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 129  :     _Non_trivial_move_assign(_Non_trivial_move_assign&&)                 = default;

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 129  :     _Non_trivial_move_assign(_Non_trivial_move_assign&&)                 = default;

	ret	0
$LN32@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 4
$LN24@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 129  :     _Non_trivial_move_assign(_Non_trivial_move_assign&&)                 = default;

	mov	rax, rcx
	ret	0
$LN44@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN230@Non_trivia:
$LN229@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 129  :     _Non_trivial_move_assign(_Non_trivial_move_assign&&)                 = default;

	DD	$LN24@Non_trivia
	DD	$LN28@Non_trivia
	DD	$LN29@Non_trivia
	DD	$LN30@Non_trivia
	DD	$LN31@Non_trivia
	DD	$LN32@Non_trivia
??0?$_Non_trivial_move_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z ENDP ; std::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
;	COMDAT ??0?$_Non_trivial_copy_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0?$_Non_trivial_copy_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z PROC ; std::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	r8, OFFSET FLAT:__ImageBase

; 788  :     _CONSTEXPR20 _Variant_base() noexcept : _Storage_t{}, _Which{_Invalid_index} {}

	mov	BYTE PTR [rcx+32], -1

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rdx+32]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN225@Non_trivia[r8+rax*4+4]
	add	rax, r8
	jmp	rax
$LN25@Non_trivia:

; 716  :             _STD _Construct_in_place(

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 92   :     _Non_trivial_copy_assign(_Non_trivial_copy_assign&&)      = default;

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 92   :     _Non_trivial_copy_assign(_Non_trivial_copy_assign&&)      = default;

	ret	0
$LN26@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 716  :             _STD _Construct_in_place(

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 92   :     _Non_trivial_copy_assign(_Non_trivial_copy_assign&&)      = default;

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 92   :     _Non_trivial_copy_assign(_Non_trivial_copy_assign&&)      = default;

	ret	0
$LN27@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 92   :     _Non_trivial_copy_assign(_Non_trivial_copy_assign&&)      = default;

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 92   :     _Non_trivial_copy_assign(_Non_trivial_copy_assign&&)      = default;

	ret	0
$LN28@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 92   :     _Non_trivial_copy_assign(_Non_trivial_copy_assign&&)      = default;

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 92   :     _Non_trivial_copy_assign(_Non_trivial_copy_assign&&)      = default;

	ret	0
$LN29@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 4
$LN21@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 92   :     _Non_trivial_copy_assign(_Non_trivial_copy_assign&&)      = default;

	mov	rax, rcx
	ret	0
$LN41@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN226@Non_trivia:
$LN225@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 92   :     _Non_trivial_copy_assign(_Non_trivial_copy_assign&&)      = default;

	DD	$LN21@Non_trivia
	DD	$LN25@Non_trivia
	DD	$LN26@Non_trivia
	DD	$LN27@Non_trivia
	DD	$LN28@Non_trivia
	DD	$LN29@Non_trivia
??0?$_Non_trivial_copy_assign@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z ENDP ; std::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_copy_assign<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
;	COMDAT ??0?$_Non_trivial_move@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
_That$ = 16
??0?$_Non_trivial_move@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z PROC ; std::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	r8, OFFSET FLAT:__ImageBase

; 788  :     _CONSTEXPR20 _Variant_base() noexcept : _Storage_t{}, _Which{_Invalid_index} {}

	mov	BYTE PTR [rcx+32], -1

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rdx+32]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN221@Non_trivia[r8+rax*4+4]
	add	rax, r8
	jmp	rax
$LN22@Non_trivia:

; 716  :             _STD _Construct_in_place(

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 62   :     }

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 62   :     }

	ret	0
$LN23@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 716  :             _STD _Construct_in_place(

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 62   :     }

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 62   :     }

	ret	0
$LN24@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 62   :     }

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 62   :     }

	ret	0
$LN25@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 62   :     }

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 62   :     }

	ret	0
$LN26@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 4
$LN18@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 62   :     }

	mov	rax, rcx
	ret	0
$LN38@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN222@Non_trivia:
$LN221@Non_trivia:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 62   :     }

	DD	$LN18@Non_trivia
	DD	$LN22@Non_trivia
	DD	$LN23@Non_trivia
	DD	$LN24@Non_trivia
	DD	$LN25@Non_trivia
	DD	$LN26@Non_trivia
??0?$_Non_trivial_move@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@$$QEAU01@@Z ENDP ; std::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Non_trivial_move<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
;	COMDAT ??0?$_Non_trivial_copy@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Non_trivial_copy@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 788  :     _CONSTEXPR20 _Variant_base() noexcept : _Storage_t{}, _Which{_Invalid_index} {}

	mov	BYTE PTR [rcx+32], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 27   :     _Non_trivial_copy() = default;

	mov	rax, rcx
	ret	0
??0?$_Non_trivial_copy@U?$_Variant_destroy_layer_@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Non_trivial_copy<std::_Variant_destroy_layer_<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ?_Construct_from@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAX$$QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_That$ = 16
?_Construct_from@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAX$$QEAV12@@Z PROC ; std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Construct_from, COMDAT

; 803  :         return static_cast<size_t>(_Which);

	movsx	rax, BYTE PTR [rdx+32]

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	r8, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN209@Construct_[r8+rax*4+4]
	add	rax, r8
	jmp	rax
$LN11@Construct_:

; 716  :             _STD _Construct_in_place(

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 0
$LN7@Construct_:

; 856  :         // move _That's contained value into *this
; 857  :         // pre: valueless_by_exception()
; 858  :         _STD _Variant_raw_visit(
; 859  :             _That.index(), _STD move(_That)._Storage(), _Variant_construct_visitor<_Types...>{*this});
; 860  :     }

	ret	0
$LN12@Construct_:

; 716  :             _STD _Construct_in_place(

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 1

; 856  :         // move _That's contained value into *this
; 857  :         // pre: valueless_by_exception()
; 858  :         _STD _Variant_raw_visit(
; 859  :             _That.index(), _STD move(_That)._Storage(), _Variant_construct_visitor<_Types...>{*this});
; 860  :     }

	ret	0
$LN13@Construct_:

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 2

; 856  :         // move _That's contained value into *this
; 857  :         // pre: valueless_by_exception()
; 858  :         _STD _Variant_raw_visit(
; 859  :             _That.index(), _STD move(_That)._Storage(), _Variant_construct_visitor<_Types...>{*this});
; 860  :     }

	ret	0
$LN14@Construct_:

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 3

; 856  :         // move _That's contained value into *this
; 857  :         // pre: valueless_by_exception()
; 858  :         _STD _Variant_raw_visit(
; 859  :             _That.index(), _STD move(_That)._Storage(), _Variant_construct_visitor<_Types...>{*this});
; 860  :     }

	ret	0
$LN15@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 4

; 856  :         // move _That's contained value into *this
; 857  :         // pre: valueless_by_exception()
; 858  :         _STD _Variant_raw_visit(
; 859  :             _That.index(), _STD move(_That)._Storage(), _Variant_construct_visitor<_Types...>{*this});
; 860  :     }

	ret	0
$LN27@Construct_:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN210@Construct_:
	npad	3
$LN209@Construct_:

; 856  :         // move _That's contained value into *this
; 857  :         // pre: valueless_by_exception()
; 858  :         _STD _Variant_raw_visit(
; 859  :             _That.index(), _STD move(_That)._Storage(), _Variant_construct_visitor<_Types...>{*this});
; 860  :     }

	DD	$LN7@Construct_
	DD	$LN11@Construct_
	DD	$LN12@Construct_
	DD	$LN13@Construct_
	DD	$LN14@Construct_
	DD	$LN15@Construct_
?_Construct_from@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAAX$$QEAV12@@Z ENDP ; std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Construct_from
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Variant_raw_get@$0A@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Variant_raw_get@$0A@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Variant_raw_get<0,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 517  :     // access the _Idx-th element of a _Variant_storage
; 518  :     if constexpr (_Idx == 0) {
; 519  :         return static_cast<_Storage&&>(_Obj)._Get();

	mov	rax, rcx

; 520  :     } else if constexpr (_Idx == 1) {
; 521  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 522  :     } else if constexpr (_Idx == 2) {
; 523  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 524  :     } else if constexpr (_Idx == 3) {
; 525  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 526  :     } else if constexpr (_Idx == 4) {
; 527  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();
; 528  :     } else if constexpr (_Idx == 5) {
; 529  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 530  :     } else if constexpr (_Idx == 6) {
; 531  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 532  :     } else if constexpr (_Idx == 7) {
; 533  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 534  :     } else if constexpr (_Idx < 16) {
; 535  :         return _STD _Variant_raw_get<_Idx - 8>(
; 536  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 537  :     } else if constexpr (_Idx < 32) {
; 538  :         return _STD _Variant_raw_get<_Idx - 16>(
; 539  :             static_cast<_Storage&&>(_Obj)
; 540  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 541  :     } else if constexpr (_Idx < 64) {
; 542  :         return _STD _Variant_raw_get<_Idx - 32>(
; 543  :             static_cast<_Storage&&>(_Obj)
; 544  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 545  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 546  :     } else { // _Idx >= 64
; 547  :         return _STD _Variant_raw_get<_Idx - 64>(
; 548  :             static_cast<_Storage&&>(_Obj)
; 549  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 550  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 551  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 552  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 553  :     }
; 554  : }

	ret	0
??$_Variant_raw_get@$0A@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Variant_raw_get<0,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Variant_raw_get@$00V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Variant_raw_get@$00V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Variant_raw_get<1,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 517  :     // access the _Idx-th element of a _Variant_storage
; 518  :     if constexpr (_Idx == 0) {
; 519  :         return static_cast<_Storage&&>(_Obj)._Get();
; 520  :     } else if constexpr (_Idx == 1) {
; 521  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();

	mov	rax, rcx

; 522  :     } else if constexpr (_Idx == 2) {
; 523  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 524  :     } else if constexpr (_Idx == 3) {
; 525  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 526  :     } else if constexpr (_Idx == 4) {
; 527  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();
; 528  :     } else if constexpr (_Idx == 5) {
; 529  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 530  :     } else if constexpr (_Idx == 6) {
; 531  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 532  :     } else if constexpr (_Idx == 7) {
; 533  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 534  :     } else if constexpr (_Idx < 16) {
; 535  :         return _STD _Variant_raw_get<_Idx - 8>(
; 536  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 537  :     } else if constexpr (_Idx < 32) {
; 538  :         return _STD _Variant_raw_get<_Idx - 16>(
; 539  :             static_cast<_Storage&&>(_Obj)
; 540  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 541  :     } else if constexpr (_Idx < 64) {
; 542  :         return _STD _Variant_raw_get<_Idx - 32>(
; 543  :             static_cast<_Storage&&>(_Obj)
; 544  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 545  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 546  :     } else { // _Idx >= 64
; 547  :         return _STD _Variant_raw_get<_Idx - 64>(
; 548  :             static_cast<_Storage&&>(_Obj)
; 549  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 550  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 551  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 552  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 553  :     }
; 554  : }

	ret	0
??$_Variant_raw_get@$00V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Variant_raw_get<1,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Variant_raw_get@$01V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Variant_raw_get@$01V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Variant_raw_get<2,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 517  :     // access the _Idx-th element of a _Variant_storage
; 518  :     if constexpr (_Idx == 0) {
; 519  :         return static_cast<_Storage&&>(_Obj)._Get();
; 520  :     } else if constexpr (_Idx == 1) {
; 521  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 522  :     } else if constexpr (_Idx == 2) {
; 523  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();

	mov	rax, rcx

; 524  :     } else if constexpr (_Idx == 3) {
; 525  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 526  :     } else if constexpr (_Idx == 4) {
; 527  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();
; 528  :     } else if constexpr (_Idx == 5) {
; 529  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 530  :     } else if constexpr (_Idx == 6) {
; 531  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 532  :     } else if constexpr (_Idx == 7) {
; 533  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 534  :     } else if constexpr (_Idx < 16) {
; 535  :         return _STD _Variant_raw_get<_Idx - 8>(
; 536  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 537  :     } else if constexpr (_Idx < 32) {
; 538  :         return _STD _Variant_raw_get<_Idx - 16>(
; 539  :             static_cast<_Storage&&>(_Obj)
; 540  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 541  :     } else if constexpr (_Idx < 64) {
; 542  :         return _STD _Variant_raw_get<_Idx - 32>(
; 543  :             static_cast<_Storage&&>(_Obj)
; 544  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 545  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 546  :     } else { // _Idx >= 64
; 547  :         return _STD _Variant_raw_get<_Idx - 64>(
; 548  :             static_cast<_Storage&&>(_Obj)
; 549  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 550  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 551  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 552  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 553  :     }
; 554  : }

	ret	0
??$_Variant_raw_get@$01V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Variant_raw_get<2,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Variant_raw_get@$02V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Variant_raw_get@$02V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Variant_raw_get<3,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 517  :     // access the _Idx-th element of a _Variant_storage
; 518  :     if constexpr (_Idx == 0) {
; 519  :         return static_cast<_Storage&&>(_Obj)._Get();
; 520  :     } else if constexpr (_Idx == 1) {
; 521  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 522  :     } else if constexpr (_Idx == 2) {
; 523  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 524  :     } else if constexpr (_Idx == 3) {
; 525  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();

	mov	rax, rcx

; 526  :     } else if constexpr (_Idx == 4) {
; 527  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();
; 528  :     } else if constexpr (_Idx == 5) {
; 529  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 530  :     } else if constexpr (_Idx == 6) {
; 531  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 532  :     } else if constexpr (_Idx == 7) {
; 533  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 534  :     } else if constexpr (_Idx < 16) {
; 535  :         return _STD _Variant_raw_get<_Idx - 8>(
; 536  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 537  :     } else if constexpr (_Idx < 32) {
; 538  :         return _STD _Variant_raw_get<_Idx - 16>(
; 539  :             static_cast<_Storage&&>(_Obj)
; 540  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 541  :     } else if constexpr (_Idx < 64) {
; 542  :         return _STD _Variant_raw_get<_Idx - 32>(
; 543  :             static_cast<_Storage&&>(_Obj)
; 544  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 545  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 546  :     } else { // _Idx >= 64
; 547  :         return _STD _Variant_raw_get<_Idx - 64>(
; 548  :             static_cast<_Storage&&>(_Obj)
; 549  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 550  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 551  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 552  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 553  :     }
; 554  : }

	ret	0
??$_Variant_raw_get@$02V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Variant_raw_get<3,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Variant_raw_get@$03V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Variant_raw_get@$03V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Variant_raw_get<4,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 517  :     // access the _Idx-th element of a _Variant_storage
; 518  :     if constexpr (_Idx == 0) {
; 519  :         return static_cast<_Storage&&>(_Obj)._Get();
; 520  :     } else if constexpr (_Idx == 1) {
; 521  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 522  :     } else if constexpr (_Idx == 2) {
; 523  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 524  :     } else if constexpr (_Idx == 3) {
; 525  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 526  :     } else if constexpr (_Idx == 4) {
; 527  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();

	mov	rax, rcx

; 528  :     } else if constexpr (_Idx == 5) {
; 529  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 530  :     } else if constexpr (_Idx == 6) {
; 531  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 532  :     } else if constexpr (_Idx == 7) {
; 533  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 534  :     } else if constexpr (_Idx < 16) {
; 535  :         return _STD _Variant_raw_get<_Idx - 8>(
; 536  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 537  :     } else if constexpr (_Idx < 32) {
; 538  :         return _STD _Variant_raw_get<_Idx - 16>(
; 539  :             static_cast<_Storage&&>(_Obj)
; 540  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 541  :     } else if constexpr (_Idx < 64) {
; 542  :         return _STD _Variant_raw_get<_Idx - 32>(
; 543  :             static_cast<_Storage&&>(_Obj)
; 544  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 545  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 546  :     } else { // _Idx >= 64
; 547  :         return _STD _Variant_raw_get<_Idx - 64>(
; 548  :             static_cast<_Storage&&>(_Obj)
; 549  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 550  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 551  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 552  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 553  :     }
; 554  : }

	ret	0
??$_Variant_raw_get@$03V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA?A_T$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Variant_raw_get<4,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ?_Storage@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Storage@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Storage, COMDAT

; 781  :         return _STD move(*this);

	mov	rax, rcx

; 782  :     }

	ret	0
?_Storage@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Storage
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEA_NXZ PROC ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get, COMDAT

; 450  :         return _STD move(_Head);

	mov	rax, rcx

; 451  :     }

	ret	0
?_Get@?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEA_NXZ ENDP ; std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAIXZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAIXZ PROC ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get, COMDAT

; 450  :         return _STD move(_Head);

	mov	rax, rcx

; 451  :     }

	ret	0
?_Get@?$_Variant_storage_@$0A@IMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAIXZ ENDP ; std::_Variant_storage_<0,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAMXZ PROC ; std::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get, COMDAT

; 450  :         return _STD move(_Head);

	mov	rax, rcx

; 451  :     }

	ret	0
?_Get@?$_Variant_storage_@$0A@MVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAMXZ ENDP ; std::_Variant_storage_<0,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$0A@VVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAVVector3F@@XZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Variant_storage_@$0A@VVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAVVector3F@@XZ PROC ; std::_Variant_storage_<0,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get, COMDAT

; 450  :         return _STD move(_Head);

	mov	rax, rcx

; 451  :     }

	ret	0
?_Get@?$_Variant_storage_@$0A@VVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAVVector3F@@XZ ENDP ; std::_Variant_storage_<0,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$0A@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Variant_storage_@$0A@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Variant_storage_<0,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get, COMDAT

; 450  :         return _STD move(_Head);

	mov	rax, rcx

; 451  :     }

	ret	0
?_Get@?$_Variant_storage_@$0A@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEHAA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Variant_storage_<0,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0$00I$0A@@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0$00I$0A@@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z PROC ; std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax

; 795  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...
; 796  :     }

	mov	rax, rcx
	mov	BYTE PTR [rcx+32], 1
	ret	0
??$?0$00I$0A@@?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$in_place_index_t@$00@1@$$QEAI@Z ENDP ; std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><1,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?0VVector3F@@@?$_Variant_storage_@$0A@VVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAVVector3F@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0VVector3F@@@?$_Variant_storage_@$0A@VVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAVVector3F@@@Z PROC ; std::_Variant_storage_<0,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Vector3F>, COMDAT

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [r8]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+8], eax
	mov	rax, rcx
	ret	0
??$?0VVector3F@@@?$_Variant_storage_@$0A@VVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@U?$integral_constant@_K$0A@@1@$$QEAVVector3F@@@Z ENDP ; std::_Variant_storage_<0,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Variant_storage_<0,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><Vector3F>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z PROC ; std::move<std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QEAV?$_Variant_base@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AEAV10@@Z ENDP ; std::move<std::_Variant_base<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Variant_raw_visit@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAX_K$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
_Idx$ = 8
_Obj$ = 16
_Func$ = 24
??$_Variant_raw_visit@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAX_K$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Variant_raw_visit<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	r9, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN204@Variant_ra[r9+rcx*4+4]
	add	rax, r9
	jmp	rax
$LN7@Variant_ra:

; 716  :             _STD _Construct_in_place(

	movzx	eax, BYTE PTR [rdx]
	mov	rcx, QWORD PTR [r8]
	mov	BYTE PTR [rcx], al

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [r8]
	mov	BYTE PTR [rax+32], 0
$LN3@Variant_ra:

; 687  :     // Call _Func with _Storage if _Idx is variant_npos, and otherwise the _Idx-th element in _Storage.
; 688  :     // pre: _Idx + 1 <= remove_reference_t<_Storage>::_Size
; 689  :     constexpr size_t _Size  = remove_reference_t<_Storage>::_Size;
; 690  :     constexpr int _Strategy = _Size <= 4 ? 1 : _Size <= 16 ? 2 : _Size <= 64 ? 3 : _Size <= 256 ? 4 : -1;
; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]
; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));
; 693  : }

	ret	0
$LN8@Variant_ra:

; 716  :             _STD _Construct_in_place(

	mov	eax, DWORD PTR [rdx]
	mov	rcx, QWORD PTR [r8]
	mov	DWORD PTR [rcx], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [r8]
	mov	BYTE PTR [rax+32], 1

; 687  :     // Call _Func with _Storage if _Idx is variant_npos, and otherwise the _Idx-th element in _Storage.
; 688  :     // pre: _Idx + 1 <= remove_reference_t<_Storage>::_Size
; 689  :     constexpr size_t _Size  = remove_reference_t<_Storage>::_Size;
; 690  :     constexpr int _Strategy = _Size <= 4 ? 1 : _Size <= 16 ? 2 : _Size <= 64 ? 3 : _Size <= 256 ? 4 : -1;
; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]
; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));
; 693  : }

	ret	0
$LN9@Variant_ra:

; 716  :             _STD _Construct_in_place(

	mov	rcx, QWORD PTR [r8]

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 2

; 687  :     // Call _Func with _Storage if _Idx is variant_npos, and otherwise the _Idx-th element in _Storage.
; 688  :     // pre: _Idx + 1 <= remove_reference_t<_Storage>::_Size
; 689  :     constexpr size_t _Size  = remove_reference_t<_Storage>::_Size;
; 690  :     constexpr int _Strategy = _Size <= 4 ? 1 : _Size <= 16 ? 2 : _Size <= 64 ? 3 : _Size <= 256 ? 4 : -1;
; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]
; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));
; 693  : }

	ret	0
$LN10@Variant_ra:

; 716  :             _STD _Construct_in_place(

	mov	rcx, QWORD PTR [r8]

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [r8]
	mov	BYTE PTR [rax+32], 3

; 687  :     // Call _Func with _Storage if _Idx is variant_npos, and otherwise the _Idx-th element in _Storage.
; 688  :     // pre: _Idx + 1 <= remove_reference_t<_Storage>::_Size
; 689  :     constexpr size_t _Size  = remove_reference_t<_Storage>::_Size;
; 690  :     constexpr int _Strategy = _Size <= 4 ? 1 : _Size <= 16 ? 2 : _Size <= 64 ? 3 : _Size <= 256 ? 4 : -1;
; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]
; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));
; 693  : }

	ret	0
$LN11@Variant_ra:

; 716  :             _STD _Construct_in_place(

	mov	rax, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	ecx, ecx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rax+16], rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rax+24], rcx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rax+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rcx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [r8]
	mov	BYTE PTR [rax+32], 4

; 687  :     // Call _Func with _Storage if _Idx is variant_npos, and otherwise the _Idx-th element in _Storage.
; 688  :     // pre: _Idx + 1 <= remove_reference_t<_Storage>::_Size
; 689  :     constexpr size_t _Size  = remove_reference_t<_Storage>::_Size;
; 690  :     constexpr int _Strategy = _Size <= 4 ? 1 : _Size <= 16 ? 2 : _Size <= 64 ? 3 : _Size <= 256 ? 4 : -1;
; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]
; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));
; 693  : }

	ret	0
$LN23@Variant_ra:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN205@Variant_ra:
	npad	1
$LN204@Variant_ra:

; 687  :     // Call _Func with _Storage if _Idx is variant_npos, and otherwise the _Idx-th element in _Storage.
; 688  :     // pre: _Idx + 1 <= remove_reference_t<_Storage>::_Size
; 689  :     constexpr size_t _Size  = remove_reference_t<_Storage>::_Size;
; 690  :     constexpr int _Strategy = _Size <= 4 ? 1 : _Size <= 16 ? 2 : _Size <= 64 ? 3 : _Size <= 256 ? 4 : -1;
; 691  :     ++_Idx; // bias index by +1 to map {variant_npos} U [0, _Size) to the contiguous range [0, _Size]
; 692  :     return _Variant_raw_visit1<_Strategy>::_Visit(_Idx, static_cast<_Fn&&>(_Func), static_cast<_Storage&&>(_Obj));
; 693  : }

	DD	$LN3@Variant_ra
	DD	$LN7@Variant_ra
	DD	$LN8@Variant_ra
	DD	$LN9@Variant_ra
	DD	$LN10@Variant_ra
	DD	$LN11@Variant_ra
??$_Variant_raw_visit@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAX_K$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAU?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Variant_raw_visit<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$_Visit@U?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@?$_Variant_raw_visit1@$01@std@@SAX_K$$QEAU?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_Idx$ = 8
_Func$ = 16
_Obj$ = 24
??$_Visit@U?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@?$_Variant_raw_visit1@$01@std@@SAX_K$$QEAU?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Variant_raw_visit1<2>::_Visit<std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 656  :         // dispatch a visitor for a _Variant_storage with at most 4^2 states
; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	lea	r9, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN201@Visit[r9+rcx*4]
	add	rax, r9
	jmp	rax
$LN5@Visit:

; 716  :             _STD _Construct_in_place(

	movzx	eax, BYTE PTR [r8]
	mov	rcx, QWORD PTR [rdx]
	mov	BYTE PTR [rcx], al

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [rdx]
	mov	BYTE PTR [rax+32], 0
$LN1@Visit:

; 658  :     }

	ret	0
$LN6@Visit:

; 716  :             _STD _Construct_in_place(

	mov	eax, DWORD PTR [r8]
	mov	rcx, QWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [rdx]
	mov	BYTE PTR [rax+32], 1

; 658  :     }

	ret	0
$LN7@Visit:

; 716  :             _STD _Construct_in_place(

	mov	rcx, QWORD PTR [rdx]

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rcx+32], 2

; 658  :     }

	ret	0
$LN8@Visit:

; 716  :             _STD _Construct_in_place(

	mov	rcx, QWORD PTR [rdx]

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [r8]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+8], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [rdx]
	mov	BYTE PTR [rax+32], 3

; 658  :     }

	ret	0
$LN9@Visit:

; 716  :             _STD _Construct_in_place(

	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	ecx, ecx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rax+16], rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rax+24], rcx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rax+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r8+16], rcx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r8+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r8], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [rdx]
	mov	BYTE PTR [rax+32], 4

; 658  :     }

	ret	0
$LN21@Visit:

; 656  :         // dispatch a visitor for a _Variant_storage with at most 4^2 states
; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN202@Visit:
	npad	1
$LN201@Visit:

; 658  :     }

	DD	$LN1@Visit
	DD	$LN5@Visit
	DD	$LN6@Visit
	DD	$LN7@Visit
	DD	$LN8@Visit
	DD	$LN9@Visit
??$_Visit@U?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@?$_Variant_raw_visit1@$01@std@@SAX_K$$QEAU?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Variant_raw_visit1<2>::_Visit<std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?R$$QEA_N$0A@@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEA_N$0A@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Source$ = 16
??$?R$$QEA_N$0A@@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEA_N$0A@@1@@Z PROC ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<bool &&,0>, COMDAT

; 713  :         // initialize _Idx-th item in _Self from _Source
; 714  :         _STL_INTERNAL_CHECK(_Self.valueless_by_exception());
; 715  :         if constexpr (_Idx != variant_npos) {
; 716  :             _STD _Construct_in_place(

	mov	rax, QWORD PTR [rdx]
	mov	rdx, QWORD PTR [rcx]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rdx], al

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [rcx]
	mov	BYTE PTR [rax+32], 0

; 717  :                 _Self._Storage(), integral_constant<size_t, _Idx>{}, static_cast<_Ty&&>(_Source._Val));
; 718  :             _Self._Set_index(_Idx);
; 719  :         }
; 720  :     }

	ret	0
??$?R$$QEA_N$0A@@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEA_N$0A@@1@@Z ENDP ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<bool &&,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?R$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$0?0@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$0?0@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Source$dead$ = 16
??$?R$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$0?0@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$0?0@1@@Z PROC ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &&,-1>, COMDAT

; 713  :         // initialize _Idx-th item in _Self from _Source
; 714  :         _STL_INTERNAL_CHECK(_Self.valueless_by_exception());
; 715  :         if constexpr (_Idx != variant_npos) {
; 716  :             _STD _Construct_in_place(
; 717  :                 _Self._Storage(), integral_constant<size_t, _Idx>{}, static_cast<_Ty&&>(_Source._Val));
; 718  :             _Self._Set_index(_Idx);
; 719  :         }
; 720  :     }

	ret	0
??$?R$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$0?0@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAV?$_Variant_storage_@$0A@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$0?0@1@@Z ENDP ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<std::_Variant_storage_<0,bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &&,-1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?R$$QEAI$00@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAI$00@1@@Z
_TEXT	SEGMENT
this$ = 8
_Source$ = 16
??$?R$$QEAI$00@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAI$00@1@@Z PROC ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<unsigned int &&,1>, COMDAT

; 713  :         // initialize _Idx-th item in _Self from _Source
; 714  :         _STL_INTERNAL_CHECK(_Self.valueless_by_exception());
; 715  :         if constexpr (_Idx != variant_npos) {
; 716  :             _STD _Construct_in_place(

	mov	rax, QWORD PTR [rdx]
	mov	rdx, QWORD PTR [rcx]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rdx], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [rcx]
	mov	BYTE PTR [rax+32], 1

; 717  :                 _Self._Storage(), integral_constant<size_t, _Idx>{}, static_cast<_Ty&&>(_Source._Val));
; 718  :             _Self._Set_index(_Idx);
; 719  :         }
; 720  :     }

	ret	0
??$?R$$QEAI$00@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAI$00@1@@Z ENDP ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<unsigned int &&,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?R$$QEAM$01@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAM$01@1@@Z
_TEXT	SEGMENT
this$ = 8
_Source$ = 16
??$?R$$QEAM$01@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAM$01@1@@Z PROC ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<float &&,2>, COMDAT

; 713  :         // initialize _Idx-th item in _Self from _Source
; 714  :         _STL_INTERNAL_CHECK(_Self.valueless_by_exception());
; 715  :         if constexpr (_Idx != variant_npos) {
; 716  :             _STD _Construct_in_place(

	mov	rax, QWORD PTR [rdx]
	mov	rdx, QWORD PTR [rcx]

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rdx], eax
	mov	rax, QWORD PTR [rcx]
	mov	BYTE PTR [rax+32], 2

; 717  :                 _Self._Storage(), integral_constant<size_t, _Idx>{}, static_cast<_Ty&&>(_Source._Val));
; 718  :             _Self._Set_index(_Idx);
; 719  :         }
; 720  :     }

	ret	0
??$?R$$QEAM$01@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAM$01@1@@Z ENDP ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<float &&,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?R$$QEAVVector3F@@$02@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAVVector3F@@$02@1@@Z
_TEXT	SEGMENT
this$ = 8
_Source$ = 16
??$?R$$QEAVVector3F@@$02@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAVVector3F@@$02@1@@Z PROC ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<Vector3F &&,3>, COMDAT

; 713  :         // initialize _Idx-th item in _Self from _Source
; 714  :         _STL_INTERNAL_CHECK(_Self.valueless_by_exception());
; 715  :         if constexpr (_Idx != variant_npos) {
; 716  :             _STD _Construct_in_place(

	mov	rax, QWORD PTR [rdx]
	mov	rdx, QWORD PTR [rcx]

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR [rdx], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdx+8], eax

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [rcx]
	mov	BYTE PTR [rax+32], 3

; 717  :                 _Self._Storage(), integral_constant<size_t, _Idx>{}, static_cast<_Ty&&>(_Source._Val));
; 718  :             _Self._Set_index(_Idx);
; 719  :         }
; 720  :     }

	ret	0
??$?R$$QEAVVector3F@@$02@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAVVector3F@@$02@1@@Z ENDP ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<Vector3F &&,3>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
;	COMDAT ??$?R$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$03@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$03@1@@Z
_TEXT	SEGMENT
this$ = 8
_Source$ = 16
??$?R$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$03@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$03@1@@Z PROC ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&,4>, COMDAT

; 713  :         // initialize _Idx-th item in _Self from _Source
; 714  :         _STL_INTERNAL_CHECK(_Self.valueless_by_exception());
; 715  :         if constexpr (_Idx != variant_npos) {
; 716  :             _STD _Construct_in_place(

	mov	r8, QWORD PTR [rdx]
	xorps	xmm0, xmm0
	mov	rax, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	edx, edx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rax+16], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rax+24], rdx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rax+16], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r8+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r8+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r8], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	rax, QWORD PTR [rcx]
	mov	BYTE PTR [rax+32], 4

; 717  :                 _Self._Storage(), integral_constant<size_t, _Idx>{}, static_cast<_Ty&&>(_Source._Val));
; 718  :             _Self._Set_index(_Idx);
; 719  :         }
; 720  :     }

	ret	0
??$?R$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$03@?$_Variant_construct_visitor@_NIMVVector3F@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBAXU?$_Tagged@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$03@1@@Z ENDP ; std::_Variant_construct_visitor<bool,unsigned int,float,Vector3F,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&,4>
_TEXT	ENDS
END
