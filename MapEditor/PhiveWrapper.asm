; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CE@MIPDAIKB@Could?5not?5find?5type?5index?5for?5c@ ; `string'
PUBLIC	??_C@_0BJ@OBAPLDIM@hkcdStaticAabbTree?3?3Impl@	; `string'
PUBLIC	??_C@_0CD@CMDPGNIM@hkRootLevelContainer?3?3NamedVari@ ; `string'
PUBLIC	??_C@_0N@DHCBLILN@PhiveWrapper@			; `string'
PUBLIC	??_C@_0BF@ODAFHGKI@hkRootLevelContainer@	; `string'
PUBLIC	??_C@_0BH@BLFLKJMI@hkaiClusterGraph?3?3Node@	; `string'
PUBLIC	??_C@_0CK@FKGJOCBM@hkcdCompressedAabbCodecs?3?3Aabb6@ ; `string'
PUBLIC	??_C@_0BC@NALGAINP@hkaiNavMesh?3?3Face@		; `string'
PUBLIC	??_C@_0BC@KHMBCKOB@hkaiNavMesh?3?3Edge@		; `string'
PUBLIC	??_C@_04LKBNGDJJ@TSHA@				; `string'
PUBLIC	??_C@_04PNNKJEI@PTCH@				; `string'
PUBLIC	??_C@_0BH@LJMMKBIB@hkaiClusterGraph?3?3Edge@	; `string'
PUBLIC	??_C@_0CE@DDIDAKNA@Could?5not?5calculate?5flag?5for?5cl@ ; `string'
;	COMDAT ??_C@_0CE@DDIDAKNA@Could?5not?5calculate?5flag?5for?5cl@
CONST	SEGMENT
??_C@_0CE@DDIDAKNA@Could?5not?5calculate?5flag?5for?5cl@ DB 'Could not ca'
	DB	'lculate flag for class ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LJMMKBIB@hkaiClusterGraph?3?3Edge@
CONST	SEGMENT
??_C@_0BH@LJMMKBIB@hkaiClusterGraph?3?3Edge@ DB 'hkaiClusterGraph::Edge', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNNKJEI@PTCH@
CONST	SEGMENT
??_C@_04PNNKJEI@PTCH@ DB 'PTCH', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LKBNGDJJ@TSHA@
CONST	SEGMENT
??_C@_04LKBNGDJJ@TSHA@ DB 'TSHA', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KHMBCKOB@hkaiNavMesh?3?3Edge@
CONST	SEGMENT
??_C@_0BC@KHMBCKOB@hkaiNavMesh?3?3Edge@ DB 'hkaiNavMesh::Edge', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NALGAINP@hkaiNavMesh?3?3Face@
CONST	SEGMENT
??_C@_0BC@NALGAINP@hkaiNavMesh?3?3Face@ DB 'hkaiNavMesh::Face', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FKGJOCBM@hkcdCompressedAabbCodecs?3?3Aabb6@
CONST	SEGMENT
??_C@_0CK@FKGJOCBM@hkcdCompressedAabbCodecs?3?3Aabb6@ DB 'hkcdCompressedA'
	DB	'abbCodecs::Aabb6BytesCodec', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BLFLKJMI@hkaiClusterGraph?3?3Node@
CONST	SEGMENT
??_C@_0BH@BLFLKJMI@hkaiClusterGraph?3?3Node@ DB 'hkaiClusterGraph::Node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ODAFHGKI@hkRootLevelContainer@
CONST	SEGMENT
??_C@_0BF@ODAFHGKI@hkRootLevelContainer@ DB 'hkRootLevelContainer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DHCBLILN@PhiveWrapper@
CONST	SEGMENT
??_C@_0N@DHCBLILN@PhiveWrapper@ DB 'PhiveWrapper', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CMDPGNIM@hkRootLevelContainer?3?3NamedVari@
CONST	SEGMENT
??_C@_0CD@CMDPGNIM@hkRootLevelContainer?3?3NamedVari@ DB 'hkRootLevelCont'
	DB	'ainer::NamedVariant', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OBAPLDIM@hkcdStaticAabbTree?3?3Impl@
CONST	SEGMENT
??_C@_0BJ@OBAPLDIM@hkcdStaticAabbTree?3?3Impl@ DB 'hkcdStaticAabbTree::Im'
	DB	'pl', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MIPDAIKB@Could?5not?5find?5type?5index?5for?5c@
CONST	SEGMENT
??_C@_0CE@MIPDAIKB@Could?5not?5find?5type?5index?5for?5c@ DB 'Could not f'
	DB	'ind type index for class', 00H		; `string'
PUBLIC	??$forward@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAPEAU12@@Z ; std::forward<PhiveWrapper::PhiveWrapperTypeTemplate *>
PUBLIC	??$forward@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YA$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@AEAV10@@Z ; std::forward<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@00@Z ; std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >
PUBLIC	??$?0V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@$$QEAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@22@Z ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1>::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1><std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,PhiveWrapper::PhiveWrapperTypeTemplate *,PhiveWrapper::PhiveWrapperTypeTemplate *,PhiveWrapper::PhiveWrapperTypeTemplate *>
PUBLIC	??$exchange@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@$$T@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAPEAU12@$$QEA$$T@Z ; std::exchange<PhiveWrapper::PhiveWrapperTypeTemplate *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YA$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@AEAV10@@Z ; std::move<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> &>
PUBLIC	??0?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAA@XZ ; std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>
PUBLIC	??0?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >
PUBLIC	??0PhiveWrapperTypeTemplate@PhiveWrapper@@QEAA@$$QEAU01@@Z ; PhiveWrapper::PhiveWrapperTypeTemplate::PhiveWrapperTypeTemplate
PUBLIC	??0PhiveWrapperNamedType@PhiveWrapper@@QEAA@$$QEAU01@@Z ; PhiveWrapper::PhiveWrapperNamedType::PhiveWrapperNamedType
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1>::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1><>
PUBLIC	??$construct_at@UPhiveWrapperTypeTemplate@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@$$QEAU12@@Z ; std::construct_at<PhiveWrapper::PhiveWrapperTypeTemplate,PhiveWrapper::PhiveWrapperTypeTemplate,0>
PUBLIC	??$construct_at@UPhiveWrapperNamedType@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@$$QEAU12@@Z ; std::construct_at<PhiveWrapper::PhiveWrapperNamedType,PhiveWrapper::PhiveWrapperNamedType,0>
PUBLIC	??0?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
PUBLIC	??0PhiveWrapperTypeTemplate@PhiveWrapper@@QEAA@XZ ; PhiveWrapper::PhiveWrapperTypeTemplate::PhiveWrapperTypeTemplate
PUBLIC	??0PhiveWrapperNamedType@PhiveWrapper@@QEAA@XZ	; PhiveWrapper::PhiveWrapperNamedType::PhiveWrapperNamedType
PUBLIC	??$construct_at@UPhiveWrapperTypeTemplate@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@@Z ; std::construct_at<PhiveWrapper::PhiveWrapperTypeTemplate,0>
PUBLIC	??$construct@UPhiveWrapperTypeTemplate@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::construct<PhiveWrapper::PhiveWrapperTypeTemplate,PhiveWrapper::PhiveWrapperTypeTemplate>
PUBLIC	??$forward@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAU12@@Z ; std::forward<PhiveWrapper::PhiveWrapperTypeTemplate>
PUBLIC	??$construct_at@UPhiveWrapperNamedType@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@@Z ; std::construct_at<PhiveWrapper::PhiveWrapperNamedType,0>
PUBLIC	??$construct@UPhiveWrapperNamedType@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@QEAUPhiveWrapperNamedType@PhiveWrapper@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::construct<PhiveWrapper::PhiveWrapperNamedType,PhiveWrapper::PhiveWrapperNamedType>
PUBLIC	??$forward@UPhiveWrapperNamedType@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperNamedType@PhiveWrapper@@AEAU12@@Z ; std::forward<PhiveWrapper::PhiveWrapperNamedType>
PUBLIC	??0PhiveWrapperPatch@PhiveWrapper@@QEAA@AEBU01@@Z ; PhiveWrapper::PhiveWrapperPatch::PhiveWrapperPatch
PUBLIC	??$construct@UPhiveWrapperTypeTemplate@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::construct<PhiveWrapper::PhiveWrapperTypeTemplate>
PUBLIC	??$_Emplace_back@UPhiveWrapperTypeTemplate@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Emplace_back<PhiveWrapper::PhiveWrapperTypeTemplate>
PUBLIC	??$move@AEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAU12@@Z ; std::move<PhiveWrapper::PhiveWrapperTypeTemplate &>
PUBLIC	??$construct@UPhiveWrapperNamedType@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@QEAUPhiveWrapperNamedType@PhiveWrapper@@@Z ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::construct<PhiveWrapper::PhiveWrapperNamedType>
PUBLIC	??$_Emplace_back@UPhiveWrapperNamedType@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperNamedType@PhiveWrapper@@@Z ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Emplace_back<PhiveWrapper::PhiveWrapperNamedType>
PUBLIC	??$move@AEAUPhiveWrapperNamedType@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperNamedType@PhiveWrapper@@AEAU12@@Z ; std::move<PhiveWrapper::PhiveWrapperNamedType &>
PUBLIC	??$construct_at@UPhiveWrapperPatch@PhiveWrapper@@AEBU12@$0A@@std@@YAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU12@AEBU12@@Z ; std::construct_at<PhiveWrapper::PhiveWrapperPatch,PhiveWrapper::PhiveWrapperPatch const &,0>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z ; std::_Uninitialized_move<PhiveWrapper::PhiveWrapperTypeTemplate *,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
PUBLIC	??$_Get_unwrapped@AEBQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z ; std::_Get_unwrapped<PhiveWrapper::PhiveWrapperTypeTemplate * const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z ; std::_Uninitialized_move<PhiveWrapper::PhiveWrapperNamedType *,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
PUBLIC	??$_Get_unwrapped@AEBQEAUPhiveWrapperNamedType@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperNamedType@PhiveWrapper@@@Z ; std::_Get_unwrapped<PhiveWrapper::PhiveWrapperNamedType * const &>
PUBLIC	??$construct@UPhiveWrapperPatch@PhiveWrapper@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@1@QEAUPhiveWrapperPatch@PhiveWrapper@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperPatch> >::construct<PhiveWrapper::PhiveWrapperPatch,PhiveWrapper::PhiveWrapperPatch const &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@XZ ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@XZ ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperNamedType>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperNamedType> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@@Z ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::max_size
PUBLIC	?capacity@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEBA_KXZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::capacity
PUBLIC	?_Getal@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@XZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@@Z ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::max_size
PUBLIC	?capacity@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEBA_KXZ ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::capacity
PUBLIC	?_Getal@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@XZ ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Getal
PUBLIC	?allocate@?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z ; std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>::allocate
PUBLIC	?max_size@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEBA_KXZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::max_size
PUBLIC	?_Calculate_growth@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Change_array
PUBLIC	?_Xlength@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@CAXXZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Xlength
PUBLIC	?allocate@?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@_K@Z ; std::allocator<PhiveWrapper::PhiveWrapperNamedType>::allocate
PUBLIC	?max_size@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEBA_KXZ ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::max_size
PUBLIC	?_Calculate_growth@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Change_array
PUBLIC	?_Xlength@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@CAXXZ ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Xlength
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperNamedType@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::~_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::~_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::__autoclassinit2
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_reallocate<PhiveWrapper::PhiveWrapperPatch const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_back_with_unused_capacity<PhiveWrapper::PhiveWrapperPatch const &>
PUBLIC	??$forward@AEBUPhiveWrapperPatch@PhiveWrapper@@@std@@YAAEBUPhiveWrapperPatch@PhiveWrapper@@AEBU12@@Z ; std::forward<PhiveWrapper::PhiveWrapperPatch const &>
PUBLIC	?_Orphan_range@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@0@Z ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Orphan_range
PUBLIC	?_Orphan_range@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperNamedType@PhiveWrapper@@0@Z ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Orphan_range
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Unfancy_maybe_null@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@Z ; std::_Unfancy_maybe_null<PhiveWrapper::PhiveWrapperItem>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Emplace_one_at_back@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_one_at_back<PhiveWrapper::PhiveWrapperPatch const &>
PUBLIC	?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::resize
PUBLIC	?_Unchecked_begin@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Unchecked_end
PUBLIC	??A?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAAEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::operator[]
PUBLIC	?data@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@XZ ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::data
PUBLIC	?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::resize
PUBLIC	?_Unchecked_begin@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Unchecked_end
PUBLIC	?push_back@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAXAEBUPhiveWrapperPatch@PhiveWrapper@@@Z ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::push_back
PUBLIC	?_Unchecked_begin@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperPatch@PhiveWrapper@@XZ ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperPatch@PhiveWrapper@@XZ ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Unchecked_end
PUBLIC	??0PhiveWrapperPatch@PhiveWrapper@@QEAA@XZ	; PhiveWrapper::PhiveWrapperPatch::PhiveWrapperPatch
PUBLIC	?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z ; PhiveWrapper::ReadStringTable
PUBLIC	?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z ; PhiveWrapper::WriteStringTable
PUBLIC	?WriteBitFieldFlagsSize@PhiveWrapper@@QEAAIEI@Z	; PhiveWrapper::WriteBitFieldFlagsSize
PUBLIC	?ReadBitFieldFlagsSize@PhiveWrapper@@QEAA?AU?$pair@EI@std@@I@Z ; PhiveWrapper::ReadBitFieldFlagsSize
PUBLIC	?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveWrapper::FindSection
PUBLIC	??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z ; PhiveWrapper::PhiveWrapper
PUBLIC	?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ ; PhiveWrapper::ToBinary
PUBLIC	?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveWrapper::GetTypeNameFlag
PUBLIC	?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveWrapper::GetTypeNameIndex
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0PhiveWrapperTypeTemplate@PhiveWrapper@@QEAA@XZ DD imagerel $LN18
	DD	imagerel $LN18+49
	DD	imagerel $unwind$??0PhiveWrapperTypeTemplate@PhiveWrapper@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0PhiveWrapperNamedType@PhiveWrapper@@QEAA@XZ DD imagerel $LN25
	DD	imagerel $LN25+70
	DD	imagerel $unwind$??0PhiveWrapperNamedType@PhiveWrapper@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UPhiveWrapperTypeTemplate@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@@Z DD imagerel $LN20
	DD	imagerel $LN20+53
	DD	imagerel $unwind$??$construct_at@UPhiveWrapperTypeTemplate@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UPhiveWrapperNamedType@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@@Z DD imagerel $LN27
	DD	imagerel $LN27+86
	DD	imagerel $unwind$??$construct_at@UPhiveWrapperNamedType@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0PhiveWrapperPatch@PhiveWrapper@@QEAA@AEBU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+41
	DD	imagerel $unwind$??0PhiveWrapperPatch@PhiveWrapper@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UPhiveWrapperNamedType@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@QEAUPhiveWrapperNamedType@PhiveWrapper@@@Z DD imagerel $LN29
	DD	imagerel $LN29+86
	DD	imagerel $unwind$??$construct@UPhiveWrapperNamedType@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@QEAUPhiveWrapperNamedType@PhiveWrapper@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@UPhiveWrapperPatch@PhiveWrapper@@AEBU12@$0A@@std@@YAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU12@AEBU12@@Z DD imagerel $LN8
	DD	imagerel $LN8+41
	DD	imagerel $unwind$??$construct_at@UPhiveWrapperPatch@PhiveWrapper@@AEBU12@$0A@@std@@YAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU12@AEBU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAXXZ DD imagerel $LN24
	DD	imagerel $LN24+59
	DD	imagerel $unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+105
	DD	imagerel $unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z DD imagerel $LN105
	DD	imagerel $LN105+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z DD imagerel $LN105+20
	DD	imagerel $LN105+181
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z DD imagerel $LN105+181
	DD	imagerel $LN105+186
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+116
	DD	imagerel $unwind$?allocate@?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z DD imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z DD imagerel $LN53+40
	DD	imagerel $LN53+121
	DD	imagerel $chain$0$?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z DD imagerel $LN53+121
	DD	imagerel $LN53+205
	DD	imagerel $chain$1$?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+108
	DD	imagerel $unwind$?allocate@?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z DD imagerel $LN53
	DD	imagerel $LN53+39
	DD	imagerel $unwind$?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z DD imagerel $LN53+39
	DD	imagerel $LN53+107
	DD	imagerel $chain$0$?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z DD imagerel $LN53+107
	DD	imagerel $LN53+188
	DD	imagerel $chain$1$?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+59
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ DD imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z DD imagerel $LN65
	DD	imagerel $LN65+169
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN184
	DD	imagerel $LN184+563
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA DD imagerel ?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
	DD	imagerel ?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA+49
	DD	imagerel $unwind$?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z DD imagerel $LN72
	DD	imagerel $LN72+183
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN196
	DD	imagerel $LN196+609
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA DD imagerel ?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
	DD	imagerel ?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA+49
	DD	imagerel $unwind$?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z DD imagerel $LN29
	DD	imagerel $LN29+277
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z@4HA DD imagerel ?catch$1@?0???$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z@4HA
	DD	imagerel ?catch$1@?0???$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z@4HA+52
	DD	imagerel $unwind$?catch$1@?0???$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z DD imagerel $LN12
	DD	imagerel $LN12+54
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN34
	DD	imagerel $LN34+49
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN34+49
	DD	imagerel $LN34+122
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN34+122
	DD	imagerel $LN34+191
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN34
	DD	imagerel $LN34+51
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN34+51
	DD	imagerel $LN34+116
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN34+116
	DD	imagerel $LN34+199
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z DD imagerel $LN16
	DD	imagerel $LN16+79
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD imagerel $LN36
	DD	imagerel $LN36+49
	DD	imagerel $unwind$?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD imagerel $LN36+49
	DD	imagerel $LN36+122
	DD	imagerel $chain$1$?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD imagerel $LN36+122
	DD	imagerel $LN36+191
	DD	imagerel $chain$2$?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD imagerel $LN36
	DD	imagerel $LN36+51
	DD	imagerel $unwind$?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD imagerel $LN36+51
	DD	imagerel $LN36+116
	DD	imagerel $chain$0$?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD imagerel $LN36+116
	DD	imagerel $LN36+199
	DD	imagerel $chain$1$?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAXAEBUPhiveWrapperPatch@PhiveWrapper@@@Z DD imagerel $LN18
	DD	imagerel $LN18+72
	DD	imagerel $unwind$?push_back@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAXAEBUPhiveWrapperPatch@PhiveWrapper@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z DD imagerel $LN206
	DD	imagerel $LN206+725
	DD	imagerel $unwind$?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z DD imagerel $LN99
	DD	imagerel $LN99+359
	DD	imagerel $unwind$?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN91
	DD	imagerel $LN91+228
	DD	imagerel $unwind$?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z DD imagerel $LN661
	DD	imagerel $LN661+2168
	DD	imagerel $unwind$??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DD imagerel $LN1642
	DD	imagerel $LN1642+9229
	DD	imagerel $unwind$?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA DD imagerel ?dtor$3@?0??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA
	DD	imagerel ?dtor$3@?0??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA+38
	DD	imagerel $unwind$?dtor$3@?0??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN537
	DD	imagerel $LN537+1122
	DD	imagerel $unwind$?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN263
	DD	imagerel $LN263+598
	DD	imagerel $unwind$?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0cH
	DB	'5', 03H
	DB	06H
	DB	0f1H, 03H
	DB	02H
	DB	'\'
	DB	08H
	DB	01cH
	DB	02H
	DB	'4'
	DB	00H
	DB	'b'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	09cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0b2c19H
	DD	01c641eH
	DD	01a341eH
	DD	014011eH
	DD	0e010f012H
	DD	0700cc00eH
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	09aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0cH
	DB	0f9H, 02H
	DB	06H
	DB	0b1H, 0cH
	DB	02H
	DB	'd'
	DB	08H
	DB	01cH
	DB	02H
	DB	'*'
	DB	00H
	DB	':'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	09cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 092819H
	DD	01a641aH
	DD	018341aH
	DD	014011aH
	DD	0700ce00eH
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	09aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DB 06H
	DB	0beH
	DB	04H
	DB	05H, 08dH
	DB	02H
	DB	0ceH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$3@?0??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA
	DB	02aH
	DD	imagerel ??1BinaryVectorWriter@@QEAA@XZ
	DB	0e0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DB 028H
	DD	imagerel $stateUnwindMap$?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
	DD	imagerel $ip2state$?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DD 0b2a19H
	DD	01e341cH
	DD	014011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
	DD	092H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z DB 08H
	DB	0f9H, 03H
	DB	010H
	DB	019H, 019H
	DB	012H
	DB	0d8H
	DB	010H
	DB	'e', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z DB 012H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	061H
	DB	02H
	DB	03eH
	DD	imagerel ?dtor$1@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA
	DB	02aH
	DD	imagerel ??1PhiveWrapperPatch@PhiveWrapper@@QEAA@XZ
	DB	081H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z DB 028H
	DD	imagerel $stateUnwindMap$??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z
	DD	imagerel $ip2state$??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z DD 0d3219H
	DD	0d6824H
	DD	026341cH
	DD	01c011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'M', 03H
	DB	00H
	DB	016H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	02aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z DB 04H
	DB	08eH
	DB	02H
	DB	01H, 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z DB 028H
	DD	imagerel $stateUnwindMap$?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z
	DD	imagerel $ip2state$?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z DD 061a19H
	DD	0e007520bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z
	DD	02aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z DB 0aH
	DB	08cH
	DB	02H
	DB	'5', 02H
	DB	04H
	DB	'E', 06H
	DB	02H
	DB	096H
	DB	00H
	DB	'@'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z DB 028H
	DD	imagerel $stateUnwindMap$?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z
	DD	imagerel $ip2state$?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z DD 0b2a19H
	DD	01c341cH
	DD	014011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z
	DD	09aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAXAEBUPhiveWrapperPatch@PhiveWrapper@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+51
	DD	imagerel $unwind$?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN36
	DD	imagerel $LN36+51
	DD	imagerel $unwind$?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD 061001H
	DD	087410H
	DD	076410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+49
	DD	imagerel $unwind$?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD 040e21H
	DD	07540eH
	DD	063405H
	DD	imagerel $LN36
	DD	imagerel $LN36+49
	DD	imagerel $unwind$?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+51
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN34
	DD	imagerel $LN34+51
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 061001H
	DD	087410H
	DD	076410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+49
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040e21H
	DD	07540eH
	DD	063405H
	DD	imagerel $LN34
	DD	imagerel $LN34+49
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z DB 06H
	DB	0e8H
	DB	00H
	DB	082H
	DB	02H
	DB	0b4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z DD 081419H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	030066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 06H
	DB	089H, 02H
	DB	00H
	DB	0c4H
	DB	02H
	DB	0d5H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
	DD	imagerel $tryMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
	DD	imagerel $ip2state$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 0a1719H
	DD	0116417H
	DD	0103417H
	DD	0f0137217H
	DD	0d00fe011H
	DD	0700bc00dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z DB 04H
	DB	0eeH
	DB	02H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z DD 061e19H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 06H
	DB	0adH, 02H
	DB	00H
	DB	0c0H
	DB	02H
	DB	0f0H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
	DD	imagerel $tryMap$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
	DD	imagerel $ip2state$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 0a1719H
	DD	0116417H
	DD	0103417H
	DD	0f0137217H
	DD	0d00fe011H
	DD	0700bc00dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z DB 04H
	DB	0eaH
	DB	02H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z DD 061e19H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+39
	DD	imagerel $unwind$?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN53
	DD	imagerel $LN53+39
	DD	imagerel $unwind$?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z DD 081401H
	DD	0b6414H
	DD	0a3414H
	DD	0f0103214H
	DD	0c00ce00eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z DD 021H
	DD	imagerel $LN105
	DD	imagerel $LN105+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z DD 020521H
	DD	037405H
	DD	imagerel $LN105
	DD	imagerel $LN105+20
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAXXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UPhiveWrapperPatch@PhiveWrapper@@AEBU12@$0A@@std@@YAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU12@AEBU12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UPhiveWrapperNamedType@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@QEAUPhiveWrapperNamedType@PhiveWrapper@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0PhiveWrapperPatch@PhiveWrapper@@QEAA@AEBU01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UPhiveWrapperNamedType@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@UPhiveWrapperTypeTemplate@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0PhiveWrapperNamedType@PhiveWrapper@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0PhiveWrapperTypeTemplate@PhiveWrapper@@QEAA@XZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
;	COMDAT ?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 128
Name$GSCopy$ = 144
__$ArrayPad$ = 152
this$ = 208
Name$ = 216
?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; PhiveWrapper::GetTypeNameIndex, COMDAT

; 74   : {

$LN263:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax
	mov	rbx, rdx
	mov	r15, rcx
	mov	QWORD PTR Name$GSCopy$[rbp-105], rdx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rbp-105], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	r14d, 2
	mov	QWORD PTR $T2[rbp-89], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	esi, 15
	mov	QWORD PTR $T2[rbp-81], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, 14906				; 00003a3aH
	mov	WORD PTR $T2[rbp-105], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T2[rbp-103], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rbp-105], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rbp-89], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-81], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, 24415				; 00005f5fH
	mov	WORD PTR $T4[rbp-105], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T4[rbp-103], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp

; 107  : 	size_t startPos = 0;

	xor	edi, edi
	npad	8
$LL88@GetTypeNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN257@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN257@GetTypeNam:

; 4343 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	QWORD PTR [rsp+32], 2
	lea	r9, QWORD PTR $T4[rbp-105]
	mov	r8, rdi
	mov	rdx, QWORD PTR [rbx+16]
	call	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp

; 108  : 	while ((startPos = str.find(from, startPos)) != std::string::npos)

	cmp	rax, -1
	je	SHORT $LN89@GetTypeNam
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r9, QWORD PTR $T2[rbp-105]

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rsi, 16

; 2236 :         if (_Large_string_engaged()) {

	cmovae	r9, QWORD PTR $T2[rbp-105]

; 3678 :         return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	QWORD PTR [rsp+32], r14
	mov	r8d, 2
	mov	rdx, rax
	mov	rcx, rbx
	call	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp

; 111  : 		startPos += to.length(); // In case the replacement string contains the target substring

	mov	r14, QWORD PTR $T2[rbp-89]
	add	rdi, r14

; 112  : 	}

	mov	rsi, QWORD PTR $T2[rbp-81]
	jmp	SHORT $LL88@GetTypeNam
$LN89@GetTypeNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN151@GetTypeNam

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T2[rbp-105]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN163@GetTypeNam

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN163@GetTypeNam
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN163@GetTypeNam:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN151@GetTypeNam:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 76   : 	for (size_t i = 0; i < mTypes.size(); i++)

	xor	esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdi, QWORD PTR [r15+80]
	mov	r14, QWORD PTR [r15+88]
	sub	r14, rdi
	sar	r14, 6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 76   : 	for (size_t i = 0; i < mTypes.size(); i++)

	test	r14, r14
	je	SHORT $LN3@GetTypeNam
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r15, QWORD PTR [rbx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r12, QWORD PTR [rbx+16]
	npad	8
$LL4@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	r15, 16
	jb	SHORT $LN258@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rbx]
$LN258@GetTypeNam:

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rdi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN182@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi]
$LN182@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r12
	jne	SHORT $LN188@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN230@GetTypeNam
$LN188@GetTypeNam:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 76   : 	for (size_t i = 0; i < mTypes.size(); i++)

	inc	rsi
	add	rdi, 64					; 00000040H
	cmp	rsi, r14
	jb	SHORT $LL4@GetTypeNam
$LN3@GetTypeNam:

; 81   : 	Logger::Error("PhiveWrapper", "Could not find type index for class" + Name);

	lea	rax, QWORD PTR $T1[rbp-105]
	mov	QWORD PTR $T5[rbp-105], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rcx, QWORD PTR [rbx+16]

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	sub	rax, rcx
	cmp	rax, 35					; 00000023H
	jb	$LN261@GetTypeNam

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN205@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN205@GetTypeNam:

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 35			; 00000023H
	lea	r9, OFFSET FLAT:??_C@_0CE@MIPDAIKB@Could?5not?5find?5type?5index?5for?5c@
	lea	rcx, QWORD PTR $T1[rbp-105]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rbp-105], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T3[rbp-89], 0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rbp-81], 0

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 12
	lea	rdx, OFFSET FLAT:??_C@_0N@DHCBLILN@PhiveWrapper@
	lea	rcx, QWORD PTR $T3[rbp-105]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 81   : 	Logger::Error("PhiveWrapper", "Could not find type index for class" + Name);

	lea	rdx, QWORD PTR $T1[rbp-105]
	lea	rcx, QWORD PTR $T3[rbp-105]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 82   : 	return 0xFFFF;

	mov	eax, 65535				; 0000ffffH
$LN1@GetTypeNam:

; 83   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN230@GetTypeNam:

; 79   : 			return i + 1;

	inc	si
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 79   : 			return i + 1;

	movzx	eax, si
	jmp	SHORT $LN1@GetTypeNam
$LN261@GetTypeNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4917 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN259@GetTypeNam:
?GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; PhiveWrapper::GetTypeNameIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 128
Name$GSCopy$ = 144
__$ArrayPad$ = 152
this$ = 208
Name$ = 216
?dtor$0@?0??GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveWrapper::GetTypeNameIndex'::`1'::dtor$0
	mov	rcx, QWORD PTR Name$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveWrapper::GetTypeNameIndex'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 128
Name$GSCopy$ = 144
__$ArrayPad$ = 152
this$ = 208
Name$ = 216
?dtor$1@?0??GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveWrapper::GetTypeNameIndex'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveWrapper::GetTypeNameIndex'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 128
Name$GSCopy$ = 144
__$ArrayPad$ = 152
this$ = 208
Name$ = 216
?dtor$2@?0??GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveWrapper::GetTypeNameIndex'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveWrapper::GetTypeNameIndex'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 128
Name$GSCopy$ = 144
__$ArrayPad$ = 152
this$ = 208
Name$ = 216
?dtor$3@?0??GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveWrapper::GetTypeNameIndex'::`1'::dtor$3
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??GetTypeNameIndex@PhiveWrapper@@QEAAGV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveWrapper::GetTypeNameIndex'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
;	COMDAT ?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 128
Name$GSCopy$ = 144
__$ArrayPad$ = 152
this$dead$ = 192
Name$ = 200
?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; PhiveWrapper::GetTypeNameFlag, COMDAT

; 86   : {

$LN537:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rsp-71]
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-89], rax
	mov	rbx, rdx
	mov	QWORD PTR Name$GSCopy$[rbp-89], rdx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rbp-89], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	r14d, 2
	mov	QWORD PTR $T2[rbp-73], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	esi, 15
	mov	QWORD PTR $T2[rbp-65], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, 14906				; 00003a3aH
	mov	WORD PTR $T2[rbp-89], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T2[rbp-87], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rbp-89], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T4[rbp-73], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-65], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, 24415				; 00005f5fH
	mov	WORD PTR $T4[rbp-89], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T4[rbp-87], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp

; 107  : 	size_t startPos = 0;

	xor	edi, edi
$LL88@GetTypeNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN516@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN516@GetTypeNam:

; 4343 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	QWORD PTR [rsp+32], 2
	lea	r9, QWORD PTR $T4[rbp-89]
	mov	r8, rdi
	mov	rdx, QWORD PTR [rbx+16]
	call	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp

; 108  : 	while ((startPos = str.find(from, startPos)) != std::string::npos)

	cmp	rax, -1
	je	SHORT $LN89@GetTypeNam
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r9, QWORD PTR $T2[rbp-89]

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rsi, 16

; 2236 :         if (_Large_string_engaged()) {

	cmovae	r9, QWORD PTR $T2[rbp-89]

; 3678 :         return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	QWORD PTR [rsp+32], r14
	mov	r8d, 2
	mov	rdx, rax
	mov	rcx, rbx
	call	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Util.cpp

; 111  : 		startPos += to.length(); // In case the replacement string contains the target substring

	mov	r14, QWORD PTR $T2[rbp-73]
	add	rdi, r14

; 112  : 	}

	mov	rsi, QWORD PTR $T2[rbp-65]
	jmp	SHORT $LL88@GetTypeNam
$LN89@GetTypeNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN151@GetTypeNam

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T2[rbp-89]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN163@GetTypeNam

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN163@GetTypeNam
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN163@GetTypeNam:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN151@GetTypeNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	rdi, QWORD PTR [rbx+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rsi, QWORD PTR [rbx+24]

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN517@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN517@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 20
	jne	SHORT $LN181@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0BF@ODAFHGKI@hkRootLevelContainer@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN3@GetTypeNam
$LN181@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN518@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN518@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 11
	jne	SHORT $LN201@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0M@IMMBLPJG@hkaiNavMesh@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN3@GetTypeNam
$LN201@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN519@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN519@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 16
	jne	SHORT $LN218@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0BB@DJGCPKK@hkaiClusterGraph@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN3@GetTypeNam
$LN218@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN520@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN520@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 33					; 00000021H
	jne	SHORT $LN235@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0CC@OEOIPNBA@hkaiNavMeshStaticTreeFaceIterat@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN3@GetTypeNam
$LN235@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN521@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN521@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 18
	jne	SHORT $LN252@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0BD@MPAAAINP@hkcdStaticAabbTree@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN3@GetTypeNam
$LN252@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN522@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN522@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 24
	jne	SHORT $LN269@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0BJ@OBAPLDIM@hkcdStaticAabbTree?3?3Impl@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN269@GetTypeNam
$LN3@GetTypeNam:

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 95   : 		return 16;

	mov	al, 16
	jmp	$LN473@GetTypeNam
$LN269@GetTypeNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN523@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN523@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 34					; 00000022H
	jne	SHORT $LN286@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0CD@CMDPGNIM@hkRootLevelContainer?3?3NamedVari@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN5@GetTypeNam
$LN286@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN524@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN524@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 4
	jne	SHORT $LN306@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_04ENMBGAPA@char@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN5@GetTypeNam
$LN306@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN525@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN525@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 17
	jne	SHORT $LN323@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0BC@NALGAINP@hkaiNavMesh?3?3Face@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN5@GetTypeNam
$LN323@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN526@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN526@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 17
	jne	SHORT $LN340@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0BC@KHMBCKOB@hkaiNavMesh?3?3Edge@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN5@GetTypeNam
$LN340@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN527@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN527@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 9
	jne	SHORT $LN357@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_09EHJMMGBA@hkVector4@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN5@GetTypeNam
$LN357@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN528@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN528@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 7
	jne	SHORT $LN374@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_07DBDHCJHM@hkInt32@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	$LN5@GetTypeNam
$LN374@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN529@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN529@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 22
	jne	SHORT $LN391@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0BH@BLFLKJMI@hkaiClusterGraph?3?3Node@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN5@GetTypeNam
$LN391@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN530@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN530@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 9
	jne	SHORT $LN408@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_09BBPHGNIO@hkaiIndex@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN5@GetTypeNam
$LN408@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN531@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN531@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 41					; 00000029H
	jne	SHORT $LN425@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0CK@FKGJOCBM@hkcdCompressedAabbCodecs?3?3Aabb6@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN5@GetTypeNam
$LN425@GetTypeNam:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN532@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN532@GetTypeNam:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 22
	jne	SHORT $LN442@GetTypeNam

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_0BH@LJMMKBIB@hkaiClusterGraph?3?3Edge@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN442@GetTypeNam
$LN5@GetTypeNam:

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 107  : 		return 32;

	mov	al, 32					; 00000020H
	jmp	$LN473@GetTypeNam
$LN442@GetTypeNam:

; 109  : 	Logger::Error("PhiveWrapper", "Could not calculate flag for class " + Name);

	lea	rax, QWORD PTR $T1[rbp-89]
	mov	QWORD PTR $T5[rbp-89], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	sub	rax, rdi
	cmp	rax, 35					; 00000023H
	jb	$LN535@GetTypeNam

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	rsi, 16
	jb	SHORT $LN456@GetTypeNam

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN456@GetTypeNam:

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 35			; 00000023H
	lea	r9, OFFSET FLAT:??_C@_0CE@DDIDAKNA@Could?5not?5calculate?5flag?5for?5cl@
	lea	rcx, QWORD PTR $T1[rbp-89]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 109  : 	Logger::Error("PhiveWrapper", "Could not calculate flag for class " + Name);

	lea	rax, QWORD PTR $T3[rbp-89]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rbp-89], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T3[rbp-73], 0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rbp-65], 0

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 12
	lea	rdx, OFFSET FLAT:??_C@_0N@DHCBLILN@PhiveWrapper@
	lea	rcx, QWORD PTR $T3[rbp-89]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 109  : 	Logger::Error("PhiveWrapper", "Could not calculate flag for class " + Name);

	lea	rdx, QWORD PTR $T1[rbp-89]
	lea	rcx, QWORD PTR $T3[rbp-89]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN473@GetTypeNam:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 110  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-89]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
$LN535@GetTypeNam:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4917 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN533@GetTypeNam:
?GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; PhiveWrapper::GetTypeNameFlag
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 128
Name$GSCopy$ = 144
__$ArrayPad$ = 152
this$dead$ = 192
Name$ = 200
?dtor$0@?0??GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveWrapper::GetTypeNameFlag'::`1'::dtor$0
	mov	rcx, QWORD PTR Name$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveWrapper::GetTypeNameFlag'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 128
Name$GSCopy$ = 144
__$ArrayPad$ = 152
this$dead$ = 192
Name$ = 200
?dtor$1@?0??GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveWrapper::GetTypeNameFlag'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveWrapper::GetTypeNameFlag'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 128
Name$GSCopy$ = 144
__$ArrayPad$ = 152
this$dead$ = 192
Name$ = 200
?dtor$2@?0??GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveWrapper::GetTypeNameFlag'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveWrapper::GetTypeNameFlag'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 96
$T4 = 96
$T5 = 128
Name$GSCopy$ = 144
__$ArrayPad$ = 152
this$dead$ = 192
Name$ = 200
?dtor$3@?0??GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveWrapper::GetTypeNameFlag'::`1'::dtor$3
	mov	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??GetTypeNameFlag@PhiveWrapper@@QEAAEV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveWrapper::GetTypeNameFlag'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
;	COMDAT ?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
_TEXT	SEGMENT
HavokTagFileEnd$1$ = 32
Writer$24$ = 36
TNAJumpback$1$ = 36
tv14952 = 40
$T2 = 48
this$GSCopy$1$ = 56
$T3 = 64
$T4 = 64
__$ReturnUdt$GSCopy$1$ = 96
__$ReturnUdt$GSCopy$ = 104
Writer$ = 112
__$ArrayPad$ = 144
this$ = 224
__$ReturnUdt$ = 232
?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ PROC ; PhiveWrapper::ToBinary, COMDAT

; 113  : {

$LN1642:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-121], rax
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-121], rdx
	mov	r13, rcx
	mov	QWORD PTR this$GSCopy$1$[rbp-121], rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-121], rdx
	xor	r15d, r15d
	mov	DWORD PTR $T2[rbp-121], r15d
	xorps	xmm0, xmm0
	movups	XMMWORD PTR Writer$[rbp-105], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Writer$[rbp-121], xmm1
	mov	QWORD PTR Writer$[rbp-105], r15
	mov	DWORD PTR Writer$[rbp-97], r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 24   : 			this->m_Data.resize(Offset + 1);

	lea	edx, QWORD PTR [r15+81]
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	r12d, 80				; 00000050H
	mov	DWORD PTR Writer$[rbp-97], r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdi, QWORD PTR [r13+160]
	mov	rsi, QWORD PTR [r13+168]
	sub	rsi, rdi
	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rbx, esi
	lea	eax, DWORD PTR [rsi+80]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN1568@ToBinary

; 71   : 	{
; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, rbx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r12d, DWORD PTR Writer$[rbp-97]
$LN1568@ToBinary:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	mov	r9d, r15d
	mov	r8, r15
	test	esi, esi
	jle	SHORT $LN1110@ToBinary
	npad	1
$LL1111@ToBinary:

; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movzx	edx, BYTE PTR [r8+rdi]
	lea	eax, DWORD PTR [r12+r9]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	lea	r9d, DWORD PTR [r9+1]
	inc	r8
	mov	r12d, DWORD PTR Writer$[rbp-97]
	cmp	r8, rbx
	jl	SHORT $LL1111@ToBinary
$LN1110@ToBinary:

; 77   : 	}
; 78   : 	this->m_Offset += Size;

	add	r12d, esi
	mov	DWORD PTR HavokTagFileEnd$1$[rbp-121], r12d
	mov	DWORD PTR Writer$[rbp-97], r12d
	test	r12b, 15

; 108  : 	while (GetPosition() % Alignment != 0)

	je	SHORT $LN1623@ToBinary
	npad	12
$LL1099@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], 0

; 14   : 	this->m_Offset++;

	mov	r12d, DWORD PTR Writer$[rbp-97]
	inc	r12d
	mov	DWORD PTR HavokTagFileEnd$1$[rbp-121], r12d
	mov	DWORD PTR Writer$[rbp-97], r12d
	test	r12b, 15

; 108  : 	while (GetPosition() % Alignment != 0)

	jne	SHORT $LL1099@ToBinary
$LN1623@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 134  : 	Writer.WriteInteger(mTypeSize, sizeof(uint32_t));

	mov	ebx, DWORD PTR [r13+132]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [r12+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN1074@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN1074@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	add	ecx, 4
	mov	DWORD PTR Writer$[rbp-97], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, rdx
	jbe	SHORT $LN1060@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ecx, DWORD PTR Writer$[rbp-97]
$LN1060@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r15d
	lea	r8, OFFSET FLAT:??_C@_04KDPJLEDB@TYPE@+1
	npad	10
$LL1059@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL1059@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 64			; 00000040H

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 139  : 	Writer.WriteInteger(_byteswap_ushort(mTypePointerPaddingSize), sizeof(uint16_t));

	movzx	eax, WORD PTR [r13+128]
	ror	ax, 8
	movzx	ebx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rcx+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN1034@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN1034@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], bl
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	edx, DWORD PTR Writer$[rbp-97]
	add	edx, 2
	mov	DWORD PTR Writer$[rbp-97], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Writer$[rbp-113]
	sub	rcx, QWORD PTR Writer$[rbp-121]
	movsxd	rax, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, rcx
	jbe	SHORT $LN1209@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	lea	rdx, QWORD PTR [rcx+4]
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	edx, DWORD PTR Writer$[rbp-97]
$LN1209@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r15d
	lea	r8, OFFSET FLAT:??_C@_04NMHLNHPB@TPTR@+1
	npad	1
$LL1208@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, edx
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	edx, DWORD PTR Writer$[rbp-97]
	inc	edx
	mov	DWORD PTR Writer$[rbp-97], edx

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL1208@ToBinary
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 141  : 	Writer.Seek(mTypePointerPaddingSize - 8, BinaryVectorWriter::Position::Current);

	movzx	ebx, WORD PTR [r13+128]
	sub	ebx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR Writer$[rbp-113]
	mov	rcx, r8
	mov	r9, QWORD PTR Writer$[rbp-121]
	sub	rcx, r9
	lea	r10d, DWORD PTR [rbx+rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rax, r10d
	cmp	rax, rcx
	jb	SHORT $LN1196@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r10+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	edx, DWORD PTR Writer$[rbp-97]
	mov	r8, QWORD PTR Writer$[rbp-113]
	mov	r9, QWORD PTR Writer$[rbp-121]
$LN1196@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	edx, ebx
	mov	DWORD PTR Writer$[rbp-97], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r8, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	lea	rdx, QWORD PTR [r8+1]
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 64			; 00000040H

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 16

; 14   : 	this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, rdx
	jbe	SHORT $LN1164@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ecx, DWORD PTR Writer$[rbp-97]
$LN1164@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r15d
	lea	r8, OFFSET FLAT:??_C@_04LKBNGDJJ@TSHA@+1
	npad	11
$LL1163@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL1163@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rcx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN1088@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN1088@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], r15

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], 0
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-97], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN1150@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN1150@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	eax, -2051720247			; 85b53bc9H
	mov	QWORD PTR [r8], rax

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], 201			; 000000c9H
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-97], 4
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rbp-121], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T4[rbp-105], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rbp-97], r15

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04IABOEAHL@TST1@
	lea	rcx, QWORD PTR $T4[rbp-121]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 151  : 	WriteStringTable(Writer, "TST1", mTypeStringTable);

	lea	r9, QWORD PTR [r13+32]
	lea	r8, QWORD PTR $T4[rbp-121]
	lea	rdx, QWORD PTR Writer$[rbp-121]
	call	?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z ; PhiveWrapper::WriteStringTable

; 152  : 
; 153  : 	uint32_t TNAJumpback = Writer.GetPosition();

	mov	edi, DWORD PTR Writer$[rbp-97]
	mov	DWORD PTR TNAJumpback$1$[rbp-121], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rdi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN1008@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN1008@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], r15

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], 0
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	add	ecx, 4
	mov	DWORD PTR Writer$[rbp-97], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, rdx
	jbe	SHORT $LN996@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ecx, DWORD PTR Writer$[rbp-97]
$LN996@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r15d
	lea	r8, OFFSET FLAT:??_C@_04DIIAKOKC@TNA1@+1
	npad	12
$LL995@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL995@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbx, QWORD PTR [r13+88]
	sub	rbx, QWORD PTR [r13+80]
	sar	rbx, 6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 156  : 	Writer.WriteInteger(mTypes.size() + 1, sizeof(uint8_t));

	inc	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rcx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN980@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN980@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rdx, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], bl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, rdx
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	ebx, DWORD PTR Writer$[rbp-97]
	inc	ebx
	mov	DWORD PTR Writer$[rbp-97], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 157  : 	for (PhiveWrapperNamedType& Type : mTypes)

	mov	r14, QWORD PTR [r13+80]
	mov	rax, QWORD PTR [r13+88]
	cmp	r14, rax
	je	$LN1235@ToBinary
	mov	r12, rax
	npad	10
$LL4@ToBinary:

; 158  : 	{
; 159  : 		Writer.WriteInteger(Type.mIndex, sizeof(uint8_t));

	movzx	edi, BYTE PTR [r14+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN912@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN912@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rdx, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dil

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, rdx
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 160  : 		Writer.WriteInteger(Type.mTemplateCount, sizeof(uint8_t));

	movzx	ebx, BYTE PTR [r14+33]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	inc	eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN934@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN934@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rdx, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], bl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, rdx
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	ebx, DWORD PTR Writer$[rbp-97]
	inc	ebx
	mov	DWORD PTR Writer$[rbp-97], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 161  : 		for (PhiveWrapperTypeTemplate& Template : Type.mTemplates)

	mov	rdi, QWORD PTR [r14+40]
	mov	r15, QWORD PTR [r14+48]
	cmp	rdi, r15
	je	$LN2@ToBinary
	npad	1
$LL7@ToBinary:

; 162  : 		{
; 163  : 			Writer.WriteInteger(Template.mIndex, sizeof(uint8_t));

	movzx	esi, BYTE PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN704@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN704@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rdx, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rsi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, rdx
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 164  : 			Writer.WriteInteger(Template.mValue, sizeof(uint8_t));

	movzx	ebx, BYTE PTR [rdi+33]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	inc	eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN718@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN718@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rdx, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], bl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, rdx
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	ebx, DWORD PTR Writer$[rbp-97]
	inc	ebx
	mov	DWORD PTR Writer$[rbp-97], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 161  : 		for (PhiveWrapperTypeTemplate& Template : Type.mTemplates)

	add	rdi, 40					; 00000028H
	cmp	rdi, r15
	jne	$LL7@ToBinary
$LN2@ToBinary:

; 157  : 	for (PhiveWrapperNamedType& Type : mTypes)

	add	r14, 64					; 00000040H
	cmp	r14, r12
	jne	$LL4@ToBinary
	mov	r12d, DWORD PTR HavokTagFileEnd$1$[rbp-121]
	mov	edi, DWORD PTR TNAJumpback$1$[rbp-121]
	xor	r15d, r15d
$LN1235@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 108  : 	while (GetPosition() % Alignment != 0)

	test	bl, 3
	je	SHORT $LN894@ToBinary
	npad	11
$LL893@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], 0

; 14   : 	this->m_Offset++;

	mov	ebx, DWORD PTR Writer$[rbp-97]
	inc	ebx
	mov	DWORD PTR Writer$[rbp-97], ebx
	test	bl, 3

; 108  : 	while (GetPosition() % Alignment != 0)

	jne	SHORT $LL893@ToBinary
$LN894@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	mov	rcx, rdx
	mov	r8, QWORD PTR Writer$[rbp-121]
	sub	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, edi
	cmp	rax, rcx
	jbe	SHORT $LN880@ToBinary

; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rdi+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rdx, QWORD PTR Writer$[rbp-113]
	mov	r8, QWORD PTR Writer$[rbp-121]
$LN880@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-97], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 64			; 00000040H

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 172  : 	Writer.WriteInteger(_byteswap_ushort(TNAEnd - TNAJumpback), sizeof(uint16_t));

	movzx	eax, bx
	sub	ax, di
	ror	ax, 8
	movzx	edi, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rcx+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN855@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN855@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dil
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-97], 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Writer$[rbp-113]
	sub	rcx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, ebx
	cmp	rax, rcx
	jbe	SHORT $LN839@ToBinary

; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN839@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-97], ebx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rbp-121], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T3[rbp-105], r15

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rbp-97], r15

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04JKDOIEJJ@FST1@
	lea	rcx, QWORD PTR $T3[rbp-121]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 175  : 	WriteStringTable(Writer, "FST1", mFieldStringTable);

	lea	r9, QWORD PTR [r13+56]
	lea	r8, QWORD PTR $T3[rbp-121]
	lea	rdx, QWORD PTR Writer$[rbp-121]
	call	?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z ; PhiveWrapper::WriteStringTable
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rsi, QWORD PTR [r13+136]
	mov	r14, QWORD PTR [r13+144]
	sub	r14, rsi
	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rbx, r14d
	mov	edi, DWORD PTR Writer$[rbp-97]
	lea	eax, DWORD PTR [rdi+r14]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN1569@ToBinary

; 71   : 	{
; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, rbx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	edi, DWORD PTR Writer$[rbp-97]
$LN1569@ToBinary:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	mov	r9d, r15d
	mov	r8, r15
	test	r14d, r14d
	jle	SHORT $LN798@ToBinary
	npad	9
$LL799@ToBinary:

; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movzx	edx, BYTE PTR [r8+rsi]
	lea	eax, DWORD PTR [r9+rdi]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	lea	r9d, DWORD PTR [r9+1]
	inc	r8
	mov	edi, DWORD PTR Writer$[rbp-97]
	cmp	r8, rbx
	jl	SHORT $LL799@ToBinary
$LN798@ToBinary:

; 77   : 	}
; 78   : 	this->m_Offset += Size;

	add	edi, r14d
	mov	DWORD PTR Writer$24$[rbp-121], edi
	mov	DWORD PTR Writer$[rbp-97], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rdi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN826@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN826@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], r15

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], 0
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	add	ecx, 4
	mov	DWORD PTR Writer$[rbp-97], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, rdx
	jbe	SHORT $LN788@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ecx, DWORD PTR Writer$[rbp-97]
$LN788@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r15d
	lea	r8, OFFSET FLAT:??_C@_04BCAEOPJE@INDX@+1
	npad	12
$LL787@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL787@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r15, QWORD PTR [r13+16]
	sub	r15, QWORD PTR [r13+8]
	sar	r15, 2
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	r15, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 183  : 	uint16_t ItemSize = 8 + mItems.size() * 12;

	movzx	eax, r15w
	add	ax, ax
	add	r15w, ax
	shl	r15w, 2
	add	r15w, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 64			; 00000040H

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 186  : 	Writer.WriteInteger(_byteswap_ushort(ItemSize), sizeof(uint16_t));

	movzx	eax, r15w
	ror	ax, 8
	movzx	ebx, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rcx+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN960@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN960@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], bl
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r14d, DWORD PTR Writer$[rbp-97]
	add	r14d, 2
	mov	DWORD PTR Writer$[rbp-97], r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	movsxd	rax, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, rdx
	jbe	SHORT $LN948@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r14d, DWORD PTR Writer$[rbp-97]
$LN948@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_04BLNHNEEM@ITEM@+1
	npad	2
$LL947@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, r14d
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	r14d, DWORD PTR Writer$[rbp-97]
	inc	r14d
	mov	DWORD PTR Writer$[rbp-97], r14d

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL947@ToBinary
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 189  : 	for (PhiveWrapperItem& Item : mItems)

	mov	rbx, QWORD PTR [r13+8]
	mov	r13, QWORD PTR [r13+16]
	cmp	rbx, r13
	je	$LN9@ToBinary
	npad	3
$LL10@ToBinary:

; 190  : 	{
; 191  : 		Writer.WriteInteger(Item.mTypeIndex, sizeof(uint16_t));

	movzx	esi, WORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [r14+2]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN732@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN732@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rsi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	add	ecx, 2
	mov	DWORD PTR Writer$[rbp-97], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 192  : 		Writer.WriteInteger(_byteswap_ushort(Item.mFlags), sizeof(uint16_t));

	movzx	eax, WORD PTR [rbx+2]
	ror	ax, 8
	movzx	esi, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rcx+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN746@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN746@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rsi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	mov	DWORD PTR Writer$[rbp-97], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 193  : 		Writer.WriteInteger(Item.mDataOffset, sizeof(uint32_t));

	mov	esi, DWORD PTR [rbx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN760@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN760@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rsi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-97], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 194  : 		Writer.WriteInteger(Item.mCount, sizeof(uint32_t));

	mov	esi, DWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN774@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN774@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rsi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r14d, DWORD PTR Writer$[rbp-97]
	add	r14d, 4
	mov	DWORD PTR Writer$[rbp-97], r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 189  : 	for (PhiveWrapperItem& Item : mItems)

	add	rbx, 12
	cmp	rbx, r13
	jne	$LL10@ToBinary
$LN9@ToBinary:

; 195  : 	}
; 196  : 
; 197  : 	uint32_t IndexSize = ItemSize + 8;

	movzx	r13d, r15w
	mov	DWORD PTR tv14952[rbp-121], r13d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [r14+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN678@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN678@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 0

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], 0
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	ebx, DWORD PTR Writer$[rbp-97]
	add	ebx, 4
	mov	DWORD PTR Writer$[rbp-97], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	movsxd	rax, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, rdx
	jbe	SHORT $LN692@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ebx, DWORD PTR Writer$[rbp-97]
$LN692@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_04PNNKJEI@PTCH@+1
	npad	13
$LL691@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, ebx
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	ebx, DWORD PTR Writer$[rbp-97]
	inc	ebx
	mov	DWORD PTR Writer$[rbp-97], ebx

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL691@ToBinary
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 202  : 	for (PhiveWrapperPatch& Patch : mPatches)

	mov	rax, QWORD PTR this$GSCopy$1$[rbp-121]
	mov	r15, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+112]
	cmp	r15, rax
	je	$LN12@ToBinary
	mov	r12, rax
$LL13@ToBinary:

; 203  : 	{
; 204  : 		Writer.WriteInteger(Patch.mTypeIndex, sizeof(uint32_t));

	mov	edi, DWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [rbx+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN397@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN397@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dil
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-97], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 205  : 		Writer.WriteInteger(Patch.mCount, sizeof(uint32_t));

	mov	ebx, DWORD PTR [r15+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN383@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN383@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	ebx, DWORD PTR Writer$[rbp-97]
	add	ebx, 4
	mov	DWORD PTR Writer$[rbp-97], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 207  : 		for (uint32_t& Offset : Patch.mOffsets)

	mov	rdi, QWORD PTR [r15+8]
	mov	r13, QWORD PTR [r15+16]
	cmp	rdi, r13
	je	$LN11@ToBinary
	npad	2
$LL16@ToBinary:

; 208  : 		{
; 209  : 			Writer.WriteInteger(Offset, sizeof(uint32_t));

	mov	esi, DWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [rbx+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN27@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN27@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rsi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	ebx, DWORD PTR Writer$[rbp-97]
	add	ebx, 4
	mov	DWORD PTR Writer$[rbp-97], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 207  : 		for (uint32_t& Offset : Patch.mOffsets)

	add	rdi, 4
	cmp	rdi, r13
	jne	$LL16@ToBinary
$LN11@ToBinary:

; 202  : 	for (PhiveWrapperPatch& Patch : mPatches)

	add	r15, 32					; 00000020H
	cmp	r15, r12
	jne	$LL13@ToBinary
	mov	r12d, DWORD PTR HavokTagFileEnd$1$[rbp-121]
	mov	edi, DWORD PTR Writer$24$[rbp-121]
	mov	r13d, DWORD PTR tv14952[rbp-121]
$LN12@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN564@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN564@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 0

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], 0
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-97], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	mov	rcx, rdx
	mov	r8, QWORD PTR Writer$[rbp-121]
	sub	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, r14d
	cmp	rax, rcx
	jbe	SHORT $LN548@ToBinary

; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [r14+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rdx, QWORD PTR Writer$[rbp-113]
	mov	r8, QWORD PTR Writer$[rbp-121]
$LN548@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-97], r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 64			; 00000040H

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 218  : 	Writer.WriteInteger(_byteswap_ushort(PatchEnd - PatchJumpback), sizeof(uint16_t));

	movzx	eax, bx
	sub	ax, r14w
	ror	ax, 8
	movzx	esi, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rcx+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN509@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN509@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rsi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-97], 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	mov	rax, rdx
	mov	r8, QWORD PTR Writer$[rbp-121]
	sub	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	r15, ebx
	cmp	r15, rax
	jbe	SHORT $LN493@ToBinary

; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rdx, QWORD PTR Writer$[rbp-113]
	mov	r8, QWORD PTR Writer$[rbp-121]
$LN493@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-97], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 221  : 	IndexSize += (PatchEnd - PatchJumpback);

	sub	r13d, r14d
	lea	esi, DWORD PTR [r13+8]
	add	esi, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, rdx
	sub	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, edi
	cmp	rax, rcx
	jbe	SHORT $LN478@ToBinary

; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rdi+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rdx, QWORD PTR Writer$[rbp-113]
	mov	r8, QWORD PTR Writer$[rbp-121]
$LN478@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-97], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 226  : 	Writer.WriteInteger(_byteswap_ulong(IndexSize), sizeof(uint32_t));

	bswap	esi
	mov	esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [rdi+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN535@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN535@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rsi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-97], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR Writer$[rbp-113]
	sub	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	cmp	r15, rax
	jbe	SHORT $LN463@ToBinary

; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN463@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	edi, ebx
	mov	DWORD PTR Writer$[rbp-97], ebx

; 108  : 	while (GetPosition() % Alignment != 0)

	test	bl, 7
	je	SHORT $LN1632@ToBinary
	npad	8
$LL451@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], 0

; 14   : 	this->m_Offset++;

	mov	edi, DWORD PTR Writer$[rbp-97]
	inc	edi
	mov	DWORD PTR Writer$[rbp-97], edi
	test	dil, 7

; 108  : 	while (GetPosition() % Alignment != 0)

	jne	SHORT $LL451@ToBinary
$LN1632@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rdi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN440@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN440@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	xor	esi, esi
	mov	QWORD PTR [rax], rsi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-97], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN426@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN426@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 1065353216		; 3f800000H

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r8d, DWORD PTR Writer$[rbp-97]
	add	r8d, 4
	mov	DWORD PTR Writer$[rbp-97], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR Writer$[rbp-113]
	mov	rdx, r9
	mov	r10, QWORD PTR Writer$[rbp-121]
	sub	rdx, r10
	lea	eax, DWORD PTR [r8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN413@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+17]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-97]
	mov	r9, QWORD PTR Writer$[rbp-113]
	mov	r10, QWORD PTR Writer$[rbp-121]
$LN413@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	r8d, 16
	mov	DWORD PTR Writer$[rbp-97], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r9, r10
	lea	eax, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, r9
	jbe	SHORT $LN369@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	lea	rdx, QWORD PTR [r9+4]
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN369@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 1065353216		; 3f800000H

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r8d, DWORD PTR Writer$[rbp-97]
	add	r8d, 4
	mov	DWORD PTR Writer$[rbp-97], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR Writer$[rbp-113]
	mov	rdx, r9
	mov	r10, QWORD PTR Writer$[rbp-121]
	sub	rdx, r10
	lea	eax, DWORD PTR [r8+11]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN356@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+12]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-97]
	mov	r9, QWORD PTR Writer$[rbp-113]
	mov	r10, QWORD PTR Writer$[rbp-121]
$LN356@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	r8d, 11
	mov	DWORD PTR Writer$[rbp-97], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r9, r10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	lea	rdx, QWORD PTR [r9+1]
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 128			; 00000080H

; 14   : 	this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-97]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-97], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR Writer$[rbp-113]
	mov	rdx, r9
	mov	r10, QWORD PTR Writer$[rbp-121]
	sub	rdx, r10
	lea	eax, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN335@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+5]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-97]
	mov	r9, QWORD PTR Writer$[rbp-113]
	mov	r10, QWORD PTR Writer$[rbp-121]
$LN335@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	r8d, 4
	mov	DWORD PTR Writer$[rbp-97], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r9, r10
	lea	eax, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, r9
	jbe	SHORT $LN319@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	lea	rdx, QWORD PTR [r9+4]
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN319@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 1065353216		; 3f800000H

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], sil
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r9d, DWORD PTR Writer$[rbp-97]
	add	r9d, 4
	mov	DWORD PTR Writer$[rbp-97], r9d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR Writer$[rbp-113]
	mov	rdx, r8
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [r9+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN306@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r9+5]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r9d, DWORD PTR Writer$[rbp-97]
	mov	r8, QWORD PTR Writer$[rbp-113]
$LN306@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	lea	r14d, DWORD PTR [r9+4]

; 26   : 		this->m_Offset = Offset;

	mov	eax, esi
	mov	DWORD PTR Writer$[rbp-97], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r8, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	cmp	r8, 5
	jae	SHORT $LN277@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	lea	rdx, QWORD PTR [r8+5]
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	eax, DWORD PTR Writer$[rbp-97]
$LN277@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, esi
	lea	r8, OFFSET FLAT:??_C@_05OFCJFJKO@Phive@+1
	npad	11
$LL276@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+3]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 5
	lea	r8, QWORD PTR [r8+5]
	cmp	r9d, 5
	jb	SHORT $LL276@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], sil

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 1

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], sil

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 255			; 000000ffH

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 254			; 000000feH

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 1

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 3

; 14   : 	this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN221@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN221@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 48			; 00000030H

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], 48			; 00000030H
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-97], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN207@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN207@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	edx, edi
	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r8d, DWORD PTR Writer$[rbp-97]
	add	r8d, 4
	mov	DWORD PTR Writer$[rbp-97], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 119  : 			uint32_t Remainder = NumToRound % Multiple;

	mov	ecx, r14d
	and	ecx, 15

; 120  : 			if (Remainder == 0)

	mov	eax, r14d
	je	SHORT $LN187@ToBinary

; 121  : 				return NumToRound;
; 122  : 
; 123  : 			return NumToRound + Multiple - Remainder;

	sub	eax, ecx
	add	eax, 16
$LN187@ToBinary:

; 227  : 
; 228  : 	Writer.Seek(FileEnd, BinaryVectorWriter::Position::Begin);
; 229  : 	uint32_t PhysicsDataEnd = Writer.GetPosition();
; 230  : 	Writer.Align(8);
; 231  : 	uint32_t LastDataOffset = Writer.GetPosition();
; 232  : 	Writer.WriteInteger(0, sizeof(uint32_t));
; 233  : 	Writer.WriteInteger(0x3F800000, sizeof(uint32_t));
; 234  : 	Writer.Seek(16, BinaryVectorWriter::Position::Current);
; 235  : 	Writer.WriteInteger(0x3F800000, sizeof(uint32_t));
; 236  : 	Writer.Seek(11, BinaryVectorWriter::Position::Current);
; 237  : 	Writer.WriteByte(0x80);
; 238  : 	Writer.Seek(4, BinaryVectorWriter::Position::Current);
; 239  : 	Writer.WriteInteger(0x3F800000, sizeof(uint32_t));
; 240  : 	Writer.Seek(4, BinaryVectorWriter::Position::Current);
; 241  : 
; 242  : 	FileEnd = Writer.GetPosition();
; 243  : 
; 244  : 	Writer.Seek(0, BinaryVectorWriter::Position::Begin);
; 245  : 
; 246  : 	Writer.WriteBytes("Phive");
; 247  : 	Writer.WriteByte(0x00);
; 248  : 	Writer.WriteByte(0x01);
; 249  : 	Writer.WriteByte(0x00);
; 250  : 	Writer.WriteByte(0xFF);
; 251  : 	Writer.WriteByte(0xFE);
; 252  : 	Writer.WriteByte(0x01);
; 253  : 	Writer.WriteByte(0x03);
; 254  : 
; 255  : 	Writer.WriteInteger(48, sizeof(uint32_t)); //TagFileOffset
; 256  : 
; 257  : 	Writer.WriteInteger(LastDataOffset, sizeof(uint32_t));
; 258  : 	Writer.WriteInteger(RoundUpToMultiple(FileEnd, 16), sizeof(uint32_t));

	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN177@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN177@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dil
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-97], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN163@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN163@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 259  : 	Writer.WriteInteger(PhysicsDataEnd - 0x30, sizeof(uint32_t));

	add	ebx, -48				; ffffffd0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	edx, ebx
	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-97], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN149@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN149@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 52			; 00000034H

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], 52			; 00000034H
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-97], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	mov	rax, rdx
	mov	rcx, QWORD PTR Writer$[rbp-121]
	sub	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	cmp	rax, 48					; 00000030H
	jae	SHORT $LN133@ToBinary

; 24   : 			this->m_Data.resize(Offset + 1);

	mov	edx, 49					; 00000031H
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rdx, QWORD PTR Writer$[rbp-113]
	mov	rcx, QWORD PTR Writer$[rbp-121]
$LN133@ToBinary:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-97], 48		; 00000030H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 24   : 	Size &= 0x3FFFFFFF;

	and	ebx, 1073741823				; 3fffffffH

; 25   : 
; 26   : 	uint32_t Combined = (static_cast<uint32_t>(Flags) << 30) | Size;
; 27   : 	return _byteswap_ulong(Combined);

	bswap	ebx

; 260  : 	Writer.WriteInteger(0x34, sizeof(uint32_t));
; 261  : 
; 262  : 	Writer.Seek(0x30, BinaryVectorWriter::Position::Begin);
; 263  : 
; 264  : 	Writer.WriteInteger(WriteBitFieldFlagsSize(0x00, PhysicsDataEnd - 0x30), sizeof(uint32_t));

	mov	ebx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	cmp	rdx, 52					; 00000034H
	jae	SHORT $LN118@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN118@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	add	ecx, 4
	mov	DWORD PTR Writer$[rbp-97], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, rdx
	jbe	SHORT $LN195@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ecx, DWORD PTR Writer$[rbp-97]
$LN195@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, esi
	lea	r8, OFFSET FLAT:??_C@_04HNHFPDAH@TAG0@+1
$LL194@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL194@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 64			; 00000040H

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], sil

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], sil

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 16

; 14   : 	this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, rdx
	jbe	SHORT $LN82@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ecx, DWORD PTR Writer$[rbp-97]
$LN82@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, esi
	lea	r8, OFFSET FLAT:??_C@_04MCDGOKGA@SDKV@+1
	npad	11
$LL81@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL81@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]
	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 8
	cmp	rax, rdx
	jbe	SHORT $LN70@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 8
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ecx, DWORD PTR Writer$[rbp-97]
$LN70@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, esi
	lea	r8, OFFSET FLAT:??_C@_08PICJLGIE@20220100@+1
	npad	9
$LL69@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+3]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+4]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+5]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+6]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	ecx, DWORD PTR Writer$[rbp-97]
	inc	ecx
	mov	DWORD PTR Writer$[rbp-97], ecx

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 8
	lea	r8, QWORD PTR [r8+8]
	cmp	r9d, 8
	jb	$LL69@ToBinary
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 272  : 	Writer.WriteInteger(_byteswap_ulong((uint32_t)(HavokTagFileEnd - 0x48)), 4);

	lea	ebx, DWORD PTR [r12-72]
	bswap	ebx
	mov	ebx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR Writer$[rbp-113]
	sub	r8, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [rcx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rdx, eax
	cmp	rdx, r8
	jbe	SHORT $LN56@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	lea	rdx, QWORD PTR [r8+4]
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN56@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rbp-97]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rbp-97]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r8d, DWORD PTR Writer$[rbp-97]
	add	r8d, 4
	mov	DWORD PTR Writer$[rbp-97], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR Writer$[rbp-113]
	mov	rdx, r9
	mov	r10, QWORD PTR Writer$[rbp-121]
	sub	rdx, r10
	lea	eax, DWORD PTR [r8-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN43@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8-3]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-97]
	mov	r9, QWORD PTR Writer$[rbp-113]
	mov	r10, QWORD PTR Writer$[rbp-121]
$LN43@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	sub	r8d, 4
	mov	DWORD PTR Writer$[rbp-97], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r9, r10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	lea	rdx, QWORD PTR [r9+1]
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-97]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 64			; 00000040H

; 14   : 	this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-97]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-97], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR Writer$[rbp-113]
	mov	rdx, r9
	sub	rdx, QWORD PTR Writer$[rbp-121]
	lea	eax, DWORD PTR [r8+3]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN586@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+4]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-97]
	mov	r9, QWORD PTR Writer$[rbp-113]
$LN586@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	r8d, 3
	mov	DWORD PTR Writer$[rbp-97], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r9, QWORD PTR Writer$[rbp-121]
	movsxd	rax, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, r9
	jbe	SHORT $LN599@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	lea	rdx, QWORD PTR [r9+4]
	lea	rcx, QWORD PTR Writer$[rbp-121]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-97]
$LN599@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r10d, esi
	lea	r9, OFFSET FLAT:??_C@_04DFNBDBBL@DATA@+1
	npad	11
$LL598@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, r8d
	movzx	ecx, BYTE PTR [r9-1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r9]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r9+1]
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-97]
	inc	eax
	mov	DWORD PTR Writer$[rbp-97], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r9+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-121]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-97]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-97], r8d

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r10d, 4
	lea	r9, QWORD PTR [r9+4]
	cmp	r10d, 4
	jb	SHORT $LL598@ToBinary
	xorps	xmm0, xmm0
	mov	r15, QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-121]
	movups	XMMWORD PTR [r15], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r15], rsi
	mov	QWORD PTR [r15+8], rsi
	mov	QWORD PTR [r15+16], rsi

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-113]
	sub	rdx, QWORD PTR Writer$[rbp-121]

; 2065 :         if (_Count != 0) {

	je	SHORT $LN640@ToBinary

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax
	ja	$LN1640@ToBinary

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	mov	rcx, r15
	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rsi, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));

	mov	rbx, QWORD PTR Writer$[rbp-121]

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rdi, QWORD PTR Writer$[rbp-113]
	mov	r8, rdi
	sub	r8, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rbx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1850 :             return _Dest;

	sub	rdi, rbx

; 1827 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1828 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1829 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1830 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1831 :     auto _ULast  = _Get_unwrapped(_STD move(_Last));
; 1832 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1833 : 
; 1834 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1835 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1836 : 
; 1837 :     if constexpr (_Can_memmove) {
; 1838 : #if _HAS_CXX20
; 1839 :         if (!_STD is_constant_evaluated())
; 1840 : #endif // _HAS_CXX20
; 1841 :         {
; 1842 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1843 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1844 :                 _Dest += _ULast - _UFirst;

	add	rdi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [r15+8], rdi
$LN640@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 281  : 	return Data;

	mov	DWORD PTR $T2[rbp-121], 1

; 273  : 	Writer.Seek(-4, BinaryVectorWriter::Position::Current);
; 274  : 	Writer.WriteByte(0x40);
; 275  : 	Writer.Seek(3, BinaryVectorWriter::Position::Current);
; 276  : 	Writer.WriteBytes("DATA");
; 277  : 
; 278  : 	std::vector<unsigned char> Data = Writer.GetData();
; 279  : 	Data.resize(FileEnd);

	mov	edx, r14d
	mov	rcx, r15
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Writer$[rbp-121]
	test	rcx, rcx
	je	SHORT $LN650@ToBinary

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Writer$[rbp-105]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN668@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN668@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN668@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN650@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 281  : 	return Data;

	mov	rax, r15

; 282  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-121]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+240]
	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN1640@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN1638@ToBinary:
?ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ ENDP ; PhiveWrapper::ToBinary
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
HavokTagFileEnd$1$ = 32
Writer$24$ = 36
TNAJumpback$1$ = 36
tv14952 = 40
$T2 = 48
this$GSCopy$1$ = 56
$T3 = 64
$T4 = 64
__$ReturnUdt$GSCopy$1$ = 96
__$ReturnUdt$GSCopy$ = 104
Writer$ = 112
__$ArrayPad$ = 144
this$ = 224
__$ReturnUdt$ = 232
?dtor$0@?0??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA PROC ; `PhiveWrapper::ToBinary'::`1'::dtor$0
	lea	rcx, QWORD PTR Writer$[rdx]
	jmp	??1BinaryVectorWriter@@QEAA@XZ
?dtor$0@?0??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA ENDP ; `PhiveWrapper::ToBinary'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
HavokTagFileEnd$1$ = 32
Writer$24$ = 36
TNAJumpback$1$ = 36
tv14952 = 40
$T2 = 48
this$GSCopy$1$ = 56
$T3 = 64
$T4 = 64
__$ReturnUdt$GSCopy$1$ = 96
__$ReturnUdt$GSCopy$ = 104
Writer$ = 112
__$ArrayPad$ = 144
this$ = 224
__$ReturnUdt$ = 232
?dtor$3@?0??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA PROC ; `PhiveWrapper::ToBinary'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN22@dtor$3
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
$LN22@dtor$3:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA ENDP ; `PhiveWrapper::ToBinary'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
;	COMDAT ??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z
_TEXT	SEGMENT
TypeCount$1$ = 32
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
_Newlast$1$ = 80
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 112
Bytes$GSCopy$1$ = 120
this$GSCopy$1$ = 128
_Newsize$1$ = 136
this$GSCopy$ = 144
Bytes$GSCopy$ = 152
$T18 = 160
Patch$19 = 160
Reader$ = 160
__$ArrayPad$ = 192
this$ = 288
Bytes$ = 296
EnablePatches$dead$ = 304
??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z PROC ; PhiveWrapper::PhiveWrapper, COMDAT

; 285  : {

$LN661:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rsp+208], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-185], rax
	mov	rbx, rdx
	mov	QWORD PTR Bytes$GSCopy$1$[rbp-185], rdx
	mov	QWORD PTR this$GSCopy$1$[rbp-185], rcx

; 20   : }
; 21   : 
; 22   : uint32_t PhiveWrapper::WriteBitFieldFlagsSize(uint8_t Flags, uint32_t Size)
; 23   : {
; 24   : 	Size &= 0x3FFFFFFF;
; 25   : 
; 26   : 	uint32_t Combined = (static_cast<uint32_t>(Flags) << 30) | Size;
; 27   : 	return _byteswap_ulong(Combined);
; 28   : }
; 29   : 
; 30   : void PhiveWrapper::WriteStringTable(BinaryVectorWriter& Writer, std::string SectionMagic, std::vector<std::string>& StringTable)
; 31   : {
; 32   : 	uint32_t Jumpback = Writer.GetPosition();
; 33   : 	Writer.Seek(4, BinaryVectorWriter::Position::Current);
; 34   : 	Writer.WriteBytes(SectionMagic.c_str());
; 35   : 	for (const std::string& Buf : StringTable)
; 36   : 	{
; 37   : 		Writer.WriteBytes(Buf.c_str());
; 38   : 		Writer.WriteByte(0x00);
; 39   : 	}
; 40   : 	Writer.Align(4, 0xFF);
; 41   : 	uint32_t End = Writer.GetPosition();
; 42   : 	Writer.Seek(Jumpback, BinaryVectorWriter::Position::Begin);
; 43   : 	Writer.WriteInteger(WriteBitFieldFlagsSize(0x01, End - Jumpback), sizeof(uint32_t));
; 44   : 	Writer.Seek(End, BinaryVectorWriter::Position::Begin);
; 45   : }
; 46   : 
; 47   : void PhiveWrapper::ReadStringTable(BinaryVectorReader& Reader, std::string SectionMagic, std::vector<std::string>& StringTable)
; 48   : {
; 49   : 	Reader.Seek(FindSection(Reader, SectionMagic), BinaryVectorReader::Position::Begin);
; 50   : 
; 51   : 	uint32_t Size = ReadBitFieldFlagsSize(Reader.ReadUInt32()).second;
; 52   : 	Reader.Seek(4, BinaryVectorReader::Position::Current); //Magic
; 53   : 	Size = Size - 8; //Flags(1) - Size(3) - Magic(4)
; 54   : 
; 55   : 	std::string Buffer;
; 56   : 	for (uint32_t i = 0; i < Size; i++)
; 57   : 	{
; 58   : 		char Character = Reader.ReadUInt8();
; 59   : 		if (Character == 0xFF)
; 60   : 			continue;
; 61   : 
; 62   : 		if (Character == 0x00)
; 63   : 		{
; 64   : 			StringTable.push_back(Buffer);
; 65   : 			Buffer.clear();
; 66   : 			continue;
; 67   : 		}
; 68   : 
; 69   : 		Buffer += Character;
; 70   : 	}
; 71   : }
; 72   : 
; 73   : uint16_t PhiveWrapper::GetTypeNameIndex(std::string Name)
; 74   : {
; 75   : 	Util::ReplaceString(Name, "__", "::");
; 76   : 	for (size_t i = 0; i < mTypes.size(); i++)
; 77   : 	{
; 78   : 		if (mTypes[i].mName == Name)
; 79   : 			return i + 1;
; 80   : 	}
; 81   : 	Logger::Error("PhiveWrapper", "Could not find type index for class" + Name);
; 82   : 	return 0xFFFF;
; 83   : }
; 84   : 
; 85   : uint8_t PhiveWrapper::GetTypeNameFlag(std::string Name)
; 86   : {
; 87   : 	Util::ReplaceString(Name, "__", "::");
; 88   : 
; 89   : 	if (Name == "hkRootLevelContainer" ||
; 90   : 		Name == "hkaiNavMesh" ||
; 91   : 		Name == "hkaiClusterGraph" ||
; 92   : 		Name == "hkaiNavMeshStaticTreeFaceIterator" ||
; 93   : 		Name == "hkcdStaticAabbTree" ||
; 94   : 		Name == "hkcdStaticAabbTree::Impl")
; 95   : 		return 16;
; 96   : 
; 97   : 	if (Name == "hkRootLevelContainer::NamedVariant" ||
; 98   : 		Name == "char" ||
; 99   : 		Name == "hkaiNavMesh::Face" ||
; 100  : 		Name == "hkaiNavMesh::Edge" ||
; 101  : 		Name == "hkVector4" ||
; 102  : 		Name == "hkInt32" ||
; 103  : 		Name == "hkaiClusterGraph::Node" ||
; 104  : 		Name == "hkaiIndex" ||
; 105  : 		Name == "hkcdCompressedAabbCodecs::Aabb6BytesCodec" ||
; 106  : 		Name == "hkaiClusterGraph::Edge")
; 107  : 		return 32;
; 108  : 
; 109  : 	Logger::Error("PhiveWrapper", "Could not calculate flag for class " + Name);
; 110  : }
; 111  : 
; 112  : std::vector<unsigned char> PhiveWrapper::ToBinary()
; 113  : {
; 114  : 	auto RoundUpToMultiple = [](uint32_t NumToRound, uint32_t Multiple)
; 115  : 		{
; 116  : 			if (Multiple == 0)
; 117  : 				return NumToRound;
; 118  : 
; 119  : 			uint32_t Remainder = NumToRound % Multiple;
; 120  : 			if (Remainder == 0)
; 121  : 				return NumToRound;
; 122  : 
; 123  : 			return NumToRound + Multiple - Remainder;
; 124  : 		};
; 125  : 
; 126  : 	BinaryVectorWriter Writer;
; 127  : 	Writer.Seek(0x50, BinaryVectorWriter::Position::Begin);
; 128  : 	Writer.WriteRawUnsafeFixed(reinterpret_cast<const char*>(mHavokTagFile.data()), mHavokTagFile.size());
; 129  : 
; 130  : 	Writer.Align(16);
; 131  : 
; 132  : 	uint32_t HavokTagFileEnd = Writer.GetPosition();
; 133  : 
; 134  : 	Writer.WriteInteger(mTypeSize, sizeof(uint32_t));
; 135  : 	Writer.WriteBytes("TYPE");
; 136  : 
; 137  : 	Writer.WriteByte(0x40);
; 138  : 	Writer.WriteByte(0x00);
; 139  : 	Writer.WriteInteger(_byteswap_ushort(mTypePointerPaddingSize), sizeof(uint16_t));
; 140  : 	Writer.WriteBytes("TPTR");
; 141  : 	Writer.Seek(mTypePointerPaddingSize - 8, BinaryVectorWriter::Position::Current);
; 142  : 
; 143  : 	Writer.WriteByte(0x40);
; 144  : 	Writer.WriteByte(0x00);
; 145  : 	Writer.WriteByte(0x00);
; 146  : 	Writer.WriteByte(0x10);
; 147  : 	Writer.WriteBytes("TSHA");
; 148  : 	Writer.WriteInteger(0, sizeof(uint32_t));
; 149  : 	Writer.WriteInteger(_byteswap_ulong(0xC93BB585), sizeof(uint32_t));
; 150  : 
; 151  : 	WriteStringTable(Writer, "TST1", mTypeStringTable);
; 152  : 
; 153  : 	uint32_t TNAJumpback = Writer.GetPosition();
; 154  : 	Writer.WriteInteger(0, sizeof(uint32_t));
; 155  : 	Writer.WriteBytes("TNA1");
; 156  : 	Writer.WriteInteger(mTypes.size() + 1, sizeof(uint8_t));
; 157  : 	for (PhiveWrapperNamedType& Type : mTypes)
; 158  : 	{
; 159  : 		Writer.WriteInteger(Type.mIndex, sizeof(uint8_t));
; 160  : 		Writer.WriteInteger(Type.mTemplateCount, sizeof(uint8_t));
; 161  : 		for (PhiveWrapperTypeTemplate& Template : Type.mTemplates)
; 162  : 		{
; 163  : 			Writer.WriteInteger(Template.mIndex, sizeof(uint8_t));
; 164  : 			Writer.WriteInteger(Template.mValue, sizeof(uint8_t));
; 165  : 		}
; 166  : 	}
; 167  : 	Writer.Align(4);
; 168  : 	uint32_t TNAEnd = Writer.GetPosition();
; 169  : 	Writer.Seek(TNAJumpback, BinaryVectorWriter::Position::Begin);
; 170  : 	Writer.WriteByte(0x40);
; 171  : 	Writer.WriteByte(0x00);
; 172  : 	Writer.WriteInteger(_byteswap_ushort(TNAEnd - TNAJumpback), sizeof(uint16_t));
; 173  : 	Writer.Seek(TNAEnd, BinaryVectorWriter::Position::Begin);
; 174  : 
; 175  : 	WriteStringTable(Writer, "FST1", mFieldStringTable);
; 176  : 
; 177  : 	Writer.WriteRawUnsafeFixed(reinterpret_cast<const char*>(mConstantBlock.data()), mConstantBlock.size());
; 178  : 
; 179  : 	uint32_t IndexJumpback = Writer.GetPosition();
; 180  : 	Writer.WriteInteger(0, sizeof(uint32_t));
; 181  : 	Writer.WriteBytes("INDX");
; 182  : 
; 183  : 	uint16_t ItemSize = 8 + mItems.size() * 12;
; 184  : 	Writer.WriteByte(0x40);
; 185  : 	Writer.WriteByte(0x00);
; 186  : 	Writer.WriteInteger(_byteswap_ushort(ItemSize), sizeof(uint16_t));
; 187  : 	Writer.WriteBytes("ITEM");
; 188  : 
; 189  : 	for (PhiveWrapperItem& Item : mItems)
; 190  : 	{
; 191  : 		Writer.WriteInteger(Item.mTypeIndex, sizeof(uint16_t));
; 192  : 		Writer.WriteInteger(_byteswap_ushort(Item.mFlags), sizeof(uint16_t));
; 193  : 		Writer.WriteInteger(Item.mDataOffset, sizeof(uint32_t));
; 194  : 		Writer.WriteInteger(Item.mCount, sizeof(uint32_t));
; 195  : 	}
; 196  : 
; 197  : 	uint32_t IndexSize = ItemSize + 8;
; 198  : 
; 199  : 	uint32_t PatchJumpback = Writer.GetPosition();
; 200  : 	Writer.WriteInteger(0, sizeof(uint32_t));
; 201  : 	Writer.WriteBytes("PTCH");
; 202  : 	for (PhiveWrapperPatch& Patch : mPatches)
; 203  : 	{
; 204  : 		Writer.WriteInteger(Patch.mTypeIndex, sizeof(uint32_t));
; 205  : 		Writer.WriteInteger(Patch.mCount, sizeof(uint32_t));
; 206  : 
; 207  : 		for (uint32_t& Offset : Patch.mOffsets)
; 208  : 		{
; 209  : 			Writer.WriteInteger(Offset, sizeof(uint32_t));
; 210  : 		}
; 211  : 	}
; 212  : 	uint32_t PatchEnd = Writer.GetPosition();
; 213  : 	Writer.WriteInteger(0, sizeof(uint32_t)); //Terminator
; 214  : 
; 215  : 	Writer.Seek(PatchJumpback, BinaryVectorWriter::Position::Begin);
; 216  : 	Writer.WriteByte(0x40);
; 217  : 	Writer.WriteByte(0x00);
; 218  : 	Writer.WriteInteger(_byteswap_ushort(PatchEnd - PatchJumpback), sizeof(uint16_t));
; 219  : 	Writer.Seek(PatchEnd, BinaryVectorWriter::Position::Begin);
; 220  : 
; 221  : 	IndexSize += (PatchEnd - PatchJumpback);
; 222  : 
; 223  : 	uint32_t FileEnd = Writer.GetPosition();
; 224  : 
; 225  : 	Writer.Seek(IndexJumpback, BinaryVectorWriter::Position::Begin);
; 226  : 	Writer.WriteInteger(_byteswap_ulong(IndexSize), sizeof(uint32_t));
; 227  : 
; 228  : 	Writer.Seek(FileEnd, BinaryVectorWriter::Position::Begin);
; 229  : 	uint32_t PhysicsDataEnd = Writer.GetPosition();
; 230  : 	Writer.Align(8);
; 231  : 	uint32_t LastDataOffset = Writer.GetPosition();
; 232  : 	Writer.WriteInteger(0, sizeof(uint32_t));
; 233  : 	Writer.WriteInteger(0x3F800000, sizeof(uint32_t));
; 234  : 	Writer.Seek(16, BinaryVectorWriter::Position::Current);
; 235  : 	Writer.WriteInteger(0x3F800000, sizeof(uint32_t));
; 236  : 	Writer.Seek(11, BinaryVectorWriter::Position::Current);
; 237  : 	Writer.WriteByte(0x80);
; 238  : 	Writer.Seek(4, BinaryVectorWriter::Position::Current);
; 239  : 	Writer.WriteInteger(0x3F800000, sizeof(uint32_t));
; 240  : 	Writer.Seek(4, BinaryVectorWriter::Position::Current);
; 241  : 
; 242  : 	FileEnd = Writer.GetPosition();
; 243  : 
; 244  : 	Writer.Seek(0, BinaryVectorWriter::Position::Begin);
; 245  : 
; 246  : 	Writer.WriteBytes("Phive");
; 247  : 	Writer.WriteByte(0x00);
; 248  : 	Writer.WriteByte(0x01);
; 249  : 	Writer.WriteByte(0x00);
; 250  : 	Writer.WriteByte(0xFF);
; 251  : 	Writer.WriteByte(0xFE);
; 252  : 	Writer.WriteByte(0x01);
; 253  : 	Writer.WriteByte(0x03);
; 254  : 
; 255  : 	Writer.WriteInteger(48, sizeof(uint32_t)); //TagFileOffset
; 256  : 
; 257  : 	Writer.WriteInteger(LastDataOffset, sizeof(uint32_t));
; 258  : 	Writer.WriteInteger(RoundUpToMultiple(FileEnd, 16), sizeof(uint32_t));
; 259  : 	Writer.WriteInteger(PhysicsDataEnd - 0x30, sizeof(uint32_t));
; 260  : 	Writer.WriteInteger(0x34, sizeof(uint32_t));
; 261  : 
; 262  : 	Writer.Seek(0x30, BinaryVectorWriter::Position::Begin);
; 263  : 
; 264  : 	Writer.WriteInteger(WriteBitFieldFlagsSize(0x00, PhysicsDataEnd - 0x30), sizeof(uint32_t));
; 265  : 	Writer.WriteBytes("TAG0");
; 266  : 	Writer.WriteByte(0x40);
; 267  : 	Writer.WriteByte(0x00);
; 268  : 	Writer.WriteByte(0x00);
; 269  : 	Writer.WriteByte(0x10);
; 270  : 	Writer.WriteBytes("SDKV");
; 271  : 	Writer.WriteBytes("20220100");
; 272  : 	Writer.WriteInteger(_byteswap_ulong((uint32_t)(HavokTagFileEnd - 0x48)), 4);
; 273  : 	Writer.Seek(-4, BinaryVectorWriter::Position::Current);
; 274  : 	Writer.WriteByte(0x40);
; 275  : 	Writer.Seek(3, BinaryVectorWriter::Position::Current);
; 276  : 	Writer.WriteBytes("DATA");
; 277  : 
; 278  : 	std::vector<unsigned char> Data = Writer.GetData();
; 279  : 	Data.resize(FileEnd);
; 280  : 
; 281  : 	return Data;
; 282  : }
; 283  : 
; 284  : PhiveWrapper::PhiveWrapper(std::vector<unsigned char> Bytes, bool EnablePatches) : mEnablePatches(EnablePatches)

	mov	QWORD PTR this$GSCopy$[rbp-185], rcx
	mov	QWORD PTR Bytes$GSCopy$[rbp-185], rdx
	mov	BYTE PTR [rcx], 1

; 285  : {

	lea	rsi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	edx, edx
	mov	QWORD PTR [rsi], rdx
	mov	QWORD PTR [rsi+8], rdx
	mov	QWORD PTR [rsi+16], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 285  : {

	lea	r12, QWORD PTR [rcx+32]
	mov	QWORD PTR $T17[rbp-185], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r12], rdx
	mov	QWORD PTR [r12+8], rdx
	mov	QWORD PTR [r12+16], rdx
	mov	QWORD PTR [rcx+56], rdx
	mov	QWORD PTR [rcx+64], rdx
	mov	QWORD PTR [rcx+72], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 285  : {

	lea	r14, QWORD PTR [rcx+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r14], rdx
	mov	QWORD PTR [r14+8], rdx
	mov	QWORD PTR [r14+16], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 285  : {

	lea	r15, QWORD PTR [rcx+104]
	mov	QWORD PTR $T14[rbp-185], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r15], rdx
	mov	QWORD PTR [r15+8], rdx
	mov	QWORD PTR [r15+16], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.h

; 52   : 	uint16_t mTypePointerPaddingSize = 0;

	mov	WORD PTR [rcx+128], dx

; 53   : 	uint32_t mTypeSize = 0; //Big Endian

	mov	DWORD PTR [rcx+132], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 285  : {

	lea	r13, QWORD PTR [rcx+136]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r13], rdx
	mov	QWORD PTR [r13+8], rdx
	mov	QWORD PTR [r13+16], rdx
	mov	QWORD PTR [rcx+160], rdx
	mov	QWORD PTR [rcx+168], rdx
	mov	QWORD PTR [rcx+176], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 6    : BinaryVectorReader::BinaryVectorReader(std::vector<unsigned char>& Bytes, bool BigEndian) : m_Bytes(Bytes) {}

	mov	QWORD PTR Reader$[rbp-185], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.h

; 39   : 	int m_Offset = -1;

	mov	DWORD PTR Reader$[rbp-177], -1
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T9[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T9[rsp+16], rdx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T9[rbp-161], rdx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdx+4]
	lea	rdx, OFFSET FLAT:??_C@_04BLNHNEEM@ITEM@
	lea	rcx, QWORD PTR $T9[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 288  : 	Reader.Seek(FindSection(Reader, "ITEM"), BinaryVectorReader::Position::Begin);

	movaps	xmm0, XMMWORD PTR Reader$[rbp-185]
	movdqa	XMMWORD PTR $T13[rbp-185], xmm0
	lea	r8, QWORD PTR $T9[rsp]
	lea	rdx, QWORD PTR $T13[rbp-185]
	call	?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveWrapper::FindSection
	movsxd	rdi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdx, QWORD PTR [rcx+rdi]
	lea	r8, QWORD PTR [rcx+rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	ecx, BYTE PTR [rcx+rdi+2]
	shl	ecx, 8
	movzx	eax, BYTE PTR [r8+1]
	or	ecx, eax
	shl	ecx, 8
	movzx	eax, BYTE PTR [rdx+3]
	shl	eax, 24
	or	ecx, eax
	movzx	eax, BYTE PTR [r8]
	or	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 19   : 	return std::make_pair(Input >> 30, _byteswap_ulong(Input) & 0x3FFFFFFF);

	bswap	ecx
	and	ecx, 1073741823				; 3fffffffH

; 289  : 	uint32_t ItemCount = (ReadBitFieldFlagsSize(Reader.ReadUInt32()).second - 8) / 12;

	add	ecx, -8					; fffffff8H
	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx
	mov	ebx, edx
	shr	ebx, 3
	add	edi, 7

; 290  : 	Reader.Seek(4, BinaryVectorReader::Position::Current);
; 291  : 	mItems.resize(ItemCount);

	mov	edx, ebx
	mov	rcx, rsi
	call	?resize@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::resize

; 292  : 	Reader.ReadStruct(mItems.data(), sizeof(PhiveWrapperItem) * ItemCount);

	lea	ebx, DWORD PTR [rbx+rbx*2]
	shl	ebx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 146  : 	std::memcpy(Dest, this->m_Bytes.data() + this->m_Offset + 1, Size);

	mov	r8d, ebx
	movsxd	rdx, edi
	mov	rax, QWORD PTR Bytes$GSCopy$1$[rbp-185]
	mov	rax, QWORD PTR [rax]
	inc	rax
	add	rdx, rax
	mov	rcx, QWORD PTR [rsi]
	call	memcpy
	lea	eax, DWORD PTR [rdi+rbx]
	mov	DWORD PTR Reader$[rbp-177], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 294  : 	for (PhiveWrapperItem& Item : mItems)

	mov	rdx, QWORD PTR [rsi+8]

; 19   : 	return std::make_pair(Input >> 30, _byteswap_ulong(Input) & 0x3FFFFFFF);

	mov	rcx, QWORD PTR [rsi]

; 294  : 	for (PhiveWrapperItem& Item : mItems)

	cmp	rcx, rdx
	je	SHORT $LN3@PhiveWrapp
$LL4@PhiveWrapp:

; 295  : 	{
; 296  : 		Item.mFlags = _byteswap_ushort(Item.mFlags);

	movzx	eax, WORD PTR [rcx+2]
	ror	ax, 8
	mov	WORD PTR [rcx+2], ax

; 294  : 	for (PhiveWrapperItem& Item : mItems)

	add	rcx, 12
	cmp	rcx, rdx
	jne	SHORT $LL4@PhiveWrapp
$LN3@PhiveWrapp:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T8[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	edi, edi
	mov	QWORD PTR $T8[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T8[rbp-161], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+4]
	lea	rdx, OFFSET FLAT:??_C@_04NJLJDCFO@TBDY@
	lea	rcx, QWORD PTR $T8[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 299  : 	uint32_t ConstantBlockStart = FindSection(Reader, "TBDY");

	movaps	xmm6, XMMWORD PTR Reader$[rbp-185]
	movdqa	XMMWORD PTR $T12[rbp-185], xmm6
	lea	r8, QWORD PTR $T8[rsp]
	lea	rdx, QWORD PTR $T12[rbp-185]
	call	?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveWrapper::FindSection
	mov	ebx, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T7[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T7[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T7[rbp-161], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+4]
	lea	rdx, OFFSET FLAT:??_C@_04BCAEOPJE@INDX@
	lea	rcx, QWORD PTR $T7[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 300  : 	uint32_t ConstantBlockEnd = FindSection(Reader, "INDX");

	movdqa	XMMWORD PTR $T11[rbp-185], xmm6
	lea	r8, QWORD PTR $T7[rsp]
	lea	rdx, QWORD PTR $T11[rbp-185]
	call	?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveWrapper::FindSection
	mov	esi, eax

; 301  : 	uint32_t ConstantBlockSize = ConstantBlockEnd - ConstantBlockStart;

	sub	esi, ebx

; 302  : 	mConstantBlock.resize(ConstantBlockSize);

	mov	edx, esi
	mov	rcx, r13
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	dec	ebx

; 146  : 	std::memcpy(Dest, this->m_Bytes.data() + this->m_Offset + 1, Size);

	movsxd	rdx, ebx
	mov	rax, QWORD PTR Bytes$GSCopy$1$[rbp-185]
	mov	rax, QWORD PTR [rax]
	inc	rax
	add	rdx, rax
	mov	r8d, esi
	mov	rcx, QWORD PTR [r13]
	call	memcpy
	lea	eax, DWORD PTR [rbx+rsi]
	mov	DWORD PTR Reader$[rbp-177], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T6[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T6[rbp-161], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+4]
	lea	rdx, OFFSET FLAT:??_C@_04IABOEAHL@TST1@
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 306  : 	ReadStringTable(Reader, "TST1", mTypeStringTable);

	mov	r9, r12
	lea	r8, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR Reader$[rbp-185]
	call	?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z ; PhiveWrapper::ReadStringTable
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T5[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T5[rbp-161], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+4]
	lea	rdx, OFFSET FLAT:??_C@_04JKDOIEJJ@FST1@
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 307  : 	ReadStringTable(Reader, "FST1", mFieldStringTable);

	mov	r9, QWORD PTR this$GSCopy$1$[rbp-185]
	add	r9, 56					; 00000038H
	lea	r8, QWORD PTR $T5[rsp]
	lea	rdx, QWORD PTR Reader$[rbp-185]
	call	?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z ; PhiveWrapper::ReadStringTable
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T4[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rbp-161], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+4]
	lea	rdx, OFFSET FLAT:??_C@_04DIIAKOKC@TNA1@
	lea	rcx, QWORD PTR $T4[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 309  : 	Reader.Seek(FindSection(Reader, "TNA1"), BinaryVectorReader::Position::Begin);

	movaps	xmm0, XMMWORD PTR Reader$[rbp-185]
	movdqa	XMMWORD PTR $T10[rbp-185], xmm0
	lea	r8, QWORD PTR $T4[rsp]
	lea	rdx, QWORD PTR $T10[rbp-185]
	call	?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveWrapper::FindSection
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	lea	esi, DWORD PTR [rax+8]
	mov	DWORD PTR Reader$[rbp-177], esi
	movsxd	rcx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r13, QWORD PTR Reader$[rbp-185]
	mov	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	eax, BYTE PTR [rcx+rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 311  : 	uint8_t TypeCount = Reader.ReadUInt8() - 1;

	dec	al
	mov	BYTE PTR TypeCount$1$[rsp], al

; 312  : 	mTypes.resize(TypeCount);

	movzx	ebx, al
	mov	QWORD PTR _Newsize$1$[rbp-185], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r12, QWORD PTR [r14+8]
	mov	rdx, QWORD PTR [r14]
	mov	rcx, r12
	sub	rcx, rdx
	sar	rcx, 6

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rbx, rcx
	jae	SHORT $LN493@PhiveWrapp

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	mov	edi, ebx
	shl	rdi, 6
	add	rdi, rdx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rdi, r12
	je	SHORT $LN499@PhiveWrapp
	npad	5
$LL500@PhiveWrapp:
	lea	rcx, QWORD PTR [rbx+40]
	call	??1?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::~vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	cmp	rbx, r12
	jne	SHORT $LL500@PhiveWrapp
$LN499@PhiveWrapp:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [r14+8], rdi

; 1564 :             return;

	xor	edi, edi
	jmp	SHORT $LN494@PhiveWrapp
$LN493@PhiveWrapp:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN494@PhiveWrapp

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rdx
	sar	rax, 6

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	mov	rdx, rbx
	cmp	rbx, rax
	jbe	SHORT $LN495@PhiveWrapp

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN494@PhiveWrapp
$LN495@PhiveWrapp:

; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	r8, r14
	mov	rcx, r12
	call	??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
	mov	QWORD PTR [r14+8], rax
$LN494@PhiveWrapp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 313  : 	for (uint8_t i = 0; i < TypeCount; i++)

	cmp	BYTE PTR TypeCount$1$[rsp], 0
	jbe	$LN6@PhiveWrapp
	mov	r9, -3689348814741910323		; cccccccccccccccdH
	npad	8
$LL7@PhiveWrapp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	movsxd	rcx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	edx, BYTE PTR [rcx+rax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 315  : 		mTypes[i].mIndex = Reader.ReadUInt8();

	mov	BYTE PTR [rdi+rax+32], dl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	add	esi, 2
	mov	DWORD PTR Reader$[rbp-177], esi
	movsxd	rax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	ecx, BYTE PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 316  : 		mTypes[i].mTemplateCount = Reader.ReadUInt8();

	mov	BYTE PTR [rdi+rax+33], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 317  : 		mTypes[i].mTemplates.resize(mTypes[i].mTemplateCount);

	lea	r12, QWORD PTR [rdi+rax]
	movzx	edx, BYTE PTR [rdi+rax+33]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r15, QWORD PTR [r12+48]
	mov	r8, QWORD PTR [r12+40]
	mov	rcx, r15
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN207@PhiveWrapp

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*4]
	lea	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR _Newlast$1$[rbp-185], rax

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rax, r15
	je	SHORT $LN213@PhiveWrapp
$LL214@PhiveWrapp:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, r15
	jne	SHORT $LL214@PhiveWrapp
	mov	rax, QWORD PTR _Newlast$1$[rbp-185]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1564 :             return;

	jmp	SHORT $LN213@PhiveWrapp
$LN207@PhiveWrapp:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN208@PhiveWrapp

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r12+56]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN209@PhiveWrapp

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	lea	rcx, QWORD PTR [r12+40]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN208@PhiveWrapp
$LN209@PhiveWrapp:

; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	lea	r8, QWORD PTR [r12+40]
	mov	rcx, r15
	call	??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
$LN213@PhiveWrapp:

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	QWORD PTR [r12+48], rax
$LN208@PhiveWrapp:
	mov	rcx, QWORD PTR [r14]
	add	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 319  : 		mTypes[i].mName = mTypeStringTable[mTypes[i].mIndex];

	movzx	edx, BYTE PTR [rcx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdx, 5
	mov	r10, QWORD PTR $T17[rbp-185]
	add	rdx, QWORD PTR [r10]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN235@PhiveWrapp

; 3157 :             return *this;
; 3158 :         }
; 3159 : 
; 3160 :         auto& _Al             = _Getal();
; 3161 :         const auto& _Right_al = _Right._Getal();
; 3162 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3163 :             if (_Al != _Right_al) {
; 3164 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3165 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3166 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3167 : 
; 3168 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3169 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3170 :                     const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3171 :                     auto _Right_al_non_const = _Right_al;
; 3172 :                     const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity + 1); // throws
; 3173 : 
; 3174 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_size + 1);
; 3175 : 
; 3176 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3177 :                     _Tidy_deallocate();
; 3178 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3179 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3180 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3181 :                 } else {
; 3182 :                     _Copy_assign_val_from_small(_Right);
; 3183 :                 }
; 3184 : 
; 3185 :                 _Pocca(_Al, _Right_al);
; 3186 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3187 :                 return *this;
; 3188 :             }
; 3189 :         }
; 3190 : 
; 3191 :         _Pocca(_Al, _Right_al);
; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdx+24], 16
	jb	SHORT $LN239@PhiveWrapp

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN239@PhiveWrapp:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	r10, QWORD PTR $T17[rbp-185]
$LN235@PhiveWrapp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 321  : 		for (int8_t j = 0; j < mTypes[i].mTemplateCount; j++)

	xor	bl, bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 321  : 		for (int8_t j = 0; j < mTypes[i].mTemplateCount; j++)

	cmp	BYTE PTR [rdi+r9+33], bl
	jbe	$LN5@PhiveWrapp
	npad	9
$LL10@PhiveWrapp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	movsxd	rcx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	edx, BYTE PTR [rcx+rax+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 323  : 			mTypes[i].mTemplates[j].mIndex = Reader.ReadUInt8();

	movsx	rax, bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	r8, QWORD PTR [rcx*8]
	mov	rax, QWORD PTR [r9+rdi+40]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 323  : 			mTypes[i].mTemplates[j].mIndex = Reader.ReadUInt8();

	mov	BYTE PTR [r8+rax+32], dl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	add	esi, 2
	movsxd	rax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	ecx, BYTE PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14]
	mov	rax, QWORD PTR [rdi+rax+40]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 324  : 			mTypes[i].mTemplates[j].mValue = Reader.ReadUInt8();

	mov	BYTE PTR [r8+rax+33], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14]
	mov	rcx, QWORD PTR [rdi+rax+40]
	add	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 326  : 			mTypes[i].mTemplates[j].mName = mTypeStringTable[mTypes[i].mTemplates[j].mIndex];

	movzx	edx, BYTE PTR [rcx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdx, 5
	add	rdx, QWORD PTR [r10]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN8@PhiveWrapp

; 3157 :             return *this;
; 3158 :         }
; 3159 : 
; 3160 :         auto& _Al             = _Getal();
; 3161 :         const auto& _Right_al = _Right._Getal();
; 3162 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3163 :             if (_Al != _Right_al) {
; 3164 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3165 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3166 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3167 : 
; 3168 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3169 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3170 :                     const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3171 :                     auto _Right_al_non_const = _Right_al;
; 3172 :                     const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity + 1); // throws
; 3173 : 
; 3174 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_size + 1);
; 3175 : 
; 3176 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3177 :                     _Tidy_deallocate();
; 3178 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3179 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3180 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3181 :                 } else {
; 3182 :                     _Copy_assign_val_from_small(_Right);
; 3183 :                 }
; 3184 : 
; 3185 :                 _Pocca(_Al, _Right_al);
; 3186 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3187 :                 return *this;
; 3188 :             }
; 3189 :         }
; 3190 : 
; 3191 :         _Pocca(_Al, _Right_al);
; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdx+24], 16
	jb	SHORT $LN40@PhiveWrapp

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN40@PhiveWrapp:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	r10, QWORD PTR $T17[rbp-185]
$LN8@PhiveWrapp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 321  : 		for (int8_t j = 0; j < mTypes[i].mTemplateCount; j++)

	inc	bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 321  : 		for (int8_t j = 0; j < mTypes[i].mTemplateCount; j++)

	movzx	ecx, BYTE PTR [rdi+r9+33]
	movsx	eax, bl
	cmp	eax, ecx
	jl	$LL10@PhiveWrapp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	mov	DWORD PTR Reader$[rbp-177], esi
$LN5@PhiveWrapp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 313  : 	for (uint8_t i = 0; i < TypeCount; i++)

	add	rdi, 64					; 00000040H
	sub	QWORD PTR _Newsize$1$[rbp-185], 1
	mov	r9, -3689348814741910323		; cccccccccccccccdH
	jne	$LL7@PhiveWrapp
	mov	r15, QWORD PTR $T14[rbp-185]
$LN6@PhiveWrapp:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	esi, esi
	mov	QWORD PTR $T3[rsp+16], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rbp-161], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+4]
	lea	rdx, OFFSET FLAT:??_C@_04NMHLNHPB@TPTR@
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 330  : 	Reader.Seek(FindSection(Reader, "TPTR"), BinaryVectorReader::Position::Begin);

	movaps	xmm0, XMMWORD PTR Reader$[rbp-185]
	movdqa	XMMWORD PTR $T16[rbp-185], xmm0
	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR $T16[rbp-185]
	call	?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveWrapper::FindSection
	movsxd	rcx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	eax, DWORD PTR [rcx+3]
	mov	DWORD PTR Reader$[rbp-177], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13]
	lea	rdx, QWORD PTR [rcx+rax]
	lea	r8, QWORD PTR [rcx+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	ecx, BYTE PTR [r8+2]
	shl	ecx, 8
	movzx	eax, BYTE PTR [r8+1]
	or	ecx, eax
	shl	ecx, 8
	movzx	eax, BYTE PTR [rdx+3]
	shl	eax, 24
	or	ecx, eax
	movzx	eax, BYTE PTR [r8]
	or	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 19   : 	return std::make_pair(Input >> 30, _byteswap_ulong(Input) & 0x3FFFFFFF);

	bswap	ecx
	and	ecx, 1073741823				; 3fffffffH

; 331  : 	mTypePointerPaddingSize = ReadBitFieldFlagsSize(Reader.ReadUInt32()).second;

	mov	rdi, QWORD PTR this$GSCopy$1$[rbp-185]
	mov	WORD PTR [rdi+128], cx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rsp+16], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rbp-161], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+4]
	lea	rdx, OFFSET FLAT:??_C@_04KDPJLEDB@TYPE@
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 332  : 	Reader.Seek(FindSection(Reader, "TYPE"), BinaryVectorReader::Position::Begin);

	movaps	xmm0, XMMWORD PTR Reader$[rbp-185]
	movdqa	XMMWORD PTR $T15[rbp-185], xmm0
	lea	r8, QWORD PTR $T2[rsp]
	lea	rdx, QWORD PTR $T15[rbp-185]
	call	?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveWrapper::FindSection
	movsxd	rcx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	eax, DWORD PTR [rcx+3]
	mov	DWORD PTR Reader$[rbp-177], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13]
	lea	rdx, QWORD PTR [rcx+rax]
	lea	r9, QWORD PTR [rcx+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	ecx, BYTE PTR [r9+2]
	shl	ecx, 8
	movzx	eax, BYTE PTR [r9+1]
	or	ecx, eax
	shl	ecx, 8
	movzx	eax, BYTE PTR [rdx+3]
	shl	eax, 24
	or	ecx, eax
	movzx	eax, BYTE PTR [r9]
	or	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 333  : 	mTypeSize = Reader.ReadUInt32();

	mov	DWORD PTR [rdi+132], ecx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T1[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T1[rsp+16], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T1[rbp-161], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rsi+4]
	lea	rdx, OFFSET FLAT:??_C@_04PNNKJEI@PTCH@
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 338  : 	Reader.Seek(FindSection(Reader, "PTCH") + 8, BinaryVectorReader::Position::Begin);

	movaps	xmm0, XMMWORD PTR Reader$[rbp-185]
	movdqa	XMMWORD PTR $T18[rbp-185], xmm0
	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR $T18[rbp-185]
	call	?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveWrapper::FindSection
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	lea	ebx, DWORD PTR [rax+7]
	npad	7
$LL11@PhiveWrapp:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r11, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r9, ebx
	lea	eax, DWORD PTR [rbx+3]
	movsxd	rdx, eax
	lea	eax, DWORD PTR [rbx+2]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [rbx+1]
	movsxd	r8, eax
	movzx	r10d, BYTE PTR [rdx+r11]
	shl	r10d, 8
	movzx	eax, BYTE PTR [rcx+r11]
	or	r10d, eax
	shl	r10d, 8
	movzx	eax, BYTE PTR [r9+r11+4]
	shl	eax, 24
	or	r10d, eax
	movzx	eax, BYTE PTR [r8+r11]
	or	r10d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 342  : 		if (TypeIndex == 0)

	je	$LN636@PhiveWrapp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	edi, DWORD PTR [rbx+8]

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [r11+rax]
	lea	rdx, QWORD PTR [r11+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	ebx, BYTE PTR [r11+rax-1]
	shl	ebx, 8
	movzx	eax, BYTE PTR [r11+rax-2]
	or	ebx, eax
	shl	ebx, 8
	movzx	eax, BYTE PTR [rcx]
	shl	eax, 24
	or	ebx, eax
	movzx	eax, BYTE PTR [rdx-3]
	or	ebx, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Patch$19[rbp-177], xmm0
	mov	QWORD PTR Patch$19[rbp-161], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 348  : 		Patch.mTypeIndex = TypeIndex;

	mov	DWORD PTR Patch$19[rbp-185], r10d

; 349  : 		Patch.mCount = Count;

	mov	DWORD PTR Patch$19[rbp-181], ebx

; 350  : 		Patch.mOffsets.resize(Count);

	mov	edx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1567 :         if (_Newsize > _Oldsize) { // append

	je	SHORT $LN179@PhiveWrapp

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	lea	rcx, QWORD PTR Patch$19[rbp-177]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@IV?$allocator@I@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Resize_reallocate<std::_Value_init_tag>
$LN179@PhiveWrapp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 351  : 		Reader.ReadStruct(Patch.mOffsets.data(), sizeof(uint32_t) * Count);

	lea	ebx, DWORD PTR [rbx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 146  : 	std::memcpy(Dest, this->m_Bytes.data() + this->m_Offset + 1, Size);

	mov	r8d, ebx
	movsxd	rcx, edi
	mov	rdx, QWORD PTR [r13]
	inc	rdx
	add	rdx, rcx
	mov	rcx, QWORD PTR Patch$19[rbp-177]
	call	memcpy
	add	ebx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [r15+8]
	cmp	rdx, QWORD PTR [r15+16]
	je	SHORT $LN153@PhiveWrapp
	mov	eax, DWORD PTR Patch$19[rbp-185]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR Patch$19[rbp-181]
	mov	DWORD PTR [rdx+4], eax
	lea	rcx, QWORD PTR [rdx+8]
	lea	rdx, QWORD PTR Patch$19[rbp-177]
	call	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >

; 806  :         ++_Mylast;

	add	QWORD PTR [r15+8], 32			; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN152@PhiveWrapp
$LN153@PhiveWrapp:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Patch$19[rbp-185]
	mov	rcx, r15
	call	??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_reallocate<PhiveWrapper::PhiveWrapperPatch const &>
	npad	1
$LN152@PhiveWrapp:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Patch$19[rbp-177]
	test	rcx, rcx
	je	$LL11@PhiveWrapp

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Patch$19[rbp-161]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN143@PhiveWrapp

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN140@PhiveWrapp
$LN143@PhiveWrapp:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 354  : 	}

	jmp	$LL11@PhiveWrapp
$LN140@PhiveWrapp:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN636@PhiveWrapp:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR Bytes$GSCopy$1$[rbp-185]
	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN348@PhiveWrapp

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN366@PhiveWrapp

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN363@PhiveWrapp

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN366@PhiveWrapp:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx], rsi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rsi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rsi
$LN348@PhiveWrapp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 355  : }

	mov	rax, QWORD PTR this$GSCopy$1$[rbp-185]
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-185]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+304]
	movaps	xmm6, XMMWORD PTR [rsp+208]
	add	rsp, 224				; 000000e0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN363@PhiveWrapp:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN658@PhiveWrapp:
??0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z ENDP ; PhiveWrapper::PhiveWrapper
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
TypeCount$1$ = 32
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
_Newlast$1$ = 80
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 112
Bytes$GSCopy$1$ = 120
this$GSCopy$1$ = 128
_Newsize$1$ = 136
this$GSCopy$ = 144
Bytes$GSCopy$ = 152
$T18 = 160
Patch$19 = 160
Reader$ = 160
__$ArrayPad$ = 192
this$ = 288
Bytes$ = 296
EnablePatches$dead$ = 304
?dtor$0@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA PROC ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$0
	mov	rcx, QWORD PTR Bytes$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA ENDP ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
TypeCount$1$ = 32
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
_Newlast$1$ = 80
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 112
Bytes$GSCopy$1$ = 120
this$GSCopy$1$ = 128
_Newsize$1$ = 136
this$GSCopy$ = 144
Bytes$GSCopy$ = 152
$T18 = 160
Patch$19 = 160
Reader$ = 160
__$ArrayPad$ = 192
this$ = 288
Bytes$ = 296
EnablePatches$dead$ = 304
?dtor$1@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA PROC ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 8
	jmp	??1?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::~vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >
?dtor$1@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA ENDP ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
TypeCount$1$ = 32
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
_Newlast$1$ = 80
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 112
Bytes$GSCopy$1$ = 120
this$GSCopy$1$ = 128
_Newsize$1$ = 136
this$GSCopy$ = 144
Bytes$GSCopy$ = 152
$T18 = 160
Patch$19 = 160
Reader$ = 160
__$ArrayPad$ = 192
this$ = 288
Bytes$ = 296
EnablePatches$dead$ = 304
?dtor$2@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA PROC ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$2@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA ENDP ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
TypeCount$1$ = 32
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
_Newlast$1$ = 80
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 112
Bytes$GSCopy$1$ = 120
this$GSCopy$1$ = 128
_Newsize$1$ = 136
this$GSCopy$ = 144
Bytes$GSCopy$ = 152
$T18 = 160
Patch$19 = 160
Reader$ = 160
__$ArrayPad$ = 192
this$ = 288
Bytes$ = 296
EnablePatches$dead$ = 304
?dtor$3@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA PROC ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$3
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 56					; 00000038H
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$3@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA ENDP ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
TypeCount$1$ = 32
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
_Newlast$1$ = 80
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 112
Bytes$GSCopy$1$ = 120
this$GSCopy$1$ = 128
_Newsize$1$ = 136
this$GSCopy$ = 144
Bytes$GSCopy$ = 152
$T18 = 160
Patch$19 = 160
Reader$ = 160
__$ArrayPad$ = 192
this$ = 288
Bytes$ = 296
EnablePatches$dead$ = 304
?dtor$4@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA PROC ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$4
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 80					; 00000050H
	jmp	??1?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::~vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
?dtor$4@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA ENDP ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
TypeCount$1$ = 32
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
_Newlast$1$ = 80
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 112
Bytes$GSCopy$1$ = 120
this$GSCopy$1$ = 128
_Newsize$1$ = 136
this$GSCopy$ = 144
Bytes$GSCopy$ = 152
$T18 = 160
Patch$19 = 160
Reader$ = 160
__$ArrayPad$ = 192
this$ = 288
Bytes$ = 296
EnablePatches$dead$ = 304
?dtor$5@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA PROC ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$5
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 104				; 00000068H
	jmp	??1?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::~vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >
?dtor$5@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA ENDP ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
TypeCount$1$ = 32
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
_Newlast$1$ = 80
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 112
Bytes$GSCopy$1$ = 120
this$GSCopy$1$ = 128
_Newsize$1$ = 136
this$GSCopy$ = 144
Bytes$GSCopy$ = 152
$T18 = 160
Patch$19 = 160
Reader$ = 160
__$ArrayPad$ = 192
this$ = 288
Bytes$ = 296
EnablePatches$dead$ = 304
?dtor$6@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA PROC ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$6
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 136				; 00000088H
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$6@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA ENDP ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
TypeCount$1$ = 32
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
_Newlast$1$ = 80
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 112
Bytes$GSCopy$1$ = 120
this$GSCopy$1$ = 128
_Newsize$1$ = 136
this$GSCopy$ = 144
Bytes$GSCopy$ = 152
$T18 = 160
Patch$19 = 160
Reader$ = 160
__$ArrayPad$ = 192
this$ = 288
Bytes$ = 296
EnablePatches$dead$ = 304
?dtor$7@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA PROC ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$7
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 160				; 000000a0H
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$7@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA ENDP ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
TypeCount$1$ = 32
$T1 = 40
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
_Newlast$1$ = 80
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 112
Bytes$GSCopy$1$ = 120
this$GSCopy$1$ = 128
_Newsize$1$ = 136
this$GSCopy$ = 144
Bytes$GSCopy$ = 152
$T18 = 160
Patch$19 = 160
Reader$ = 160
__$ArrayPad$ = 192
this$ = 288
Bytes$ = 296
EnablePatches$dead$ = 304
?dtor$17@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA PROC ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$17
	lea	rcx, QWORD PTR Patch$19[rdx]
	jmp	??1PhiveWrapperPatch@PhiveWrapper@@QEAA@XZ
?dtor$17@?0???0PhiveWrapper@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@_N@Z@4HA ENDP ; `PhiveWrapper::PhiveWrapper'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
;	COMDAT ?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
Section$GSCopy$ = 32
__$ArrayPad$ = 40
this$dead$ = 64
Reader$ = 72
Section$ = 80
?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; PhiveWrapper::FindSection, COMDAT

; 7    : {

$LN91:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r11, rdx

; 6    : uint32_t PhiveWrapper::FindSection(BinaryVectorReader Reader, std::string Section)

	mov	QWORD PTR Section$GSCopy$[rsp], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	ebx, -1
	mov	DWORD PTR [rdx+8], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 9    : 	char Data[4] = { 0 };

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2267 :         if (_Mysize <= _Off) {

	mov	r10, QWORD PTR [r8+16]
	test	r10, r10
	je	$LN81@FindSectio

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [r8+24]
	npad	8
$LL2@FindSectio:

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rcx, r8

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN86@FindSectio

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r8]
$LN86@FindSectio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 10   : 	while (!(Data[0] == Section.at(0) && Data[1] == Section.at(1) && Data[2] == Section.at(2) && Data[3] == Section.at(3)))

	cmp	al, BYTE PTR [rcx]
	jne	SHORT $LN4@FindSectio
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2267 :         if (_Mysize <= _Off) {

	cmp	r10, 1
	jbe	$LN81@FindSectio

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, r8

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN85@FindSectio

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r8]
$LN85@FindSectio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 10   : 	while (!(Data[0] == Section.at(0) && Data[1] == Section.at(1) && Data[2] == Section.at(2) && Data[3] == Section.at(3)))

	mov	ecx, eax
	shr	ecx, 8
	cmp	cl, BYTE PTR [r9+1]
	jne	SHORT $LN4@FindSectio
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2267 :         if (_Mysize <= _Off) {

	cmp	r10, 2
	jbe	SHORT $LN81@FindSectio

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r9, r8

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN87@FindSectio

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r8]
$LN87@FindSectio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 10   : 	while (!(Data[0] == Section.at(0) && Data[1] == Section.at(1) && Data[2] == Section.at(2) && Data[3] == Section.at(3)))

	mov	ecx, eax
	shr	ecx, 16
	cmp	cl, BYTE PTR [r9+2]
	jne	SHORT $LN4@FindSectio
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2267 :         if (_Mysize <= _Off) {

	cmp	r10, 3
	jbe	SHORT $LN81@FindSectio

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rcx, r8

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN56@FindSectio

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r8]
$LN56@FindSectio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 10   : 	while (!(Data[0] == Section.at(0) && Data[1] == Section.at(1) && Data[2] == Section.at(2) && Data[3] == Section.at(3)))

	shr	eax, 24
	cmp	al, BYTE PTR [rcx+3]
	je	SHORT $LN3@FindSectio
$LN4@FindSectio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 146  : 	std::memcpy(Dest, this->m_Bytes.data() + this->m_Offset + 1, Size);

	mov	rax, QWORD PTR [r11]
	movsxd	rcx, ebx
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+rcx+1]

; 147  : 
; 148  : 	//std::memcopy(this->m_Bytes.begin() + this->m_Offset + 1, this->m_Bytes.begin() + this->m_Offset + 1 + Size, static_cast<char*>(Dest));
; 149  : 
; 150  : 	this->m_Offset += Size;

	add	ebx, 4
	mov	DWORD PTR [r11+8], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2267 :         if (_Mysize <= _Off) {

	jmp	SHORT $LL2@FindSectio
$LN3@FindSectio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 14   : 	return Reader.GetPosition() - 8; //-8 = Flags(1) - Size(3) - Magic(4)

	add	ebx, -7					; fffffff9H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, r8
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 14   : 	return Reader.GetPosition() - 8; //-8 = Flags(1) - Size(3) - Magic(4)

	mov	eax, ebx

; 15   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN81@FindSectio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2268 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	npad	1
$LN88@FindSectio:
?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; PhiveWrapper::FindSection
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Section$GSCopy$ = 32
__$ArrayPad$ = 40
this$dead$ = 64
Reader$ = 72
Section$ = 80
?dtor$0@?0??FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `PhiveWrapper::FindSection'::`1'::dtor$0
	mov	rcx, QWORD PTR Section$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `PhiveWrapper::FindSection'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
;	COMDAT ?ReadBitFieldFlagsSize@PhiveWrapper@@QEAA?AU?$pair@EI@std@@I@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
Input$ = 24
?ReadBitFieldFlagsSize@PhiveWrapper@@QEAA?AU?$pair@EI@std@@I@Z PROC ; PhiveWrapper::ReadBitFieldFlagsSize, COMDAT

; 19   : 	return std::make_pair(Input >> 30, _byteswap_ulong(Input) & 0x3FFFFFFF);

	mov	eax, r8d
	shr	eax, 30
	bswap	r8d
	and	r8d, 1073741823				; 3fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 270  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

	mov	BYTE PTR [rdx], al
	mov	DWORD PTR [rdx+4], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 19   : 	return std::make_pair(Input >> 30, _byteswap_ulong(Input) & 0x3FFFFFFF);

	mov	rax, rdx

; 20   : }

	ret	0
?ReadBitFieldFlagsSize@PhiveWrapper@@QEAA?AU?$pair@EI@std@@I@Z ENDP ; PhiveWrapper::ReadBitFieldFlagsSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
;	COMDAT ?WriteBitFieldFlagsSize@PhiveWrapper@@QEAAIEI@Z
_TEXT	SEGMENT
this$dead$ = 8
Flags$ = 16
Size$ = 24
?WriteBitFieldFlagsSize@PhiveWrapper@@QEAAIEI@Z PROC	; PhiveWrapper::WriteBitFieldFlagsSize, COMDAT

; 24   : 	Size &= 0x3FFFFFFF;
; 25   : 
; 26   : 	uint32_t Combined = (static_cast<uint32_t>(Flags) << 30) | Size;

	movzx	eax, dl
	and	r8d, 1073741823				; 3fffffffH
	shl	eax, 30
	or	eax, r8d

; 27   : 	return _byteswap_ulong(Combined);

	bswap	eax

; 28   : }

	ret	0
?WriteBitFieldFlagsSize@PhiveWrapper@@QEAAIEI@Z ENDP	; PhiveWrapper::WriteBitFieldFlagsSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
;	COMDAT ?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z
_TEXT	SEGMENT
SectionMagic$GSCopy$ = 32
__$ArrayPad$ = 40
this$dead$ = 96
Writer$ = 104
SectionMagic$ = 112
StringTable$ = 120
?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z PROC ; PhiveWrapper::WriteStringTable, COMDAT

; 31   : {

$LN99:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r9
	mov	r14, r8
	mov	rbx, rdx

; 28   : }
; 29   : 
; 30   : void PhiveWrapper::WriteStringTable(BinaryVectorWriter& Writer, std::string SectionMagic, std::vector<std::string>& StringTable)

	mov	QWORD PTR SectionMagic$GSCopy$[rsp], r8

; 32   : 	uint32_t Jumpback = Writer.GetPosition();

	movsxd	rbp, DWORD PTR [rdx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rdx+8]
	sub	rdx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	lea	eax, DWORD PTR [rbp+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN71@WriteStrin

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [rbp+5]
	movsxd	rdx, eax
	mov	rcx, rbx
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN71@WriteStrin:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	DWORD PTR [rbx+24], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r14+24], 16
	jb	SHORT $LN83@WriteStrin

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [r14]
$LN83@WriteStrin:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 34   : 	Writer.WriteBytes(SectionMagic.c_str());

	mov	rcx, rbx
	call	?WriteBytes@BinaryVectorWriter@@QEAAXPEBD@Z ; BinaryVectorWriter::WriteBytes

; 35   : 	for (const std::string& Buf : StringTable)

	mov	rsi, QWORD PTR [rdi+8]

; 34   : 	Writer.WriteBytes(SectionMagic.c_str());

	mov	rdi, QWORD PTR [rdi]

; 35   : 	for (const std::string& Buf : StringTable)

	cmp	rdi, rsi
	je	SHORT $LN96@WriteStrin
$LL4@WriteStrin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN10@WriteStrin

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN10@WriteStrin:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 37   : 		Writer.WriteBytes(Buf.c_str());

	mov	rcx, rbx
	call	?WriteBytes@BinaryVectorWriter@@QEAAXPEBD@Z ; BinaryVectorWriter::WriteBytes
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+8]
	sub	rdx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	mov	rcx, rbx
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	inc	DWORD PTR [rbx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 35   : 	for (const std::string& Buf : StringTable)

	add	rdi, 32					; 00000020H
	cmp	rdi, rsi
	jne	SHORT $LL4@WriteStrin
$LN96@WriteStrin:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 108  : 	while (GetPosition() % Alignment != 0)

	mov	edi, DWORD PTR [rbx+24]
	test	dil, 3
	je	SHORT $LN22@WriteStrin
	npad	9
$LL21@WriteStrin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+8]
	sub	rdx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	mov	rcx, rbx
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR [rbx+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 255			; 000000ffH

; 14   : 	this->m_Offset++;

	mov	edi, DWORD PTR [rbx+24]
	inc	edi
	mov	DWORD PTR [rbx+24], edi

; 108  : 	while (GetPosition() % Alignment != 0)

	test	dil, 3
	jne	SHORT $LL21@WriteStrin
$LN22@WriteStrin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+8]
	sub	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	cmp	rbp, rcx
	jbe	SHORT $LN33@WriteStrin

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbp+1]
	movsxd	rdx, eax
	mov	rcx, rbx
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN33@WriteStrin:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR [rbx+24], ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 43   : 	Writer.WriteInteger(WriteBitFieldFlagsSize(0x01, End - Jumpback), sizeof(uint32_t));

	mov	edx, edi
	sub	edx, ebp

; 24   : 	Size &= 0x3FFFFFFF;

	and	edx, 1073741823				; 3fffffffH

; 25   : 
; 26   : 	uint32_t Combined = (static_cast<uint32_t>(Flags) << 30) | Size;

	bts	edx, 30

; 27   : 	return _byteswap_ulong(Combined);

	bswap	edx

; 43   : 	Writer.WriteInteger(WriteBitFieldFlagsSize(0x01, End - Jumpback), sizeof(uint32_t));

	mov	edx, edx
	mov	r8d, 4
	mov	rcx, rbx
	call	?WriteInteger@BinaryVectorWriter@@QEAAX_JH@Z ; BinaryVectorWriter::WriteInteger
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+8]
	sub	rdx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, edi
	cmp	rax, rdx
	jbe	SHORT $LN50@WriteStrin

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rdi+1]
	movsxd	rdx, eax
	mov	rcx, rbx
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN50@WriteStrin:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR [rbx+24], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, r14
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 45   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z ENDP ; PhiveWrapper::WriteStringTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
SectionMagic$GSCopy$ = 32
__$ArrayPad$ = 40
this$dead$ = 96
Writer$ = 104
SectionMagic$ = 112
StringTable$ = 120
?dtor$0@?0??WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z@4HA PROC ; `PhiveWrapper::WriteStringTable'::`1'::dtor$0
	mov	rcx, QWORD PTR SectionMagic$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??WriteStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorWriter@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z@4HA ENDP ; `PhiveWrapper::WriteStringTable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
;	COMDAT ?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z
_TEXT	SEGMENT
i$1$ = 32
Size$1$ = 48
$T1 = 48
Reader$GSCopy$1$ = 64
SectionMagic$GSCopy$1$ = 72
$T2 = 80
SectionMagic$GSCopy$ = 112
Buffer$ = 120
__$ArrayPad$ = 152
this$dead$ = 224
Reader$ = 232
SectionMagic$ = 240
StringTable$ = 248
?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z PROC ; PhiveWrapper::ReadStringTable, COMDAT

; 48   : {

$LN206:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-121], rax
	mov	r15, r9
	mov	r13, r8
	mov	QWORD PTR SectionMagic$GSCopy$1$[rbp-121], r8
	mov	rbx, rdx
	mov	QWORD PTR Reader$GSCopy$1$[rbp-121], rdx

; 20   : }
; 21   : 
; 22   : uint32_t PhiveWrapper::WriteBitFieldFlagsSize(uint8_t Flags, uint32_t Size)
; 23   : {
; 24   : 	Size &= 0x3FFFFFFF;
; 25   : 
; 26   : 	uint32_t Combined = (static_cast<uint32_t>(Flags) << 30) | Size;
; 27   : 	return _byteswap_ulong(Combined);
; 28   : }
; 29   : 
; 30   : void PhiveWrapper::WriteStringTable(BinaryVectorWriter& Writer, std::string SectionMagic, std::vector<std::string>& StringTable)
; 31   : {
; 32   : 	uint32_t Jumpback = Writer.GetPosition();
; 33   : 	Writer.Seek(4, BinaryVectorWriter::Position::Current);
; 34   : 	Writer.WriteBytes(SectionMagic.c_str());
; 35   : 	for (const std::string& Buf : StringTable)
; 36   : 	{
; 37   : 		Writer.WriteBytes(Buf.c_str());
; 38   : 		Writer.WriteByte(0x00);
; 39   : 	}
; 40   : 	Writer.Align(4, 0xFF);
; 41   : 	uint32_t End = Writer.GetPosition();
; 42   : 	Writer.Seek(Jumpback, BinaryVectorWriter::Position::Begin);
; 43   : 	Writer.WriteInteger(WriteBitFieldFlagsSize(0x01, End - Jumpback), sizeof(uint32_t));
; 44   : 	Writer.Seek(End, BinaryVectorWriter::Position::Begin);
; 45   : }
; 46   : 
; 47   : void PhiveWrapper::ReadStringTable(BinaryVectorReader& Reader, std::string SectionMagic, std::vector<std::string>& StringTable)

	mov	QWORD PTR SectionMagic$GSCopy$[rbp-121], r8

; 49   : 	Reader.Seek(FindSection(Reader, SectionMagic), BinaryVectorReader::Position::Begin);

	mov	rdx, r8
	lea	rcx, QWORD PTR $T2[rbp-121]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	movups	xmm0, XMMWORD PTR [rbx]
	movaps	XMMWORD PTR $T1[rbp-121], xmm0
	mov	r8, rax
	lea	rdx, QWORD PTR $T1[rbp-121]
	call	?FindSection@PhiveWrapper@@QEAAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; PhiveWrapper::FindSection
	movsxd	r10, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	lea	ecx, DWORD PTR [r10+3]

; 76   : 	this->m_Offset += 4;

	mov	DWORD PTR [rbx+8], ecx
	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	ecx, DWORD PTR [r10+1]
	movsxd	rdx, ecx

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	r12d, BYTE PTR [r8+r10+2]
	shl	r12d, 8
	movzx	eax, BYTE PTR [rdx+r8]
	or	r12d, eax
	shl	r12d, 8
	movzx	eax, BYTE PTR [r10+r8+3]
	shl	eax, 24
	or	r12d, eax
	movzx	eax, BYTE PTR [r8+r10]
	or	r12d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 19   : 	return std::make_pair(Input >> 30, _byteswap_ulong(Input) & 0x3FFFFFFF);

	bswap	r12d
	and	r12d, 1073741823			; 3fffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 16   : 		this->m_Offset += Offset;

	lea	eax, DWORD PTR [r10+7]
	mov	DWORD PTR [rbx+8], eax
	add	r12d, -8				; fffffff8H
	mov	DWORD PTR Size$1$[rbp-121], r12d
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Buffer$[rbp-121], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	edi, edi
	mov	QWORD PTR Buffer$[rbp-105], rdi

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	r14d, 15
	mov	QWORD PTR Buffer$[rbp-97], r14

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Buffer$[rbp-121], dil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 56   : 	for (uint32_t i = 0; i < Size; i++)

	xor	esi, esi
	mov	DWORD PTR i$1$[rbp-121], esi
	test	r12d, r12d
	je	$LN200@ReadString
	mov	rdx, 9223372036854775807		; 7fffffffffffffffH
	lea	r8d, QWORD PTR [rdi+22]
	lea	r10, QWORD PTR [rdi-1]
	npad	13
$LL4@ReadString:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	movsxd	rcx, DWORD PTR [rbx+8]
	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rbx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbx]

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 58   : 		char Character = Reader.ReadUInt8();

	movzx	r9d, BYTE PTR [rcx+rax+1]

; 59   : 		if (Character == 0xFF)
; 60   : 			continue;
; 61   : 
; 62   : 		if (Character == 0x00)

	test	r9b, r9b
	jne	$LN6@ReadString
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rbx, QWORD PTR [r15+8]
	cmp	rbx, QWORD PTR [r15+16]
	je	$LN75@ReadString
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], 0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], 0

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r12, QWORD PTR Buffer$[rbp-121]

; 2236 :         if (_Large_string_engaged()) {

	mov	r13, QWORD PTR Buffer$[rbp-121]
	cmp	r14, 16
	cmovae	r12, r13

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, rdx
	ja	$LN183@ReadString

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rbx+24], 15
	cmp	rdi, 16
	jae	SHORT $LN100@ReadString

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR [rbx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [r15+8], 32			; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	r12d, DWORD PTR Size$1$[rbp-121]
	jmp	SHORT $LN74@ReadString
$LN100@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rsi, rdi
	or	rsi, 15
	cmp	rsi, rdx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN111@ReadString

; 4716 :             return _Max;

	mov	rsi, rdx
	jmp	SHORT $LN110@ReadString
$LN111@ReadString:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rsi, 22
	cmovb	rsi, r8
$LN110@ReadString:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rsi
	add	rdx, 1
	cmovb	rdx, r10
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rbx], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rsi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
	mov	esi, DWORD PTR i$1$[rbp-121]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [r15+8], 32			; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	r12d, DWORD PTR Size$1$[rbp-121]
	jmp	SHORT $LN74@ReadString
$LN75@ReadString:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Buffer$[rbp-121]
	mov	rdx, rbx
	mov	rcx, r15
	call	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	mov	r14, QWORD PTR Buffer$[rbp-97]
	mov	r13, QWORD PTR Buffer$[rbp-121]
$LN74@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Buffer$[rbp-121]

; 2227 :         if (_Large_string_engaged()) {

	cmp	r14, 16
	cmovae	rax, r13

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR Buffer$[rbp-105], 0
	mov	BYTE PTR [rax], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 66   : 			continue;

	mov	rbx, QWORD PTR Reader$GSCopy$1$[rbp-121]
	jmp	SHORT $LN203@ReadString
$LN6@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	cmp	rdi, r14

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN141@ReadString

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rdi+1]
	mov	QWORD PTR Buffer$[rbp-105], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Buffer$[rbp-121]

; 2227 :         if (_Large_string_engaged()) {

	cmp	r14, 16
	cmovae	rax, QWORD PTR Buffer$[rbp-121]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rdi], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rdi+1], 0

; 4053 :             return;

	jmp	SHORT $LN2@ReadString
$LN141@ReadString:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR Buffer$[rbp-121]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN203@ReadString:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 56   : 	for (uint32_t i = 0; i < Size; i++)

	mov	r10, -1
	lea	r8d, QWORD PTR [r10+23]
	mov	rdx, 9223372036854775807		; 7fffffffffffffffH
$LN2@ReadString:
	inc	esi
	mov	DWORD PTR i$1$[rbp-121], esi
	mov	r14, QWORD PTR Buffer$[rbp-97]
	cmp	esi, r12d
	jae	SHORT $LN201@ReadString
	mov	rdi, QWORD PTR Buffer$[rbp-105]
	jmp	$LL4@ReadString
$LN201@ReadString:
	mov	r13, QWORD PTR SectionMagic$GSCopy$1$[rbp-121]
$LN200@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	r14, 16
	jb	SHORT $LN160@ReadString

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [r14+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR Buffer$[rbp-121]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN172@ReadString

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN172@ReadString
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN172@ReadString:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN160@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, r13
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp

; 71   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-121]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+224]
	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN183@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN202@ReadString:
?ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z ENDP ; PhiveWrapper::ReadStringTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
Size$1$ = 48
$T1 = 48
Reader$GSCopy$1$ = 64
SectionMagic$GSCopy$1$ = 72
$T2 = 80
SectionMagic$GSCopy$ = 112
Buffer$ = 120
__$ArrayPad$ = 152
this$dead$ = 224
Reader$ = 232
SectionMagic$ = 240
StringTable$ = 248
?dtor$0@?0??ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z@4HA PROC ; `PhiveWrapper::ReadStringTable'::`1'::dtor$0
	mov	rcx, QWORD PTR SectionMagic$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z@4HA ENDP ; `PhiveWrapper::ReadStringTable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
Size$1$ = 48
$T1 = 48
Reader$GSCopy$1$ = 64
SectionMagic$GSCopy$1$ = 72
$T2 = 80
SectionMagic$GSCopy$ = 112
Buffer$ = 120
__$ArrayPad$ = 152
this$dead$ = 224
Reader$ = 232
SectionMagic$ = 240
StringTable$ = 248
?dtor$2@?0??ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z@4HA PROC ; `PhiveWrapper::ReadStringTable'::`1'::dtor$2
	lea	rcx, QWORD PTR Buffer$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??ReadStringTable@PhiveWrapper@@QEAAXAEAVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@4@@Z@4HA ENDP ; `PhiveWrapper::ReadStringTable'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PhiveWrapper.cpp
;	COMDAT ??R<lambda_1>@?1??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@QEBA@II@Z
_TEXT	SEGMENT
this$dead$ = 8
NumToRound$ = 16
Multiple$dead$ = 24
??R<lambda_1>@?1??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@QEBA@II@Z PROC ; `PhiveWrapper::ToBinary'::`2'::<lambda_1>::operator(), COMDAT

; 116  : 			if (Multiple == 0)
; 117  : 				return NumToRound;
; 118  : 
; 119  : 			uint32_t Remainder = NumToRound % Multiple;

	mov	eax, edx
	and	eax, 15

; 120  : 			if (Remainder == 0)

	jne	SHORT $LN3@operator

; 121  : 				return NumToRound;

	mov	eax, edx

; 124  : 		};

	ret	0
$LN3@operator:

; 122  : 
; 123  : 			return NumToRound + Multiple - Remainder;

	sub	edx, eax
	lea	eax, DWORD PTR [rdx+16]

; 124  : 		};

	ret	0
??R<lambda_1>@?1??ToBinary@PhiveWrapper@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@QEBA@II@Z ENDP ; `PhiveWrapper::ToBinary'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0PhiveWrapperPatch@PhiveWrapper@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0PhiveWrapperPatch@PhiveWrapper@@QEAA@XZ PROC		; PhiveWrapper::PhiveWrapperPatch::PhiveWrapperPatch, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0PhiveWrapperPatch@PhiveWrapper@@QEAA@XZ ENDP		; PhiveWrapper::PhiveWrapperPatch::PhiveWrapperPatch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperPatch@PhiveWrapper@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperPatch@PhiveWrapper@@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperPatch@PhiveWrapper@@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperPatch@PhiveWrapper@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperPatch@PhiveWrapper@@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperPatch@PhiveWrapper@@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?push_back@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAXAEBUPhiveWrapperPatch@PhiveWrapper@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAXAEBUPhiveWrapperPatch@PhiveWrapper@@@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::push_back, COMDAT

; 872  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rcx, QWORD PTR [rcx+8]
	cmp	rcx, QWORD PTR [rbx+16]
	je	SHORT $LN4@push_back
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	add	rdx, 8
	mov	DWORD PTR [rcx+4], eax
	add	rcx, 8
	call	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >

; 806  :         ++_Mylast;

	add	QWORD PTR [rbx+8], 32			; 00000020H

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@push_back:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rbx

; 873  :         _Emplace_one_at_back(_Val);
; 874  :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_reallocate<PhiveWrapper::PhiveWrapperPatch const &>
?push_back@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@QEAAXAEBUPhiveWrapperPatch@PhiveWrapper@@@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN36:
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx
	mov	rdi, rdx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, rdx
	sar	rcx, 6

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdi, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rdi, 6
	add	rdi, rdx
	mov	QWORD PTR [rsp+48], rbx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rsi
	je	SHORT $LN10@resize
$LL11@resize:
	lea	rcx, QWORD PTR [rbx+40]
	call	??1?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::~vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	cmp	rbx, rsi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rdi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rdx
	sar	rax, 6

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdi, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rdi
	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdi, rcx
	mov	r8, r14
	mov	rdx, rdi
	mov	rcx, rsi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?data@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@XZ
_TEXT	SEGMENT
this$ = 8
?data@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::data, COMDAT

; 1787 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx]

; 1788 :     }

	ret	0
?data@?$vector@UPhiveWrapperItem@PhiveWrapper@@V?$allocator@UPhiveWrapperItem@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperItem@PhiveWrapper@@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperItem,std::allocator<PhiveWrapper::PhiveWrapperItem> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAAEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAAEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*4]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAAEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Unchecked_end, COMDAT

; 1855 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1856 :     }

	ret	0
?_Unchecked_end@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Unchecked_begin, COMDAT

; 1847 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1848 :     }

	ret	0
?_Unchecked_begin@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN36:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rsi, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, -3689348814741910323		; cccccccccccccccdH
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+48], rbx

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*4]
	mov	QWORD PTR [rsp+56], rbp
	lea	rbp, QWORD PTR [r8+rax*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rdi
	je	SHORT $LN10@resize
	npad	5
$LL11@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rsi+8], rbp
	mov	rbp, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	r8, rsi
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
	mov	QWORD PTR [rsi+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_one_at_back@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_one_at_back<PhiveWrapper::PhiveWrapperPatch const &>, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rcx, QWORD PTR [rcx+8]
	cmp	rcx, QWORD PTR [rbx+16]
	je	SHORT $LN2@Emplace_on
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	add	rdx, 8
	mov	DWORD PTR [rcx+4], eax
	add	rcx, 8
	call	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+32]
	mov	QWORD PTR [rbx+8], rcx

; 786  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rbx

; 786  :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_reallocate<PhiveWrapper::PhiveWrapperPatch const &>
??$_Emplace_one_at_back@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_one_at_back<PhiveWrapper::PhiveWrapperPatch const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN34:
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	rdi, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, rdx
	sar	rcx, 6

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdi, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rdi, 6
	add	rdi, rdx
	mov	QWORD PTR [rsp+48], rbx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rsi
	je	SHORT $LN8@Resize
$LL9@Resize:
	lea	rcx, QWORD PTR [rbx+40]
	call	??1?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::~vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	cmp	rbx, rsi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rdi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, rdx
	sar	rax, 6

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdi, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rdi
	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdi, rcx
	mov	r8, r14
	mov	rdx, rdi
	mov	rcx, rsi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Unfancy_maybe_null@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@Z PROC ; std::_Unfancy_maybe_null<PhiveWrapper::PhiveWrapperItem>, COMDAT

; 434  :     return _Ptr;

	mov	rax, rcx

; 435  : }

	ret	0
??$_Unfancy_maybe_null@UPhiveWrapperItem@PhiveWrapper@@@std@@YAPEAUPhiveWrapperItem@PhiveWrapper@@PEAU12@@Z ENDP ; std::_Unfancy_maybe_null<PhiveWrapper::PhiveWrapperItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN34:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rsi, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, -3689348814741910323		; cccccccccccccccdH
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+48], rbx

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+rdx*4]
	mov	QWORD PTR [rsp+56], rbp
	lea	rbp, QWORD PTR [r8+rax*8]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rdi
	je	SHORT $LN8@Resize
	npad	5
$LL9@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rsi+8], rbp
	mov	rbp, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rsi+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rsi

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	r8, rsi
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
	mov	QWORD PTR [rsi+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperNamedType@PhiveWrapper@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperNamedType@PhiveWrapper@@0@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperNamedType@PhiveWrapper@@0@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@0@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBAXPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@0@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBUPhiveWrapperPatch@PhiveWrapper@@@std@@YAAEBUPhiveWrapperPatch@PhiveWrapper@@AEBU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUPhiveWrapperPatch@PhiveWrapper@@@std@@YAAEBUPhiveWrapperPatch@PhiveWrapper@@AEBU12@@Z PROC ; std::forward<PhiveWrapper::PhiveWrapperPatch const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBUPhiveWrapperPatch@PhiveWrapper@@@std@@YAAEBUPhiveWrapperPatch@PhiveWrapper@@AEBU12@@Z ENDP ; std::forward<PhiveWrapper::PhiveWrapperPatch const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_back_with_unused_capacity@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_back_with_unused_capacity<PhiveWrapper::PhiveWrapperPatch const &>, COMDAT

; 789  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	eax, DWORD PTR [rdx]
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	add	rdx, 8
	mov	DWORD PTR [rcx+4], eax
	add	rcx, 8
	call	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rbx+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+32]
	mov	QWORD PTR [rbx+8], rdx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Emplace_back_with_unused_capacity@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAAEAUPhiveWrapperPatch@PhiveWrapper@@AEBU23@@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_back_with_unused_capacity<PhiveWrapper::PhiveWrapperPatch const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_reallocate<PhiveWrapper::PhiveWrapperPatch const &>, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN29:
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r12, rdx
	mov	rdi, rcx

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rdx, QWORD PTR [rcx]
	mov	r14, r12
	sub	r14, rdx

; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, rdx
	sar	rax, 5

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	rbx, 576460752303423487			; 07ffffffffffffffH
	cmp	rax, rbx
	je	$LN28@Emplace_re

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r15, QWORD PTR [rax+1]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	sar	rcx, 5

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN25@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, r15
	cmovb	rbx, r15
$LN25@Emplace_re:

; 829  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 830  : 
; 831  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	call	?allocate@?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperPatch@PhiveWrapper@@_K@Z ; std::allocator<PhiveWrapper::PhiveWrapperPatch>::allocate
	mov	rsi, rax
	mov	QWORD PTR _Newvec$[rsp], rax

; 832  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	and	r14, -32				; ffffffffffffffe0H
	add	r14, rax
	lea	r13, QWORD PTR [r14+32]
	mov	QWORD PTR _Constructed_last$[rsp], r13

; 833  :         pointer _Constructed_first      = _Constructed_last;

	mov	QWORD PTR _Constructed_first$[rsp], r13
	mov	rdx, QWORD PTR <_Val_0>$[rsp]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r14], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [r14+4], eax
	lea	rcx, QWORD PTR [r14+8]
	add	rdx, 8
	call	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >

; 834  : 
; 835  :         _TRY_BEGIN
; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);
; 837  :         _Constructed_first = _Newvec + _Whereoff;

	mov	QWORD PTR _Constructed_first$[rsp], r14

; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rdi]
	mov	r8, rsi
	cmp	r12, rdx
	je	SHORT $LN26@Emplace_re

; 840  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 841  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 842  :             } else {
; 843  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 844  :             }
; 845  :         } else { // provide basic guarantee
; 846  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	rdx, r12
	call	??$_Uninitialized_move@PEAUPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@0@@Z ; std::_Uninitialized_move<PhiveWrapper::PhiveWrapperPatch *,std::allocator<PhiveWrapper::PhiveWrapperPatch> >

; 847  :             _Constructed_first = _Newvec;

	mov	QWORD PTR _Constructed_first$[rsp], rsi

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	r8, r13
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, r12
$LN26@Emplace_re:
	call	??$_Uninitialized_move@PEAUPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@0@@Z ; std::_Uninitialized_move<PhiveWrapper::PhiveWrapperPatch *,std::allocator<PhiveWrapper::PhiveWrapperPatch> >
	npad	1

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, r15
	mov	rdx, rsi
	mov	rcx, rdi
	call	?_Change_array@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperPatch@PhiveWrapper@@_K1@Z ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Change_array

; 857  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 858  :     }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN28@Emplace_re:

; 825  :             _Xlength();

	call	?_Xlength@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@CAXXZ ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Xlength
	int	3
$LN24@Emplace_re:
??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_reallocate<PhiveWrapper::PhiveWrapperPatch const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?catch$1@?0???$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z@4HA PROC ; `std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_reallocate<PhiveWrapper::PhiveWrapperPatch const &>'::`1'::catch$1

; 850  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z$0:

; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rdx, QWORD PTR _Constructed_last$[rbp]
	mov	rcx, QWORD PTR _Constructed_first$[rbp]
	call	??$_Destroy_range@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@YAXPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU12@AEAV?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<PhiveWrapper::PhiveWrapperPatch> >

; 852  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	call	?deallocate@?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@QEAAXQEAUPhiveWrapperPatch@PhiveWrapper@@_K@Z ; std::allocator<PhiveWrapper::PhiveWrapperPatch>::deallocate

; 853  :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$1@?0???$_Emplace_reallocate@AEBUPhiveWrapperPatch@PhiveWrapper@@@?$vector@UPhiveWrapperPatch@PhiveWrapper@@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@AEAAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU23@AEBU23@@Z@4HA ENDP ; `std::vector<PhiveWrapper::PhiveWrapperPatch,std::allocator<PhiveWrapper::PhiveWrapperPatch> >::_Emplace_reallocate<PhiveWrapper::PhiveWrapperPatch const &>'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_Newcapacity$ = 32
$T2 = 40
_Appended_last$ = 48
_Appended_first$ = 56
this$ = 112
_Newsize$ = 120
_Val$dead$ = 128
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN196:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	r15, rdx
	mov	rsi, rcx

; 1512 :         if (_Newsize > max_size()) {

	mov	r8, 288230376151711743			; 03ffffffffffffffH
	cmp	rdx, r8
	ja	$LN195@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r13, QWORD PTR [rcx+8]
	sub	r13, QWORD PTR [rcx]
	sar	r13, 6

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 6

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, r8
	sub	rax, rdx
	cmp	rcx, rax
	jbe	SHORT $LN10@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow

	mov	QWORD PTR _Newcapacity$[rsp], r8
	mov	r14, -64				; ffffffffffffffc0H
	lea	rcx, QWORD PTR [r14+39]
	jmp	SHORT $LN33@Resize_rea
$LN10@Resize_rea:

; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, r15
	jae	SHORT $LN11@Resize_rea

; 1973 :             return _Newsize; // geometric growth would be insufficient

	mov	rbx, r15
	jmp	SHORT $LN188@Resize_rea
$LN11@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	cmp	rbx, r8
	ja	$LN190@Resize_rea
$LN188@Resize_rea:

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	mov	r14, rbx
	shl	r14, 6
	mov	QWORD PTR _Newcapacity$[rsp], rbx

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r14, 4096				; 00001000H
	jb	SHORT $LN182@Resize_rea

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [r14+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, r14
	jbe	$LN190@Resize_rea
$LN33@Resize_rea:

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN159@Resize_rea

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	QWORD PTR $T2[rsp], rdi
	xor	r12d, r12d
	jmp	SHORT $LN21@Resize_rea
$LN182@Resize_rea:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	r14, r14
	je	SHORT $LN24@Resize_rea

; 87   :         return ::operator new(_Bytes);

	mov	rcx, r14
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
	mov	QWORD PTR $T2[rsp], rax

; 245  :         return _Traits::_Allocate(_Bytes);

	xor	r12d, r12d
	jmp	SHORT $LN193@Resize_rea
$LN24@Resize_rea:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	r12d, r12d
	mov	edi, r12d
	mov	QWORD PTR $T2[rsp], r12
$LN193@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	QWORD PTR _Newcapacity$[rsp], rbx
$LN21@Resize_rea:
	mov	rcx, r13
	shl	rcx, 6
	add	rcx, rdi
	mov	QWORD PTR _Appended_first$[rsp], rcx

; 1526 :         pointer _Appended_last        = _Appended_first;

	mov	QWORD PTR _Appended_last$[rsp], rcx

; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, r15
	sub	rdx, r13
	mov	r8, rsi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
	mov	QWORD PTR _Appended_last$[rsp], rax

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r10, QWORD PTR [rsi+8]
	mov	r9, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r9, r10
	je	$LN45@Resize_rea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	lea	r8, QWORD PTR [rdi+56]
	sub	r9, rdi
	npad	2
$LL46@Resize_rea:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8-56], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r8-40], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8-32], r12

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r9+r8-56]
	movups	XMMWORD PTR [r8-56], xmm0
	movups	xmm1, XMMWORD PTR [r9+r8-40]
	movups	XMMWORD PTR [r8-40], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r9+r8-40], r12
	mov	QWORD PTR [r9+r8-32], 15
	mov	BYTE PTR [r9+r8-56], 0
	movzx	eax, BYTE PTR [r9+r8-24]
	mov	BYTE PTR [r8-24], al
	movzx	eax, BYTE PTR [r9+r8-23]
	mov	BYTE PTR [r8-23], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r9+r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+r8], r12

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r9+r8-8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+r8-8], r12

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r9+r8-16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+r8-16], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8-16], rax
	mov	QWORD PTR [r8-8], rcx
	mov	QWORD PTR [r8], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	r8, QWORD PTR [r8+64]
	lea	rax, QWORD PTR [r8-56]
	add	rax, r9
	cmp	rax, r10
	jne	$LL46@Resize_rea
$LN45@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rsi]
	test	rbx, rbx
	je	SHORT $LN150@Resize_rea

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r12, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, r12
	je	SHORT $LN130@Resize_rea
	npad	6
$LL131@Resize_rea:
	lea	rcx, QWORD PTR [rbx+40]
	call	??1?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::~vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	cmp	rbx, r12
	jne	SHORT $LL131@Resize_rea
$LN130@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN162@Resize_rea

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN159@Resize_rea

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN162@Resize_rea:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN150@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rsi], rdi

; 2030 :         _Mylast  = _Newvec + _Newsize;

	shl	r15, 6
	add	r15, rdi
	mov	QWORD PTR [rsi+8], r15

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [r14+rdi]
	mov	QWORD PTR [rsi+16], rax

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1548 :     }

	lea	r11, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN159@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN190@Resize_rea:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN195@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@CAXXZ ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Xlength
	int	3
$LN192@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newcapacity$ = 32
$T2 = 40
_Appended_last$ = 48
_Appended_first$ = 56
this$ = 112
_Newsize$ = 120
_Val$dead$ = 128
?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA PROC ; `std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Resize_reallocate<std::_Value_init_tag>'::`1'::catch$8

; 1541 :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z$0:

; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);

	mov	rdx, QWORD PTR _Appended_last$[rbp]
	mov	rcx, QWORD PTR _Appended_first$[rbp]
	call	??$_Destroy_range@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAXPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >

; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR $T2[rbp]
	call	?deallocate@?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@QEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K@Z ; std::allocator<PhiveWrapper::PhiveWrapperNamedType>::deallocate

; 1544 :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA ENDP ; `std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Resize_reallocate<std::_Value_init_tag>'::`1'::catch$8
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Al$ = 96
??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN72:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], rcx
	mov	QWORD PTR _Backout$[rsp+8], rcx
	mov	QWORD PTR _Backout$[rsp+16], r8

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN69@Uninitiali
	xor	esi, esi
	npad	14
$LL4@Uninitiali:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rbx+16], xmm0
	movups	XMMWORD PTR [rbx+32], xmm0
	movups	XMMWORD PTR [rbx+48], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, rbx
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+40], rsi
	mov	QWORD PTR [rbx+48], rsi
	mov	QWORD PTR [rbx+56], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 64					; 00000040H
	mov	QWORD PTR _Backout$[rsp+8], rbx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdi, 1
	jne	SHORT $LL4@Uninitiali
$LN69@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Al$ = 96
?dtor$0@?0???$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z@4HA PROC ; `std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::~_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
?dtor$0@?0???$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z@4HA ENDP ; `std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_Newcapacity$ = 32
$T2 = 40
_Appended_last$ = 48
_Appended_first$ = 56
this$ = 112
_Newsize$ = 120
_Val$dead$ = 128
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN184:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	r12, rdx
	mov	rsi, rcx

; 1512 :         if (_Newsize > max_size()) {

	mov	r8, 461168601842738790			; 0666666666666666H
	cmp	rdx, r8
	ja	$LN183@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r15, QWORD PTR [rcx+8]
	sub	r15, QWORD PTR [rcx]
	sar	r15, 3
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	imul	r15, rdx

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 3
	imul	rcx, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, r8
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN178@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, r12
	jae	SHORT $LN11@Resize_rea

; 1973 :             return _Newsize; // geometric growth would be insufficient

	mov	rbx, r12
	jmp	SHORT $LN176@Resize_rea
$LN11@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	cmp	rbx, r8
	ja	$LN178@Resize_rea
$LN176@Resize_rea:

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rbx+rbx*4]
	lea	r13, QWORD PTR [rax*8]
	mov	QWORD PTR _Newcapacity$[rsp], rbx

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r13, 4096				; 00001000H
	jb	SHORT $LN170@Resize_rea

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [r13+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, r13
	jbe	$LN178@Resize_rea

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN147@Resize_rea

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	QWORD PTR $T2[rsp], rdi
	xor	r14d, r14d
	jmp	SHORT $LN21@Resize_rea
$LN170@Resize_rea:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	r13, r13
	je	SHORT $LN24@Resize_rea

; 87   :         return ::operator new(_Bytes);

	mov	rcx, r13
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
	mov	QWORD PTR $T2[rsp], rax

; 245  :         return _Traits::_Allocate(_Bytes);

	xor	r14d, r14d
	jmp	SHORT $LN181@Resize_rea
$LN24@Resize_rea:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	r14d, r14d
	mov	edi, r14d
	mov	QWORD PTR $T2[rsp], r14
$LN181@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	QWORD PTR _Newcapacity$[rsp], rbx
$LN21@Resize_rea:
	lea	rax, QWORD PTR [r15+r15*4]
	lea	rcx, QWORD PTR [rdi+rax*8]
	mov	QWORD PTR _Appended_first$[rsp], rcx

; 1526 :         pointer _Appended_last        = _Appended_first;

	mov	QWORD PTR _Appended_last$[rsp], rcx

; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	rdx, r12
	sub	rdx, r15
	mov	r8, rsi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
	mov	QWORD PTR _Appended_last$[rsp], rax

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r8, QWORD PTR [rsi+8]
	mov	rdx, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rdx, r8
	je	SHORT $LN45@Resize_rea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	lea	rcx, QWORD PTR [rdi+24]
	sub	rdx, rdi
$LL46@Resize_rea:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx-24], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx-8], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rcx+rdx-24]
	movups	XMMWORD PTR [rcx-24], xmm0
	movups	xmm1, XMMWORD PTR [rcx+rdx-8]
	movups	XMMWORD PTR [rcx-8], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [rdx+rcx-8], r14
	mov	QWORD PTR [rcx+rdx], 15
	mov	BYTE PTR [rcx+rdx-24], 0
	movzx	eax, BYTE PTR [rcx+rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rcx+rdx+9]
	mov	BYTE PTR [rcx+9], al

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [rcx+40]
	lea	rax, QWORD PTR [rcx-24]
	add	rax, rdx
	cmp	rax, r8
	jne	SHORT $LL46@Resize_rea
$LN45@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rsi]
	test	rbx, rbx
	je	SHORT $LN138@Resize_rea

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r14, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, r14
	je	SHORT $LN118@Resize_rea
$LL119@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, r14
	jne	SHORT $LL119@Resize_rea
$LN118@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rax, QWORD PTR [rsi+16]
	sub	rax, rcx
	sar	rax, 3
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN150@Resize_rea

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN147@Resize_rea

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN150@Resize_rea:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN138@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rsi], rdi

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [r12+r12*4]
	lea	rcx, QWORD PTR [rdi+rax*8]
	mov	QWORD PTR [rsi+8], rcx

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rdi+r13]
	mov	QWORD PTR [rsi+16], rax

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1548 :     }

	lea	r11, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN147@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN178@Resize_rea:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN183@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@CAXXZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Xlength
	int	3
$LN180@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newcapacity$ = 32
$T2 = 40
_Appended_last$ = 48
_Appended_first$ = 56
this$ = 112
_Newsize$ = 120
_Val$dead$ = 128
?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA PROC ; `std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Resize_reallocate<std::_Value_init_tag>'::`1'::catch$8

; 1541 :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z$0:

; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);

	mov	rdx, QWORD PTR _Appended_last$[rbp]
	mov	rcx, QWORD PTR _Appended_first$[rbp]
	call	??$_Destroy_range@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAXPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >

; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR $T2[rbp]
	call	?deallocate@?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z ; std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>::deallocate

; 1544 :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$8@?0???$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z@4HA ENDP ; `std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Resize_reallocate<std::_Value_init_tag>'::`1'::catch$8
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Al$ = 96
??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN65:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], rcx
	mov	QWORD PTR _Backout$[rsp+8], rcx
	mov	QWORD PTR _Backout$[rsp+16], r8

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN62@Uninitiali
	xor	esi, esi
	npad	14
$LL4@Uninitiali:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	movups	XMMWORD PTR [rbx+16], xmm0
	mov	QWORD PTR [rbx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, rbx
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rbx, 40					; 00000028H
	mov	QWORD PTR _Backout$[rsp+8], rbx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdi, 1
	jne	SHORT $LL4@Uninitiali
$LN62@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Al$ = 96
?dtor$0@?0???$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z@4HA PROC ; `std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::~_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
?dtor$0@?0???$_Uninitialized_value_construct_n@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU12@_KAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z@4HA ENDP ; `std::_Uninitialized_value_construct_n<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::~_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::~_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::~_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >, COMDAT

; 1796 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1797 :         _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN5@Uninitiali
$LL6@Uninitiali:
	lea	rcx, QWORD PTR [rbx+40]
	call	??1?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::~vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	cmp	rbx, rdi
	jne	SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1798 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::~_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperNamedType@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperNamedType@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperNamedType@PhiveWrapper@@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@CAXXZ PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@CAXXZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN53:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rbp, r9
	mov	r14, r8
	mov	r15, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN26@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
	lea	rcx, QWORD PTR [rbx+40]
	call	??1?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::~vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN38@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN35@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN38@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	shl	r14, 6
	add	r14, r15
	shl	rbp, 6
	add	rbp, r15
	mov	QWORD PTR [rsi], r15
	mov	QWORD PTR [rsi+8], r14
	mov	QWORD PTR [rsi+16], rbp
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN35@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN50@Change_arr:
?_Change_array@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperNamedType@PhiveWrapper@@_K1@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 6

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEBA_KXZ PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@_K@Z PROC ; std::allocator<PhiveWrapper::PhiveWrapperNamedType>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	shl	rdx, 6

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN10@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperNamedType@PhiveWrapper@@_K@Z ENDP ; std::allocator<PhiveWrapper::PhiveWrapperNamedType>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@CAXXZ PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@CAXXZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN53:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r15, r9
	mov	r12, r8
	mov	r14, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN26@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, -3689348814741910323		; cccccccccccccccdH
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN38@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN35@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN38@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [r12+r12*4]
	lea	rcx, QWORD PTR [r14+rax*8]
	mov	QWORD PTR [rsi], r14
	mov	QWORD PTR [rsi+8], rcx
	lea	rax, QWORD PTR [r15+r15*4]
	lea	rcx, QWORD PTR [r14+rax*8]
	mov	QWORD PTR [rsi+16], rcx
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN35@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN50@Change_arr:
?_Change_array@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEAAXQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K1@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	sub	r8, QWORD PTR [rcx]
	sar	r8, 3
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 461168601842738790			; 0666666666666666H
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEBA_KXZ PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 461168601842738790			; 0666666666666666H

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z PROC ; std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 461168601842738790			; 0666666666666666H
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*4]
	lea	rcx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@_K@Z ENDP ; std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEBA_KXZ PROC ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 6

; 1880 :     }

	ret	0
?capacity@?$vector@UPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperNamedType,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@AEBAAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEBA_KXZ PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -3689348814741910323		; cccccccccccccccdH
	sar	rax, 3
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 461168601842738790			; 0666666666666666H

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SA_KAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperNamedType>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperNamedType> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperNamedType>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperNamedType> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UPhiveWrapperPatch@PhiveWrapper@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@1@QEAUPhiveWrapperPatch@PhiveWrapper@@AEBU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UPhiveWrapperPatch@PhiveWrapper@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@1@QEAUPhiveWrapperPatch@PhiveWrapper@@AEBU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperPatch> >::construct<PhiveWrapper::PhiveWrapperPatch,PhiveWrapper::PhiveWrapperPatch const &>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	eax, DWORD PTR [r8]
	lea	rcx, QWORD PTR [rdx+8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
	lea	rdx, QWORD PTR [r8+8]
	jmp	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
??$construct@UPhiveWrapperPatch@PhiveWrapper@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperPatch@PhiveWrapper@@@1@QEAUPhiveWrapperPatch@PhiveWrapper@@AEBU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperPatch> >::construct<PhiveWrapper::PhiveWrapperPatch,PhiveWrapper::PhiveWrapperPatch const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUPhiveWrapperNamedType@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperNamedType@PhiveWrapper@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUPhiveWrapperNamedType@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperNamedType@PhiveWrapper@@@Z PROC ; std::_Get_unwrapped<PhiveWrapper::PhiveWrapperNamedType * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUPhiveWrapperNamedType@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperNamedType@PhiveWrapper@@@Z ENDP ; std::_Get_unwrapped<PhiveWrapper::PhiveWrapperNamedType * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z PROC ; std::_Uninitialized_move<PhiveWrapper::PhiveWrapperNamedType *,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN105:
	push	rbx
	mov	r10, r8
	mov	rbx, rdx

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	$LN100@Uninitiali
	mov	r11, r10
	mov	QWORD PTR [rsp+24], rdi
	sub	r11, rcx
	lea	r8, QWORD PTR [rcx+48]
	xor	edi, edi
	npad	14
$LL4@Uninitiali:
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r10], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r11+r8-96], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r11+r8-88], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8-112]
	movups	XMMWORD PTR [r10], xmm0
	movups	xmm1, XMMWORD PTR [r8-96]
	movups	XMMWORD PTR [r10+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8-96], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	r10, 64					; 00000040H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8-88], 15
	mov	BYTE PTR [r8-112], dil
	movzx	eax, BYTE PTR [r8-80]
	mov	BYTE PTR [r8+r11-80], al
	movzx	eax, BYTE PTR [r8-79]
	mov	BYTE PTR [r8+r11-79], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-72]
	mov	r9, QWORD PTR [r8-56]
	mov	rdx, QWORD PTR [r8-64]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-56], rdi
	mov	QWORD PTR [r8-64], rdi
	mov	QWORD PTR [r8-72], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r11-72], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r11-64], rdx
	mov	QWORD PTR [r11+r8-56], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rbx
	jne	SHORT $LL4@Uninitiali
	mov	rdi, QWORD PTR [rsp+24]
$LN100@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rax, r10
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAUPhiveWrapperNamedType@PhiveWrapper@@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@0@@Z ENDP ; std::_Uninitialized_move<PhiveWrapper::PhiveWrapperNamedType *,std::allocator<PhiveWrapper::PhiveWrapperNamedType> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Emplace_back<>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN31:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rbx, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	esi, esi
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rbx+32], rsi
	mov	QWORD PTR [rbx+40], rsi
	mov	QWORD PTR [rbx+48], rsi
	mov	QWORD PTR [rbx+56], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], rsi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+40], rsi
	mov	QWORD PTR [rbx+48], rsi
	mov	QWORD PTR [rbx+56], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rdi+8], 64			; 00000040H

; 1804 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z PROC ; std::_Get_unwrapped<PhiveWrapper::PhiveWrapperTypeTemplate * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA?A_TAEBQEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z ENDP ; std::_Get_unwrapped<PhiveWrapper::PhiveWrapperTypeTemplate * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$dead$ = 32
??$_Uninitialized_move@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z PROC ; std::_Uninitialized_move<PhiveWrapper::PhiveWrapperTypeTemplate *,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rax, r8

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN88@Uninitiali

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	r9, rax
	lea	r8, QWORD PTR [rcx+24]
	sub	r9, rcx
	xor	r10d, r10d
	npad	11
$LL4@Uninitiali:
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r9+r8-48], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+r9-40], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8-64]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [r8-48]
	movups	XMMWORD PTR [rax+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [r8-48], r10
	add	rax, 40					; 00000028H
	mov	QWORD PTR [r8-40], 15
	mov	BYTE PTR [r8-64], r10b
	movzx	ecx, BYTE PTR [r8-32]
	mov	BYTE PTR [r9+r8-32], cl
	movzx	ecx, BYTE PTR [r8-31]
	mov	BYTE PTR [r9+r8-31], cl

; 1928 :     // move [_First, _Last) to raw _Dest, using _Al
; 1929 :     // note: only called internally from elsewhere in the STL
; 1930 :     using _Ptrval     = typename _Alloc::value_type*;
; 1931 :     auto _UFirst      = _Get_unwrapped(_First);
; 1932 :     const auto _ULast = _Get_unwrapped(_Last);
; 1933 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1934 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1935 : #if _HAS_CXX20
; 1936 :         if (!_STD is_constant_evaluated())
; 1937 : #endif // _HAS_CXX20
; 1938 :         {
; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1940 :             return _Dest + (_ULast - _UFirst);
; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-24]
	cmp	rcx, rdx
	jne	SHORT $LL4@Uninitiali
$LN88@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	ret	0
??$_Uninitialized_move@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@0PEAU12@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@@Z ENDP ; std::_Uninitialized_move<PhiveWrapper::PhiveWrapperTypeTemplate *,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Emplace_back<>, COMDAT

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN24:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	rbx, rcx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rbx+8], 40			; 00000028H

; 1804 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UPhiveWrapperPatch@PhiveWrapper@@AEBU12@$0A@@std@@YAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU12@AEBU12@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$ = 56
??$construct_at@UPhiveWrapperPatch@PhiveWrapper@@AEBU12@$0A@@std@@YAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU12@AEBU12@@Z PROC ; std::construct_at<PhiveWrapper::PhiveWrapperPatch,PhiveWrapper::PhiveWrapperPatch const &,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	eax, DWORD PTR [rdx]
	mov	rbx, rcx
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	add	rdx, 8
	mov	DWORD PTR [rcx+4], eax
	add	rcx, 8
	call	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rbx

; 242  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$construct_at@UPhiveWrapperPatch@PhiveWrapper@@AEBU12@$0A@@std@@YAPEAUPhiveWrapperPatch@PhiveWrapper@@QEAU12@AEBU12@@Z ENDP ; std::construct_at<PhiveWrapper::PhiveWrapperPatch,PhiveWrapper::PhiveWrapperPatch const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUPhiveWrapperNamedType@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperNamedType@PhiveWrapper@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUPhiveWrapperNamedType@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperNamedType@PhiveWrapper@@AEAU12@@Z PROC ; std::move<PhiveWrapper::PhiveWrapperNamedType &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUPhiveWrapperNamedType@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperNamedType@PhiveWrapper@@AEAU12@@Z ENDP ; std::move<PhiveWrapper::PhiveWrapperNamedType &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UPhiveWrapperNamedType@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperNamedType@PhiveWrapper@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UPhiveWrapperNamedType@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperNamedType@PhiveWrapper@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Emplace_back<PhiveWrapper::PhiveWrapperNamedType>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r11d, r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	r9, rdx
	xorps	xmm0, xmm0
	mov	r10, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r8+16], r11

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+24], r11

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [r8+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r11b
	movzx	eax, BYTE PTR [rdx+32]
	mov	BYTE PTR [r8+32], al
	movzx	eax, BYTE PTR [rdx+33]
	mov	BYTE PTR [r8+33], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+56]
	mov	rcx, QWORD PTR [r9+48]
	mov	rax, QWORD PTR [r9+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+56], r11
	mov	QWORD PTR [r9+48], r11
	mov	QWORD PTR [r9+40], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+40], rax
	mov	QWORD PTR [r8+48], rcx
	mov	QWORD PTR [r8+56], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [r10+8], 64			; 00000040H

; 1804 :     }

	ret	0
??$_Emplace_back@UPhiveWrapperNamedType@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperNamedType@PhiveWrapper@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::_Emplace_back<PhiveWrapper::PhiveWrapperNamedType>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UPhiveWrapperNamedType@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@QEAUPhiveWrapperNamedType@PhiveWrapper@@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
??$construct@UPhiveWrapperNamedType@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@QEAUPhiveWrapperNamedType@PhiveWrapper@@@Z PROC ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::construct<PhiveWrapper::PhiveWrapperNamedType>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rdx+32], rdi
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx+40], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rdx+48], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rdx+56], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+40], rdi
	mov	QWORD PTR [rbx+48], rdi
	mov	QWORD PTR [rbx+56], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct@UPhiveWrapperNamedType@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@QEAUPhiveWrapperNamedType@PhiveWrapper@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::construct<PhiveWrapper::PhiveWrapperNamedType>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAU12@@Z PROC ; std::move<PhiveWrapper::PhiveWrapperTypeTemplate &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAU12@@Z ENDP ; std::move<PhiveWrapper::PhiveWrapperTypeTemplate &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UPhiveWrapperTypeTemplate@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UPhiveWrapperTypeTemplate@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Emplace_back<PhiveWrapper::PhiveWrapperTypeTemplate>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r8+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [r8+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], al
	movzx	eax, BYTE PTR [rdx+32]
	mov	BYTE PTR [r8+32], al
	movzx	eax, BYTE PTR [rdx+33]
	mov	BYTE PTR [r8+33], al
	add	QWORD PTR [rcx+8], 40			; 00000028H

; 1804 :     }

	ret	0
??$_Emplace_back@UPhiveWrapperTypeTemplate@PhiveWrapper@@@?$_Uninitialized_backout_al@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAAX$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Emplace_back<PhiveWrapper::PhiveWrapperTypeTemplate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UPhiveWrapperTypeTemplate@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UPhiveWrapperTypeTemplate@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z PROC ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::construct<PhiveWrapper::PhiveWrapperTypeTemplate>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rdx+32], rcx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], rcx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], rcx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, rax
	jmp	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
??$construct@UPhiveWrapperTypeTemplate@PhiveWrapper@@$$V@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::construct<PhiveWrapper::PhiveWrapperTypeTemplate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0PhiveWrapperPatch@PhiveWrapper@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0PhiveWrapperPatch@PhiveWrapper@@QEAA@AEBU01@@Z PROC	; PhiveWrapper::PhiveWrapperPatch::PhiveWrapperPatch, COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	eax, DWORD PTR [rdx]
	mov	rbx, rcx
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	add	rdx, 8
	mov	DWORD PTR [rcx+4], eax
	add	rcx, 8
	call	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0PhiveWrapperPatch@PhiveWrapper@@QEAA@AEBU01@@Z ENDP	; PhiveWrapper::PhiveWrapperPatch::PhiveWrapperPatch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UPhiveWrapperNamedType@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperNamedType@PhiveWrapper@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UPhiveWrapperNamedType@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperNamedType@PhiveWrapper@@AEAU12@@Z PROC ; std::forward<PhiveWrapper::PhiveWrapperNamedType>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UPhiveWrapperNamedType@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperNamedType@PhiveWrapper@@AEAU12@@Z ENDP ; std::forward<PhiveWrapper::PhiveWrapperNamedType>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UPhiveWrapperNamedType@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@QEAUPhiveWrapperNamedType@PhiveWrapper@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UPhiveWrapperNamedType@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@QEAUPhiveWrapperNamedType@PhiveWrapper@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::construct<PhiveWrapper::PhiveWrapperNamedType,PhiveWrapper::PhiveWrapperNamedType>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	r9, rdx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8+16], r10
	mov	QWORD PTR [r8+24], 15
	mov	BYTE PTR [r8], r10b
	movzx	eax, BYTE PTR [r8+32]
	mov	BYTE PTR [rdx+32], al
	movzx	eax, BYTE PTR [r8+33]
	mov	BYTE PTR [rdx+33], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+56]
	mov	rcx, QWORD PTR [r8+48]
	mov	rax, QWORD PTR [r8+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+56], r10
	mov	QWORD PTR [r8+48], r10
	mov	QWORD PTR [r8+40], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+40], rax
	mov	QWORD PTR [r9+48], rcx
	mov	QWORD PTR [r9+56], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UPhiveWrapperNamedType@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperNamedType@PhiveWrapper@@@1@QEAUPhiveWrapperNamedType@PhiveWrapper@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperNamedType> >::construct<PhiveWrapper::PhiveWrapperNamedType,PhiveWrapper::PhiveWrapperNamedType>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UPhiveWrapperNamedType@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 48
??$construct_at@UPhiveWrapperNamedType@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@@Z PROC ; std::construct_at<PhiveWrapper::PhiveWrapperNamedType,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+32], rdi
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx+40], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+48], rdi
	mov	rbx, rcx
	mov	QWORD PTR [rcx+56], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+40], rdi
	mov	QWORD PTR [rbx+48], rdi
	mov	QWORD PTR [rbx+56], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$construct_at@UPhiveWrapperNamedType@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@@Z ENDP ; std::construct_at<PhiveWrapper::PhiveWrapperNamedType,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAU12@@Z PROC ; std::forward<PhiveWrapper::PhiveWrapperTypeTemplate>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAU12@@Z ENDP ; std::forward<PhiveWrapper::PhiveWrapperTypeTemplate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UPhiveWrapperTypeTemplate@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UPhiveWrapperTypeTemplate@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::construct<PhiveWrapper::PhiveWrapperTypeTemplate,PhiveWrapper::PhiveWrapperTypeTemplate>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	mov	QWORD PTR [r8+16], rax
	mov	QWORD PTR [r8+24], 15
	mov	BYTE PTR [r8], al
	movzx	eax, BYTE PTR [r8+32]
	mov	BYTE PTR [rdx+32], al
	movzx	eax, BYTE PTR [r8+33]
	mov	BYTE PTR [rdx+33], al
	ret	0
??$construct@UPhiveWrapperTypeTemplate@PhiveWrapper@@U12@@?$_Default_allocator_traits@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@SAXAEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@QEAUPhiveWrapperTypeTemplate@PhiveWrapper@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::construct<PhiveWrapper::PhiveWrapperTypeTemplate,PhiveWrapper::PhiveWrapperTypeTemplate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UPhiveWrapperTypeTemplate@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 48
??$construct_at@UPhiveWrapperTypeTemplate@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@@Z PROC ; std::construct_at<PhiveWrapper::PhiveWrapperTypeTemplate,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+32], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rbx

; 242  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$construct_at@UPhiveWrapperTypeTemplate@PhiveWrapper@@$$V$0A@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@@Z ENDP ; std::construct_at<PhiveWrapper::PhiveWrapperTypeTemplate,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0PhiveWrapperNamedType@PhiveWrapper@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0PhiveWrapperNamedType@PhiveWrapper@@QEAA@XZ PROC	; PhiveWrapper::PhiveWrapperNamedType::PhiveWrapperNamedType, COMDAT
$LN25:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	edi, edi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	xorps	xmm0, xmm0
	xor	r8d, r8d

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rdi
	mov	rbx, rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	mov	rax, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+40], rdi
	mov	QWORD PTR [rbx+48], rdi
	mov	QWORD PTR [rbx+56], rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0PhiveWrapperNamedType@PhiveWrapper@@QEAA@XZ ENDP	; PhiveWrapper::PhiveWrapperNamedType::PhiveWrapperNamedType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0PhiveWrapperTypeTemplate@PhiveWrapper@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0PhiveWrapperTypeTemplate@PhiveWrapper@@QEAA@XZ PROC	; PhiveWrapper::PhiveWrapperTypeTemplate::PhiveWrapperTypeTemplate, COMDAT
$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	xorps	xmm0, xmm0
	xor	r8d, r8d

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax
	mov	rbx, rcx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0PhiveWrapperTypeTemplate@PhiveWrapper@@QEAA@XZ ENDP	; PhiveWrapper::PhiveWrapperTypeTemplate::PhiveWrapperTypeTemplate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UPhiveWrapperNamedType@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UPhiveWrapperNamedType@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<PhiveWrapper::PhiveWrapperNamedType,PhiveWrapper::PhiveWrapperNamedType,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r8, rdx
	mov	r9, rcx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r10b
	movzx	eax, BYTE PTR [rdx+32]
	mov	BYTE PTR [rcx+32], al
	movzx	eax, BYTE PTR [rdx+33]
	mov	BYTE PTR [rcx+33], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8+40]
	mov	rdx, QWORD PTR [rdx+56]
	mov	rcx, QWORD PTR [r8+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+56], r10
	mov	QWORD PTR [r8+48], r10
	mov	QWORD PTR [r8+40], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+40], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+48], rcx
	mov	QWORD PTR [r9+56], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@UPhiveWrapperNamedType@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperNamedType@PhiveWrapper@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<PhiveWrapper::PhiveWrapperNamedType,PhiveWrapper::PhiveWrapperNamedType,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UPhiveWrapperTypeTemplate@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UPhiveWrapperTypeTemplate@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<PhiveWrapper::PhiveWrapperTypeTemplate,PhiveWrapper::PhiveWrapperTypeTemplate,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], al
	movzx	eax, BYTE PTR [rdx+32]
	mov	BYTE PTR [rcx+32], al
	movzx	eax, BYTE PTR [rdx+33]
	mov	BYTE PTR [rcx+33], al
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UPhiveWrapperTypeTemplate@PhiveWrapper@@U12@$0A@@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<PhiveWrapper::PhiveWrapperTypeTemplate,PhiveWrapper::PhiveWrapperTypeTemplate,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1>::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1>::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0PhiveWrapperNamedType@PhiveWrapper@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0PhiveWrapperNamedType@PhiveWrapper@@QEAA@$$QEAU01@@Z PROC ; PhiveWrapper::PhiveWrapperNamedType::PhiveWrapperNamedType, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
	mov	r8, rdx
	mov	r9, rcx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r10b
	movzx	eax, BYTE PTR [rdx+32]
	mov	BYTE PTR [rcx+32], al
	movzx	eax, BYTE PTR [rdx+33]
	mov	BYTE PTR [rcx+33], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8+40]
	mov	rdx, QWORD PTR [rdx+56]
	mov	rcx, QWORD PTR [r8+48]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+56], r10
	mov	QWORD PTR [r8+48], r10
	mov	QWORD PTR [r8+40], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+40], rax
	mov	rax, r9
	mov	QWORD PTR [r9+48], rcx
	mov	QWORD PTR [r9+56], rdx
	ret	0
??0PhiveWrapperNamedType@PhiveWrapper@@QEAA@$$QEAU01@@Z ENDP ; PhiveWrapper::PhiveWrapperNamedType::PhiveWrapperNamedType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0PhiveWrapperTypeTemplate@PhiveWrapper@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0PhiveWrapperTypeTemplate@PhiveWrapper@@QEAA@$$QEAU01@@Z PROC ; PhiveWrapper::PhiveWrapperTypeTemplate::PhiveWrapperTypeTemplate, COMDAT

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], rax

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	mov	QWORD PTR [rdx+16], rax
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], al
	movzx	eax, BYTE PTR [rdx+32]
	mov	BYTE PTR [rcx+32], al
	movzx	eax, BYTE PTR [rdx+33]
	mov	BYTE PTR [rcx+33], al
	mov	rax, rcx
	ret	0
??0PhiveWrapperTypeTemplate@PhiveWrapper@@QEAA@$$QEAU01@@Z ENDP ; PhiveWrapper::PhiveWrapperTypeTemplate::PhiveWrapperTypeTemplate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@UPhiveWrapperTypeTemplate@PhiveWrapper@@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >::vector<PhiveWrapper::PhiveWrapperTypeTemplate,std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAA@XZ PROC ; std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@QEAA@XZ ENDP ; std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YA$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YA$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@AEAV10@@Z PROC ; std::move<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YA$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@$$T@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAPEAU12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@$$T@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAPEAU12@$$QEA$$T@Z PROC ; std::exchange<PhiveWrapper::PhiveWrapperTypeTemplate *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@$$T@std@@YAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAPEAU12@$$QEA$$T@Z ENDP ; std::exchange<PhiveWrapper::PhiveWrapperTypeTemplate *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@$$QEAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@$$QEAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@22@Z PROC ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1>::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1><std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,PhiveWrapper::PhiveWrapperTypeTemplate *,PhiveWrapper::PhiveWrapperTypeTemplate *,PhiveWrapper::PhiveWrapperTypeTemplate *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@V?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@1@$$QEAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@22@Z ENDP ; std::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1>::_Compressed_pair<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >,1><std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate>,PhiveWrapper::PhiveWrapperTypeTemplate *,PhiveWrapper::PhiveWrapperTypeTemplate *,PhiveWrapper::PhiveWrapperTypeTemplate *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@00@Z PROC ; std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@QEAA@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >::_Vector_val<std::_Simple_types<PhiveWrapper::PhiveWrapperTypeTemplate> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YA$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YA$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@@std@@YA$$QEAV?$allocator@UPhiveWrapperTypeTemplate@PhiveWrapper@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<PhiveWrapper::PhiveWrapperTypeTemplate> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAPEAU12@@Z PROC ; std::forward<PhiveWrapper::PhiveWrapperTypeTemplate *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAUPhiveWrapperTypeTemplate@PhiveWrapper@@@std@@YA$$QEAPEAUPhiveWrapperTypeTemplate@PhiveWrapper@@AEAPEAU12@@Z ENDP ; std::forward<PhiveWrapper::PhiveWrapperTypeTemplate *>
_TEXT	ENDS
END
